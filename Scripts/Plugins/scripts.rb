begin
#===============================================================================
# * Global variables
#===============================================================================

# Define supported languages map, language vocab files should be placed under 
# 'Vocab/#{language_hey}/' folder.
$supported_languages = {
  :en_us => "English(US)",
  :zh_tw => "繁體中文",
}

$rgss_encoding    = "ASCII-8BIT"  # RGSS default encoding
$default_encoding = 'UTF-8'       # User defined default encoding

# Errno flag shared between threads
$error_activated = false 
#-------------------------------------------------------------------------------
# * Used CSIDL
#-------------------------------------------------------------------------------
CSIDL_APPDATA = 0x1a
=begin
--------------------------------------------------------------------------------
  CSIDL	                        Decimal/Hex	      	Description
--------------------------------------------------------------------------------
CSIDL_ADMINTOOLS	                48	0x30	
  * The file system directory that is used to store administrative tools for an 
  individual user.
CSIDL_ALTSTARTUP      	          29	0x1D	
  * The file system directory that corresponds to the user's nonlocalized 
  Startup program group.
  
CSIDL_APPDATA   	                26	0x1A	
  * The file system directory that serves as a common repository for application
  -specific data. 
CSIDL_BITBUCKET	                  10	0x0A	
  * The virtual folder containing the objects in the user's Recycle Bin.
CSIDL_CDBURN_AREA	                59	0x3B	
  * The file system directory acting as a staging area for files waiting to be 
  written to CD.
CSIDL_COMMON_ADMINTOOLS	          47	0x2F	
  * The file system directory containing administrative tools for all users of 
  the computer.
CSIDL_COMMON_ALTSTARTUP         	30	0x1E	
  NT-based only	The file system directory that corresponds to the nonlocalized 
  Startup program group for all users.
CSIDL_COMMON_APPDATA	            35	0x2	
  The file system directory containing application data for all users.
CSIDL_COMMON_DESKTOPDIRECTORY	    25	0x19	
  NT-based only	The file system directory that contains files and folders that 
  appear on the desktop for all users.
CSIDL_COMMON_DOCUMENTS	          46	0x2E	 	
  The file system directory that contains documents that are common to all users
CSIDL_COMMON_FAVORITES	          31	0x1F	
  NT-based only	The file system directory that serves as a common repository for 
  favorite items common to all users.
CSIDL_COMMON_MUSIC	              53	0x35
  The file system directory that serves as a repository for music files common 
  to all users.
CSIDL_COMMON_PICTURES	            54	0x36
  The file system directory that serves as a repository for image files common 
  to all users.
CSIDL_COMMON_PROGRAMS	            23	0x17	
  NT-based only	The file system directory that contains the directories for the 
  common program groups that appear on the Start menu for all users.
CSIDL_COMMON_STARTMENU	          22	0x16	
  NT-based only	The file system directory that contains the programs and folders
  that appear on the Start menu for all users.
CSIDL_COMMON_STARTUP	            24	0x18	
  NT-based only	The file system directory that contains the programs that appear 
  in the Startup folder for all users.
CSIDL_COMMON_TEMPLATES	          45	0x2D	
  NT-based only	The file system directory that contains the templates that are 
  available to all users.
CSIDL_COMMON_VIDEO	              55	0x37
  The file system directory that serves as a repository for video files common 
  to all users.
CSIDL_COMPUTERSNEARME	            61	0x3D
  The folder representing other machines in your workgroup.
CSIDL_CONNECTIONS	                49	0x31
  The virtual folder representing Network Connections, containing network and 
  dial-up connections.
CSIDL_CONTROLS                     3	0x03	 	
  The virtual folder containing icons for the Control Panel applications.
CSIDL_COOKIES	                    33	0x21	 	
  The file system directory that serves as a common repository for Internet 
  cookies.
CSIDL_DESKTOP	                     0	0x00	 	
  The virtual folder representing the Windows desktop, the root of the shell 
  namespace.
CSIDL_DESKTOPDIRECTORY	          16	0x10	 	
  The file system directory used to physically store file objects on the desktop
CSIDL_DRIVES	                    17	0x11	 	
  The virtual folder representing My Computer, containing everything on the 
  local computer: storage devices, printers, and Control Panel. The folder may 
  also contain mapped network drives.
CSIDL_FAVORITES	                   6	0x06	 	
  The file system directory that serves as a common repository for the user's
  favorite items.
CSIDL_FONTS                      	20	0x14	 	
  A virtual folder containing fonts.
CSIDL_HISTORY	                    34	0x22	 	
  The file system directory that serves as a common repository for Internet 
  history items.
CSIDL_INTERNET	                   1	0x01	 
  A viritual folder for Internet Explorer.
CSIDL_INTERNET_CACHE	            32	0x20
  The file system directory that serves as a common repository for temporary 
  Internet files.
CSIDL_LOCAL_APPDATA	              28	0x1C		
  The file system directory that serves as a data repository for local 
  (nonroaming) applications.
CSIDL_MYDOCUMENTS	                 5	0x05
  The virtual folder representing the My Documents desktop item.
CSIDL_MYMUSIC	                    13	0x0D	
  he file system directory that serves as a common repository for music files.
CSIDL_MYPICTURES	                39	0x27	
  The file system directory that serves as a common repository for image files.
CSIDL_MYVIDEO	                    14	0x0E	
  The file system directory that serves as a common repository for video files.
CSIDL_NETHOOD	                    19	0x13	 	
  A file system directory containing the link objects that may exist in the My 
  Network Places virtual folder.
CSIDL_NETWORK	                    18	0x12	 	
  A virtual folder representing Network Neighborhood, the root of the network 
  namespace hierarchy.
CSIDL_PERSONAL	                   5	0x05	 	
  The file system directory used to physically store a user's common repository 
  of documents. (From shell version 6.0 onwards, CSIDL_PERSONAL is equivalent to 
  CSIDL_MYDOCUMENTS, which is a virtual folder.)
CSIDL_PHOTOALBUMS	                69	0x45	
  Vista	The virtual folder used to store photo albums.
CSIDL_PLAYLISTS	                  63	0x3F	
  Vista	The virtual folder used to store play albums.
CSIDL_PRINTERS	                   4	0x04	 	T
  The virtual folder containing installed printers.
CSIDL_PRINTHOOD	                  27	0x1B	 	
  The file system directory that contains the link objects that can exist in the 
  Printers virtual folder.
CSIDL_PROFILE	                    40	0x28	5.0	
  The user's profile folder.
CSIDL_PROGRAM_FILES	              38	0x26	5.0	
  The Program Files folder.
CSIDL_PROGRAM_FILESX86	          42	0x2A	5.0	
  The Program Files folder for 32-bit programs on 64-bit systems.
CSIDL_PROGRAM_FILES_COMMON	      43	0x2B	5.0	
  A folder for components that are shared across applications.
CSIDL_PROGRAM_FILES_COMMONX86	    44	0x2C	5.0	
  A folder for 32-bit components that are shared across applications on 64-bit 
  systems.
CSIDL_PROGRAMS	                   2	0x02	 	
  The file system directory that contains the user's program groups (which are 
  themselves file system directories).
CSIDL_RECENT	                     8	0x08	 	
  The file system directory that contains shortcuts to the user's most recently 
  used documents.
CSIDL_RESOURCES	                  56	0x38	6.0	
  The file system directory that contains resource data.
CSIDL_RESOURCES_LOCALIZED	        57	0x39	6.0
  The file system directory that contains localized resource data.
CSIDL_SAMPLE_MUSIC	              64	0x40	
  Vista	The file system directory that contains sample music.
CSIDL_SAMPLE_PLAYLISTS	          65	0x41	
  Vista	The file system directory that contains sample playlists.
CSIDL_SAMPLE_PICTURES	            66	0x42	
  Vista	The file system directory that contains sample pictures.
CSIDL_SAMPLE_VIDEOS	              67	0x43	
  Vista	The file system directory that contains sample videos.
CSIDL_SENDTO	                     9	0x09	 	
  The file system directory that contains Send To menu items.
CSIDL_STARTMENU	                  11	0x0B	 	
  The file system directory containing Start menu items.
CSIDL_STARTUP	                     7	0x07	 
  The file system directory that corresponds to the user's Startup program group
CSIDL_SYSTEM	                    37	0x25	
  The Windows System folder.
CSIDL_SYSTEMX86	                  41	0x29	
  The Windows 32-bit System folder on 64-bit systems.
CSIDL_TEMPLATES	                  21	0x15	 	
  The file system directory that serves as a common repository for document 
  templates.
CSIDL_WINDOWS	                    36	0x24	
  The Windows directory or SYSROOT.
  
=end

#--------------------------------------------------------------------------
# * Print error informations
#--------------------------------------------------------------------------
def report_exception(error)
  scripts_name = $RGSS_SCRIPTS.collect{|script|  script[1]  }
  backtrace = []

  error.backtrace.each_with_index {|line,i|
    if line =~ /:(\d+):/
      line_number = $1.to_i
    end

    if line =~ /{(.*)}(.*)/
      backtrace << (scripts_name[$1.to_i] + $2)
    elsif line.start_with?(':1:')
      break
    else
      backtrace << translate_debug_message(line)
    end
  }
  
  error_line = backtrace.first
  backtrace[0] = ''
  err_class = " (#{error.class})"
  back_trace_txt = backtrace.join("\n\tfrom ")
  $error_tracer_header = backtrace[0]
  error_txt = sprintf("%s %s %s %s %s %s",error_line, ": ", error.message, err_class, back_trace_txt, "\n" )
  error_txt = error_txt.force_encoding($default_encoding)
  print error_txt rescue nil
  return error_txt
end
#--------------------------------------------------------------------------
# * Raise errors that not occurred in Main Thread
#--------------------------------------------------------------------------
def flag_error(error)
  caller.each{|i| puts i}
  if !$error_activated
    error_txt = report_exception(error)
    Audio.se_play('Audio/SE/Buzzer1',80,100)
    info = (Vocab::Errno::Exception rescue "An error occurred during the gameplay, please submit \"ErrorLog.txt\" to the developers in order to resolve the problem.\n")
    info = info.force_encoding($default_encoding)
    print info
    msgbox(info)
    filename = "ErrorLog.txt"
    File.open(filename, 'w+') {|f| f.write(error_txt + "\n") }
  end
  
  $error_activated = true
  raise error.class, error.message, [$error_tracer_header]
end
#--------------------------------------------------------------------------
# * Find the error source
#--------------------------------------------------------------------------
def translate_debug_message(line)
  return line unless Plugins
  return line unless (line =~ /:(\d+)/)
  line_number = $1.to_i
  info = Plugins.find_file_by_line(line_number)
  line_number = line_number - info[4] + 1
  msg = line.split(':'+$1.to_s)
  msg = msg.size > 1 ? msg.last : ''
  return sprintf("%s:%s%s", info[1], line_number, msg)
end
#--------------------------------------------------------------------------
def sprite_valid?(sprite)
  return sprite && !sprite.disposed? rescue false
end
#--------------------------------------------------------------------------
def debug_mode?
  return (GameManager.debug_mode? rescue true)
end
#--------------------------------------------------------------------------
# * Print debug info
#--------------------------------------------------------------------------
def debug_print(*args)
  return unless debug_mode?
  info = ""
  args.each do |line|
    info += line.to_s + ' '
  end
  puts "[Debug]: #{info}"
end
alias debug_printf debug_print
#--------------------------------------------------------------------------
def setup_font
  
  if CurrentLanguage == :zh_tw
    Font.default_name = "NotoSansCJKtc-Regular"
  else
    Font.default_name = "Celestia Medium Redux"
  end
  puts "[Debug]: Setup Font #{Font.default_name}"
  Font.default_size = 24
  
end
#--------------------------------------------------------------------------
# * Alias: load_data
#--------------------------------------------------------------------------
alias load_data_pony load_data
def load_data(filename)
  SceneManager.update_loading if defined?(SceneManager.update_loading)
  load_data_pony(filename)
end
#--------------------------------------------------------------------------
alias puts_debug puts
def puts(*args)
  return unless debug_mode?
  args[0] = "<#{Time.now}> " + args[0] if args[0] =~ /\[(.*)\]/i
  begin
    puts_debug(*args)
  rescue Encoding::UndefinedConversionError
    args.each{|ar| ar = ar.to_s.force_encoding($default_encoding)}
    puts_debug(*args)
  end
end
#--------------------------------------------------------------------------
def change_encoding(target_encoding, *args)
  conv_proc = Proc.new{ |arg|
    if arg.is_a?(Regexp) && arg.encoding != target_encoding
      rear = arg.inspect.rindex('/')
      Regexp.new(arg.inspect[1...rear].force_encoding(target_encoding), Regexp::FIXEDENCODING | arg.options)
    elsif arg.is_a?(String) && arg.encoding != target_encoding
      arg.force_encoding(target_encoding)
    else
      arg
    end
  }
  if args.size == 0
    return nil
  elsif args.size == 1
    return conv_proc.call(args[0])
  else
    re_args = []
    args.each{|arg| re_args << conv_proc.call(arg)}
    return re_args
  end
end
#--------------------------------------------------------------------------
# * Overwrite the exit method to program-friendly
#--------------------------------------------------------------------------
def exit(stat = true)
  $exited = true
  SceneManager.scene.fadeout_all rescue nil
  Cache.release
  SceneManager.exit
end
#--------------------------------------------------------------------------
def sec_to_frame(t)
  return (t * Graphics.frame_rate).to_i
end
#--------------------------------------------------------------------------

#===============================================================================
# Module Math
#===============================================================================
module Math
  #-----------------------------------------------------------------------------
  # * Module variables
  #-----------------------------------------------------------------------------
  @rotation_cache = {}
  #-----------------------------------------------------------------------------
  # * Get rotated position
  #-----------------------------------------------------------------------------
  def self.rotation_matrix(x, y, angle, flip = false)
    key  = (x * 10000 + y * 360 + angle)
    key *= flip ? -1 : 1
    if !@rotation_cache[key]
      rx = x * Math.cos(angle.to_rad) - y * Math.sin(angle.to_rad)
      ry = x * Math.sin(angle.to_rad) + y * Math.cos(angle.to_rad)
      ry *= -1 if flip
      @rotation_cache[key] = [rx.round(6), ry.round(6)]
    end
    return @rotation_cache[key]
  end
  #-----------------------------------------------------------------------------
  def self.slope(x1, y1, x2, y2)
    return nil if x2 == x1
    return (y2 - y1).to_f / (x2 - x1)
  end
  #-----------------------------------------------------------------------------
  # *) in arc:
  #
  # x1, y1: target coord
  # x2, y2: source coord
  # angle1, angle2: left's and right's Generalized Angle
  # distance: effective distance
  #-----------------------------------------------------------------------------
  def self.in_arc?(x1, y1, x2, y2, angle1, angle2, distance, original_dir)
    return false if self.hypot( x2 - x1, y2 - y1 ) > distance
    move_x = $game_map.width / 2
    move_y = $game_map.height / 2
    
    x1 = x1 - move_x
    y1 = move_y - y1
    x2 = x2 - move_x
    y2 = move_y - y2
    
    left_x    = x2 + self.rotation_matrix(1,0, angle1).at(0)
    left_y    = y2 + self.rotation_matrix(1,0, angle1).at(1)
    right_x   = x2 + self.rotation_matrix(1,0, angle2).at(0)
    right_y   = y2 + self.rotation_matrix(1,0, angle2).at(1)
    m1 = slope(x2, y2, left_x, left_y)
    m2 = slope(x2, y2, right_x, right_y)
    on_m1_right = on_m2_left = true
    
    offset1 = (left_y - m1 * left_x)
    offset2 = (right_y - m2 * right_x)
    delta   = m2 - m1
    delta_x = offset1 - offset2
    cx = delta_x.to_f / delta
    
    if m1.nil?
      on_m1_right = (angle1 == 90 ? x1 >= x2 : x1 <= x2)
    else
      if [4,7,8,9].include?(original_dir)
        on_m1_right = y1 >= m1 * x1 + offset1
      else
        on_m1_right = y1 <= m1 * x1 + offset1
      end
    end
    
    if m2.nil?
      on_m2_left = (angle2 == 270 ? x1 >= x2 : x1 <=x2)
    else
      if [4,1,2,3].include?(original_dir)
        on_m2_left = y1 <= m2 * x1 + offset2
      else
        on_m2_left = y1 >= m2 * x1 + offset2
      end
    end
    return on_m1_right && on_m2_left
  end
end
#===============================================================================
# * Array
#===============================================================================
class Array
  #-----------------------------------------------------------------------------
  def swap_at(loc_a, loc_b)
    self[loc_a], self[loc_b] = self[loc_b], self[loc_a]
  end
  #-----------------------------------------------------------------------------
  def x; self[0]; end
  def y; self[1]; end
  def z; self[2]; end
  #-----------------------------------------------------------------------------
end
#===============================================================================
# * Fiber class
#===============================================================================
class Fiber
  
end
#-------------------------------------------------------------------------------
# * Basic Marshal class
#-------------------------------------------------------------------------------
class << Marshal
  alias_method(:load_source, :load)
  def load(file, proc = nil)
    load_source(file, proc)
  rescue TypeError
    if file.kind_of?(File)
      file.rewind 
      file.read
    else
      file
    end
  end
end unless Marshal.respond_to?(:load_source)
#===============================================================================
# * Mutex
#===============================================================================
class Mutex
  #----------------------------------------------------------------------------
  def synchronize
    self.lock
    begin
      debug_print "[Thread]: Yield Block"
      yield
    ensure
      self.unlock rescue nil
      debug_print "[Thread]: Block completed"
    end
  end
end
#==============================================================================
# ■ Numeric
#==============================================================================
class Numeric
  #----------------------------------------------------------------------------
  # *) Convert to boolean
  #----------------------------------------------------------------------------
  def to_bool
    return self != 0 # self == 0 ? false : true
  end
  #----------------------------------------------------------------------------
  # *) Convert to radians
  #----------------------------------------------------------------------------
  def to_rad
    self * Math::PI / 180
  end
end
#===============================================================================
# * Basic Fixnum class
#===============================================================================
class Fixnum
=begin
  #----------------------------------------------------------------------------
  alias plus +
  def +(*args)
    plus(*args)
  end
  #----------------------------------------------------------------------------
  alias minus -
  def -(*args)
    minus(*args)
  end
  #----------------------------------------------------------------------------
  alias bigger >
  def >(*args)
    bigger(*args)
  end
  #----------------------------------------------------------------------------
  alias ebigger >=
  def >=(*args)
    ebigger(*args)
  end
  #----------------------------------------------------------------------------
  alias smaller <
  def <(*args)
    smaller(*args)
  end
  #----------------------------------------------------------------------------
  alias esmaller <=
  def <=(*args)
    esmaller(*args)
  end
  #----------------------------------------------------------------------------
  alias :divid :/
  def /(*args)
    divid(*args)
  end
=end
  #----------------------------------------------------------------------------
  # *) String for filename
  #----------------------------------------------------------------------------
  def to_fileid(deg)
    n = self
    cnt = 0
    while n > 0
      n /= 10
      cnt += 1
    end
    cnt = [cnt, 1].max
    PONY::ERRNO.raise(:fileid_overflow, :exit) if cnt > deg
    return ('0' * (deg - cnt)) + self.to_s
  end
  #----------------------------------------------------------------------------
  # * To second in frame
  #----------------------------------------------------------------------------
  def to_sec
    return (self / Graphics.frame_rate).to_i + 1
  end
  #----------------------------------------------------------------------------
  def set_bit(index, n)
    n = n.to_i rescue nil
    if n.nil?
      PONY::ERRNO.raise(:datatype_error, nil, nil, "Nil bit given")
      return
    elsif n != 1 && n != 0
      puts "n: #{n}"
      PONY::ERRNO.raise(:datatype_error, nil, nil, "Bit operation excess 0/1")
      return
    end
    
    return self |  (1 << index) if n == 1
    return self & ~(1 << index)
  end
  alias setbit set_bit
  alias sb set_bit
  #----------------------------------------------------------------------------
end
#===============================================================================
# * Basic Object
#===============================================================================
class Object
  #------------------------------------------------------------------------
  InhertID = 0
  alias :ruby_class :class # Alias for class prevent misuse of Game_Actor
  #------------------------------------------------------------------------
  attr_reader :active
  #------------------------------------------------------------------------
  alias init_rbobj initialize
  def initialize(*args)
    activate
    init_rbobj(*args)
  end
  #------------------------------------------------------------------------
  def eigenclass
    class << self
      self
    end
  end
  #------------------------------------------------------------------------
  def deactivate
    @active = false
  end
  #------------------------------------------------------------------------
  def activate
    @active = true
  end
  #------------------------------------------------------------------------
  def active?
    @active || false
  end
  #------------------------------------------------------------------------
  # * Set hashid
  #------------------------------------------------------------------------
  def hash_self
    PONY.hashid_table[@hashid] = self
    return @hashid
  end
  #------------------------------------------------------------------------
  def hashid
    hash_self if @hashid.nil?
    return @hashid
  end
  #------------------------------------------------------------------------
  def to_bool
    return true
  end
  #------------------------------------------------------------------------
  # * Synchronize instance variables with newer verison of object
  #------------------------------------------------------------------------
  def sync_new_data(newone)
    return unless newone.ruby_class == self.ruby_class
    
    vars    = self.instance_variables
    newvars = newone.instance_variables
    
    # Create instance of new variable
    newvars.each do |varname|
      next if vars.include?(varname)
      ivar = newone.instance_variable_get(varname)
      debug_print("New instance variable for #{self}: #{varname} = #{ivar ? ivar : 'nil'}")
      self.instance_variable_set(varname, ivar)
    end
    
  end
end
#===============================================================================
# * True/Flase/Nil class
#===============================================================================
class TrueClass
  def to_i
    return 1
  end
end

class FalseClass
  def to_i
    return 0
  end
end

class NilClass
  #----------------------------------------------------------------------------
  # *) Convert to boolean
  #----------------------------------------------------------------------------
  def to_bool
    false
  end
end
#--
# frozen_string_literal: true
#
# set.rb - defines the Set class
#++
# Copyright (c) 2002-2016 Akinori MUSHA <knu@iDaemons.org>
#
# Documentation by Akinori MUSHA and Gavin Sinclair.
#
# All rights reserved.  You can redistribute and/or modify it under the same
# terms as Ruby.
#
#   $Id$
#
# == Overview
#
# This library provides the Set class, which deals with a collection
# of unordered values with no duplicates.  It is a hybrid of Array's
# intuitive inter-operation facilities and Hash's fast lookup.  If you
# need to keep values sorted in some order, use the SortedSet class.
#
# The method +to_set+ is added to Enumerable for convenience.
#
# See the Set and SortedSet documentation for examples of usage.
#
# Set implements a collection of unordered values with no duplicates.
# This is a hybrid of Array's intuitive inter-operation facilities and
# Hash's fast lookup.
#
# Set is easy to use with Enumerable objects (implementing +each+).
# Most of the initializer methods and binary operators accept generic
# Enumerable objects besides sets and arrays.  An Enumerable object
# can be converted to Set using the +to_set+ method.
#
# Set uses Hash as storage, so you must note the following points:
#
# * Equality of elements is determined according to Object#eql? and
#   Object#hash.  Use Set#compare_by_identity to make a set compare
#   its elements by their identity.
# * Set assumes that the identity of each element does not change
#   while it is stored.  Modifying an element of a set will render the
#   set to an unreliable state.
# * When a string is to be stored, a frozen copy of the string is
#   stored instead unless the original string is already frozen.
#
# == Comparison
#
# The comparison operators <, >, <=, and >= are implemented as
# shorthand for the {proper_,}{subset?,superset?} methods.  However,
# the <=> operator is intentionally left out because not every pair of
# sets is comparable ({x, y} vs. {x, z} for example).
#
# == Example
#
#   require 'set'
#   s1 = Set[1, 2]                        #=> #<Set: {1, 2}>
#   s2 = [1, 2].to_set                    #=> #<Set: {1, 2}>
#   s1 == s2                              #=> true
#   s1.add("foo")                         #=> #<Set: {1, 2, "foo"}>
#   s1.merge([2, 6])                      #=> #<Set: {1, 2, "foo", 6}>
#   s1.subset?(s2)                        #=> false
#   s2.subset?(s1)                        #=> true
#
# == Contact
#
#   - Akinori MUSHA <knu@iDaemons.org> (current maintainer)
#
class Set
  include Enumerable
  # Creates a new set containing the given objects.
  #
  #     Set[1, 2]                   # => #<Set: {1, 2}>
  #     Set[1, 2, 1]                # => #<Set: {1, 2}>
  #     Set[1, 'c', :s]             # => #<Set: {1, "c", :s}>
  def self.[](*ary)
    new(ary)
  end
  # Creates a new set containing the elements of the given enumerable
  # object.
  #
  # If a block is given, the elements of enum are preprocessed by the
  # given block.
  #
  #     Set.new([1, 2])                       #=> #<Set: {1, 2}>
  #     Set.new([1, 2, 1])                    #=> #<Set: {1, 2}>
  #     Set.new([1, 'c', :s])                 #=> #<Set: {1, "c", :s}>
  #     Set.new(1..5)                         #=> #<Set: {1, 2, 3, 4, 5}>
  #     Set.new([1, 2, 3]) { |x| x * x }      #=> #<Set: {1, 4, 9}>
  def initialize(enum = nil, &block) # :yields: o
    @hash ||= Hash.new(false)
    enum.nil? and return
    if block
      do_with_enum(enum) { |o| add(block[o]) }
    else
      merge(enum)
    end
  end
  # Makes the set compare its elements by their identity and returns
  # self.  This method may not be supported by all subclasses of Set.
  def compare_by_identity
    if @hash.respond_to?(:compare_by_identity)
      @hash.compare_by_identity
      self
    else
      raise NotImplementedError, "#{self.class.name}\##{__method__} is not implemented"
    end
  end
  # Returns true if the set will compare its elements by their
  # identity.  Also see Set#compare_by_identity.
  def compare_by_identity?
    @hash.respond_to?(:compare_by_identity?) && @hash.compare_by_identity?
  end
  def do_with_enum(enum, &block) # :nodoc:
    if enum.respond_to?(:each_entry)
      enum.each_entry(&block) if block
    elsif enum.respond_to?(:each)
      enum.each(&block) if block
    else
      raise ArgumentError, "value must be enumerable"
    end
  end
  private :do_with_enum
  # Dup internal hash.
  def initialize_dup(orig)
    super
    @hash = orig.instance_variable_get(:@hash).dup
  end
  # Clone internal hash.
  def initialize_clone(orig)
    super
    @hash = orig.instance_variable_get(:@hash).clone
  end
  def freeze    # :nodoc:
    @hash.freeze
    super
  end
  def taint     # :nodoc:
    @hash.taint
    super
  end
  def untaint   # :nodoc:
    @hash.untaint
    super
  end
  # Returns the number of elements.
  def size
    @hash.size
  end
  alias length size
  # Returns true if the set contains no elements.
  def empty?
    @hash.empty?
  end
  # Removes all elements and returns self.
  #
  #     set = Set[1, 'c', :s]             #=> #<Set: {1, "c", :s}>
  #     set.clear                         #=> #<Set: {}>
  #     set                               #=> #<Set: {}>
  def clear
    @hash.clear
    self
  end
  # Replaces the contents of the set with the contents of the given
  # enumerable object and returns self.
  #
  #     set = Set[1, 'c', :s]             #=> #<Set: {1, "c", :s}>
  #     set.replace([1, 2])               #=> #<Set: {1, 2}>
  #     set                               #=> #<Set: {1, 2}>
  def replace(enum)
    if enum.instance_of?(self.class)
      @hash.replace(enum.instance_variable_get(:@hash))
      self
    else
      do_with_enum(enum)  # make sure enum is enumerable before calling clear
      clear
      merge(enum)
    end
  end
  # Converts the set to an array.  The order of elements is uncertain.
  #
  #     Set[1, 2].to_a                    #=> [1, 2]
  #     Set[1, 'c', :s].to_a              #=> [1, "c", :s]
  def to_a
    @hash.keys
  end
  # Returns self if no arguments are given.  Otherwise, converts the
  # set to another with klass.new(self, *args, &block).
  #
  # In subclasses, returns klass.new(self, *args, &block) unless
  # overridden.
  def to_set(klass = Set, *args, &block)
    return self if instance_of?(Set) && klass == Set && block.nil? && args.empty?
    klass.new(self, *args, &block)
  end
  def flatten_merge(set, seen = Set.new) # :nodoc:
    set.each { |e|
      if e.is_a?(Set)
        if seen.include?(e_id = e.object_id)
          raise ArgumentError, "tried to flatten recursive Set"
        end
        seen.add(e_id)
        flatten_merge(e, seen)
        seen.delete(e_id)
      else
        add(e)
      end
    }
    self
  end
  protected :flatten_merge
  # Returns a new set that is a copy of the set, flattening each
  # containing set recursively.
  def flatten
    self.class.new.flatten_merge(self)
  end
  # Equivalent to Set#flatten, but replaces the receiver with the
  # result in place.  Returns nil if no modifications were made.
  def flatten!
    replace(flatten()) if any? { |e| e.is_a?(Set) }
  end
  # Returns true if the set contains the given object.
  #
  # Note that <code>include?</code> and <code>member?</code> do not test member
  # equality using <code>==</code> as do other Enumerables.
  #
  # See also Enumerable#include?
  def include?(o)
    @hash[o]
  end
  alias member? include?
  # Returns true if the set is a superset of the given set.
  def superset?(set)
    case
    when set.instance_of?(self.class) && @hash.respond_to?(:>=)
      @hash >= set.instance_variable_get(:@hash)
    when set.is_a?(Set)
      size >= set.size && set.all? { |o| include?(o) }
    else
      raise ArgumentError, "value must be a set"
    end
  end
  alias >= superset?
  # Returns true if the set is a proper superset of the given set.
  def proper_superset?(set)
    case
    when set.instance_of?(self.class) && @hash.respond_to?(:>)
      @hash > set.instance_variable_get(:@hash)
    when set.is_a?(Set)
      size > set.size && set.all? { |o| include?(o) }
    else
      raise ArgumentError, "value must be a set"
    end
  end
  alias > proper_superset?
  # Returns true if the set is a subset of the given set.
  def subset?(set)
    case
    when set.instance_of?(self.class) && @hash.respond_to?(:<=)
      @hash <= set.instance_variable_get(:@hash)
    when set.is_a?(Set)
      size <= set.size && all? { |o| set.include?(o) }
    else
      raise ArgumentError, "value must be a set"
    end
  end
  alias <= subset?
  # Returns true if the set is a proper subset of the given set.
  def proper_subset?(set)
    case
    when set.instance_of?(self.class) && @hash.respond_to?(:<)
      @hash < set.instance_variable_get(:@hash)
    when set.is_a?(Set)
      size < set.size && all? { |o| set.include?(o) }
    else
      raise ArgumentError, "value must be a set"
    end
  end
  alias < proper_subset?
  # Returns true if the set and the given set have at least one
  # element in common.
  #
  #   Set[1, 2, 3].intersect? Set[4, 5]   #=> false
  #   Set[1, 2, 3].intersect? Set[3, 4]   #=> true
  def intersect?(set)
    set.is_a?(Set) or raise ArgumentError, "value must be a set"
    if size < set.size
      any? { |o| set.include?(o) }
    else
      set.any? { |o| include?(o) }
    end
  end
  # Returns true if the set and the given set have no element in
  # common.  This method is the opposite of +intersect?+.
  #
  #   Set[1, 2, 3].disjoint? Set[3, 4]   #=> false
  #   Set[1, 2, 3].disjoint? Set[4, 5]   #=> true
  def disjoint?(set)
    !intersect?(set)
  end
  # Calls the given block once for each element in the set, passing
  # the element as parameter.  Returns an enumerator if no block is
  # given.
  def each(&block)
    block or return enum_for(__method__) { size }
    @hash.each_key(&block)
    self
  end
  # Adds the given object to the set and returns self.  Use +merge+ to
  # add many elements at once.
  #
  #     Set[1, 2].add(3)                    #=> #<Set: {1, 2, 3}>
  #     Set[1, 2].add([3, 4])               #=> #<Set: {1, 2, [3, 4]}>
  #     Set[1, 2].add(2)                    #=> #<Set: {1, 2}>
  def add(o)
    @hash[o] = true
    self
  end
  alias << add
  # Adds the given object to the set and returns self.  If the
  # object is already in the set, returns nil.
  #
  #     Set[1, 2].add?(3)                    #=> #<Set: {1, 2, 3}>
  #     Set[1, 2].add?([3, 4])               #=> #<Set: {1, 2, [3, 4]}>
  #     Set[1, 2].add?(2)                    #=> nil
  def add?(o)
    add(o) unless include?(o)
  end
  # Deletes the given object from the set and returns self.  Use +subtract+ to
  # delete many items at once.
  def delete(o)
    @hash.delete(o)
    self
  end
  # Deletes the given object from the set and returns self.  If the
  # object is not in the set, returns nil.
  def delete?(o)
    delete(o) if include?(o)
  end
  # Deletes every element of the set for which block evaluates to
  # true, and returns self. Returns an enumerator if no block is
  # given.
  def delete_if
    block_given? or return enum_for(__method__) { size }
    # @hash.delete_if should be faster, but using it breaks the order
    # of enumeration in subclasses.
    select { |o| yield o }.each { |o| @hash.delete(o) }
    self
  end
  # Deletes every element of the set for which block evaluates to
  # false, and returns self. Returns an enumerator if no block is
  # given.
  def keep_if
    block_given? or return enum_for(__method__) { size }
    # @hash.keep_if should be faster, but using it breaks the order of
    # enumeration in subclasses.
    reject { |o| yield o }.each { |o| @hash.delete(o) }
    self
  end
  # Replaces the elements with ones returned by collect().
  # Returns an enumerator if no block is given.
  def collect!
    block_given? or return enum_for(__method__) { size }
    set = self.class.new
    each { |o| set << yield(o) }
    replace(set)
  end
  alias map! collect!
  # Equivalent to Set#delete_if, but returns nil if no changes were
  # made. Returns an enumerator if no block is given.
  def reject!(&block)
    block or return enum_for(__method__) { size }
    n = size
    delete_if(&block)
    self if size != n
  end
  # Equivalent to Set#keep_if, but returns nil if no changes were
  # made. Returns an enumerator if no block is given.
  def select!(&block)
    block or return enum_for(__method__) { size }
    n = size
    keep_if(&block)
    self if size != n
  end
  # Equivalent to Set#select!
  alias filter! select!
  # Merges the elements of the given enumerable object to the set and
  # returns self.
  def merge(enum)
    if enum.instance_of?(self.class)
      @hash.update(enum.instance_variable_get(:@hash))
    else
      do_with_enum(enum) { |o| add(o) }
    end
    self
  end
  # Deletes every element that appears in the given enumerable object
  # and returns self.
  def subtract(enum)
    do_with_enum(enum) { |o| delete(o) }
    self
  end
  # Returns a new set built by merging the set and the elements of the
  # given enumerable object.
  #
  #     Set[1, 2, 3] | Set[2, 4, 5]         #=> #<Set: {1, 2, 3, 4, 5}>
  #     Set[1, 5, 'z'] | (1..6)             #=> #<Set: {1, 5, "z", 2, 3, 4, 6}>
  def |(enum)
    dup.merge(enum)
  end
  alias + |
  alias union |
  # Returns a new set built by duplicating the set, removing every
  # element that appears in the given enumerable object.
  #
  #     Set[1, 3, 5] - Set[1, 5]                #=> #<Set: {3}>
  #     Set['a', 'b', 'z'] - ['a', 'c']         #=> #<Set: {"b", "z"}>
  def -(enum)
    dup.subtract(enum)
  end
  alias difference -
  # Returns a new set containing elements common to the set and the
  # given enumerable object.
  #
  #     Set[1, 3, 5] & Set[3, 2, 1]             #=> #<Set: {3, 1}>
  #     Set['a', 'b', 'z'] & ['a', 'b', 'c']    #=> #<Set: {"a", "b"}>
  def &(enum)
    n = self.class.new
    do_with_enum(enum) { |o| n.add(o) if include?(o) }
    n
  end
  alias intersection &
  # Returns a new set containing elements exclusive between the set
  # and the given enumerable object.  (set ^ enum) is equivalent to
  # ((set | enum) - (set & enum)).
  #
  #     Set[1, 2] ^ Set[2, 3]                   #=> #<Set: {3, 1}>
  #     Set[1, 'b', 'c'] ^ ['b', 'd']           #=> #<Set: {"d", 1, "c"}>
  def ^(enum)
    n = Set.new(enum)
    each { |o| n.add(o) unless n.delete?(o) }
    n
  end
  # Returns true if two sets are equal.  The equality of each couple
  # of elements is defined according to Object#eql?.
  #
  #     Set[1, 2] == Set[2, 1]                       #=> true
  #     Set[1, 3, 5] == Set[1, 5]                    #=> false
  #     Set['a', 'b', 'c'] == Set['a', 'c', 'b']     #=> true
  #     Set['a', 'b', 'c'] == ['a', 'c', 'b']        #=> false
  def ==(other)
    if self.equal?(other)
      true
    elsif other.instance_of?(self.class)
      @hash == other.instance_variable_get(:@hash)
    elsif other.is_a?(Set) && self.size == other.size
      other.all? { |o| @hash.include?(o) }
    else
      false
    end
  end
  def hash      # :nodoc:
    @hash.hash
  end
  def eql?(o)   # :nodoc:
    return false unless o.is_a?(Set)
    @hash.eql?(o.instance_variable_get(:@hash))
  end
  # Resets the internal state after modification to existing elements
  # and returns self.
  #
  # Elements will be reindexed and deduplicated.
  def reset
    if @hash.respond_to?(:rehash)
      @hash.rehash # This should perform frozenness check.
    else
      raise "can't modify frozen #{self.class.name}" if frozen?
    end
    self
  end
  # Returns true if the given object is a member of the set,
  # and false otherwise.
  #
  # Used in case statements:
  #
  #   require 'set'
  #
  #   case :apple
  #   when Set[:potato, :carrot]
  #     "vegetable"
  #   when Set[:apple, :banana]
  #     "fruit"
  #   end
  #   # => "fruit"
  #
  # Or by itself:
  #
  #   Set[1, 2, 3] === 2   #=> true
  #   Set[1, 2, 3] === 4   #=> false
  #
  alias === include?
  # Classifies the set by the return value of the given block and
  # returns a hash of {value => set of elements} pairs.  The block is
  # called once for each element of the set, passing the element as
  # parameter.
  #
  #   require 'set'
  #   files = Set.new(Dir.glob("*.rb"))
  #   hash = files.classify { |f| File.mtime(f).year }
  #   hash       #=> {2000=>#<Set: {"a.rb", "b.rb"}>,
  #              #    2001=>#<Set: {"c.rb", "d.rb", "e.rb"}>,
  #              #    2002=>#<Set: {"f.rb"}>}
  #
  # Returns an enumerator if no block is given.
  def classify # :yields: o
    block_given? or return enum_for(__method__) { size }
    h = {}
    each { |i|
      (h[yield(i)] ||= self.class.new).add(i)
    }
    h
  end
  # Divides the set into a set of subsets according to the commonality
  # defined by the given block.
  #
  # If the arity of the block is 2, elements o1 and o2 are in common
  # if block.call(o1, o2) is true.  Otherwise, elements o1 and o2 are
  # in common if block.call(o1) == block.call(o2).
  #
  #   require 'set'
  #   numbers = Set[1, 3, 4, 6, 9, 10, 11]
  #   set = numbers.divide { |i,j| (i - j).abs == 1 }
  #   set        #=> #<Set: {#<Set: {1}>,
  #              #           #<Set: {11, 9, 10}>,
  #              #           #<Set: {3, 4}>,
  #              #           #<Set: {6}>}>
  #
  # Returns an enumerator if no block is given.
  def divide(&func)
    func or return enum_for(__method__) { size }
    if func.arity == 2
      require 'tsort'
      class << dig = {}         # :nodoc:
        include TSort
        alias tsort_each_node each_key
        def tsort_each_child(node, &block)
          fetch(node).each(&block)
        end
      end
      each { |u|
        dig[u] = a = []
        each{ |v| func.call(u, v) and a << v }
      }
      set = Set.new()
      dig.each_strongly_connected_component { |css|
        set.add(self.class.new(css))
      }
      set
    else
      Set.new(classify(&func).values)
    end
  end
  InspectKey = :__inspect_key__         # :nodoc:
  # Returns a string containing a human-readable representation of the
  # set ("#<Set: {element1, element2, ...}>").
  def inspect
    ids = (Thread.current[InspectKey] ||= [])
    if ids.include?(object_id)
      return sprintf('#<%s: {...}>', self.class.name)
    end
    ids << object_id
    begin
      return sprintf('#<%s: {%s}>', self.class, to_a.inspect[1..-2])
    ensure
      ids.pop
    end
  end
  alias to_s inspect
  def pretty_print(pp)  # :nodoc:
    pp.text sprintf('#<%s: {', self.class.name)
    pp.nest(1) {
      pp.seplist(self) { |o|
        pp.pp o
      }
    }
    pp.text "}>"
  end
  def pretty_print_cycle(pp)    # :nodoc:
    pp.text sprintf('#<%s: {%s}>', self.class.name, empty? ? '' : '...')
  end
end
#
# SortedSet implements a Set that guarantees that its elements are
# yielded in sorted order (according to the return values of their
# #<=> methods) when iterating over them.
#
# All elements that are added to a SortedSet must respond to the <=>
# method for comparison.
#
# Also, all elements must be <em>mutually comparable</em>: <tt>el1 <=>
# el2</tt> must not return <tt>nil</tt> for any elements <tt>el1</tt>
# and <tt>el2</tt>, else an ArgumentError will be raised when
# iterating over the SortedSet.
#
# == Example
#
#   require "set"
#
#   set = SortedSet.new([2, 1, 5, 6, 4, 5, 3, 3, 3])
#   ary = []
#
#   set.each do |obj|
#     ary << obj
#   end
#
#   p ary # => [1, 2, 3, 4, 5, 6]
#
#   set2 = SortedSet.new([1, 2, "3"])
#   set2.each { |obj| } # => raises ArgumentError: comparison of Fixnum with String failed
#
class SortedSet < Set
  @@setup = false
  @@mutex = Mutex.new
  class << self
    def [](*ary)        # :nodoc:
      new(ary)
    end
    def setup   # :nodoc:
      @@setup and return
      @@mutex.synchronize do
        # a hack to shut up warning
        alias_method :old_init, :initialize
        begin
          require 'rbtree'
          module_eval <<-END, __FILE__, __LINE__+1
            def initialize(*args)
              @hash = RBTree.new
              super
            end
            def add(o)
              o.respond_to?(:<=>) or raise ArgumentError, "value must respond to <=>"
              super
            end
            alias << add
          END
        rescue LoadError
          module_eval <<-END, __FILE__, __LINE__+1
            def initialize(*args)
              @keys = nil
              super
            end
            def clear
              @keys = nil
              super
            end
            def replace(enum)
              @keys = nil
              super
            end
            def add(o)
              o.respond_to?(:<=>) or raise ArgumentError, "value must respond to <=>"
              @keys = nil
              super
            end
            alias << add
            def delete(o)
              @keys = nil
              @hash.delete(o)
              self
            end
            def delete_if
              block_given? or return enum_for(__method__) { size }
              n = @hash.size
              super
              @keys = nil if @hash.size != n
              self
            end
            def keep_if
              block_given? or return enum_for(__method__) { size }
              n = @hash.size
              super
              @keys = nil if @hash.size != n
              self
            end
            def merge(enum)
              @keys = nil
              super
            end
            def each(&block)
              block or return enum_for(__method__) { size }
              to_a.each(&block)
              self
            end
            def to_a
              (@keys = @hash.keys).sort! unless @keys
              @keys
            end
            def freeze
              to_a
              super
            end
            def rehash
              @keys = nil
              super
            end
          END
        end
        # a hack to shut up warning
        remove_method :old_init
        @@setup = true
      end
    end
  end
  def initialize(*args, &block) # :nodoc:
    SortedSet.setup
    initialize(*args, &block)
  end
end

module Enumerable
  # Makes a set from the enumerable object with given arguments.
  # Needs to +require "set"+ to use this method.
  def to_set(klass = Set, *args, &block)
    klass.new(self, *args, &block)
  end
end
#===============================================================================
# * Basic String class
#===============================================================================
class String  
  #----------------------------------------------------------------------------
  # *) Delete a char at certain position
  #----------------------------------------------------------------------------
  def delete_at(*args)
    self.slice!(*args)
  end
  #----------------------------------------------------------------------------
  # * Delete extra empty chars via Win32API
  #----------------------------------------------------------------------------
  def purify
    #self.gsub!("\u0000", '').delete!('\\0').squeeze!('\\').tr!('\\','/').delete_at(length-1)
    self.gsub!(/(?:\u0000)(.+)/,'')
    self.gsub!('\\n', 10.chr)
    self
  end
  #----------------------------------------------------------------------------
  # * Alias for fix encoding issue
  #----------------------------------------------------------------------------
  alias :gsub_enc! :gsub!
  def gsub!(*args)
    begin
      gsub_enc!(*args)
    rescue => exception
      args = change_encoding($default_encoding, *args)
      gsub_enc!(*args)
    end # begin
  end
  #----------------------------------------------------------------------------
  alias :gsub_enc :gsub
  def gsub(*args)
    begin
      gsub_enc(*args)
    rescue => exception
      args = change_encoding($default_encoding, *args)
      gsub_enc(*args)
    end # begin
  end
  #----------------------------------------------------------------------------
  alias :tr_enc :tr
  def tr(*args)
    begin
      tr_enc(*args)
    rescue => exception
      args = change_encoding($default_encoding, *args)
      tr_enc(*args)
    end # begin
  end
  #----------------------------------------------------------------------------
end
#==============================================================================
# ** PONY
#------------------------------------------------------------------------------
#  Pone Pone Pone~ Po-Po-Pony should poni pony
#==============================================================================
$imported = {} if $imported.nil?
$imported["COM::DND::BasicModule"] = true
Button_CoolDown = 10
SPLIT_LINE = "-------------------------------------------------"
module PONY
  #----------------------------------
  TOTAL_BIT_VARIABLE_ID   = 31
  TOTAL_XP_VARIABLE_ID    = 32
  
  COMBAT_STOP_FLAG        = 98
  Enable_Loading          = true
  
  TimeCycle               = 60  # Frame
  @hashid_table           = {}
  @inhert_table           = {}
  
  # tag: icon
  #----------------------------------
  IconID = {
    :bit            => 558,
    :chromastal     => 571,
    :mouse_casting  => 386,
    :loot_drop      => 573,
    :aim            => 6140,
    :targeting      => 6140,
    :fighting       => 115,
    :self           => 125,
    :plus           => 1143,
    :minus          => 1145,
    :player         => 556,
    :level_up       => 8182,
  }
  #----------------------------------
  StateID = {
    :aggressive_level => [7,8,9,10,11,12],
    :true_sight       => 13,
    :hold_position    => 4,
    :free_movement    => 24,
    :invisible        => 19,
  }
  #----------------------------------
  LightStateID = {
    14  =>  0, # Light_Core::Effects
  }
  #----------------------------------
  Bitset = Array.new(500){|i| 1 << i}
  #-----------------------------------------------------------------------------
  def self.InitObjSpace
    return ; # Currently not used
    superclasses = Set.new
    ObjectSpace.each_object(Class) do |cls|
      superclasses.merge(cls.ancestors)
    end
    ar = []
    superclasses.each{|i| ar << i}
    bitnum = {}; bitnum.default = 0
    objs = {}
    
    ar.each do |cls|
      n = cls.ancestors.select{|i| i != cls}.size
      cls.const_set(:Ancestor_num, n)
      objs[n] = Array.new if objs[n].nil?
      objs[n] << [ cls, bitnum[n] ]
      bitnum[n] += 1;
    end
    
    objs.each do |n, ary|
      ary.each do |obj|
        n = obj.first::Ancestor_num
        cls = obj.first
        offset = 0
        n.times{|i| offset += bitnum[i]}
        bit = (1 << (obj.last + offset))
        cls.const_set(:InhertID, bit)
      end
    end
    
    ar.each do |cls|
      final_bit = cls::InhertID
      cls.ancestors.each do |anc|
        final_bit |= anc::InhertID
      end
      cls.const_set(:InhertID, final_bit)
    end
    
  end
  #-----------------------------------------------------------------------------
end

$imported = {} if $imported.nil?
$imported["COM::DND::API"] = true
#==============================================================================
# ** PONY::API
#------------------------------------------------------------------------------
#  API is magic
#==============================================================================
module PONY::API
  VODLPath             = "System/VODL.dll"
  OpenALPath           = "System/OpenAL.dll"
  CheckSum             = Win32API.new(VODLPath, "Checksum",'pll','l')
  ClipCursor           = Win32API.new('user32', 'ClipCursor', 'p', 'l')
  CloseWindow          = Win32API.new('user32', 'CloseWindow', 'l', 'l')
  CreateWindowEx       = Win32API.new('user32', 'CreateWindowEx', 'lppliiiipppp', 'l')
  CheckConnection      = Win32API.new(VODLPath, 'CheckConnection', 'v', 'l')
  DispatchMessage      = Win32API.new('user32', 'DispatchMessage', 'p', 'p')
  DecryptInt           = Win32API.new(VODLPath, 'DecryptInt', 'p', 'p')
  EncryptInt           = Win32API.new(VODLPath, 'EncryptInt', 'p', 'p')
  FindWindow           = Win32API.new('user32', 'FindWindow', 'pp', 'i')
  FindWindowEX         = Win32API.new('user32', 'FindWindowEx', ['l','l','p','p'], 'i')
  GamejoltConnect      = Win32API.new(VODLPath, "GetGamejoltInfo", 'i', 'pp') rescue nil
  GetAsyncKeyState     = Win32API.new("user32", "GetAsyncKeyState", 'i', 'i')
  GetClientRect        = Win32API.new('user32', 'GetClientRect', 'lp', 'i')
  GetClipboardData     = Win32API.new("user32","GetClipboardData", 'i', 'i')
  GetCursorPos         = Win32API.new('user32', 'GetCursorPos', 'p', 'i')
  GetFocus             = Win32API.new('user32', 'GetFocus', 'i', 'l')
  GetForegroundWindow  = Win32API.new('user32','GetForegroundWindow', 'v', 'l')
  GetKeyState          = Win32API.new("user32","GetKeyState", 'i', 'i')
  GetMessage           = Win32API.new('user32', 'GetMessage', 'plll', 'l')
  GetModuleHandle      = Win32API.new('kernel32', 'GetModuleHandle', 'p', 'l')
  GetPPString          = Win32API.new('kernel32', 'GetPrivateProfileString', 'pppplp', 'l')
  GetSystemMetrics     = Win32API.new('user32', 'GetSystemMetrics', ['i'], 'i')
  GetWindowRect        = Win32API.new('user32', 'GetWindowRect', 'lp', 'i')
  GetWindowText        = Win32API.new('user32', 'GetWindowText', 'lpi', 'i')
  GetWindowTextLength  = Win32API.new("user32", "GetWindowTextLength", "l", "l")
  IsWindow             = Win32API.new('user32', 'IsWindow', 'l', 'i')
  LoadGamegoltUrl      = Win32API.new(VODLPath, "LoadGamejoltUrl", 'p', 'p')
  LoadLibrary          = Win32API.new('kernel32', 'LoadLibraryA', 'p', 'i')
  MD5                  = Win32API.new(VODLPath, "MDA5",'p','p')
  Mining               = Win32API.new(VODLPath,"Mine_Block",['L','L'],'L')
  OpenALPlay           = Win32API.new(OpenALPath,"PlayAudio", 'pllllllllllll','l')
  OpenALInitDevice     = Win32API.new(OpenALPath,"InitDevice", 'P','l')
  OpenALInitContext    = Win32API.new(OpenALPath,"InitContext", 'PP','l')
  OpenALClose          = Win32API.new(OpenALPath,"DestroyDevice", 'pp','l')
  ScreenToClient       = Win32API.new('user32', 'ScreenToClient', 'lp', 'i')
  SetCursorPos         = Win32API.new('user32', 'SetCursorPos', 'nn', 'n')
  SetFocus             = Win32API.new('user32', "SetFocus", 'l', 'l')
  SetParent            = Win32API.new('user32', 'SetParent', 'll', 'l')
  SetWindowPos         = Win32API.new('user32', 'SetWindowPos', ['l','i','i','i','i','i','p'], 'i')
  SetWindowText        = Win32API.new('user32', 'SetWindowText', 'lp', 'l')
  SendMessage          = Win32API.new('user32', 'SendMessage', 'llll', 'l')
  Sha256               = Win32API.new("System/VODL.dll","Sha256",'p','p')
  ShowWindow           = Win32API.new('user32', "ShowWindow", "ll", "l")
  UpdateWindow         = Win32API.new('user32', 'UpdateWindow', 'l', 'l')
  Verify               = Win32API.new(VODLPath,"Verify_Result",['L','L'],'p')
  VerifyGiftCode       = Win32API.new(VODLPath,"CodeValid", 'pp', 'l')
  WcharToMulByte       = Win32API.new('kernel32', 'WideCharToMultiByte', 'ilpipipp', 'p')
  WritePPString        = Win32API.new('kernel32', 'WritePrivateProfileString', 'pppp', 'i')
  
  SumArray             = Win32API.new(VODLPath, "SumArray", 'lp', 'p')
  Fiboncci             = Win32API.new(VODLPath, "Fibonacci", 'l', 'p')

  LoadGame   = Win32API.new(VODLPath, 'LoadGameData', 'p', 'p')
  FindFoler  = Win32API.new(VODLPath, 'GetFolderPath', 'ip', 'i')
  #-----------------------------------------------------------------------------
  # * General Confings setup
  #-----------------------------------------------------------------------------
  GetPPString.call("Game", "Title", "", title = "\0" * 256, 256, ".//Game.ini")
  Hwnd = FindWindow.call("RGSS Player", title.unpack("C*").collect {|a| a.chr }.join.delete!("\0"))
  
  puts("API loaded")
end
#==============================================================================
# ** PONY
#------------------------------------------------------------------------------
#  API calling function
#==============================================================================
module PONY
  #==============================================================================
  connected = API::CheckConnection.call.to_bool
  define_singleton_method(:online?){connected}
  #-----------------------------------------------------------------------------
  # * Module functions
  #-----------------------------------------------------------------------------
  module_function
  #-----------------------------------------------------------------------------
  def Sha256(input = nil)
    input = input.to_s unless input.is_a?(String)
    return input.nil? ? API::Sha256 : API::Sha256.call(input)
  end
  #-----------------------------------------------------------------------------
  def MD5(input = nil)
    return input.nil? ? API::MD5 : API::MD5.call(input)
  end
  #-----------------------------------------------------------------------------
  def Mining(input = nil, difficulty = 0x64)
    return input.nil? ? API::Mining : API::Mining.call(input, difficulty)
  end
  #-----------------------------------------------------------------------------
  def Verify(input = nil, difficulty = 0x64)
    return input.nil? ? API::Verify : API::Verify.call(input, difficulty)
  end
  #-----------------------------------------------------------------------------
  def CheckSum(input = nil, is_file = true, is_bin = true)
    is_file = is_file ? 1 : 0
    is_bin  = is_bin  ? 1 : 0
    return input.nil? ? API::CheckSum : API::CheckSum.call(input, is_file, is_bin)
  end
  #-----------------------------------------------------------------------------
  def EncInt(value)
    return unless value.is_a?(Numeric)
    if value < 0
      info = "Numeric out of range: #{value}"
      ERRNO.raise(:illegel_value, :exit, nil, info)
    else
      num = API::EncryptInt.call([value].pack("Q"))
      return num.to_i
    end
  end
  class << self; alias EncryptInt EncInt; end
  #-----------------------------------------------------------------------------
  def DecInt(value)
    return unless value.is_a?(Numeric)
    if value < 0
      info = "Numeric out of range: #{value}"
      ERRNO.raise(:illegel_value, :exit, nil, info)
    else
      #caller.each {|i| puts i} if value == 0
      num = API::DecryptInt.call([value].pack("Q"))
      return num.to_i
    end
  end
  class << self; alias DecryptInt DecInt; end
  #-----------------------------------------------------------------------------
  def InitOpenAL
    # tag: error >> bugged
    #$audio_device = Object.new
    #API::OpenALInitDevice.call(memprof($audio_device))
    #File.open('openal2.txt', 'wb'){|file| file << $audio_device}
    #$audio_context = API::OpenALInitContext.call(API::OpenALInitDevice.call)
  end
  #-----------------------------------------------------------------------------
  def CloseOpenAL
    #API::OpenALClose.call($audio_device, $audio_context)
  end
  #-----------------------------------------------------------------------------
  def PlayAudio(filename, sx, sy, sz, lx, ly, lz, 
                svx = 0, svy = 0, svz = 0, lvx = 0, lvy = 0, lvz = 0)
    #API::OpenALPlay.call(filename, sx, sy, sz, lx, ly, lz, svx, svy, svz, lvx, lvy, lvz)
  end
  #-----------------------------------------------------------------------------
  def VerifyGiftCode(code)
    unless PONY.online?
      info = Vocab::OfflineMode
      t    = sec_to_frame(10)
      SceneManager.scene.raise_overlay_window(:popinfo, info: info, time: t)
      return ;
    end
    
    path = "System\\"
    if File.exist?(path + "DownloadManager")
      info  = sprintf(Vocab::Errno::GiftCodeFailed, Vocab::Errno::ProgramMissing)
      info += "GDownloader"
      SceneManager.scene.raise_overlay_window(:popinfo, info);
      return false
    end
    if File.exist?(path + "GateCloser")
      info  = sprintf(Vocab::Errno::GiftCodeFailed, Vocab::Errno::ProgramMissing)
      info += "GCloser"
      SceneManager.scene.raise_overlay_window(:popinfo, info);
      return false
    end
    SceneManager.scene.raise_overlay_window(:popinfo, Vocab::Connection);
    # need some time to make overlay window displayed
    $giftcode_verify  = code
    $verify_countdown = 20
  end
  #-----------------------------------------------------------------------------
  def DoVerifyCode
    path = "System\\"
    code = $giftcode_verify
    result = API::VerifyGiftCode.call(path, code)
    $giftcode_verify  = nil
    $verify_countdown = nil
    case result
    when 0; return true;
    when 1; return :json_failed;
    when 2; return :connection_failed;
    when 3; return :invalid_code;
    when 4; return :close_failed;
    when 5; return :decrypt_failed;
    else
      return false
    end
  end
  #-----------------------------------------------------------------------------
  def hashid_table
    return @hashid_table
  end
  #-----------------------------------------------------------------------------
  def inhert_table
    @inhert_table
  end
  #-----------------------------------------------------------------------------
end

#==============================================================================
# ** FileManager
#------------------------------------------------------------------------------
#  This module is using to change the configs in Game.ini, e.g. sound volume or
#  other settings.
#==============================================================================
module FileManager
  #---------------------------------------------------------------------------
  PaddingWidth  = 6
  DebugFilePath = "Data/Debug/"
  #---------------------------------------------------------------------------
  module_function
  #---------------------------------------------------------------------------
  # *) Ensure the file or dictionary
  #---------------------------------------------------------------------------
  def ensure_file_exist(filename)
    Dir.mkdir(filename) unless File.exist?(filename)
  end
  #--------------------------------------------------------------------------
  # * Text wrap for window contents
  #--------------------------------------------------------------------------
  def textwrap(full_text, line_width, sample_bitmap = nil)
    return [] if full_text.nil?
    

    if sample_bitmap.nil?
      using_sample = true
      sample_bitmap = Bitmap.new(1,1)
    else
      using_sample  = false
    end
    raise TypeError unless full_text.is_a?(String)
    full_text   = full_text.dup.force_encoding($default_encoding)
    
    wraped_text = []
    cur_width   = PaddingWidth
    line        = ""
    bk_full     = '　'.force_encoding($default_encoding)
    bk_half     = ' '.force_encoding($default_encoding)
    strings     = full_text.gsub(bk_full, bk_half).split(/[\r\n ]+/i)
    strs_n      = strings.size
    space_width = sample_bitmap.text_size(' ').width
    minus_width = sample_bitmap.text_size('-').width
    
    # while any string segment unprocessed
    while (str = strings.first)
      next if str.length == 0
      width = sample_bitmap.text_size(str).width
      endl  = false
      # if the segment width larger than display width
      if width + PaddingWidth >= line_width
        line      = ""
        cur_width = minus_width
        strlen    = str.length
        processed = false
        last_i    = 0
        # process each character on by one
        for i in 0...strlen
          width = sample_bitmap.text_size(str[i]).width
          last_i = i
          # unable to display character
          if !processed && cur_width + width >= line_width
            sample_bitmap.dispose if using_sample
            return [full_text]
          elsif cur_width + width < line_width
            cur_width += width
            line += str[i]
            processed = true
          else
            break
          end
        end
        # continue symbol character
        line += '-'
        # replace with left unprocessed string
        strings[0] = str[last_i...strlen]
        endl = true
      # + segment width smaller than line width, continue
      elsif cur_width + width < line_width
        cur_width += width + space_width
        line += strings.shift + ' '
        endl = true if strings.size == 0
      # + segment width over the line width, process end of line
      else
        endl = true
      end
      
      if endl
        wraped_text.push(line)
        line = ""
        cur_width = PaddingWidth
      end
    end
    sample_bitmap.dispose if using_sample
    return wraped_text
  end
  #--------------------------------------------------------------------------
  # * Load Game.ini index
  #--------------------------------------------------------------------------
  def load_ini(group, target, path = ".//Game.ini")
    buffer = '\0' * 256
    PONY::API::GetPPString.call(group, target, '', buffer, 256, path)
    return buffer.strip
  end
  #--------------------------------------------------------------------------
  # * Modify Game.ini index
  #--------------------------------------------------------------------------
  def write_ini(group, target, goal, path = ".//Game.ini")
    PONY::API::WritePPString.call(group, target, goal, path)
  end # def change ini
  #--------------------------------------------------------------------------
  # * Replace
  #--------------------------------------------------------------------------
  def convert_eval_string(str)
    return if str.nil?
    cache = ""
    detect_flag = false
    true_str = ""
    
    for i in 0...str.length
      if str[i] == '%' && str[i+1] == '{'
        detect_flag = true
        next
      end
      
      if detect_flag
        if str[i] == '}'
          cache[0] = ''
          puts "#{cache}"
          true_str += eval(cache).to_s rescue "%{CONVERSION ERROR}"
          cache = ""; detect_flag = false;
        elsif str[i]
          cache += str[i]
        end
      else # if not detecting eval code
        true_str += str[i]
      end # if detect flag on
    end # for i in str
    
    return true_str
  end # def convert
  #--------------------------------------------------------------------------
  def export_all_map_dialog
    path = "Data/Map*.rvdata2"
    files = Dir.glob(path)
    files.each do |filename|
     export_map_dialog(filename)
    end
  end
  #--------------------------------------------------------------------------
  def export_map_dialog(map_sym)
    map_sym =~ /(?:Map)[ ]\d+/i
    if map_sym.is_a?(Numeric)
      map_id = map_sym.to_fileid(3) 
    else
      map_id = map_sym.split("Map")[1].split('.').first
    end
    path = "Data/Dialog/"
    Dir.mkdir(path) unless File.exist?(path)
    path     += map_id
    Dir.mkdir(path) unless File.exist?(path)
    filename = path + "/dialog.txt"
    map  = load_data(sprintf("Data/Map%03d.rvdata2", map_sym)) if map_sym.is_a?(Numeric)
    map  = load_data(map_sym) if map_sym.is_a?(String)
    return unless map.is_a?(RPG::Map)
    output = ""
    map.events.each_value do |event|
      output += sprintf("[%03d] %s\n", event.id, event.name)
      event.pages.each do |page|
        listsize = page.list.size
        index = 0
        while index < listsize
          outputed = false
          if page.list[index].code == 101 || page.list[index].code == 105
            while page.list[index+1].code == 101 && Variable.message_rows > 4 || page.list[index+1].code == 401
              index += 1
              output += page.list[index].parameters[0].to_s + 10.chr
              outputed = true
            end
          end # if page will show text
          index += 1
          output += SPLIT_LINE + 10.chr if outputed
        end # commands in list
      end # pages in event
    end # events in map
    File.open(filename, 'w') do |file|
        file.write(output)
    end
  end
  #--------------------------------------------------------------------------
  def continue_message_string?
    return true if next_event_code == 101 && Variable.message_rows > 4
    return next_event_code == 401
  end
  #--------------------------------------------------------------------------
  def build_debug_file(filename, stat, &block)
    path = "Data/Debug"; ensure_file_exist(path); path += "/" + filename;
    File.open(path, stat) do |file|
      yield file if block_given?
    end
  end
  #--------------------------------------------------------------------------
  def compress_source(file)
    script = []
    script[0] = (file.hash + script.hash).abs
    script[1] = file.split(/[\/\\]+/).last
    script[3] = load_data(file)
    script[2] = Zlib::Deflate.deflate(script[3])
    return script
  end
  #---------------------------------------------------------------------------
  def export_debug_file(filename, index)
    mkdir(DebugFilePath) unless File.exist?(DebugFilePath)
    path = DebugFilePath + filename
    File.open(path, 'w') do |file|
      file.write(index)
    end
    return path
  end
  #---------------------------------------------------------------------------
end

#===============================================================================
# * GameManager
#===============================================================================
module GameManager
  #----------------------------------------------------------------------------
  @debug_mode       = false
  @show_roll_result = false
  @skip_loading     = false
  @focus            = true
  @hwnd             = nil
  #----------------------------------------------------------------------------
  module_function
  def initialize
    self.load_ini
    @hwnd = PONY::API::Hwnd
  end
  #----------------------------------------------------------------------------
  def load_ini
    group = "Option"
    @show_roll_result = FileManager.load_ini(group, 'ShowRollResult').to_i.to_bool
    @debug_mode       = FileManager.load_ini(group, 'DebugMode').to_i.to_bool
    @skip_loading     = FileManager.load_ini(group, 'SkipLoading').to_i.to_bool
    puts "Ini loaded"
    puts "#{@debug_mode} #{@skip_loading}"
  end
  #----------------------------------------------------------------------------
  def load_volume
    Sound.set_volume(100,100,100)
    begin
      volume = FileManager.load_ini('Option', 'Volume')
      volume = volume.split(/[\[\]]/).at(1)
      volume = volume.split(',').collect{|i| i.to_i}
    rescue Exception => e
      volume = [100, 100, 100]
    end
    volume = [100, 100, 100] if !volume
    Sound.set_volume(*volume)
    puts("Volume:", Sound.volume)
  end
  #----------------------------------------------------------------------------
  def get_language_setting
    raw = FileManager.load_ini('Option', 'Language').purify.downcase.to_sym
    puts "Language Changed: #{raw}"
    return $supported_languages.keys.include?(raw) ? raw : :en_us
  end
  #--------------------------------------------------------------------------
  def update_focus
    chwnd  = PONY::API::GetFocus.call(0)
    @focus = chwnd == @hwnd || ($input_hwnd && $input_hwnd == chwnd)
  end
  #----------------------------------------------------------------------------
  def skip_loading?
    return @skip_loading || ($game_system && ($game_system.game_mode == :credits))
  end
  #----------------------------------------------------------------------------
  # * Getter query functions
  #----------------------------------------------------------------------------
  def show_roll_result?; @show_roll_result; end
  def focused?; @focus; end
  def debug_mode?; @debug_mode; end
  #----------------------------------------------------------------------------
end

GameManager.initialize
CurrentLanguage = GameManager.get_language_setting
puts "Language: #{CurrentLanguage}"
#===============================================================================
# Mouse System
# By Jet10985(Jet)
# Some code by Daniel Martin
#===============================================================================
# This script will allow full use of the mouse inside of Ace for various
# purposes.
# This script has: 13 customization options.
#===============================================================================
# Overwritten Methods:
# Game_Player: move_by_input
# Window_NameInput: item_max
#-------------------------------------------------------------------------------
# Aliased methods:
# Scene_Title: start
# Scene_Map: update, terminate, update_transfer_player
# Input: update, trigger?, press?, repeat?, dir8/dir4
# Window_Selectable: update
# Scene_File: update, top_index=
# Game_Event: update, setup_page
# Game_Player: check_action_event, get_on_off_vehicle
# Game_System: initialize, on_after_load
#===============================================================================
=begin
Showing text above event when mouse hovers:
If you want a message to appear over an event's head if the mouse is hovering
over the event, put this comment in the event:
MOUSE TEXT MESSAGE HERE
everything after TEXT will be the hovering display.
--------------------------------------------------------------------------------
Change mouse picture above event when mouse hovers:
If you want the mouse's picture to temporarily change whne over an event, put
this comment in the event
MOUSE PIC NAME/NUMBER
if you put a name, the mouse will become that picture, but if you put a number
then the mouse will become the icon that is the id number
--------------------------------------------------------------------------------
Specific mouse click movement routes:
If you want the player to land specifically in a square around an event when
they click to move on the event, put one of these comments in the event:
MOUSE MOVE UP/LEFT/RIGHT/DOWN
only put the direction that you want the player to land on.
--------------------------------------------------------------------------------
Click to activate:
If you want an event to automatically start when it is clicked on, place
this in an event comment:
MOUSE CLICK
--------------------------------------------------------------------------------
Ignore Events:
To have an event be ignored when the mouse makes it's movement path(as if the
event isn't there), put this comment in the event:
MOUSE THROUGH
--------------------------------------------------------------------------------
You can do some extra things with the mouse using event "Script..." commands:
Mouse.set_pos(x, y) will set the mouse's position to the x and y specified.
Mouse.area?(x, y, width, height) will check if the mouse is inside the given
rectangle, on-screen. This does not account for a scrolled map.
Mouse.grid will return where on the screen the mouse is, not accounting for
a scrolled map. Returns an array: [x, y]
Mouse.true_grid will return where on the map the mouse is, accounting for a
scrolled map. Returns an array: [x, y]
Mouse.click?(1 or 2) will return true/false depending on if a mouse button was
clicked, in only the current frame. Use 1 for left-click, 2 for right-click.
Mouse.press?(1 or 2) will return true/false depending on if a mouse button is
currently being pressed. Use 1 for left-click, 2 for right-click.
swap_mouse_cursor(data) will change the idle look of the mouse icon, and it will
persist on the savefile. data is either the name of a picture eg "cursor-icon2"
or the number of an icon eg 12. Images should be in quotes, whereas icons should
just be the number.
--------------------------------------------------------------------------------
Extra Notes:
You can activate action button events by standing next to the event and clicking
on it with the mouse.
=end
module Jet
  module MouseSystem
    
    # This is the image used to display the cursor in-game.
    CURSOR_IMAGE = "cursor-picture"
    
    # If the above image does not exist, the icon at this index will be used.
    CURSOR_ICON = 10821
    
    # turning ths switch on will completely disable the mouse.
    TURN_MOUSE_OFF_SWITCH = 99
    
    # Do you want the player to be able to move using the mouse?
    # This can be changed in-game using toggle_mouse_movement(true/false)
    ALLOW_MOUSE_MOVEMENT = true
    
    # Do you want to check for diagonal movement as well? Please note this
    # enables regular diagonal movement with the keyboard as well.
    DO_DIAGONAL_MOVEMENT = false
    
    # If the tile they click on for movement is not passable, do you want
    # to check the surround tiles for a movable area?
    CHECK_FOR_MOVES = true
    
    # Would you like a black box to outline the exact tile the mouse is over?
    DEV_OUTLINE = false
    
    # Do you want the mouse to be confined to the game window?
    CLIP_CURSOR = false
    
    # Allow the use of the mouse wheel to scroll selectable windows?
    USE_WHEEL_DETECTION = false
    
  end
  
  module HoverText
    
    # This is the font for the hovering mouse text.
    FONT = "Verdana"
    
    # This is the font color for hovering mouse text.
    COLOR = Color.new(255, 255, 255, 255)
    
    # This is the font size for hovering mouse text.
    SIZE = 20
    
  end
  
  module Pathfinder
    
    # While mainly for coders, you may change this value to allow the
    # pathfinder more time to find a path. 1000 is default, as it is enough for
    # a 100x100 maze.
    MAXIMUM_ITERATIONS = 1000
    
    # This is a hash of directional values, please don't modify this.
    DIRECTIONAL_VALUES = {[1, 0] => 6, [-1, 0] => 4, [0, 1] => 2, [0, -1] => 8,
        [-1, 1] => 1, [-1, -1] => 7, [1, 1] => 3, [1, -1] => 9}
        
    # This is a hash of diagonal keys, please don't modify this.
    DIAGONAL_VALUES = {[-1, 1] => [4, 2], [-1, -1] => [4, 8], 
        [1, 1] => [6, 2], [1, -1] => [6, 8], [1, 0] => [6, 6], [-1, 0] => [4, 4], 
        [0, 1] => [2, 2], [0, -1] => [8, 8]}
    
  end
end
#===============================================================================
# DON'T EDIT FURTHER UNLESS YOU KNOW WHAT TO DO.
#===============================================================================
module Mouse
  
  ClipCursor        = PONY::API::ClipCursor
  GetKeyState       = PONY::API::GetKeyState
  GetCursorPo       = PONY::API::GetCursorPos
  SetCursorPos      = PONY::API::SetCursorPos
  GetMessage        = PONY::API::GetMessage
  GetAsyncKeyState  = PONY::API::GetAsyncKeyState
  ScreenToClient    = PONY::API::ScreenToClient
  GetClientRect     = PONY::API::GetClientRect
  GetWindowRect     = PONY::API::GetWindowRect
  ShowCursor        = Win32API.new('user32', 'ShowCursor', 'i', 'i')
  
  @handle = PONY::API::Hwnd  
  
  Point = Struct.new(:x, :y)
  
  Message = Struct.new(:message, :wparam, :lparam, :pt)
  
  Param = Struct.new(:x, :y, :scroll)
  
  Scroll = 0x0000020A
  
  module_function
  
  def hiword(dword)
    return((dword & 0xffff0000) >> 16) & 0x0000ffff
  end
  
  def loword(dword)
    return dword & 0x0000ffff
  end
    
  def word2signed_short(value)
    return value if (value & 0x8000) == 0
    return -1 *((~value & 0x7fff) + 1)
  end
  
  def unpack_dword(buffer, offset = 0)
    bitso = buffer.bytes.to_a
    ret = bitso[offset + 0] & 0x000000ff
    ret |=(bitso[offset + 1] << (8 * 1)) & 0x0000ff00
    ret |=(bitso[offset + 2] << (8 * 2)) & 0x00ff0000
    ret |=(bitso[offset + 3] << (8 * 3)) & 0xff000000
    return ret
  end
  
  def unpack_msg(buffer)
    msg = Message.new
    msg.pt = Point.new
    msg.message = unpack_dword(buffer,4 * 1)
    msg.wparam = unpack_dword(buffer, 4 * 2)
    msg.lparam = unpack_dword(buffer,4 * 3)
    msg.pt.x = unpack_dword(buffer, 4 * 5)
    msg.pt.y = unpack_dword(buffer, 4 * 6)
    return msg
  end
  
  def wmcallback(msg)
    return unless msg.message == Scroll
    param = Param.new
    param.x = word2signed_short(loword(msg.lparam))
    param.y = word2signed_short(hiword(msg.lparam))
    param.scroll = word2signed_short(hiword(msg.wparam))
    return [param.x, param.y, param.scroll]
  end
  
  def scroll
    msg = "\0" * 32
    GetMessage.call(msg, @handle, 0, 0)
    ar = []
    msg.each_byte {|bin| ar << bin}
    r = wmcallback(unpack_msg(msg))
    return r if !r.nil?
  end
  
  def click?(button)
    return false if (@pos[0] & @pos[1]) == 0
    return (@keys & PONY::Bitset[button]).to_bool
  end
  
  def press?(button)
    return false if (@pos[0] & @pos[1]) == 0
    return (@press & PONY::Bitset[button]).to_bool
  end
  
  def set_pos(x_pos = 0, y_pos = 0)
    rect = client_rect
    width = rect[2] - rect[0]
    height = rect[3] - rect[1]
    if (x_pos.between?(0, width) && y_pos.between?(0, height))
      SetCursorPos.call(rect[0] + x_pos, rect[1] + y_pos)
    end
  end
  
  def moved?
    @pos != @old_pos
  end
  
  def cursor
    @cursor
  end
  
  def set_cursor(image)
    (@cursor ||= Sprite_Cursor.new).set_cursor(image)
  end
  
  def revert_cursor
    (@cursor ||= Sprite_Cursor.new).revert
  end
  
  def update
    ClipCursor.call(client_rect.pack('l4')) if Jet::MouseSystem::CLIP_CURSOR
    if !$game_switches.nil? 
      if $game_switches[Jet::MouseSystem::TURN_MOUSE_OFF_SWITCH]
        @keys, @press = 0, 0
        @pos = [-1, -1]
        @cursor.update
        return
      end
    end
    @old_pos = @pos.dup
    @pos     = Mouse.pos
    @keys    = 0
    @press   = 0
    @keys  |= PONY::Bitset[1] if GetAsyncKeyState.call(1) & 0x01 == 1
    @keys  |= PONY::Bitset[2] if GetAsyncKeyState.call(2) & 0x01 == 1
    @keys  |= PONY::Bitset[3] if GetAsyncKeyState.call(4) & 0x01 == 1
    @press |= PONY::Bitset[1] if pressed?(1)
    @press |= PONY::Bitset[2] if pressed?(2)
    @press |= PONY::Bitset[3] if pressed?(4)
    @cursor.update rescue @cursor = Sprite_Cursor.new
  end
  
  def init
    @keys = 0
    @press = 0
    @pos = Mouse.pos
    @cursor = Sprite_Cursor.new
  end
  
  def pressed?(key)
    return true unless GetKeyState.call(key).between?(0, 1)
    return false
  end
  
  def global_pos
    pos = [0, 0].pack('ll')
    GetCursorPo.call(pos) != 0 ? (return pos.unpack('ll')) : (return [0, 0])
  end
  
  def pos
    x, y = screen_to_client(*global_pos)
    width, height = client_size
    begin
      x = 0 if x <= 0; y = 0 if y <= 0
      x = width if x >= width; y = height if y >= height
      return x, y
    end
  end
  
  def screen_to_client(x, y)
    return nil unless x && y
    pos = [x, y].pack('ll')
    if ScreenToClient.call(@handle, pos) != 0
      return pos.unpack('ll')
    else
      return [0, 0]
    end
  end
  
  def client_size
    rect = [0, 0, 0, 0].pack('l4')
    GetClientRect.call(@handle, rect)
    right,bottom = rect.unpack('l4')[2..3]
    return right, bottom
  end
  
  def client_rect
    rect = [0, 0, 0, 0].pack('l4')
    GetWindowRect.call(@handle || @hwnd, rect)
    posi = rect.unpack('l4')[0..1]
    GetClientRect.call(@handle || @hwnd, rect)
    size = rect.unpack('l4')[2..3]
    scr = screen_to_client(*posi)
    x1 = posi[0] + scr[0].abs
    y1 = posi[1] + scr[1].abs
    x2 = size[0] + posi[0]
    y2 = size[1] + posi[1] + scr[1].abs
    rect = [x1, y1, x2, y2]
    rect
  end
  
  def grid
    [(@pos[0]/32),(@pos[1]/32)]
  end
  
  def true_grid
    xy = @pos
    x = ((xy[0] + ($game_map.display_x * 32)) / 32).floor
    y = ((xy[1] + ($game_map.display_y * 32)) / 32).floor
    [x, y]
  end
  
  def grid_by_pos
    [pos[0] / 32, pos[1] / 32]
  end
  
  #tag: modified
  def true_grid_by_pos(to_int = true)
    xy = pos
    x = ((xy[0] + ($game_map.display_x * 32)) / 32)
    y = ((xy[1] + ($game_map.display_y * 32)) / 32)
    return to_int ? [x.floor, y.floor] : [x, y]
  end
  
  def area?(x, y, width, height)
    @pos[0].between?(x, width + x) && @pos[1].between?(y, height + y)
  end
  
  class Sprite_Cursor < Sprite
    
    attr_reader :cursor_bitmap
    
    def initialize
      super(nil)
      self.z = PONY::SpriteDepth::Table[:mouse]
      @bitmap_cache = initial_bitmap
      # tag: modified
      #if Jet::MouseSystem::DEV_OUTLINE
        create_outline
      #end
    end
    
    def swap_bitmap(data)
      begin
        self.bitmap = Cache.picture(data)
      rescue
        self.bitmap = Bitmap.new(24, 24)
        icon_index = data
        rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
        self.bitmap.blt(0, 0, Cache.iconset, rect, 255) rescue nil
      end
      @bitmap_cache = self.bitmap.dup
      @cursor_bitmap = data
    end
    
    def initial_bitmap
      begin
        self.bitmap = Cache.picture(Jet::MouseSystem::CURSOR_IMAGE)
        @cursor_bitmap = Jet::MouseSystem::CURSOR_IMAGE
      rescue
        self.bitmap = Bitmap.new(24, 24)
        icon_index = Jet::MouseSystem::CURSOR_ICON
        rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
        self.bitmap.blt(0, 0, Cache.system("Iconset"), rect, 255)
        @cursor_bitmap = Jet::MouseSystem::CURSOR_ICON
      end
      self.bitmap.dup
    end
    
    def set_cursor(image)
      if image.is_a?(Integer)
        self.bitmap = Bitmap.new(24, 24)
        icon_index = image
        rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
        self.bitmap.blt(0, 0, Cache.system("Iconset"), rect, 255)
      else
        self.bitmap = Cache.picture(image)
      end
    end
    
    def revert
      self.bitmap = @bitmap_cache.dup
    end
    
    def update
      super
      self.x, self.y = *Mouse.pos
      self.visible = !$game_switches[Jet::MouseSystem::TURN_MOUSE_OFF_SWITCH]
      if !@outline.nil?
        x = Mouse.true_grid_by_pos[0] * 32
        x -= $game_map.display_x.floor * 32
        x -= ($game_map.display_x % 1) * 32
        y = Mouse.true_grid_by_pos[1] * 32
        y -= $game_map.display_y.floor * 32
        y -= ($game_map.display_y % 1) * 32
        @outline.x = x
        @outline.y = [y, 1].max
      end
    end
  end
end
class << Input
  alias jet5888_press? press?
  def press?(arg)
    if arg == Input::C
      return true if Mouse.press?(1)
    elsif arg == Input::B
      return true if Mouse.press?(2)
    end
    jet5888_press?(arg)
  end
  
  alias jet5888_repeat? repeat?
  def repeat?(arg)
    if arg == Input::C
      return true if Mouse.click?(1)
    elsif arg == Input::B
      return true if Mouse.click?(2)
    end
    jet5888_repeat?(arg)
  end
  
  alias jet5888_trigger? trigger?
  def trigger?(arg)
    if arg == Input::C
      return true if Mouse.click?(1)
    elsif arg == Input::B
      return true if Mouse.click?(2)
    end
    jet5888_trigger?(arg)
  end
  
  alias jet8432_update update
  def update(*args, &block)
    jet8432_update(*args, &block)
    Mouse.update
  end
end
class Window_Selectable
  
  alias jet1084_update update
  def update(*args, &block)
    jet1084_update(*args, &block)
    @scrolled ||= false
    return if $game_switches[Jet::MouseSystem::TURN_MOUSE_OFF_SWITCH]
    @mouse_timer -= 1 if @mouse_timer > 0
    update_scroll if self.active && self.visible && Jet::MouseSystem::USE_WHEEL_DETECTION
    update_mouse  if self.active && self.visible && (Mouse.moved? or @scrolled)
  end
  
  def update_scroll
    return unless scrollable?
    
    f = Mouse.scroll
    if !f.nil?
      Mouse.flag_scroll = f[2]
      if f[2] < 0
        if contents.height > self.height && self.oy - contents.height < -self.height + 32
          self.top_row = self.top_row + 1
        end
      else
        self.top_row = self.top_row - 1 if contents.height > self.height
      end
      @scrolled = true
    else
      Mouse.flag_scroll = nil
    end
  end
  
  def scrollable?
    @scroll_enable
  end
  
  def get_mouse_timer
    return DefaultMouseTimer
  end
  
  def update_mouse
    return unless @mouse_timer == 0
    return unless Mouse.collide_sprite?(self)
    @mouse_timer = get_mouse_timer
    
    @scrolled = false
    orig_index = @index
    rects = []
    add_x = self.x + 16 - self.ox
    add_y = self.y + 16 - self.oy
    
    if !self.viewport.nil?
      add_x += self.viewport.rect.x - self.viewport.ox
      add_y += self.viewport.rect.y - self.viewport.oy
    end
    
    unless self.is_a?(Window_PopInfo)
      self.item_max.times {|i|
        mouse_update_cursor(i)
        rects << cursor_rect.dup
      }
      
      @index = orig_index
      
      rects.each_with_index {|rect, i|
        if Mouse.area?(rect.x + add_x, rect.y + add_y, rect.width, rect.height)
          select(i)
        end
      }
    end # skip selecting if window is a popup info
    update_cursor
    call_update_help
  end
  
  def mouse_update_cursor(_index = @index)
    if @cursor_all
      cursor_rect.set(0, 0, contents.width, row_max * item_height)
    elsif @index < 0
      cursor_rect.empty
    else
      cursor_rect.set(item_rect(_index))
    end
  end
end
class Window_NameInput
  
  def item_max
    90
  end
end
class Scene_File
  
  alias jet3467_update update
  def update(*args, &block)
    update_mouse if Mouse.moved?
    jet3467_update(*args, &block)
  end
  
  alias jet7222_top_index top_index=
  def top_index=(*args, &block)
    @last_cursor_move = 0 if @last_cursor_move.nil?
    @last_cursor_move -= 1
    return if @last_cursor_move > 0 && Mouse.moved?
    jet7222_top_index(*args, &block)
    @last_cursor_move = 10
  end
  
  def update_mouse
    self.item_max.times {|i|
      ix = @savefile_windows[i].x
      iy = @savefile_windows[i].y + 48 - @savefile_viewport.oy
      iw = @savefile_windows[i].width
      ih = @savefile_windows[i].height
      if Mouse.area?(ix, iy, iw, ih)
        @savefile_windows[@index].selected = false
        @savefile_windows[i].selected = true
        @index = i
      end
    }
    ensure_cursor_visible
  end
end
class Game_Temp
  
  attr_accessor :mouse_character, :mouse_movement, :mouse_path
  
end
class Window_MousePopUp < Window_Base
  
  def initialize(event, text)
    rect = Bitmap.new(1, 1).text_size(text)
    width = rect.width
    height = rect.height
    super(event.screen_x - width / 2, event.screen_y - 48, width + 32, height + 32)
    self.opacity = 0
    self.contents.font.name = Jet::HoverText::FONT
    self.contents.font.color = Jet::HoverText::COLOR
    self.contents.font.size = Jet::HoverText::SIZE
    @text = text
    @event = event
    refresh
  end
  
  def refresh
    contents.clear
    draw_text(0, 0, contents.width, contents.height, @text)
  end
  
  def update
    super
    self.visible = !@event.erased? && Mouse.true_grid_by_pos == [@event.x, @event.y]
    self.x = @event.screen_x - contents.width / 2 - 8
    self.y = @event.screen_y - 64
  end
end
class Game_Event
  
  attr_accessor :text_box
  
  def check_for_comment(regexp)
    return false if empty?
    for item in @list
      if item.code == 108 or item.code == 408
        if !item.parameters[0][regexp].nil?
          return $1.nil? ? true : $1
        end
      end
    end
    return false
  end
  
  def mouse_empty?
    return true if empty?
    return @list.reject {|a| [108, 408].include?(a.code) }.size <= 1
  end
  
  alias jet3745_setup_page setup_page
  def setup_page(*args, &block)
    jet3745_setup_page(*args, &block)
    @text_box = nil
    @mouse_activated = nil
    @mouse_cursor = nil
  end
  
  def mouse_activated?
    @mouse_activated ||= check_for_comment(/MOUSE[ ]*CLICK/i)
  end
  
  def text_box
    @text_box ||= (
      if (a = check_for_comment(/MOUSE[ ]*TEXT[ ]*(.+)/i))
        Window_MousePopUp.new(self, a)
      else
        false
      end
    )
  end
  
  def mouse_cursor
    @mouse_cursor ||= (
      if (a = check_for_comment(/MOUSE[ ]*PIC[ ]*(\d+)/i))
        a.to_i
      elsif (a = check_for_comment(/MOUSE[ ]*PIC[ ]*(.+)/i))
        a
      else
        false
      end
    )
  end
  
  def erased?
    @erased
  end
  
  def check_mouse_change
    if mouse_cursor
      Mouse.set_cursor(@mouse_cursor)
      return true
    end
    return false
  end
  
  alias jet3845_update update
  def update(*args, &block)
    jet3845_update(*args, &block)
    @text_box.update if text_box
  end
end
class Game_System
  
  attr_accessor :mouse_movement, :cursor_bitmap
  attr_reader :main_cursor_bitmap
  
  alias jet2735_initialize initialize
  def initialize(*args, &block)
    jet2735_initialize(*args, &block)
    @mouse_movement = Jet::MouseSystem::ALLOW_MOUSE_MOVEMENT
    @cursor_bitmap = Mouse.cursor.cursor_bitmap
    @main_cursor_bitmap = @cursor_bitmap
  end
  
  def change_cursor_bitmap(data)
    @main_cursor_bitmap = Jet::MouseSystem::CURSOR_ICON if @main_cursor_bitmap.nil?
    data = @main_cursor_bitmap if data.nil?
    Mouse.cursor.swap_bitmap(data)
    @cursor_bitmap = data
  end
  
  alias jet3457_on_after_load on_after_load
  def on_after_load(*args, &block)
    jet3457_on_after_load(*args, &block)
    Mouse.cursor.swap_bitmap(@cursor_bitmap)
  end
end
class Game_Interpreter
  
  def swap_mouse_cursor(data)
    $game_system.change_cursor_bitmap(data)
  end
end
class Scene_Title
  
  alias jet0019_start start
  def start(*args, &block)
    Mouse.cursor.initial_bitmap
    jet0019_start(*args, &block)
  end
end
#------------------------------------------------------------------------------
class Scene_Map
  #------------------------------------------------------------------------------
  attr_reader :target_cancel_timer
  #------------------------------------------------------------------------------
  alias start_mouse start
  def start
    @target_cancel_timer = 0
    start_mouse
  end
  #------------------------------------------------------------------------------
  alias jet3745_update update
  def update(*args, &block)
    jet3745_update
    check_mouse_movement if $game_system.mouse_movement
    check_mouse_icon_change
    @target_cancel_timer -= 1 if @target_cancel_timer > 0
  end
  #------------------------------------------------------------------------------
  alias jet5687_terminate terminate
  def terminate(*args, &block)
    $game_map.events.values.each {|a| 
      a.text_box.dispose if a.text_box
      a.text_box = nil
    }
    Mouse.update
    jet5687_terminate(*args, &block)
  end
  #------------------------------------------------------------------------------
  def mouse_char
    $game_temp.mouse_character
  end
  #------------------------------------------------------------------------------
  # * tag: merge
  #------------------------------------------------------------------------------
  def check_mouse_icon_change
    changed_mouse = false
    mouse_clicked = [Mouse.click?(1), Mouse.click?(2)]
    player_target = nil
    
    mpos = POS.new(*Mouse.true_grid_by_pos(false))
    events = $game_map.get_nearby_quadtree_value($game_map.get_quadtree_index(mpos.x,mpos.y))
    target = [nil, 0xffff]
    events.each do |event|
      next unless event.is_a?(Game_Event)
      dis = event.distance_to_character(mpos)
      next if dis > 1.5
      next if dis > target.last
      target = [event, dis]
    end
    target = target.first
    
    if mouse_clicked[1]
      $game_player.target_event = target
      $game_player.cancel_action_without_penalty
      $game_player.set_target(nil)
    elsif mouse_clicked[0]
      $game_player.set_target(target) if target
    end
    
    if target
      changed_mouse  = changed_mouse || target.check_mouse_change
      @mouse_hovered = target if target.trigger == 0
    end
    
    Mouse.revert_cursor unless changed_mouse
  end
  #------------------------------------------------------------------------------
  # tag: modified
  #------------------------------------------------------------------------------
  def check_mouse_movement
    return if $game_system.story_mode?
    return unless $game_player.controlable?
    $game_temp.mouse_character ||= $game_player
    if Mouse.click?(2) && !SceneManager.tactic_enabled?
      tx, ty = *Mouse.true_grid_by_pos
      $game_player.move_to_position(tx, ty, tool_range: 0)
    end
  end
  
end

#==============================================================================
# * Mouse add-ons
#==============================================================================
module Mouse
  #-----------------------------------------------------------------------------
  module_function
  #-----------------------------------------------------------------------------
  def global_cursor_visible?
    return @global_cursor_visible
  end
  #-----------------------------------------------------------------------------
  def hide_global_cursor
    @global_cursor_visible = false
    p 'hide cursor'
    ShowCursor.call(0)
  end
  #-----------------------------------------------------------------------------
  def show_global_cursor
    @global_cursor_visible = true
    p 'show cursor'
    ShowCursor.call(1)
  end
  #-----------------------------------------------------------------------------
  def scroll_up?
    return !@flag_scroll.nil? && @flag_scroll > 0
  end
  #-----------------------------------------------------------------------------
  def scroll_down?
    return !@flag_scroll.nil? && @flag_scroll < 0
  end
  #-----------------------------------------------------------------------------
  def flag_scroll=(stat)
    @flag_scroll = stat
  end
  #-----------------------------------------------------------------------------
  def collide_sprite?(sprite)
    return false if !sprite.is_a?(Rect) && sprite.disposed?
    return area?(sprite.x, sprite.y, sprite.width, sprite.height) rescue false
  end
  #-----------------------------------------------------------------------------
  # * Check if mouse pointer if over skillbar
  #-----------------------------------------------------------------------------
  def hover_skillbar?(index = nil)
    return false if $game_party.skillbar.sprite.nil? || $game_party.skillbar.sprite.disposed?
    sx = $game_party.skillbar.sprite.true_x
    sy = $game_party.skillbar.sprite.true_y
    return area?(sx, sy, $game_party.skillbar.sprite.width, 32) if index.nil?
    return area?(sx + 32 * index, sy, 32, 32) rescue false
  end
  #------------------------------------------------------------------------------
  # * Hotkey triggered?
  #------------------------------------------------------------------------------
  def trigger_skillbar?(index)
    return hover_skillbar?(index) && click?(1) rescue false
  end
  #------------------------------------------------------------------------------
  # * Check if pointer if hovered the UI in Scene Map
  #------------------------------------------------------------------------------
  def hover_UI?
    return false unless SceneManager.scene_is?(Scene_Map)
    return true  if hover_window_log?
    return true  if collide_sprite?($game_party.skillbar.sprite)
    return false
  end
  #------------------------------------------------------------------------------
  def hover_window_log?
    window = SceneManager.scene.window_log
    return false if !window
    return true  if collide_sprite?(window.button_sprite)
    return false if !window.active?
    return collide_sprite?(window)
  end
  #------------------------------------------------------------------------------
  def trigger_sprite?(sprite)
    return collide_sprite?(sprite) && click?(1) rescue false
  end
  #------------------------------------------------------------------------------
  # * Return shortest pixel range from a sprite
  #------------------------------------------------------------------------------
  def distance_to_sprite(sprite)
    area_id = determine_area(sprite)
    case area_id
    when 1; return Math.hypot(@pos[0] - sprite.x, @pos[1] - sprite.y - sprite.height)
    when 2; return @pos[1] - sprite.y - sprite.height
    when 3; return Math.hypot(@pos[0] - sprite.x - sprite.width, @pos[0] - sprite.y - sprite.height)
    when 4; return sprite.x - @pos[0];
    when 5; return 0;
    when 6; return @pos[0] - sprite.x - sprite.width;
    when 7; return Math.hypot(@pos[0] - sprite.x, @pos[1] - sprite.y);
    when 8; return sprite.y - @pos[1]
    when 9; return Math.hypot(@pos[0] - sprite.x - sprite.width, @pos[1] - sprite.y);
    end
  end
  #------------------------------------------------------------------------------
  def determine_area(sprite)
    return determine_y_area(4, sprite) if @pos[0] < sprite.x
    return determine_y_area(6, sprite) if @pos[0] > sprite.x + sprite.width
    return determine_y_area(5, sprite)
  end
  #------------------------------------------------------------------------------
  def determine_y_area(base, sprite)
    return base + 3 if @pos[1] < sprite.y
    return base - 3 if @pos[1] > sprite.y + sprite.height
    return base
  end
  #=============================================================================
  # * Sprite_Cursor
  #-----------------------------------------------------------------------------
  #   The Cursor Sprite for mouse
  #=============================================================================
  class Sprite_Cursor < Sprite
    #---------------------------------------------------------------------------
    # * Outline sprite
    #---------------------------------------------------------------------------
    def create_outline
      @outline = Sprite.new(nil)
      @outline.bitmap = Bitmap.new(32, 32)
      @outline.bitmap.fill_rect(0, 0, 32, 32, Color.new(0, 0, 0, 190))
      @outline.bitmap.fill_rect(1, 1, 30, 30, Color.new(0, 0, 0, 0))
      @outline.hide
    end
    #-----------------------------------------------------------------------------
    alias update_tactic update
    def update
      @outline.visible = SceneManager.tactic_enabled?
      update_tactic
    end
    
  end
end
#==============================================================================
# * Scene_Map
#==============================================================================
class Scene_Map
  
  alias check_mouse_movement_hover check_mouse_movement
  def check_mouse_movement
    return if Mouse.hover_UI?
    check_mouse_movement_hover
  end
  
end
#==============================================================================
# ** Window_Selectable
#------------------------------------------------------------------------------
#  This window class contains cursor movement and scroll functions.
#==============================================================================
class Window_Selectable < Window_Base
  #---------------------------------------------------------------------------
  alias refresh_mouse_selection refresh
  def refresh
    @selection_rects = nil
    refresh_mouse_selection
  end
  #---------------------------------------------------------------------------
  def selection_rects_for_mouse
    return @selection_rects if @selection_rects && item_max == @selection_rects.size
    @selection_rects = []
    item_max.times do |i|
      @selection_rects.push(get_selection_rect(i))
    end
    return @selection_rects
  end
  #---------------------------------------------------------------------------
  def get_selection_rect(index)
    return Rect.new(0, 0, contents.width, row_max * item_height) if @cursor_all
    return Rect.new(0,0,0,0) if index < 0
    return item_rect(index)
  end
  #---------------------------------------------------------------------------
  # * Update mouse movement
  #---------------------------------------------------------------------------
  def update_mouse
    return unless @mouse_timer == 0
    return unless Mouse.collide_sprite?(self)
    @mouse_timer = get_mouse_timer
    
    last_index = @index
    rects = []
    add_x = self.x + 16 - self.ox
    add_y = self.y + 16 - self.oy
    
    if !self.viewport.nil?
      add_x += self.viewport.rect.x - self.viewport.ox
      add_y += self.viewport.rect.y - self.viewport.oy
    end
    
    if select_cursor_needed?
      rects = selection_rects_for_mouse
      rects.each_with_index do |rect, i|
        select(i) if Mouse.area?(rect.x + add_x, rect.y + add_y, rect.width, rect.height)
      end
    end # skip selecting if window needn't to select anything
    return if last_index == @index
    update_cursor
    call_update_help
  end
  #---------------------------------------------------------------------------
end

module DND
  
  module REGEX
    #-------------------------------------------------------------------------
    # <thac0: +/-x>
    #-------------------------------------------------------------------------
    THAC0 = /<(?:THAC0|thac0):[ ]([\+\-]\d+)>/i
    #-------------------------------------------------------------------------
    # <ac: +/-x>
    #-------------------------------------------------------------------------
    ARMOR_CLASS = /<(?:AC|ac):[ ]([\+\-]\d+)>/i
    #-------------------------------------------------------------------------
    # <saving throw adjust: (+/-x) * 8>
    # <saving throw adjust: 0, 0, 0, 0, 0, 0>
    # -> mhp, mmp, str, con, int, wis, dex, cha; first 2 should remain 0
    #-------------------------------------------------------------------------
    SAVING_THROW_ADJUST  = /<(?:SAVING_THROW_ADJUST|saving throw adjust):[ ](.+)>/i
    #-------------------------------------------------------------------------
    # <dc adjust: +/-x * 8>
    #-------------------------------------------------------------------------
    DC_ADJUST  = /<(?:DC_ADJUST|dc adjust):[ ](.+)>/i
    #-------------------------------------------------------------------------
    # <param adjust: +/-x * 8>
    #-------------------------------------------------------------------------
    Param_Adjust = /<(?:PARAM_ADJUST|param adjust):[ ](.+)>/i
    #-------------------------------------------------------------------------
    # <poison>
    #-------------------------------------------------------------------------
    POISON = /<(?:POISON|poison)>/i
    #-------------------------------------------------------------------------
    # <debuff>
    #-------------------------------------------------------------------------
    DEBUFF = /<(?:DEBUFF|debuff)>/i
    #-------------------------------------------------------------------------
    # <magic>
    #-------------------------------------------------------------------------
    MAGIC_EFFECT = /<(?:MAGIC|magic)>/i
    #-------------------------------------------------------------------------
    # <physical>
    #-------------------------------------------------------------------------
    IS_PHYSICAL = /<(?:PHYSICAL|physical)>/i
    #-------------------------------------------------------------------------
    # <magical>
    #-------------------------------------------------------------------------
    IS_MAGICAL = /<(?:MAGICAL|magical)>/i
    #-------------------------------------------------------------------------
    # <block by event>
    #-------------------------------------------------------------------------
    PROJ_BLOCK_BY_EVENT = /<(?:BLOCK BY EVENT|block by event)>/i
    #-------------------------------------------------------------------------
    # <damage ndx + q, element, modifier>
    #-------------------------------------------------------------------------
    DAMAGE = /<(?:DAMAGE|damage)[ ](.+)[ ]([\+\-]\d+),[ ](.+),[ ](.+)>/i
    #-------------------------------------------------------------------------
    # <item max: x>
    #-------------------------------------------------------------------------
    ITEM_MAX = /<(?:ITEM_MAX|item max):[ ](\d+)>/i
    #-------------------------------------------------------------------------
    # <taem id: x>
    #-------------------------------------------------------------------------
    TeamID = /<(?:TEAM_ID|team id):[ ](\d+)>/i
    #-------------------------------------------------------------------------
    # <load image: x>   <load name: x>
    #-------------------------------------------------------------------------
    MapLoad_Image = /<(?:LOAD_IMAGE|load image):[ ](.+?)>/
    MapLoad_Name  = /<(?:LOAD_NAME|load name):[ ](.+?)>/
    #-------------------------------------------------------------------------
    # <load image: x>   <load name: x>
    #-------------------------------------------------------------------------
    MapBattleBGM = /<(?:BATTLE_BGM|battle bgm):[ ](.+?),[ ](\d+),[ ](\d+)>/i
    #-------------------------------------------------------------------------
  end
  
  # tag: event config
  module REGEX::NPCEvent
    Enemy           = /<(?:enemy):[ ](\d+)>/i
    StaticObject    = /<static object>/i
    ConfigON        = /(?:config)/i
    ConfigOFF       = /<(?:\/config)>/i
  end
  
  # See "tag: charparam" for details
  module REGEX::Character
    DefaultWeapon     = /(?:Default Weapon =)[ ](\d+)/i           # Weapon id when no weapon is equipped
    SecondaryWeapon   = /(?:Secondary Weapon =)[ ](\d+)/i         # Secondary Weapon id
    SecondaryArmor    = /(?:Secondary Armor =)[ ](\d+)/i          # Secondary Weapon in data_armors id
    TeamID            = /(?:Team ID =)[ ](\d+)/i                  # Team ID
    DeathSwitchSelf   = /(?:Death Self Switch =)[ ](.+?)/i        # Self Switch trigger when dead
    DeathSwitchGlobal = /(?:Death Global Switch =)[ ](\d+)/i      # Game_Switch trigger when dead
    DeathVarSelf      = /(?:Death Self Variable =)[ ](\d+), [ ](\d+)/i
    DeathVarGlobal    = /(?:Death Global Variable =)[ ](\d+), [ ](\d+)/i
    
    DefaultAmmo       = /(?:Default Ammo =)[ ](\d+)/i
    # Variable change when dead, $2 = number, $3 = value
    
    DeathAnimation    = /(?:Death Animation =)[ ](\d+)/i          # Animation display when dead
    VisibleSight      = /(?:Visible Sight =)[ ](\d+)/i            # Sight range when not blinded
    BlindSight        = /(?:Blind Sight =)[ ](\d+)/i               # Sight range whem blinded
    Infravision       = /(?:Infravision =)[ ](\d+)/i              # As it says
    MoveLimit         = /(?:Move Limit =)[ ](\d+)/i               # Move Limit
    AggressiveLevel   = /(?:Aggressive Level =)[ ](\d+)/i         # 0~5, see tag for details
    
    KOGraphic         = /(?:Knockdown Graphic =)[ ](.+)/i         # KO Graphic Filename
    KOIndex           = /(?:Knockdown Index =)[ ](\d+)/i          # KO Graphic Index
    KOPattern         = /(?:Knockdown pattern =)[ ](\d+)/i        # KO Graphics Pattern
    KODirection       = /(?:Knockdown Direction =)[ ](\d+)/i      # KO Character Direction
    KOSound           = /(?:Knockdown Sound =)[ ](.+)/i           # Sound when KO
    CastGraphic       = /(?:Casting Graphic =)[ ](.+)/i
    CastIndex         = /(?:Casting Index =)[ ](\d+)/i
    CastPattern       = /(?:Casting pattern =)[ ](\d+)/i
    IconIndex         = /(?:Icon Index =)[ ](\d+)/i
    
    WeaponLvProtect   = /(?:Weapon Level Prof =)[ ](\d+)/i  # Immune weapon attacks bwlown N level
    CastingAnimation  = /(?:Casting Animation =)[ ](\d+)/i
    
    FaceName          = /(?:Face Name =)[ ](.+)/i   # Face file name
    FaceIndex         = /(?:Face Index=)[ ](\d+)/i  # Face index
    
    Body_Size         = /(?:Body Size =)[ ](\d+)/i  # Size of body to determine character sight visible 
  end
  
  #tag: event config
  module REGEX::Event
    Terminated        = /<(?:terminated)>/i                    # Finalize event
    Frozen            = /<(?:frozen)>/i
    Condition         = /<(?:condition:)[ ](.+)>/i
  end
  
  module REGEX::Map
    LightEffect       = /<(?:Fog Opacity:)[ ](\d+)>/i
  end
  
  
  # See "tag: equiparam" for details
  module REGEX::Equipment
    UserGraphic       = /(?:User Graphic =)[ ](.+)/i           # Sprite display on user
    ToolGraphic       = /(?:Tool Graphic =)[ ](.+)/i           # Tool sprite
    WeaponEffect      = /(?:Weapon effect skill =)[ ](\d+)/i   # Skill effect apply on hit
    ToolIndex         = /(?:Tool Index =)[ ](\d+)/i            # Index of Graphic
    CoolDown          = /(?:Tool Cooldown =)[ ](\d+)/i         # CoolDownTime(CDT)
    ToolDistance      = /(?:Tool Distance =)[ ](\d+)/i         # Effective Range (for missiles)
    ToolEffectDelay   = /(?:Tool Effect Delay =)[ ](\d+)/i     # Delay until effect occur
    ToolDestroyDelay  = /(?:Tool Destroy Delay =)[ ](\d+)/i    # Tool Sprite dispose delay timeing
    ToolSpeed         = /(?:Tool Speed =)[ ](.+)/i             # Tool Move Speed
    ToolCastime       = /(?:Tool Cast Time =)[ ](\d+)/i        # Cast needed time until done
    ToolCastAnimation = /(?:Tool Cast Animation =)[ ](\d+)/i   # Casting animation
    ToolBlowPower     = /(?:Tool Blow Power =)[ ](\d+)/i       # Knockback power
    ToolPiercing      = /(?:Tool Piercing =)[ ](\d+)/i         # Piercing number
    ToolAnimation     = /(?:Tool Animation =)[ ](\d+)/i        # Animation display on tool/project on collide
    ToolAnimMoment    = /(?:Tool Animation Moment =)[ ](\d+)/i # Start moment of tool's animation
    ToolSpecial       = /(?:Tool Special =)[ ](\d+),[ ](\d*)/i # Tool Special, see the list below
    ToolScope         = /(?:Tool Scope =)[ ](\d+)/i            # Tool target scope, same as skill/item one
    ToolScopeDir      = /(?:Tool Scope Dir =)[ ](\d+)/i        # see tag 4 details
    ToolScopeAngle    = /(?:Tool Scope Angle =)[ ](\d+)/i      # c tag 4 details
    ToolInvokeSkill   = /(?:Tool Invoke Skill =)[ ](\d+)/i     # Skill id invoked upon the tool used
    ToolSE            = /(?:Tool SE =)[ ](.+),[ ](\d+)/i                # Sound Effect when tool is used
    ToolItemCost      = /(?:Tool Item Cost =)[ ](\d+)/i        # Item  id needed for using this tool
    ToolItemCostType  = /(?:Tool Wtype Cost =)[ ](\d+)/i       # Wtype id needed for using this tool
    ToolThrough       = /(?:Tool Through =)[ ](\d+)/i          # Tool go through obstacle?(0/1 = false/true)
    ToolPriority      = /(?:Tool Priority =)[ ](\d+)/i         # (Chatacter)Display Priority Type
    ToolHitShake      = /(?:Tool Hit Shake =)[ ](\d+)/i        # Level of screen shake upon tool hitting
    ToolType          = /(?:Tool Type =)[ ](\d+)/i             # Tool Type, 0 = missile, 1 = bomb
    ToolCombo         = /(?:Tool Combo =)[ ](\d+)/i            # Next Weapon Id use after player contiune to
                                                               #   using this tool (default: in 20 frames)
    
    DamageSavingThrow = /(?:Saving Throw =)[ ](.+),[ ](.+)/i   # Saving Throw when hitted
    ToolRanged        = /<(?:ranged)>/i
    ApplyAction       = /(?:Apply Action =)[ ](\d+)/i          # Apply given action sequence id when item is used
  end
  
  # tag: leveling
  # last work: add leveling tag to skills
  module REGEX::Leveling
    LevelingStart  = /<(?:leveling)>/i
    LevelingEnd    = /<\/(?:leveling)>/i
    
    # Select skill when level up, learned skill won't show up again
    # Supposed in closure of Leveling Tags (<leveling> </leveling>)
    # Pattern: skill select: skill_id, skill_id2...; number can be selected
    # Example:
    # <leveling>
    # skill select: 46,47,48,49,50,51; 1
    # </leveling>
    SelectSkill    = /(?:skill select:)[ ](.+);[ ](\d+)/i  
    
    # DND Class Settings
    LoadStart      = /<(?:DND)>/i   # <DND>
    LoadEnd        = /<\/(?:DND)>/i # </DND>
    
    # (Sub)Race, next is the id in $data_classes
    Race           = /(?:race:)[ ](\d+)/i
    Subrace        = /(?:subrace:)[ ](\d+)/i
    
    # (Dual)Class, next is the id in $data_classes
    Class          = /(?:class:)[ ](\d+)/i
    DualClass      = /(?:dualClass:)[ ](\d+)/i
    
    # Parent class ID of the advanced class
    ClassParent    = /(?:parent:)[ ](\d+)/i  
    
    HP             = /(?:HP:)[ ](\d+)/i      # init hp/hit dice
    EP             = /(?:EP:)[ ](\d+)/i      # init ep(plus for race)
    Requirement    = /(?:REQ:)[ ](.+)/i      # Score ability needed to choose
    Strength       = /(?:STR:)[ ](\d+)/i     # Score ability - str
    Constitution   = /(?:CON:)[ ](\d+)/i     # Score ability - con
    Intelligence   = /(?:INT:)[ ](\d+)/i     # Score ability - int
    Wisdom         = /(?:WIS:)[ ](\d+)/i     # Score ability - wis
    Dexterity      = /(?:DEX:)[ ](\d+)/i     # Score ability - dex
    Charisma       = /(?:CHA:)[ ](\d+)/i     # Score ability - cha
  end
  
end
#===============================================================================
=begin
	class RPG::UsableItem::Effect
-----------------------------------------------------------------------------------------------------------------------------
|	Effect Name	|		code		|			data_id				|			value(		1		,		2		)		|	
-----------------------------------------------------------------------------------------------------------------------------
	Recover HP			11						unknow									Value (%)		Value(fixnum)
	Recover MP		  12						unknow									Value (%)		Value(fixnum)
	Recover TP	    13						unknow									Value (%)			    nil
	
	Add State			  21					object state id						Success Rate(%)		nil
	Remove State		22					object state id						Success Rate(%)		nil
	
	Buff    				31						Param id								Duration(turn)		nil
	Debuff	  			32						Param id
	
	Remove Buff			33						Param id
	Remove Debuff		34						Param id
	
	
	class RPG::BaseItem::Feature
-----------------------------------------------------------------------------------------------------------------------------
|	Effect Name	|	Attribute Code	|			data_id				|						value							|	
-----------------------------------------------------------------------------------------------------------------------------
Attack Element			31						element id								0.0
Element Rate			  11						element id								Rate(%)
Debuff Rate			  	12						param id									Rate(%)
State Rate			  	13						state id									Rate(%)
Param				      	21						param id									Rate(%)
Ex-Param		  	  	22						xparam id									Rate(%)
Sp-Param			    	23						sparam id									Rate(%)
-----------------------------------------------------------------------------------------------------------------------------
|	 Name		|		Attribute Code		|			
-----------------------------------------------------------------------------------------------------------------------------
  mhp; 					 param(0);                 # MHP  Maximum Hit Points
  mmp; 					 param(1);                 # MMP  Maximum Magic Points
  atk; 					 param(2);                 # ATK  ATtacK power
  def;					 param(3);                 # DEFense power
  mat; 					 param(4);                 # MAT  Magic ATtack power
  mdf; 					 param(5);                 # MDF  Magic DeFense power
  agi;  				 param(6);                 # AGI  AGIlity
  luk;  				 param(7);                 # LUK  LUcK
  
  
  hit; 					 xparam(0);                # HIT  HIT rate
  eva; 					 xparam(1);                # EVA  EVAsion rate
  cri; 					 xparam(2);                # CRI  CRItical rate
  cev; 					 xparam(3);                # CEV  Critical EVasion rate
  mev;  		   	 xparam(4);                # MEV  Magic EVasion rate
  mrf;  				 xparam(5);                # MRF  Magic ReFlection rate
  cnt;  				 xparam(6);                # CNT  CouNTer attack rate
  hrg;  				 xparam(7);                # HRG  Hp ReGeneration rate
  mrg;  				 xparam(8);                # MRG  Mp ReGeneration rate
  trg;  				 xparam(9);                # TRG  Tp ReGeneration rate
  
  
  tgr;  				 sparam(0);                # TGR  TarGet Rate
  grd;  				 sparam(1);                # GRD  GuaRD effect rate
  rec;  				 sparam(2);                # REC  RECovery effect rate
  pha; 					 sparam(3);                # PHA  PHArmacology
  mcr; 					 sparam(4);                # MCR  Mp Cost Rate
  tcr; 					 sparam(5);                # TCR  Tp Charge Rate
  pdr; 					 sparam(6);                # PDR  Physical Damage Rate
  mdr;           sparam(7);                # MDR  Magical Damage Rate
  fdr; 					 sparam(8);                # FDR  Floor Damage Rate
  exr; 					 sparam(9);                # EXR  EXperience Rate
  
=end

#===============================================================================
# * Module DND
#-------------------------------------------------------------------------------
#   General settings, configs, and regexp etc. of core system
#===============================================================================
module DND
  #=============================================================================
  # * Graphics Settings
  #=============================================================================
  module Graphics
    # Melee weapon wielding angles
    Wield_Angles = {
      2 => [ 80, 110, 140, 170],
      4 => [340,  10,  40,  70],
      6 => [290, 260, 230, 200],
      8 => [290, 320, 350,  20],
    }
    
    # Angles address correction
    Wield_Dir_Offest = {
      2 => [-8, -10],
      4 => [ 0, -10],
      6 => [ 0,  -4],
      8 => [ 4, -10],
    }
    
    # Z Axis value correction
    Wield_Depth_Correction = { 2 => 120, 4 => 50, 6 => 120, 8 => 50 }
  end
  #=============================================================================
  # * Color Settings
  #=============================================================================
  module COLOR
    HPHeal            = Color.new( 15, 140,  10)
    EPHeal            = Color.new(140, 230, 110)
    HPDamage          = Color.new(250,  45,  45)
    EPDamage          = Color.new(175,  55, 140)
    
    Black             = Color.new(  0,   0,   0)
    White             = Color.new(255, 255, 255)
    Red               = Color.new(255,   0,   0)
    Blue              = Color.new(  0,   0, 255)
    Green             = Color.new(  0, 255,   0)
    Yellow            = Color.new(255, 255,   0)
    Purple            = Color.new(128,   0, 255)
    Orange            = Color.new(255, 128,   0)
    Brown             = Color.new(128,  64,   0)
    Pink              = Color.new(255, 128, 255)
    Tan               = Color.new(200, 200, 110)
    
    HitPoint          = Green
    EnergyPoint       = Color.new(100, 200, 255)
  end
  #=============================================================================
  # * Battler Settings
  #=============================================================================
  module BattlerSetting
    RegenerateTime    = 30
    PhaseIdle         = 0
    PhaseCombat       = 1
    DefaultWeapon     = 0
    TeamID            = 1
    DeathSwitchSelf   = nil
    DeathSwitchGlobal = 0
    DeathVarSelf      = nil
    DeathVarGlobal    = [0, 0]
    VisibleSight      = 8
    BlindSight        = 0
    DeathAnimation    = 114
    Infravision       = false
    MoveLimit         = 30
    AggressiveLevel   = 4
    BodySize          = 1
    KOGraphic         = "$Coffin"
    KOIndex           = 0
    KOPattern         = 0
    KODirection       = 8
    CastingAnimation  = 162
    DefaultRaceID     = 119
    DefaultClassID    = 119
    LevelCap          = 20
  end
  #=============================================================================
  # * Corresponding class and subclass to its original class
  #=============================================================================
  module ClassID
    Barbarian   = [1, 15, 16]
    Bard        = [2, 17, 18]
    Cleric      = [3, 19, 20, 21, 22, 23, 24, 25, 26, 27]
    Druid       = [4, 28, 29, 30, 31, 32, 33, 34, 35, 36]
    Fighter     = [5, 37, 38, 39]
    Monk        = [6, 40, 41, 42]
    Paladin     = [7, 43, 44, 45]
    Ranger      = [8, 46, 47]
    Rogue       = [9, 48, 49, 50]
    Sorcerer    = [10, 51, 52, 53, 54]
    Warlock     = [11, 55, 56, 57]
    Wizard      = [12, 58, 59, 60, 61, 62, 63, 64, 65]
    
    PrimaryPathes =[
      Barbarian, Bard, Cleric, Druid, Fighter, Monk, Paladin, Ranger, Rogue,
      Sorcerer, Warlock, Wizard,
    ]
    
  end
  #=============================================================================
  # * Saving type
  #=============================================================================
  module SavingThrow
    List = {
      "1/2"           => :halfdmg,
      "Neg."          => :nullify,
      "None"          => nil,
      nil             => nil
    }
  end
  #=============================================================================
  # Enemy rank
  Rank  = [
    :critter,
    :minion,
    :elite,
    :captain,
    :chief,
  ]
  #=============================================================================
  # Basic attack type
  AttackType = [
    :melee,
    :magic,
    :ranged,
  ]
  #=============================================================================
  # Detail info description of item
  ItemParamDec = {
    :weapon => [:wtype, :speed, :range, :damage],
    :armor  => [:atype, :ac],
    :skill  => [:stype, :cost, :casting, :range, :cooldown, :save, :damage],
    :item   => [:cooldown, :range, :save, :damage],
  }
  #=============================================================================
  # The race that can't perform arcane magic (cannot choose wizard class)
  NoWizardry = [
    81,   # Earth Pony
    83,   # Pegasus
    88,   # Zebra
    89,   # Donkey
    91,   # Buffalo
    92,   # Diamond Dog
    95,   # Yak
    96,   # Deer
  ]
  #----------------------------------------------------------------------------
end

#===============================================================================
# * Module DND::Utility
#-------------------------------------------------------------------------------
#   Utility functions
#===============================================================================
module DND
  module Utility
    #--------------------------------------------------------------------------
    # * Constants (Features)
    #--------------------------------------------------------------------------
    FEATURE_ELEMENT_RATE  = 11              # Element Rate
    FEATURE_DEBUFF_RATE   = 12              # Debuff Rate
    FEATURE_STATE_RATE    = 13              # State Rate
    FEATURE_STATE_RESIST  = 14              # State Resist
    FEATURE_PARAM         = 21              # Parameter
    FEATURE_XPARAM        = 22              # Ex-Parameter
    FEATURE_SPARAM        = 23              # Sp-Parameter
    FEATURE_ATK_ELEMENT   = 31              # Atk Element
    FEATURE_ATK_STATE     = 32              # Atk State
    FEATURE_ATK_SPEED     = 33              # Atk Speed
    FEATURE_ATK_TIMES     = 34              # Atk Times+
    FEATURE_STYPE_ADD     = 41              # Add Skill Type
    FEATURE_STYPE_SEAL    = 42              # Disable Skill Type
    FEATURE_SKILL_ADD     = 43              # Add Skill
    FEATURE_SKILL_SEAL    = 44              # Disable Skill
    FEATURE_EQUIP_WTYPE   = 51              # Equip Weapon
    FEATURE_EQUIP_ATYPE   = 52              # Equip Armor
    FEATURE_EQUIP_FIX     = 53              # Lock Equip
    FEATURE_EQUIP_SEAL    = 54              # Seal Equip
    FEATURE_SLOT_TYPE     = 55              # Slot Type
    FEATURE_ACTION_PLUS   = 61              # Action Times+
    FEATURE_SPECIAL_FLAG  = 62              # Special Flag
    FEATURE_COLLAPSE_TYPE = 63              # Collapse Effect
    FEATURE_PARTY_ABILITY = 64              # Party Ability
    #--------------------------------------------------------------------------
    # * Constants (Feature Flags)
    #--------------------------------------------------------------------------
    FLAG_ID_AUTO_BATTLE   = 0               # auto battle
    FLAG_ID_GUARD         = 1               # guard
    FLAG_ID_SUBSTITUTE    = 2               # substitute
    FLAG_ID_PRESERVE_TP   = 3               # preserve TP
    #--------------------------------------------------------------------------
    # * Constants (Starting Number of Buff/Debuff Icons)
    #--------------------------------------------------------------------------
    ICON_BUFF_START       = 64              # buff (16 icons)
    ICON_DEBUFF_START     = 80              # debuff (16 icons)
    #--------------------------------------------------------------------------
    # * (X/S)Param ID
    #--------------------------------------------------------------------------
    PARAM_MHP             = 0               # maximum hit point
    PARAM_MMP = PARAM_MEP = 1               # maximum MP/EP
    PARAM_STR = PARAM_ATK = 2               # Strength/Attack
    PARAM_CON = PARAM_DEF = 3               # Constitution/Defense
    PARAM_INT = PARAM_MAT = 4               # Intelligence/Magic Attack
    PARAM_WIS = PARAM_MDF = 5               # Wisdom/Magic Defense
    PARAM_DEX = PARAM_AGI = 6               # Dexterity/Agility
    PARAM_CHA = PARAM_LUK = 7               # Charisma/Luck
    #--------------------------------------------------------------------------
    XPARAM_HIT = XPARAM_THAC0 = 0           # Hit rate/To Hit Armor Class 0
    XPARAM_EVA = XPARAM_AC    = 1           # Evasion/Armor Class
    XPARAM_CRI                = 2           # Critical Rate
    XPARAM_CEV                = 3           # Critical Evasion Rate
    XPARAM_MEV                = 4           # Magic Evasion Rate
    XPARAM_MRF                = 5           # Magic Reflection Rate
    XPARAM_CNT                = 9           # Counter Attack Rate
    XPARAM_HRH                = 7           # HP Regeneration Rate
    XPARAM_MRG                = 8           # MP Regeneration Rate
    XPARAM_TRG                = 9           # TP Regeneration Rate
    #--------------------------------------------------------------------------
    SPARAM_TGR                = 0            # Target Rate
    SPARAM_GRD                = 1            # Guard Rate
    SPARAM_REC                = 2            # Recovery Rate
    SPARAM_PHA = SPARAM_CTR   = 3            # Pharmacology/Cast Time Reduction Rate
    SPARAM_MCR                = 4            # MP Cost Rate
    SPARAM_TCR = SPARAM_CSR   = 5            # TP Charge Rate/Casting Speed Rate
    SPARAM_PDR                = 6            # Physical Damage Rate
    SPARAM_MDR                = 7            # Magical Damamge Rate
    SPARAM_FDR                = 8            # Floor Damage Rate
    SPARAM_EXR                = 9            # Experience Rate
    #--------------------------------------------------------------------------
    def get_element_id(string)
      return string if string.is_a?(Numeric)
      string = string.upcase
      for i in 0...$data_system.elements.size
        return i if string == $data_system.elements[i].upcase
      end
      return 0
    end
    #--------------------------------------------------------------------------
    def get_param_id(string)
      unless string.is_a?(String) || string.is_a?(Symbol)
        raise TypeError, "Expect String or Symbol, but a #{string.class}"
      end
      string = string.downcase.to_sym
      _id = 0
      if     string == :hp  then _id = 0
      elsif  string == :ep  then _id = 1
      elsif  string == :str then _id = 2
      elsif  string == :con then _id = 3
      elsif  string == :int then _id = 4
      elsif  string == :wis then _id = 5
      elsif  string == :dex then _id = 6
      elsif  string == :cha then _id = 7
      end
      return _id
    end
    #--------------------------------------------------------------------------
    def get_saving_name(saves)
      return Vocab::Equipment::None if saves.nil?
      return Vocab::Equipment::SavingName[saves.first]
    end
    #--------------------------------------------------------------------------
    def get_wtype_name(id)
      return Vocab::DND::WEAPON_TYPE_NAME[id]
    end
    #--------------------------------------------------------------------------
    def get_element_name(id)
      return Vocab::DND::ELEMENT_NAME[id]
    end
    #--------------------------------------------------------------------------
    def get_param_name(id)
      return (Vocab::DND::PARAM_NAME[id] || "")
    end
    #--------------------------------------------------------------------------
  end
end


#==============================================================================
# ** MakerSystems
#------------------------------------------------------------------------------
#  Module four our Systems.
#==============================================================================
module MakerSystems
  
  #============================================================================
  # ** Effectus
  #----------------------------------------------------------------------------
  #  This module contains variables that you can edit to make Effectus work
  # in whatever way you may need.
  #============================================================================
  
  module Effectus
    
    #------------------------------------------------------------------------
    # * Always Update Patterns.                                         [OPT]
    #------------------------------------------------------------------------
    # This are the patterns that Effectus will look for to know if it needs
    # to always update the event. The search is performed through all comments
    # in the current page of the event, so the order of the event commands
    # doesn't matter.
    # You don't have to use this feature if you set PREVENT_OFFSCREEN_UPDATES
    # to false.
    #------------------------------------------------------------------------
    PATTERNS = ['<always update>']
    #------------------------------------------------------------------------
    # * Prevent Offscreen Updates.                                      [OPT]
    #------------------------------------------------------------------------
    # Common technique against event lag.
    # If true, events that are not inside the screen area won't be updated.
    # If false, events will be normally updated as in vanilla Ace.
    #           but you will still enjoy an enhanced experience thanks to
    #           the system's clever improvements.
    #------------------------------------------------------------------------
    PREVENT_OFFSCREEN_UPDATES = true
    #------------------------------------------------------------------------
    # * Screen Tile Division Modulo.                                    [OPT]
    #------------------------------------------------------------------------
    # Set this to true if either screen width or height divided by 32 (pixels
    # in a tile) has a division remainder.
    # If true, an additional tile is considered as "near the visible area".
    #          Tiny (really tiny) performance loss.
    # If false, screen size must be evenly divisible by 32 to avoid errors.
    #------------------------------------------------------------------------
    SCREEN_TILE_DIVMOD = false
    #------------------------------------------------------------------------
    # * Only Parallax Maps.                                             [OPT]
    #------------------------------------------------------------------------
    # Set this to true if you ONLY use parallax mapping in your project for
    # a huge performance boost.
    # If true, the tilemap (the thing needed to render the maps you created 
    #          using the editor inside the game) will be removed.
    # If false, the tilemap will be created as usual.
    #------------------------------------------------------------------------
    ONLY_PARALLAX_MAPS = false
    #------------------------------------------------------------------------
    # * Improved Plane.                                                 [OPT]
    #------------------------------------------------------------------------
    # Set this to true to use the best custom Plane script available, that is 
    # both memory and CPU efficient. This will improve the performance, 
    # especially for screen sizes bigger than 544x416.
    # If true, the default Plane script will be replaced by our version.
    # If false, the default Plane will be used as usual.
    #------------------------------------------------------------------------
    IMPROVED_PLANE     = true
    #------------------------------------------------------------------------
    # * ATB Bars Need Fixing?                                           [OPT]
    #------------------------------------------------------------------------
    # Set this to true if the bars from the battle system of your game are
    # not being displayed properly.
    # Ignore otherwise.
    # If true, the new Plane script will be in compatibility mode.
    # If false, the new Plane script will work normally.
    #------------------------------------------------------------------------
    ATB_BARS_NEED_FIXING = false
    #------------------------------------------------------------------------
    # * Improved Map Window Control.                                    [OPT]
    #------------------------------------------------------------------------
    # Set this to true to make Effectus improve the handling of default
    # Window objects in the map scene. It's a small improvement, deactivate
    # if you find any weird behavior with custom message systems.
    # If true, default Window objects on the map will be created on demand.
    # If false, default Window objects on the map will be handled as usual.
    #------------------------------------------------------------------------
    MAP_SCENE_WINDOW_IMPROVEMENTS = false
    #------------------------------------------------------------------------
    # * Sprite_Character Full Update Rate.                              [OPT]
    #------------------------------------------------------------------------
    # This is the interval at which the full update for Sprite_Character 
    # instances (The sprites for each event on the map) will be performed.
    # Must be greater than 0. Default is 2 (safe for everyone).
    # Increasing this number makes Sprite_Character less responsive to 
    # changes so you'll have to try to find a value that suits your game.
    #------------------------------------------------------------------------
    SPRITE_CHARACTER_FULL_UPDATE_RATE = 2
    
  end
  
end

#------------------------------------------------------------------------------
# Moonlight INN
# http://cgi.members.interq.or.jp/aquarius/rasetsu/
# RaTTiE
# rasetsu@aquarius.interq.or.jp
#------------------------------------------------------------
# EasyConv::s2u(text) : S-JIS -> UTF-8
# EasyConv::u2s(text) : UTF-8 -> S-JIS
#==============================================
module EasyConv
   CP_ACP = 0
   CP_UTF8 = 65001
#--------------------------------------------------------------------------
# S-JIS -> UTF-8
#--------------------------------------------------------------------------
def s2u(text)
   m2w = Win32API.new('kernel32', 'MultiByteToWideChar', 'ilpipi', 'i')
   w2m = Win32API.new('kernel32', 'WideCharToMultiByte', 'ilpipipp', 'i')
# S-JIS -> Unicode
   len = m2w.call(CP_ACP, 0, text, -1, nil, 0);
   buf = "\0" * (len*2)
   m2w.call(CP_ACP, 0, text, -1, buf, buf.size/2);
# Unicode -> UTF-8
   len = w2m.call(CP_UTF8, 0, buf, -1, nil, 0, nil, nil);
   ret = "\0" * len
   w2m.call(CP_UTF8, 0, buf, -1, ret, ret.size, nil, nil);
   
   return ret
end
module_function :s2u
#--------------------------------------------------------------------------
# UTF-8 -> S-JIS
#--------------------------------------------------------------------------
def u2s(text)
   m2w = Win32API.new('kernel32', 'MultiByteToWideChar', 'ilpipi', 'i')
   w2m = Win32API.new('kernel32', 'WideCharToMultiByte', 'ilpipipp', 'i')
# UTF-8 -> Unicode
   len = m2w.call(CP_UTF8, 0, text, -1, nil, 0);
   buf = "\0" * (len*2)
   m2w.call(CP_UTF8, 0, text, -1, buf, buf.size/2);
# Unicode -> S-JIS
   len = w2m.call(CP_ACP, 0, buf, -1, nil, 0, nil, nil);
   ret = "\0" * len
   w2m.call(CP_ACP, 0, buf, -1, ret, ret.size, nil, nil);
   
   return ret
end
module_function :u2s
end

#==============================================================================
# ** PONY::CHAIN
#------------------------------------------------------------------------------
#  Pone's block chain setting
#==============================================================================
module PONY::CHAIN
  
  # Total Bits available for transaction
  TotalBalance = 10 ** 9
  
  # Total Chromastal available for transaction
  TotalChromastal = 0xffff
  
  # Transaction fee
  Transaction_Fee = 0.00042
  
  # Unnamed transaction source
  CoinBase = 0xc4f10a20486103dd74203a315edf9200
  # Mining Difficulty
  Difficulty = 0x64
  
  #--------------------------------------------------------------------------
  # * Nodes process block mining and player local bits flows
  #--------------------------------------------------------------------------
  Nodes = [
    "Equestria", # 0
      "Player",  # 1
      "Ponyvile",
      "Canterlot",
      "Cloudsdale",
      "Manehattan", # 5
      "Appleloosa",
      "Dodge_Junction",
      "Filly_Delphia",
      "Las_Pegasus",
      "Baltimare",  # 10
      "Starlights_Village",
      "Yanhooyer",
      "Rock_Farm", # 13
    #---------------------------
    "Crystal_Mountains", # 14
      "Crystal_Empire",
      "Yakyakistan",
    #---------------------------
    "HeartLands", # 17
      "Smoky_Mountains",
    #---------------------------
    "BadLands", # 19
      "UnderTribe",
    #---------------------------
    "Forbidden_Jungle", # 21
    #---------------------------
    "EastLands", # 22
      "Griffon_Stone",
      "Dragon_Land",
    #---------------------------
    "SouthEquestria", # 25
      "Saddle_Arbia",
      "Zefribia",
  ]
  #--------------------------------------------------------------------------#
  # * Each node's initial Bits in new game                                   #
  #--------------------------------------------------------------------------#
  #                   *  Magic Numbers  *                                    #
  Dispute_Weight = {
    0xc4f10a20486103dd74203a315edf9200 => 0.150, # Equestria
    0x636da1d35e805b00eae0fcd8333f9234 => 0    , # Player
    0xd8ce07f3e67ffde6d6260e426a51a70b => 0.050, # Ponyvile
    0x518f65c35638945cb6b2e3855b7c8f20 => 0.060, # Canterlot
    0x5ea8847659eedf0104b9b74cb26533df => 0.040, # Cloudsdale
    0x1e44e014507e1db404ebc32871d6d5ca => 0.060, # Manehattan
    0xa2ececaab1570fdc9dda6761b9fd4ccb => 0.008, # Appleloosa
    0x4588cc55c932638be854e8f503c9c088 => 0.005, # Dodge_Junction
    0x9cc4410a5715561f6eb559b9e2feadcf => 0.015, # Filly_Delphia
    0x42d7683217d076f0317d37e30f0796dd => 0.020, # Las_Pegasus
    0xf69d7bf4390d5f32d4e74ae56d72973d => 0.048, # Baltimare
    0x7ddcb5482c9ec7c003b35ee26053541c => 0.001, # Starlights_Village
    0x7c5cab193bf23cfb5932ab9b2e786a81 => 0.012, # Yanhooyer
    0xf066193a1b22cb02186da10f8ff2f745 => 0.003, # Rock_Farm
    0xa6ba93608028cb3d87c7c545a7beea37 => 0.060, # Crystal Mountains
    0x8efec93859f44adb1ee2f486710ba609 => 0.045, # Crystal Empire
    0x4483ac41f5856b3c63187901af52d593 => 0.012, # Yakyakistan
    0xe5bbc032695e96ea1d95163db1b9b1a7 => 0.065, # Heartlands
    0xf832346e5964994e4e0b6048c4af5569 => 0.008, # Smoky Mounatins
    0xf593ae588dfb9596a61f3431e4ae9475 => 0.010, # Badlands
    0x7a8f93689d916c5ee846d1fc1cd9e2a7 => 0.006, # Undertribe
    0xa59cd0371e35dde9ef61707d846e6414 => 0.004, # Forbidden Jungle
    0xb1237f571e8ea9bbe802e69d20087c45 => 0.060, # Eastlands
    0x560e56027d39ab11b5650c2f3bc46cbb => 0.060, # Griffon Stone
    0xb54b9f45b857c9bc910466a6f6e0e94f => 0.080, # Dragon Lands
    0xecc531adf9d75553a46be49dfee3cc2d => 0.008, # South Equestria
    0xb4c38b478dee769f5978662d7ca409ad => 0.095, # Saddle Arbia
    0x07c651182bf62dd18653ccf2f103d710 => 0.015, # Zefribia
  }
  #--------------------------------------------------------------------------
  # * Verify all nodes balance if equal to totalbalance
  #--------------------------------------------------------------------------
  def self.verify_totalbalance
    return true if BlockChain.node_empty?
    return true if SceneManager.scene_is?(Scene_Map)
    sum = BlockChain.account_balance
    result = (sum == TotalBalance)
    PONY::ERRNO.raise(:bits_incorrect, :exit, nil) unless result
    return result
  end
  #--------------------------------------------------------------------------
  # * Collect BC data
  #--------------------------------------------------------------------------
  def self.collect_data
  end
  
end

#==============================================================================
# ** PONY::Formula
#------------------------------------------------------------------------------
#  Projectile movement definitions
#==============================================================================
# tag: formula
module PONY::Formula
  # empty, so far
end

#===============================================================================
# * PONY::Hud
#-------------------------------------------------------------------------------
#   Hud settings
#===============================================================================
module PONY::Hud
  
  LayoutFilename     = "Hud_Outline"
  LeadLayoutFilename = "Hud_Outline_Lead"
  FaceFilename       = "HudFace_"
  
  HudSize	          = [170, 64]
  ContentBitmapSize = [200, 70]
  
  HPBarRect   = Rect.new(59, 25, 100, 4)
  
  EPBarRect   = Rect.new(61, 34, 92, 4)
  
  FaceHudRect = Rect.new(0, 0, 62, 62)
  FaceSrcRect = Rect.new(0, 0, 68, 68)
  
  NameRect    = Rect.new(58, 4, 102, 18)
  
  StatRect    = Rect.new(60, 40, 200, 24)
  
  FaceTimer   = 60
  FaceIdle    = 0
  FaceCombat  = 1
  FaceAttack  = 2
  FaceInjured = 3
  FaceDying   = 4
  FaceKO      = 5
  
end

#==============================================================================
# ** PONY::SpriteDepth
#------------------------------------------------------------------------------
#  Handles sprites depth (z) values
#==============================================================================
module PONY::SpriteDepth
  #--------------------------------------------------------------------------
  # * Return depth by layer id
  #--------------------------------------------------------------------------
  def self.layers(id)
    return 50 * (id + 1)
  end
  #--------------------------------------------------------------------------
  # * Pre-definied depth table
  #--------------------------------------------------------------------------
  Table = {
    :viewport       =>            self.layers(2),
    :viewport2      =>            self.layers(0),
    :viewport3      =>            self.layers(1),
    :character      =>                       200,
    :super          =>                      5000,
    :mouse          =>                     10000,
    :foreground_ov  =>                     99999,
    :overlays       =>                      1000,
    :huds           =>            self.layers(5),
    :input          =>                       500,
    :ballon         =>                       200,
    :animation      =>                       300,
    :parallax       =>                      -100,
    :shadow         =>                       180,
    :tile           =>                         1,
    :override       =>                       400,
    :win_info       =>                       800,
    :foreground     =>                      2000,
    :win_debug      =>                       999,
  }
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Vocab::Dungeons and Dragons
#------------------------------------------------------------------------------
#  The collection of words that belong to D&D terms
#==============================================================================
# tag: translate
module Vocab::DND
  
  PARAM_NAME = [
    "None",
    "None",
    "Str",
    "Con",
    "Int",
    "Wis",
    "Dex",
    "Cha",
  ]
  
  WEAPON_TYPE_NAME = [
    "",
    "Hoof Axe",
    "Horseshoe",
    "Polearm",
    "1H Sword",
    "2H Sword",
    "Bow",
    "Crossbow",
    "Hammer",
    "Mace",
    "Firearm",
    "Arrow",
    "Bolt",
    "Bullet",
    "Mage Staff"
  ]
  
  ARMOR_TYPE_NAME = [
  "",
  "Light Armor",
  "Medium Armor",
  "Heavy Armor",
  "Clothing",
  "Shield",
  "Great Shield",
  "Hooves",
  "Belt",
  "Necklace",
  "Cloak",
  "Ring",
  "Greave",
  "Rune",
  "Gem",
  ]
  
  SKILL_TYPE_NAME = [
  "",
  "Skill",
  "Spell",
  "Vancian",
  "Passive",
  ]
  
  ELEMENT_NAME = [
    "",
    "Bludgeoning",
    "Piercing",
    "Slashing",
    "Acid",
    "Cold",
    "Fire",
    "Force",
    "Lightning",
    "Necrotic",
    "Poison",
    "Psychic",
    "Radiant",
    "Thunder",
  ]
  
  RankName = {
    :critter  => "Critter",
    :minion   => "Minion",
    :elite    => "Elite",
    :captain  => "Captain",
    :chief    => "Chief",
  }
  
end

#==============================================================================
# ** Vocab
#------------------------------------------------------------------------------
#  This module defines terms and messages. It defines some data as constant
# variables. Terms in the database are obtained from $data_system.
#==============================================================================
module Vocab::YEA
  ICON_HASH = {
    # Matching Text   => Icon ID,
      "New story"            => 125,    # Title scene.
      "Continue story"       => 126,    # Title scene.
      "Leave"                => 127,    # Title scene. Game End scene.
      
      "Battle"        => 386,     # Battle scene.
      "Gallop"        => 328,     # Battle scene.
      "Strike"        => 116,     # Battle scene.
      "Guard"         => 506,     # Battle scene.
      "Relic"         => 9299,
      "Relics"        => 9299,
      "Skill"         => 8175,    # Skill scene. Battle scene.
      "Skills"        => 8175,
      "Ability"       => 106,     # Skill scene. Battle scene.
      "Spells"        => 106,     # Skill scene. Battle scene.
      "Passive"       => 3193,
      "Friendship"    => 8056,
      "Learn Skills"  => 2437,
      "Songs"         => 6470,
      "Pet"           => 3316,
      "Talent"        => 10662,
      "Bio"           => 233,
      "Brew"          => 3814,
      "Science"       => 8249,
      "Summon"        => 3761,
      "Parameters"    => 228,
      "Quest"         => 1334,
      "Overview"      => 1354,
      "Saddlebag"     => 1528,     # Menu scene. Item scene. Battle scene.
      "Items"         => 1528,     # Menu scene. Item scene. Battle scene.
      "Talk"          => 4,
      "Actions"       => 143,
      "Cook"          => 2580,
      "Crafting"       => 125,
      "Skills"        => 104,      # Menu scene.
      "Log"           => 2441,
      "Books"         => 2384,
      "History"       => 2435,
      "Execute"       => 125,
      "Run"           => 172,
      "Gear"          => 524,      # Menu scene.
      "Stats"         => 1204,     # Menu scene.
      "Party"         =>  11,      # Menu scene.
      "Special"       => 775,
      "Save"          => 10675,      # Menu scene.
      "Load"          => 10674,
      "Delete"        => 10676,
      "System"        => 2144,
      "End"           => 1020,      # Menu scene.
      "Craft"         => 2059,  
      "Weapons"       => 386,      # Item scene.
      "Armors"        => 436,      # Item scene.
      "Key Items"     => 243,      # Item scene.
      "Special Items" => 243,      # Item scene.
      "Special Item"  => 243,      # Item scene.
      "To Title"      => 224,      # Game End scene.
      "Cancel"        => 119,      # Game End scene.
      "Spellbook"     => 4052,
      "Vancian"       => 10044,
      "Vancians"      => 10044,
      "Vancian Spell" => 10044,
      "Encyclopedia"  => 3734,
      "Codex"         => 2399, 
      "Bestiary"      => 3343,
      "Music Room"    => 118,
      "Talent Tree"   => 117,
      "Equip"         => 3786,
      "Add Point"     => 6476,
      "Special stuff" => 1646,
      "Buy"           => 555,
      "Sell"          => 554,
      "Properties"    => 2375,
      "General"       => 556,
      "Healings"      => 3958,
      "Ingredient"    => 200,
      "All"            => 1140,
      "Hidden Weapons" => 159,
      "Music Sheet"    => 118,
      "Book"           => 2384,
      "Scroll"         => 3733,
      "Save/Load"      => 2431,
      "Dismantle"      => 8175,
      "Gamejolt"       => 570,
      "Life Skills"    => 8075,
      "Equip Skill"    => 117,
      "Level Up"       => 8182,
      "Move to"        => 572,
      "Follow"         => 1117,
      "Patrol"         => 1114,
      "Hold/Move"      => 9301,
      ":Hold"          => 9301,
      ":Move"          => 2255,
      ":No Attack"     => 1141,
      ":Passive"       => 13,
      ":Stand Ground"  => 7346,
      ":Defensive"     => 139,
      ":Aggressive"    => 131,
      ":Striking"      => 116,
      "Tactics"        => 2103,
      "Protect"        => 506,
      "Skill Tree"     => 108,
    }
    #--------------------------------------------------------------------------
  end
  
#==============================================================================
# ** Vocab::YEA::Item
#==============================================================================
module Vocab
  module YEA::ITEM
    #--------------------------------------------------------------------------
    ITEM_TYPES = {
      :all          => "All",
      :healings     => "Healings",
      :book         => "Book",
      :scroll       => "Scroll",
      :hdweapons    => "Hidden Weapons",
      :special      => "Special",
      :ingredient   => "Ingredient",
      :music_sheet  => "Music Sheet",
      :misc         => "Misc",
    }
    #--------------------------------------------------------------------------
    WEAPON_TYPES = {
      :all      => "All",
    }
    #--------------------------------------------------------------------------  
    ARMOUR_TYPES = {
      :all      => "All",
    }
    #--------------------------------------------------------------------------
    VOCAB_STATUS = {
      :empty      => "---",          # Text used when nothing is shown.
      :hp_recover => "HP Heal",      # Text used for HP Recovery.
      :mp_recover => "MP Heal",      # Text used for MP Recovery.
      :tp_recover => "TP Heal",      # Text used for TP Recovery.
      :tp_gain    => "TP Gain",      # Text used for TP Gain.
      :applies    => "Applies",      # Text used for applied states and buffs.
      :removes    => "Removes",      # Text used for removed states and buffs.
    } # Do not remove this.
    #--------------------------------------------------------------------------
  end
end

#==============================================================================
# ** Vocab
#------------------------------------------------------------------------------
#  This module defines terms and messages. It defines some data as constant
# variables. Terms in the database are obtained from $data_system.
#==============================================================================
# tag: translate
CurrentLanguage = :en_us unless defined?(CurrentLanguage)

module Vocab
  
  # BlockChain Node Name
  Player         = "Player"
  Coinbase       = "Equestria"
  
  # Tactic processing
  Pause           = "Paused"
  Unpause         = "Unpaused"
  
  # Title Screen
  Continue        = "Continue the lastest saved game"
  NewGame         = "Start a new story"
  LoadGame        = "Continue your journey"
  ShutDown        = "Crashing back to your OS"
  Option          = "Option"
  Credits         = "Credits"
  StartGame       = "Start"
  
  # Connections
  Connection      = "Connecting...Your game will have no response for few minutes, please wait..."
  
  # Exit Info
  ExitConfirm     = "Do you really want to leave? Ponies will miss you..."
  
  None            = "<None>"  
  Type            = "Type"
  
  Quest           = "Quest Journal"
  QuestUpdated    = "Your journal has been updated: %s"
  QuestHint       = "Use Up/Down to negative the information"
  
  LevelUp         = "Level Up"
  Skilltree       = "Skill Tree"
  Upgradeable     = "You can level-up now!"
  
  InitLoadingMsg  = "To ensure your best gameplay experience, please close the app that will consume your system resource, such as Flash, Youtube and other games."
  Unavailable     = "Not available yet"
  
  TransferGather  = "You must gather your party before venturing forth"
  TransferCombat  = "You can't change location during the combat"
  
  SaveDec         = "Save your game progess"
  SystemDec       = "Change options or leave current game"
  
  CritialMiss     = "%s - critical miss"
  CritialHit      = "%s - critical hit"
  AttackImmune    = "%s: %s immune to my damage"
  Ineffective     = "%s - weapon ineffective"
  
  MoreInfo        = "Info"
  
  # path to database vocabulary dictionary
  DictPath        = "History/en_us"
  CategoryPath = {
    :weapon     => "/Weapons",
    :item       => "/Items",
    :armor      => "/Armors",
    :skill      => "/Skills",
    :actor      => "/Actors",
    :class      => "/Classes",
    :term       => "/Terms",
    :state      => "/States",
  }
  
  Offline = "Unable connect to internet, some features won't be available," +
            " such as Gamejolt achievement." + " If you have connected, " +
            "please re-launch the game."
            
  OfflineMode = "This feature is unavailable in offline mode. You cannot " +
                "access it until connected to internet and re-launch the game"
  #----------------------------------------------------------------------------
  VODL      = "Vengeance of Dark Lord"
  VODLHelp  = "Play the main story, help Equestria fight against the invasion " +
              "of King Sombra!"
              
  Tutorial  = "Tutorial"
  TutorialHelp = "Help you understand core features of the game and learn how " +
                 "to play & use them."
  #----------------------------------------------------------------------------
  # * Return dictionary file of language
  #----------------------------------------------------------------------------
  def self.GetDictPath(category)
    return DictPath + CategoryPath[category] + '/'
  end
  #----------------------------------------------------------------------------
end
#==============================================================================
# ** Vocab::SaveLoad
#------------------------------------------------------------------------------
#   Message in SnL load screen
#==============================================================================
module Vocab::SaveLoad
  
  ACTION_LOAD   = "Load"           # Text used for loading games.
  ACTION_SAVE   = "Save"           # Text used for saving games.
  ACTION_DELETE = "Delete"         # Text used for deleting games.
    
  # These text settings adjust what displays in the help window.
  SELECT_HELP = "Select a savefile..."
  LOAD_HELP   = "Load saved game progress"
  SAVE_HELP   = "Save current game progress"
  DELETE_HELP = "Delete this savefile"
    
  EMPTY_TEXT = "~No Data~"      # Text used when no save data is present.
  PLAYTIME   = "Play time"          # Text used for total playtime.
  TOTAL_SAVE = "Times saved: "     # Text used to indicate total saves.
  TOTAL_GOLD = "βits: "      # Text used to indicate total gold.
  LOCATION   = "Location: "        # Text used to indicate current location.
  
  Slot      = "File %s"
  ASaveSlot = "AutoSave%s"
  QSaveSlot = "QuickSave%s"
end
#==============================================================================
# ** Vocab::Equipment
#------------------------------------------------------------------------------
#   Vocab that related to equipments and params
#==============================================================================
module Vocab::Equipment
  
  Weapon    = "Weapon"
  Shield    = "Shield"
  Head      = "Head"
  Body      = "Body"
  Accessory = "Accessory"
  Cloak     = "Cloak"
  Necklace  = "Necklace"
  Boots     = "Boots"
  Rune      = "Rune"
  Gem       = "Gem"
  Ammo      = "Ammo"
  
  WeaponDMG = "Weapon Damage"
  AmmoDMG   = "Ammo Damage"
  Speed     = "Speed"
  
  Thac0     = "Attack Bonus"
  AC        = "Armor Class"
  Damage    = "Damage"
  Range     = "Range"
  SType     = "Skill Type"
  Cost      = "EP Cost"
  Cooldown  = "Cooldown"
  Save      = "Save"
  
  Remove    = "<Remove Equip>"
  Empty     = "<Empty>"
  
  None      = "None"
  Type      = "Type"
  
  Melee     = "Melee"
  Magic     = "Magic"
  Ranged    = "Ranged"
  
  CastingTime = "Casting Time"
  SavingThrow = "Saves"
  
  SavingName = {
    :halfdmg  => "1/2",
    :nullify  => "Neg.",
    :none     => "None",
    nil       => "None",
  }
  
end
#==============================================================================
# ** Vocab::System
#------------------------------------------------------------------------------
#   System option vocabs
#==============================================================================
module Vocab::System
  
  Language    = "Language"
  LanguageDec = "Change game language"
  
  WarCry          = "Way cry"
  WarCryDec       = "Character voices when enter the battle and other actions"
  Difficulty      = "Combat Difficulty"
  DifficultyName  = ["Novice", "Normal", "Hard", "Expert"]
  DifficultyDec   = "Change the combat difficulty, Hp/Damage multipler: Easy: 0.5x/0.8x, \n" + 
                    "Normal: 1x/1x, Hard:1.5x/1.2x, Expert: 2x/1.5x"
                    
  BGM           = "BGM Volume"
  BGMDec        = "Adjust the volume of Background music\n" + "You can drag the meter by mouse to change the value"
  BGS           = "BGS Volume"
  BGSDec        = "Adjust the volume of Background sound\n" + "You can drag the meter by mouse to change the value"
  SE            = "SE Volume"
  SEDec         = "Adjust the volume of SFX\n" + "You can drag the meter by mouse to change the value"
  
  ToTitle       = "Back to Title"
  ToTitleDec    = "Leave current game and back to title screen, please don't forget to save"
  
  ShutDown      = "Shutdown"
  ShutDownDec   = "Close the game, please don't forget to save"
  
  UnsavedInfo   = "Unsaved progress will be lost, continue?"
  
  Overwrite     = "Selected file will be overwritten, continue?"
  Delete        = "Do you really wanna delete this file?"
  
  AutoSave          = "Auto-Save"
  AutoSaveDec       = "Auto save file if it's allowed. Save location is at the buttom\n" +
                      "of the files."
  AutoSaveCombat    = "Boss fight"
  AutoSaveCombatDec = "Auto-Save file before boss fight"
  AutoSaveStep      = "Steps"
  AutoSaveStepDec   = "Auto-save after you walked a certain steps, 0 = inactive"
  
  Restart = "Options will be applied after restart the game"
end
#==============================================================================
# ** Vocab::Errno
#------------------------------------------------------------------------------
#   Message displayed when an error occurred
#==============================================================================
module Vocab::Errno
  
  LoadErr         = "An error occurred while loading the file, please submit %s\n to the developers"
  SaveErr         = "An error occurred while saving the file:\n%s, please submit %s to the developers and try again later"
  
  Exception       = "An error occurred during the gameplay, please submit \"ErrorLog.txt\" to the developers in order to resolve the problem.\n"
  ScriptErr       = "An error occurred while executing the event script: %s\nplease submit %s to the developers"
  
  GiftCodeFailed  = "Gift code verify failed: %s"
  ProgramMissing  = "Program missing: "
  
  PluginInitErr   = "Failed to initialize plugins: #{}" #tag: todo
  PluginLoadErr   = "Failed to load some plugins, please send 'PluginErr.txt' to developer to resolve this bug."
  
  APIErr          = "An error occurred while calling API:\n%s"
  
  APISymbol_Table = {
    true               => "Success!",
    :json_failed       => "Configuration file build failed",
    :connection_failed => "Internet connection failed",
    :invalid_code      => "Your code has been used or invalid",
    :close_failed      => "Gateway close error",
    :decrypt_failed    => "File decryption failed",
    false              => "Hmm...IDK, please contact the developers!",
  }
  
  RunTimeErr  = "  An Error has occurred during gameplay: %s %s"
  
  RESymbol_Table = {
    :bits_incorrect   => "Bits amount asynchronous with Block Chain",
    :fileid_overflow  => "Object id overflow while convert to savefile format",
    :item_unconsumed  => "Consumable Item can't be consumed",
    :int_overflow     => "Integer Overflow",
    :datatype_error   => "Data Type Error:\n",
    :nil_block        => "Block nil miner",
    :chain_broken     => "Block Chain Error:\n",
    :illegel_value    => "Illegel value:\n",
    :checksum_failed  => "File CheckSum failure",
    :file_missing     => "File missing:\n",
    :tactic_sym_missing => "Tactic command symbol unavailable:\n",
    :secure_hash_failed => "Security hash match failed:\n",
    :config_error       => "Script configuration error:\n",
    :gib_nil_handler    => "InteractiveButton nil handler called\n",
  }
  
  SequenceArgError = "%s has at least %d args, received %d\n"
end
#==============================================================================
# ** Vocab::Status
#------------------------------------------------------------------------------
#   Message displayed when on the status menu
#==============================================================================
module Vocab::Status
  
  General         = "General"
  Property        = "Properties"
  Tactic          = "Tactics"
  Leveling        = "Level up"
  
  Parameter       = "Parameters"
  Experience      = "Experience"
  Next_Lv_Total   = "Next %s Total EXP"
  
  StrAth    = "Athletics"
  DexAcr    = "Acrobatics"
  DexSle    = "Sleight of Hand"
  DexSte    = "Stealth"
  IntArc    = "Arcana"
  IntHis    = "History"
  IntInv    = "Investigation"
  IntNat    = "Nature"
  IntRel    = "Religion"
  WisAni    = "Animal Handling"
  WisIns    = "Insight"
  WisMed    = "Medicine"
  WisPer    = "Perception"
  WisSur    = "Survival"
  ChaDec    = "Deception"
  ChaInt    = "Intimidation"
  ChaPerf   = "Performance"
  ChaPers   = "Persuasion"
end
#==============================================================================
# ** Vocab::Party
#------------------------------------------------------------------------------
#   Message displayed on the Scene_Party
#==============================================================================
module Vocab::Party
  Change      = "Change"
  Remove      = "Remove"
  Revert      = "Revert"
  Finish      = "Finish"
  TextEmpty   = "-No pony-"
  TextRemove  = "-Remove-"
  TextEquip   = "Gear"
  
  GoldGain    = "Party has %s βits: %s%s"
  ItemGain    = "Party has %s an item(x%s)"
  EXPGain     = "Party has gained xp: %d"
  BCGain      = "Party has gained block chain reward: %s"
  
  Limited     = "(max amount reached)"
  WordGain    = "gained"
  WordLost    = "lost"
end
#==============================================================================
# ** Vocab::Tactic
#------------------------------------------------------------------------------
#   Message about the tactic processes
#==============================================================================
module Vocab::Tactic
  CmdMove     = "Move to"
  CmdFollow   = "Follow"
  CmdGuard    = "Guard"
  CmdPatrol   = "Patrol"
  CmdMoving   = ":Move"
  CmdHolding  = ":Hold"
  CmdMHing    = "Hold/Move"
  
  HelpMove    = "Select a location to move, or an enemy to attack."
  HelpSel     = "Select a location"
  
  DecMove     = "Move to a position or attack an enemy"
  DecMHing    = "Press to toggle between hold/moving"
  DecReaction = "Toggle between combat reactions"
  DecFollow   = "Follow a character"
  DecGuard    = "Protect a character"
  DecPatrol   = "Guard an area"
  
  Targeting   = 'Visible Enemies'
  Fighting    = 'Target fighting'
  Self        = 'Self'
  Item        = 'Items'
  Skill       = 'Skills'
  General     = 'General'
  EdCondition = 'Edit condition'
  EdAction    = 'Edit Action'
  Delete      = "Delete"
  
  Hints = [
    "Notice: Bot tactic will only works when the party AI is enabled [press 'C'",
    "(default) in map scene to toggle it].",
    "You can see the detailed information of all commands available in Player's",
    "handbook",
    "--------------------------------------------------------------------------",
    "You can add up to 20 commands for each character, and the command will",
    "works if and only if both condition and action is assigned.",
    "If the command id is \\c[18]Red\\c[0], it's an invalid command, and \\c[29]Green\\c[0] is a valid one.",
    "You can toggle enable/disable the command by press \\c[23]CTRL\\c[0], if the command",
    "is disabled, the id color will be \\c[15]Black.",
    "Conditions won't be checked if the command is invalid or disabled, but \\c[10]the",
    "\\c[10]command accessed by 'Jump to Tactic' is not affected by disabling it.",
    "",
    "The priority of the command is from lower to higher according to its id.",
    "So if multiple command condition is meet, the one with higher id will be",
    "executed first; meanwhile AI will always prefer taking the action which",
    "could causing effects to the target(including parties) instantly.",
    "",
    "To change the priority(id) of the command, press \\c[23]SHIFT\\c[0] then negative it",
    "with cursor to the position you want; once you done, press \\c[23]shift/ok\\c[0] to",
    "exit editing.",
    "",
  ]
  
  Help     = "No idea what's this? Press F4 for help"
  SwapHelp = "Negative the cursor to swap order"
  
  Name_Table  = {
    :attack_mainhoof      => "Use main-hoof attack",
    :attack_offhoof       => "Use off-hoof attack",
    :add_command          => "Add a new tactic logic",
    :target_none          => "Set target to none",
    :hp_most_power        => "Use Hp potion: most powerful",
    :hp_least_power       => "Use Hp potion: least powerful",
    :ep_most_power        => "Use Ep potion: most powerful",
    :ep_least_power       => "Use Ep potion: least powerful",
    :set_target           => "Set to primary target",
    :jump_to              => "Jump to tactic:",
    :move_away            => "Move away from target",
    :move_close           => "Move close to target",
    :player               => "Player",
  }
end
#==============================================================================
# ** Vocab::TacticConfig
#------------------------------------------------------------------------------
#   Text info of tactic commands
#==============================================================================
module Vocab::TacticConfig
  
  Name_Table = {
    :lowest_hp              => "Lowest HP",
    :highest_hp             => "Highest HP",
    :has_state              => "Has state:",
    :nearest_visible        => "Nearest visible",
    :attacking_ally         => "Attacking ally:",
    :target_of_ally         => "Target of ally:",
    :rank                   => "Rank:",
    
    :any                    => "Any",
    :clustered              => "Clustered:",
    :hp_lower               => "Hp lower than:",
    :hp_higher              => "Hp higher than:",
    :target_range           => "At range:",
    :target_atk_type        => "Attack type:",
    
    :ep_lower               => "EP lower than:",
    :being_attacked_by_type => "Hurt by attack type:",
    
    :enemies_alive          => "X Enemies alive:",
    :allies_alive           => "X Team member alive:",
    :allies_dead            => "X Team member K.O.:",
    :surrounded_by_enemies  => "Surrounded by X enemies:",
    :using_attack_type      => "Main-hoof attack type:",
    
    :attack_mainhoof        => "Main-hoof attack",
    :attack_offhoof         => "Off-hoof attack",
    :target_none            => "Set target to none",
    :hp_most_power          => "Use hp potion: most powerful",
    :hp_least_power         => "Use hp potion: least powerful",
    :ep_most_power          => "Use ep potion: most powerful",
    :ep_least_power         => "Use ep potion: least powerful",
    
    :set_target             => "Set to primary target",
    :jump_to                => "Jump to tactic:",
    :move_away            => "Move away from target",
    :move_close           => "Move close to target",
    
    :enemies      => "Enemies:",
    :targeting    => "Enemies:",
    :target       => "Target:",
    :fighting     => "Target:",
    :self         => "Self:",
    :new_command  => "<Add New Tactic>",
    
    :short      => "Short",
    :medium     => "Medium",
    :long       => "Long",
    
    :critter    => "Critter",
    :minion     => "Minion",
    :elite      => "Elite",
    :captain    => "Captain",
    :chief      => "Chief",
    
    :melee      => "Melee",
    :ranged     => "Ranged",
    :magic      => "Magic/Casting",
    
    :player => "Player"
  }
  
  InputHelp = {
    :attacking_ally => "Select a team member",
    :target_of_ally => "Select a team member",
    :has_state    => "Select a state",
    :rank         => "Select a rank",
    :hp_lower     => "Please enter the percentage, press Enter ot finish, ESC to abort",
    :hp_higher    => "Please enter the percentage, press Enter ot finish, ESC to abort",
    :ep_lower     => "Please enter the percentage, press Enter ot finish, ESC to abort",
    :target_range => "Select a scale",
    :target_atk_type  => "Select a type",
    :being_attacked_by_type => "Select a type",
    :using_attack_type      => "Select a type",
    :clustered              => "Enter a number, operator is greater or equal",
    :enemies_alive          => "Enter a number, operator is greater or equal",
    :allies_alive           => "Enter a number, operator is greater or equal",
    :allies_dead            => "Enter a number, operator is greater or equal",
    :surrounded_by_enemies  => "Enter a number, operator is greater or equal",
    :jump_to                => "Select the id of the command..."
  }
  
  ArgDec_Table = {
    :has_state    => "%s",
    :rank         => "%s",
    :hp_lower     => "%d\%",
    :hp_higher    => "%d\%",
    :ep_lower     => "%d\%",
    :target_range => "at %s range",
    :target_atk_type  => "%s",
    :being_attacked_by_type => "%s",
    :using_attack_type      => "%s",
    :clustered              => "%d or more",
    :enemies_alive          => ">= %d",
    :allies_alive           => ">= %d",
    :allies_dead            => ">= %d",
    :surrounded_by_enemies  => ">= %d",
    :short      => "Short",
    :medium     => "Medium",
    :long       => "Long",
    :player     => "Player",
  }
  
end
#==============================================================================
# ** Vocab::Skillbar
#------------------------------------------------------------------------------
#   Text info in skillbar
#==============================================================================
module Vocab::Skillbar
  
  Follower    = "Toggle on/off Follower AI"
  AllSkill    = "All Skills"
  Vancian     = "Vancian"
  AllItem     = "All Items"
  PrevPage    = "Previous page"
  NextPage    = "Next page"
  Cancel      = "Cancel"
  None        = "<Empty>"
  
  Use         = "Use"
  Hotkey      = "Hotkey"
  Info        = "Info"
  MouseEdit   = "Now you can edit your hotkeys with mouse"
  
  SelHelp     = "Please press the hotkey(0~9) or mouse left-clicking on the slot"
  SelSucc     = "You have assigned %s on hotkey '%s'"
end
#==============================================================================
# ** Vocab::Debug
#------------------------------------------------------------------------------
#   Texts for Debug window
#==============================================================================
module Vocab::Debug
  
  Hint    = "Press Q/E(Pageup/Pagedown) to change category"
  
  Switch   = "This is list of available switches\n" + Hint
  Variable = "This is list of available variables\n" + Hint
  Sprite   = "This is list of undisposed bitmaps from last scene\n" + Hint
  
  SwitchHelp   = "C (Enter) : ON / OFF"
  VariableHelp = "← (Left)    :  -1\n"  + "→ (Right)   :  +1\n" +
                 "L (Pageup)   : -10\n" + "R (Pagedown) : +10"
                 
  SpriteHelp   = "Using WASD/↑←↓→ to negative the graph"
  
end
#==============================================================================
# ** Vocab::Leveling
#------------------------------------------------------------------------------
#   Text info about level up
#==============================================================================
module Vocab::Leveling
  
  Helps = {
    :level_up   => "Level up!",
    :unique     => "Unique skills of this character",
    :race       => "Race skills",
    :class      => "Class skills",
    :dualclass  => "Dual-class skills",
    :skilltree  => "Open the skill tree and manage available skills",
    :level_up_main => "Advance your main class to next level",
    :level_up_dual => "Advance your dual-class to next level",
    :set_dualclass => "Start a dual-class",
  }
  
  DualClass  = "Dual-Class"
  SelectFeat = "New class feature available!"
  Confirm_Dualclass  = "Are you sure about becoming a %s?"
  Confirm_LearnSkill = "Do you really want to learn %s?"
end
#==============================================================================
# ** Vocab::BlockChain
#------------------------------------------------------------------------------
#   Texts about block chain stuff
#==============================================================================
module Vocab::BlockChain
  Info = {
    :split_line => "-----------------------------",
    :transinfo  => "\\c[1]Info:\\c[0] %s",
    :payment    => "Payment is from \\c[1]%s \\c[0]to\\c[1] %s",
    :currency   => "%s amount:\\c[6] %d",
    :goods      => "Item: %s x%d",
    :nogoods    => "No item was traded",
  }
  DropLoot = "Received via dropped loot"
  LargeHistory = "You're going to view a large transaction history." +
                 " This will take a while to display all item. Continue anyway?"
end
#==============================================================================
# ** Vocab::Rescue
#------------------------------------------------------------------------------
#   Text info of the rescues
#==============================================================================
module Vocab::Rescue
  Luna    = "\\af[9]\\n<Luna>Thou shall glad I followed you.."
end

if CurrentLanguage == :zh_tw
#==============================================================================
# ** Dungeons and Dragons
#------------------------------------------------------------------------------
#  Config: Item and features sets
#==============================================================================
# tag: config
module Vocab::DND
 
  PARAM_NAME = [
    "無",
    "無",
    "力量",
    "體質",
    "智力",
    "智慧",
    "敏捷",
    "魅力",
  ]
  
  WEAPON_TYPE_NAME = [
    "",
    "蹄斧",
    "馬蹄",
    "棍棒",
    "單蹄劍",
    "雙蹄劍",
    "弓",
    "弩",
    "戰錘",
    "流星錘",
    "熱武器",
    "箭矢",
    "弩矢",
    "子彈",
    "法杖"
  ]
  
  SKILL_TYPE_NAME = [
  "",
  "技能",
  "法術",
  "萬西安",
  "被動",
  ]
  
  ARMOR_TYPE_NAME = [
  "",
  "輕型甲",
  "中型甲",
  "重型甲",
  "衣服",
  "盾牌",
  "大盾",
  "靴子",
  "腰帶",
  "項鍊",
  "斗篷",
  "戒指",
  "護腿",
  "符文",
  "寶石",
  ]
  
  ELEMENT_NAME = [
  "",
  "鈍擊",
  "穿刺",
  "揮砍",
  "強酸",
  "寒冷",
  "火焰",
  "淨力",
  "閃電",
  "壞死",
  "毒",
  "精神",
  "聖",
  "雷電",
  ]
  
  RankName = {
    :critter    => "弱雞",
    :minion     => "嘍囉",
    :elite      => "菁英",
    :captain    => "領班",
    :chief      => "首領",
  }
  
end
end # Current Language

if CurrentLanguage == :zh_tw
#==============================================================================
# ** Vocab
#------------------------------------------------------------------------------
#  This module defines terms and messages. It defines some data as constant
# variables. Terms in the database are obtained from $data_system.
#==============================================================================
module Vocab::YEA
  ICON_HASH = {
    # Matching Text   => Icon ID,
      "New story"            => 125,    # Title scene.
      "Continue story"       => 126,    # Title scene.
      "Leave"                => 127,    # Title scene. Game End scene.
      
      "Battle"        => 386,     # Battle scene.
      "Gallop"        => 328,     # Battle scene.
      "攻擊"          => 116,     # Battle scene.
      "防禦"          => 506,     # Battle scene.
      "聖物"          => 9299,
      "技能"          => 8175,    # Skill scene. Battle scene.
      "法術"          => 106,     # Skill scene. Battle scene.
      "被動"          => 3193,
      "Learn Skills"  => 2437,
      "Songs"         => 6470,
      "Pet"           => 3316,
      "Talent"        => 10662,
      "Bio"           => 233,
      "Brew"          => 3814,
      "Science"       => 8249,
      "Summon"        => 3761,
      "屬性能力"      => 228,
      "能力點"        => 228,
      "任務日誌"      => 1334,
      "Overview"      => 1354,
      "鞍袋(物品欄)"  => 1528,     # Menu scene. Item scene. Battle scene.
      "物品"          => 1528,     # Menu scene. Item scene. Battle scene.
      "Talk"          => 4,
      "Actions"       => 143,
      "Cook"          => 2580,
      "Crafting"      => 125,
      "Skills"        => 104,      # Menu scene.
      "Log"           => 2441,
      "書籍"          => 2384,
      "歷史"          => 2435,
      "Execute"       => 125,
      "Run"           => 172,
      "裝備"          => 524,      # Menu scene.
      "狀態"          => 1204,     # Menu scene.
      "隊伍"          =>  11,      # Menu scene.
      "Special"       => 775,
      "存檔"          => 10675,      # Menu scene.
      "讀檔"          => 10674,
      "Delete"        => 10676,
      "刪除"          => 10676,
      "System"        => 2144,
      "End"           => 1020,      # Menu scene.
      "Craft"         => 2059,  
      "武器"          => 386,      # Item scene.
      "裝甲"          => 436,      # Item scene.
      "關鍵物品"      => 243,      # Item scene.
      "回到標題"      => 224,      # Game End scene.
      "取消"          => 119,      # Game End scene.
      "魔法書"        => 4052,
      "萬西安法術"    => 10044,
      "萬西安"        => 10044,
      "Encyclopedia"  => 3734,
      "文獻"          => 2399, 
      "圖鑑"          => 3343,
      "Music Room"    => 118,
      "技能"          => 117,
      "裝備"          => 3786,
      "Add Point"     => 6476,
      "特殊物品"      => 1646,
      "購買"          => 555,
      "售出"          => 554,
      "屬性"          => 2375,
      "概覽"          => 556,
      "一般"          => 556,
      "醫療"          => 3958,
      "材料"          => 200,
      "素材"          => 200,
      "全部"          => 1140,
      "暗器"          => 159,
      "樂譜"          => 118,
      "書籍"          => 2384,
      "卷軸"          => 3733,
      "存檔/讀檔"     => 2431,
      "Dismantle"     => 8175,
      "Gamejolt"      => 570,
      "Life Skills"   => 8075,
      "Equip Skill"   => 117,
      "升級"          => 8182,
      "移動到"        => 572,
      "跟隨"          => 1117,
      "巡邏"          => 1114,
      "移動/停止"     => 9301,
      ":停止"         => 9301,
      ":移動"         => 2255,
      ":不攻擊"       => 1141,
      ":被動"         => 13,
      ":堅守"         => 7346,
      ":防衛"         => 139,
      ":主動"         => 131,
      ":突襲"         => 116,
      "戰術"          => 2103,
      "保護"          => 506,
      "技能樹"        => 108,
    }
    #--------------------------------------------------------------------------
  end
  
#==============================================================================
# ** Vocab::YEA::Item
#==============================================================================
module Vocab
  module YEA::ITEM
    #--------------------------------------------------------------------------
    ITEM_TYPES = {
      :all          => "全部",
      :healings     => "醫療",
      :book         => "書籍",
      :scroll       => "卷軸",
      :hdweapons    => "暗器",
      :special      => "特殊物品",
      :ingredient   => "素材",
      :music_sheet  => "樂譜",
      :misc         => "其他",
    }
    #--------------------------------------------------------------------------
    WEAPON_TYPES = {
      :all      => "全部",
    }
    #--------------------------------------------------------------------------  
    ARMOUR_TYPES = {
      :all      => "全部",
    }
    #--------------------------------------------------------------------------
    VOCAB_STATUS = {
      :empty      => "---",          # Text used when nothing is shown.
      :hp_recover => "恢復生命",      # Text used for HP Recovery.
      :mp_recover => "恢復能量",      # Text used for MP Recovery.
      :tp_recover => "恢復TP",      # Text used for TP Recovery.
      :tp_gain    => "獲得TP",      # Text used for TP Gain.
      :applies    => "狀態追加",      # Text used for applied states and buffs.
      :removes    => "狀態解除",      # Text used for removed states and buffs.
    } # Do not remove this.
    #--------------------------------------------------------------------------
  end
end
end # Current Language

if CurrentLanguage == :zh_tw
#==============================================================================
# ** Vocab
#------------------------------------------------------------------------------
#  這個模組包含部分遊戲內的顯示文字內容，資料庫內的顯示文字及物品詳細資料須在
#  "History/zh_tw/"內
#==============================================================================
# tag: translate
module Vocab
  
  # Shop Screen
  ShopBuy         = "購買"
  ShopSell        = "售出"
  ShopCancel      = "取消"
  Possession      = "擁有"
  
  # Status Screen
  ExpTotal        = "當前經驗"
  ExpNext         = "下級所需經驗 %s"
  Upgradeable     = "已經可以升級!"
  LevelUp         = "升級"
  Skilltree       = "技能樹"
  
  # Save/Load Screen
  SaveMessage     = "要儲存到哪個檔案呢?"
  LoadMessage     = "要讀取哪個檔案呢?"
  File            = "檔案"
  
  # Display when there are multiple members
  PartyName       = "%s's 隊伍"
  
  # BlockChain Node Name
  Player         = "Player"
  Coinbase       = "Equestria"
  
  # Tactic processing
  Pause           = "暫停"
  Unpause         = "解除暫停"
  
  # Title Screen
  Continue        = "繼續上次遊玩存檔"
  NewGame         = "開始新的故事"
  LoadGame        = "繼續您的旅程"
  ShutDown        = "崩潰到桌面"
  Option          = "遊戲選項"
  Credits         = "製作群"
  StartGame       = "開始遊戲"
  
  # Connections
  Connection      = "連線中...遊戲程式可能會沒有回應數分鐘, 請耐心等待"
  
  # Exit Info
  ExitConfirm     = "你真的要離開嗎? 小馬們會想念你的..."
  
  None            = "<無>"
  Type            = "類別"
  
  # Quest stuff
  Quest           = "任務日誌"
  QuestUpdated    = "任務日誌已更新: %s"
  
  # Game hint
  InitLoadingMsg  = "為了確保最佳的遊戲體驗, 請關閉占用系統資源的軟體及視窗.\n 例如Flash, Youtube或其他遊戲等"
  Unavailable     = "尚未開發完成, 敬請期待"
  
  # Transfer Info
  TransferGather  = "您必須集合隊伍才能繼續前進"
  TransferCombat  = "戰鬥中無法脫出"
  
  # Menu Stuff
  SaveDec         = "儲存遊戲進度或讀取先前的檔案"
  SystemDec       = "更改參數選項或離開遊戲"
  
  CritialMiss     = "%s - 嚴重失誤"
  CritialHit      = "%s - 致命一擊"
  AttackImmune    = "%s: %s 免疫我的傷害"
  Ineffective     = "%s - 武器無效"
  
  MoreInfo        = "詳細資料"
  
  # path to database vocabulary dictionary
  DictPath        = "History/zh_tw"
  #----------------------------------------------------------------------------
  Offline = "無法連線至網際網路, 部分功能(如gamejolt成就)將被停用. 如已連線, " +
            "請重啟遊戲變更為連線模式來恢復所有功能運作"
            
  OfflineMode = "此項功能在離線模式下無法使用, 請連接至網路並重新啟動遊戲"
  #----------------------------------------------------------------------------
  VODL      = "夜影復仇曲"
  VODLHelp  = "遊玩主線故事, 對抗重新復活並想征服小馬國的影王!"
              
  Tutorial  = "教學"
  TutorialHelp = "理解遊戲機制如何靈活運用所有功能, 強烈建議首次遊玩者"
end
#==============================================================================
# ** Vocab::SaveLoad
#------------------------------------------------------------------------------
#   Message in SnL load screen
#==============================================================================
module Vocab::SaveLoad
  
  ACTION_LOAD   = "讀檔"           # Text used for loading games.
  ACTION_SAVE   = "存檔"           # Text used for saving games.
  ACTION_DELETE = "刪除"         # Text used for deleting games.
    
  # These text settings adjust what displays in the help window.
  SELECT_HELP = "請選擇檔案欄位"
  LOAD_HELP   = "讀取已儲存的遊戲進度"
  SAVE_HELP   = "儲存當前遊戲進度"
  DELETE_HELP = "刪除該存檔"
    
  EMPTY_TEXT = "~沒有檔案~"      # Text used when no save data is present.
  PLAYTIME   = "遊戲時間"          # Text used for total playtime.
  TOTAL_SAVE = "儲存次數: "     # Text used to indicate total saves.
  TOTAL_GOLD = "擁有貨幣: "      # Text used to indicate total gold.
  LOCATION   = "地點: "        # Text used to indicate current location.
  
  Slot      = "存檔 %s"
  ASaveSlot = "自動存檔 %s"
  QSaveSlot = "快速存檔 %s"
end
#==============================================================================
# ** Vocab::Equipment
#------------------------------------------------------------------------------
#   Vocab that related to equipments and params
#==============================================================================
module Vocab::Equipment
  
  Weapon    = "武器"
  Shield    = "盾牌"
  Head      = "頭部"
  Body      = "身體"
  Accessory = "飾品"
  Cloak     = "斗篷"
  Necklace  = "項鍊"
  Boots     = "靴子"
  Rune      = "符文"
  Ammo      = "彈藥"
  Gem       = "寶石"
  
  WeaponDMG = "武器傷害"
  AmmoDMG   = "彈藥傷害"
  Speed     = "速度"
  
  Thac0     = "攻擊骰加成"
  AC        = "護甲等級"
  Damage    = "傷害"
  Range     = "距離"
  SType     = "類型"
  Cost      = "能量消耗"
  Cooldown  = "冷卻時間"
  Save      = "豁免率檢定"
  
  Remove    = "<卸下裝備>"
  Empty     = "<無>"
  None      = "<無>"
  Type      = "類別"
  
  Melee     = "物理"
  Magic     = "魔法"
  Ranged    = "遠程"
  
  CastingTime = "詠唱時間"
  SavingThrow = "豁免率檢定"
  
  SavingName = {
    :halfdmg  => "1/2",
    :nullify  => "通過則無效(Neg.)",
    :none     => "無",
    nil       => "無",
  }
  
end
#==============================================================================
# ** Vocab::System
#------------------------------------------------------------------------------
#   System option vocabs
#==============================================================================
module Vocab::System
  
  Language    = "語言"
  LanguageDec = "更改遊戲語言"
  
  WarCry          = "啟用戰鬥語音"
  WarCryDec       = "開關進入戰鬥時的開場白以及戰鬥時的部分語音效果"
  Difficulty      = "戰鬥難度"
  DifficultyName  = ["簡單", "普通", "困難", "專家"]
  DifficultyDec   = "改變戰鬥難度, 生命/傷害變化: 簡單: 0.5x/0.8x, 普通: 1x/1x\n" + 
                  "困難:1.5x/1.2x, 專家: 2x/1.5x"
                  
  BGM           = "BGM音量"
  BGMDec        = "調整背景音樂的音量, 可滑鼠拖曳數量條來改變"
  BGS           = "BGS音量"
  BGSDec        = "調整背景聲音的音量, 可滑鼠拖曳數量條來改變"
  SE            = "SE音量"
  SEDec         = "調整聲音特效的音量, 可滑鼠拖曳數量條來改變"
  
  ToTitle       = "回到標題"
  ToTitleDec    = "離開當前遊戲並回到標題畫面, 不要忘記存檔喔~"
  
  ShutDown      = "離開遊戲"
  ShutDownDec   = "離開遊戲, 不要忘記存檔喔~"
  
  UnsavedInfo   = "未儲存的進度將會遺失，確認繼續嗎?"
  
  Delete        = "確認刪除?"
  Overwrite     = "選擇的檔案將被覆蓋, 確認繼續?"
  
  AutoSave          = "自動存檔"
  AutoSaveDec       = "達成特定條件且允許存檔時將自動存檔\n" +
                      "存檔欄位位於檔案列最下方"
  AutoSaveCombat    = "頭目戰"
  AutoSaveCombatDec = "頭目戰前自動存檔"
  AutoSaveStep      = "步數"
  AutoSaveStepDec   = "每走N步後自動存檔, 0 = 關閉此功能"
  
  Restart = "新設定將在遊戲重啟後生效"
end
#==============================================================================
# ** Vocab::Errno
#------------------------------------------------------------------------------
#   Message displayed when an error occurred
#==============================================================================
module Vocab::Errno
  
  LoadErr         = "讀取檔案時發生錯誤! 請將 %s\n寄送給開發團隊"
  SaveErr         = "存檔時發生錯誤:\n%s, 請將 %s 寄送給開發團隊並稍後再試"
  
  Exception       = "遊戲運行時發生錯誤! 請將檔案\"ErrorLog.txt\"寄送給開發團隊以處理錯誤.\n"
  ScriptErr       = "事件腳本運行時期錯誤!: %s\n請寄送 %s 給開發人員"
  
  GiftCodeFailed  = "禮物碼驗證失敗: %s"
  ProgramMissing  = "遺失程式: "
  
  PluginInitErr   = "無法初始化擴充腳本: #{}" #tag: todo
  PluginLoadErr   = "部分擴充腳本無法讀取, 請將'PluginErr.txt'寄送至開發團隊以解決問題"
  
  APIErr          = "呼叫API過程中發生錯誤:\n%s"
  
  APISymbol_Table = {
    true               => "成功!",
    :json_failed       => "組態檔建立失敗",
    :connection_failed => "網際網路連線失敗",
    :invalid_code      => "您的代碼已經被使用過或無效",
    :close_failed      => "網路閘道關閉失敗",
    :decrypt_failed    => "檔案解密失敗",
    false              => "痾...我也不知道, 請聯絡開發人員!",
  }
  
  RunTimeErr  = "遊戲執行時發生錯誤: %s %s"
  
  RESymbol_Table = {
    :bits_incorrect   => "貨幣數量與區塊量不一致",
    :fileid_overflow  => "檔案ID溢位",
    :item_unconsumed  => "消耗品使用時期錯誤",
    :int_overflow     => "整數溢位",
    :datatype_error   => "資料型別錯誤:\n",
    :nil_block        => "無效的區塊鏈礦工",
    :chain_broken     => "區塊鏈:\n",
    :illegel_value    => "非法數值:\n",
    :checksum_failed  => "檔案驗證和失敗",
    :file_missing     => "遺失檔案:\n",
    :tactic_sym_missing => "無效的戰術指令符號:\n",
    :secure_hash_failed => "安全性雜湊驗證失敗:\n",
    :config_error       => "腳本設定錯誤:\n",
    :gib_nil_handler    => "InteractiveButton nil handler called\n",
  }
  
  SequenceArgError = "%s has at least %d args, received %d\n"
end
#==============================================================================
# ** Vocab::Status
#------------------------------------------------------------------------------
#   Message displayed when on the status menu
#==============================================================================
module Vocab::Status
  
  General         = "概覽"
  Property        = "屬性"
  Tactic          = "戰術"
  
  Parameter       = "能力點"
  Experience      = "經驗值"
  Next_Lv_Total   = "下級所需經驗 %s"
  
  StrAth    = "體育"
  DexAcr    = "雜技"
  DexSle    = "巧手"
  DexSte    = "潛行"
  IntArc    = "奧術"
  IntHis    = "歷史"
  IntInv    = "偵查"
  IntNat    = "自然"
  IntRel    = "宗教"
  WisAni    = "動物"
  WisIns    = "洞察"
  WisMed    = "醫學"
  WisPer    = "感知"
  WisSur    = "生存"
  ChaDec    = "詐術"
  ChaInt    = "威嚇"
  ChaPerf   = "表演"
  ChaPers   = "說服"
end
#==============================================================================
# ** Vocab::Party
#------------------------------------------------------------------------------
#   Message displayed on the Scene_Party
#==============================================================================
module Vocab::Party
  Change      = "變更"
  Remove      = "移除"
  Revert      = "復原"
  Finish      = "完成"
  TextEmpty   = "- 空 -"
  TextRemove  = "-移除-"
  TextEquip   = "裝備"
  
  GoldGain    = "隊伍%s金錢: %s%s"
  ItemGain    = "隊伍%s物品(x%s)"
  EXPGain     = "隊伍獲得經驗值: %d"
  BCGain      = "隊伍獲得挖礦獎勵: %s"
  
  Limited     = "(已達上限)"
  WordGain    = "獲得"
  WordLost    = "失去"
end
#==============================================================================
# ** Vocab::Tactic
#------------------------------------------------------------------------------
#   Message about the tactic processes
#==============================================================================
module Vocab::Tactic
  
  CmdMove     = "移動到"
  CmdFollow   = "跟隨"
  CmdGuard    = "保護"
  CmdPatrol   = "巡邏"
  CmdMoving   = ":移動"
  CmdHolding  = ":停止"
  CmdMHing    = "移動/停止"
  
  HelpMove    = "選擇一點移動到該位置，或一敵人以進行攻擊"
  HelpSel     = "請選擇一位置"
  
  DecMove     = "移動到一定點或攻擊敵人"
  DecMHing    = "按鍵切換是否移動"
  DecReaction = "按鍵切換戰鬥反應模式"
  DecFollow   = "跟隨目標"
  DecGuard    = "保護目標"
  DecPatrol   = "巡邏區域"
  
  Targeting   = '視野內敵方單位'
  Fighting    = '主要目標條件'
  Self        = '自身條件'
  Item        = '物品'
  Skill       = '技能'
  General     = '一般'
  EdCondition = '更改條件'
  EdAction    = '更改動作'
  Delete      = "刪除"
  
  Hints = [
    "※此功能只有在隊伍AI啟用時才有效果，在地圖場景中按下\\c[23]C(預設)即可切換開/關。",
    "關於各指令的詳細功能請參閱玩家手冊",
    "--------------------------------------------------------------------------",
    "每個角色都可以設置最大20個的戰術指令，並且皆須指明條件與動作才會生效。",
    "如果該指令ID為\\c[18]紅色\\c[0], 代表該指令無效; \\c[29]綠色\\c[0]則是代表有效的指令。",
    "你可以按下\\c[23]CTRL\\c[0]來啟用/停用該指令，若指令ID為\\c[15]黑色\\c[0]則代表該指令為停用狀態。",
    "無效或停用的指令不會進行條檢查。\\c[10]但是動作'跳到戰術'如果跳到一個被停用的指令，",
    "\\c[10]該指令依然會進行檢查。",
    "",
    "指令動作執行的優先順序等同它的ID，意即如果有多個指令條件吻合，ID較高的指令",
    "將優先被執行；但AI會優先執行當下使用後對目標(包含敵我雙方)有效果的動作。",
    "",
    "若要改變指令的順序，按下\\c[23]SHIFT\\c[0]並將該指令移至你想要的位置即可。",
    "完成後，按下\\c[23]shift/ok\\c[0]即可離開該指令的編輯模式",
  ]
  
  Help = "霧煞煞? 按下F4取得幫助"
  SwapHelp = "移動游標即可變更順序"
  
  Name_Table  = {
    :attack_mainhoof      => "使用主武器",
    :attack_offhoof       => "使用副武器",
    :add_command          => "新增戰術",
    :target_none          => "放棄當前目標",
    :hp_most_power        => "使用生命藥水: 最強效",
    :hp_least_power       => "使用生命藥水: 最弱效",
    :ep_most_power        => "使用能量藥水: 最強效",
    :ep_least_power       => "使用能量藥水: 最弱效",
    :set_target           => "設為主要攻擊目標",
    :jump_to              => "跳到戰術: ",
    :move_away            => "遠離目標",
    :move_close           => "接近目標",
    :player               => "玩家當前操作角色",
  }
end
#==============================================================================
# ** Vocab::TacticConfig
#------------------------------------------------------------------------------
#   Text info of tactic commands
#==============================================================================
module Vocab::TacticConfig
  
  Name_Table = {
    :lowest_hp              => "最低生命比",
    :highest_hp             => "最高生命比",
    :has_state              => "擁有狀態:",
    :nearest_visible        => "最近可視敵方單位",
    :attacking_ally         => "正在攻擊隊友:",
    :target_of_ally         => "隊友的目標:",
    :rank                   => "等級:",
    
    :any                    => "任何時刻",
    :clustered              => "X名敵方聚集:",
    :hp_lower               => "生命少於:",
    :hp_higher              => "生命多於:",
    :target_range           => "與自身的距離:",
    :target_atk_type        => "攻擊型態:",
    
    :ep_lower               => "能量少於:",
    :being_attacked_by_type => "被某攻擊所傷:",
    
    :enemies_alive          => "X名敵方存活:",
    :allies_alive           => "存活隊員數量:",
    :allies_dead            => "死亡隊員數量:",
    :surrounded_by_enemies  => "被X名敵方包圍:",
    :using_attack_type      => "主武器攻擊類型:",
    
    :attack_mainhoof        => "使用主武器攻擊",
    :attack_offhoof         => "使用副武器攻擊",
    :target_none            => "放棄當前目標",
    :hp_most_power          => "使用生命藥水: 最強效",
    :hp_least_power         => "使用生命藥水: 最弱效",
    :ep_most_power          => "使用能量藥水: 最強效",
    :ep_least_power         => "使用能量藥水: 最弱效",
    
    :set_target             => "設為主要攻擊目標",
    :jump_to                => "跳到戰術: ",
    :move_away              => "遠離目標",
    :move_close             => "接近目標",
    
    :enemies      => "所有敵人:",
    :targeting    => "所有敵人:",
    :target       => "主要目標:",
    :fighting     => "主要目標:",
    :self         => "自己:",
    :new_command  => "<新增戰術>",
    
    :short      => "短程",
    :medium     => "中程",
    :long       => "長程",
    
    :critter    => "弱雞",
    :minion     => "嘍囉",
    :elite      => "菁英",
    :captain    => "領班",
    :chief      => "首領",
    
    :melee      => "物理攻擊",
    :ranged     => "遠程攻擊",
    :magic      => "魔法攻擊或詠唱",
    
    :player     => "玩家當前操作角色",
  }
  
  InputHelp = {
    :attacking_ally => "請選擇一名隊伍成員",
    :target_of_ally => "請選擇一名隊伍成員",
    :has_state    => "請選擇一個狀態",
    :rank         => "請選擇一個等級",
    :hp_lower     => "請輸入百分比, 按下Enter鍵完成, ESC取消",
    :hp_higher    => "請輸入百分比, 按下Enter鍵完成, ESC取消",
    :ep_lower     => "請輸入百分比, 按下Enter鍵完成, ESC取消",
    :target_range => "請選擇一個距離",
    :target_atk_type  => "請選擇一個類型",
    :being_attacked_by_type => "請選擇一個類型",
    :using_attack_type      => "請選擇一個類型",
    :clustered              => "請輸入數量, 條件門檻為大於等於這個數字",
    :enemies_alive          => "請輸入數量, 條件門檻為大於等於這個數字",
    :allies_alive           => "請輸入數量, 條件門檻為大於等於這個數字",
    :allies_dead            => "請輸入數量, 條件門檻為大於等於這個數字",
    :surrounded_by_enemies  => "請輸入數量, 條件門檻為大於等於這個數字",
    :jump_to                => "請選擇指令的編號"
  }
  
  ArgDec_Table = {
    :has_state    => "%s",
    :rank         => "%s",
    :hp_lower     => "%d\%",
    :hp_higher    => "%d\%",
    :ep_lower     => "%d\%",
    :target_range => "在 %s 時",
    :target_atk_type  => "%s",
    :being_attacked_by_type => "%s",
    :using_attack_type      => "%s",
    :clustered              => "%d名或更多",
    :enemies_alive          => ">= %d",
    :allies_alive           => ">= %d",
    :allies_dead            => ">= %d",
    :surrounded_by_enemies  => ">= %d",
    :player     => "當前操縱角色",
  }
  
end
#==============================================================================
# ** Vocab::Skillbar
#------------------------------------------------------------------------------
#   Text info in skillbar
#==============================================================================
module Vocab::Skillbar
  
  Follower    = "開關隊伍成員AI"
  AllSkill    = "所有技能"
  Vancian     = "萬西安"
  AllItem     = "所有物品"
  PrevPage    = "上一頁"
  NextPage    = "下一頁"
  Cancel      = "取消"
  None        = "<無>"
  
  Use         = "使用"
  Hotkey      = "熱鍵"
  Info        = "詳細資料"
  MouseEdit   = "現在您可以使用滑鼠拖曳編輯熱鍵欄"
  
  SelHelp     = "請用滑鼠點擊熱鍵欄位或按下對應按鍵來設定"
  SelSucc     = "您已經將%s指定在熱鍵%s上"
end
#==============================================================================
# ** Vocab::Leveling
#------------------------------------------------------------------------------
#   Text info about level up
#==============================================================================
module Vocab::Leveling
  Helps = {
    :level_up   => "升級!",
    :unique     => "屬於這個角色的獨特技能",
    :race       => "種族技能",
    :class      => "職業技能",
    :dualclass  => "第二職業(兼職)技能",
    :skilltree  => "開啟並管理技能樹",
    :level_up_main => "升級主要職業",
    :level_up_dual => "升級第二職業",
    :set_dualclass => "角色兼職",
  }
  
  DualClass  = "兼職"
  SelectFeat = "有新的職業屬性可用!"
  Confirm_Dualclass  = "確定要兼職'%s'嗎?"
  Confirm_LearnSkill = "確定要學習'%s'嗎?"
end
#==============================================================================
# ** Vocab::Rescue
#------------------------------------------------------------------------------
#   Text info of the rescues
#==============================================================================
module Vocab::Rescue
  Luna    = "\\af[9]\\n<Luna>汝該慶幸本宮隨之在後.."
end
end # Current Language

#==============================================================================
# +++ MOG - Wallpaper EX (V1.1) +++
#==============================================================================
# By Moghunter
# http://www.atelier-rgss.com
#==============================================================================
# - Adiciona um papel de parede e adiciona alguns efeitos animados.
#==============================================================================
# Para mudar de papel de parede no meio do jogo basta usar o código abaixo.
#
# $game_system.wallpaper = "FILE_NAME"
#
#==============================================================================
# E para mudar de velocidade de scroll use o código abaixo.
#
# $game_system.wallpaper_scroll = [ SPEED_X, SPEED_Y]
#
#==============================================================================
# Serão necessários os seguintes arquivos na pasta GRAPHICS/SYSTEM.
# 
# Menu_Particles.png
# wallpaper
#
#==============================================================================
# ● Histórico (Version History)
#==============================================================================
# v 1.1 - Melhoria no sistema de dispose de imagens.
#==============================================================================
module MOG_WALLPAPER_EX
  #Ativar Particulas animadas.
  PARTICLES = true
  #Numero de particulas.
  NUMBER_OF_PARTICLES = 10
  #Deslizar a imagem de fundo.
  BACKGROUND_SCROLL_SPEED = [0,0]
  #Definição da opacidade das janelas.
  WINDOW_OPACITY = 80
  
  Wallpapers = [
    "Circle_of_friendship","Generosity","Kindness","Laughter",
    "Loyalty","Magic","Honesty"
  ]
end
#==============================================================================
# ■ LAYOUT_EX
#==============================================================================
module WALLPAPER_EX
  
  include MOG_WALLPAPER_EX
  
  #--------------------------------------------------------------------------
  # ● Start
  #--------------------------------------------------------------------------          
  def start
      super
      create_particles
  end   
  
  #--------------------------------------------------------------------------
  # ● Set Window OPACITY
  #--------------------------------------------------------------------------            
  def set_window_opacity    
      instance_variables.each do |varname|
          ivar = instance_variable_get(varname)
           if ivar.is_a?(Window) && !ivar.disposed?
              ivar.opacity = WINDOW_OPACITY
          end
      end
  end
 
  #--------------------------------------------------------------------------
  # ● Create Particles
  #--------------------------------------------------------------------------  
  def create_particles
    return unless PARTICLES
    dispose_menu_particles
    debug_print("Create menu particles #{self.class}")
    @particle_viewport = Viewport.new(-32, -32, 576, 448)
    @particle_bitmap =[]
    for i in 0...NUMBER_OF_PARTICLES
      sprite = Menu_Particles.new(@particle_viewport)
      @particle_bitmap.push(sprite)
    end
  end  
  #--------------------------------------------------------------------------
  # ● Create Background
  #--------------------------------------------------------------------------
  def create_background
      @background_sprite = Plane.new
      @background_sprite.bitmap = Cache.system($game_system.wallpaper) rescue nil
      @background_sprite.bitmap = SceneManager.background_bitmap if @background_sprite.bitmap == nil
  end
 
 #--------------------------------------------------------------------------
 # ● Dispose Light
 #--------------------------------------------------------------------------              
  def dispose_menu_particles
      return unless PARTICLES
      debug_print "Dispose menu particle sprites #{self.class}"
      if @particle_bitmap != nil
         @particle_bitmap.each {|sprite| sprite.dispose} 
         @particle_viewport.dispose
         @particle_bitmap = nil
      end      
  end     
  
  #--------------------------------------------------------------------------
  # ● Dispose Background
  #--------------------------------------------------------------------------
  def dispose_background
      return if @background_sprite == nil
      @background_sprite.bitmap.dispose
      @background_sprite.dispose
      @background_sprite = nil
  end
  
  #--------------------------------------------------------------------------
  # ● Terminate
  #--------------------------------------------------------------------------  
  def terminate
      super
      dispose_menu_particles
  end    
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------  
  def update
    super
    update_background
    update_particle
  end
  #--------------------------------------------------------------------------
  # ● Update Background
  #--------------------------------------------------------------------------    
  def update_background
      @background_sprite.ox += $game_system.wallpaper_scroll[0]
      @background_sprite.oy += $game_system.wallpaper_scroll[1] 
  end
  
 #--------------------------------------------------------------------------
 # ● Update Particle
 #--------------------------------------------------------------------------              
 def update_particle
     return unless PARTICLES
     return if @particle_bitmap.any?{|bitmap| bitmap.disposed?}
     @particle_bitmap.each {|sprite| sprite.update }
 end  
  
end

#==============================================================================
# * Game mode configuration
#==============================================================================
#tag: game_mode
module PONY::GameMode
  #------------------------------------------------------------------------------
  GameMode = Struct.new(:symbol, :name, :image, :enabled, :help, :init_map_id,
                        :sx, :sy, :init_party)
  #------------------------------------------------------------------------------
  Modes = []
  CursorImage = "Mode_Frame"
  #------------------------------------------------------------------------------
  Tone_VODL     = Tone.new(0,0,155)
  Tone_Tutorial = Tone.new(0,0,0)
  #------------------------------------------------------------------------------
  CreditMapID   = 26
  
  ModeConfig = {
    :main => # Mode Symbol
    {
      :name         => Vocab::VODL,       # Mode name
      :image        => "Mode_VODL",       # Path to display image file
      :enabled      => true,              # Enabled?
      :help         => Vocab::VODLHelp,   # Help text
      :init_map_id  => nil,               # Starting map id, nil for default
      :sx           => nil,               # Starting x corrd, nil for default
      :sy           => nil,               # Starting y coord, nil for default
      :init_party   => nil,               # Starting party member id, nil for deafult
    },
    #-----------
    :tutorial => 
    {
      :name         => Vocab::Tutorial,
      :image        => "Mode_Tutorial",
      :enabled      => true,
      :help         => Vocab::TutorialHelp,
      :init_map_id  => 27,
      :sx           => 5,
      :sy           => 0,
      :init_party   => nil,
    },
    #-----------
  }
  #------------------------------------------------------------------------------
  def self.setup_modes
    #-- roll credits
    setup_credit
    #-- push modes to list
    @modes = []
    ModeConfig.each do |symbol, info|
      mode = GameMode.new(symbol)
      mode.name         = info[:name]
      mode.image        = info[:image]
      mode.enabled      = info[:enabled]
      mode.help         = info[:help]
      mode.init_map_id  = info[:init_map_id]
      mode.sx, mode.sy  = info[:sx], info[:sy]
      mode.init_party   = info[:init_party]
      @modes << mode
    end
    const_set(:Modes, @modes)
  end
  #------------------------------------------------------------------------------
  def self.setup_credit
    mode_credit             = GameMode.new(:credits)
    mode_credit.name        = Vocab::Credits
    mode_credit.image       = nil
    mode_credit.enabled     = true
    mode_credit.help        = nil
    mode_credit.init_map_id = CreditMapID
    mode_credit.init_party  = nil
    mode_credit.sx, mode_credit.sy = 0, 0
    const_set(:ModeCredit, mode_credit)
  end
  #------------------------------------------------------------------------------
  def init_gamemode(mode_symbol)
    debug_print("Start mode: #{mode_symbol}, is_credit: #{mode_symbol == :credits}")
    mode = mode_symbol == :credits ? ModeCredit : Modes.find{|m| m.symbol == mode_symbol}
    debug_print("Current mode: #{mode}")
    $game_system.game_mode = mode.symbol
    DataManager.setup_new_game(mode)
  end
  #------------------------------------------------------------------------------
  setup_modes
end

#==============================================================================
# ** Audio
#------------------------------------------------------------------------------
#  This module handles and plays sound effects.
#==============================================================================
module Audio
end

#==============================================================================
# ** Cache
#------------------------------------------------------------------------------
#  This module loads graphics, creates bitmap objects, and retains them.
# To speed up load times and conserve memory, this module holds the
# created bitmap object in the internal hash, allowing the program to
# return preexisting objects when the same bitmap is requested again.
#==============================================================================
module Cache
  #--------------------------------------------------------------------------
  # * Module instance
  #--------------------------------------------------------------------------
  @sprite_linker      = []
  @undisposed_sprites = []
  #--------------------------------------------------------------------------
  def self.init
    @iconset = system("Iconset")
    @target  = Popups("targeted")
  end
  #--------------------------------------------------------------------------
  def self.Popups(filename)
    load_bitmap("Graphics/Popups/", filename)
  end
  #--------------------------------------------------------------------------
  # * Get UI Graphic
  #--------------------------------------------------------------------------
  def self.UI(filename)
    load_bitmap("Graphics/UI/", filename)
  end
  #--------------------------------------------------------------------------
  # * Get Arms Graphic
  #--------------------------------------------------------------------------
  def self.Arms(filename)
    load_bitmap("Graphics/Arms/", filename)
  end
  #--------------------------------------------------------------------------
  # * Get BG Graphic
  #--------------------------------------------------------------------------
  def self.background(filename)
    load_bitmap("Graphics/Background/", filename)
  end
  #--------------------------------------------------------------------------
  def self.tilemap(filename)
    load_bitmap("Graphics/Tilemap/", filename)
  end
  #--------------------------------------------------------------------------
  def self.iconset
    @iconset
  end
  #--------------------------------------------------------------------------
  def self.target_sprite
    @target
  end
  #--------------------------------------------------------------------------
  def self.link_sprite(sprite)
    @sprite_linker << sprite
  end
  #--------------------------------------------------------------------------
  def self.unchain_linker(sprite)
    @sprite_linker.delete(sprite)
  end
  #--------------------------------------------------------------------------
  def self.clear_sprite
    @undisposed_sprites.clear
    @sprite_linker.each do |sp|
      if sp.disposed?
        @sprite_linker.delete(sp)
      else
        debug_print("Warning: undisposed sprite #{sp}")
        @undisposed_sprites << sp
      end
    end
  end
  #--------------------------------------------------------------------------
  def self.undisposed_sprites
    @undisposed_sprites.select!{|sp| !sp.disposed?}
    return @undisposed_sprites
  end
  #--------------------------------------------------------------------------
  # * Free all cached sprites
  #--------------------------------------------------------------------------
  def self.release
    @iconset.dispose
    @iconset = nil
  end
end

#==============================================================================
module Graphics
  #-----------------------------------------------------------------------------
  # * Alias Method: Transition
  #-----------------------------------------------------------------------------
  class << self; alias transition_dnd transition; end
  def self.transition(duration = 10, filename = "", vague = 40)
    puts SPLIT_LINE
    debug_print "Graphics Transition"
    @transitioning = true
    transition_dnd(duration, filename, vague)
    @transitioning = false
    debug_print "Transition Successful"
  end
  #-----------------------------------------------------------------------------
  def self.transitioning?
    return @transitioning
  end
  #-----------------------------------------------------------------------------
  def self.center_width(cx)
    return [(width  - cx) / 2, 0].max
  end
  #-----------------------------------------------------------------------------
  def self.center_height(cy)
    return [(height - cy) / 2, 0].max
  end
  #-----------------------------------------------------------------------------
end

module Input
  
  class << self; alias dir4_wasd dir4; end
  def self.dir4
    return 2 if Input.press?(:kS) # S
    return 4 if Input.press?(:kA) # A
    return 6 if Input.press?(:kD) # D
    return 8 if Input.press?(:kW) # W
    return dir4_wasd
  end
  
  def self.dir8
    return 1 if (press?(:DOWN) || press?(:kS)) && (press?(:LEFT)  || press?(:kA))
    return 3 if (press?(:DOWN) || press?(:kS)) && (press?(:RIGHT) || press?(:kD))
    return 7 if (press?(:UP)   || press?(:kW)) && (press?(:LEFT)  || press?(:kA))
    return 9 if (press?(:UP)   || press?(:kW)) && (press?(:RIGHT) || press?(:kD))
    return dir4
  end
    
end

#==============================================================================
# ** Sound
#------------------------------------------------------------------------------
#  This module plays sound effects. It obtains sound effects specified in the
# database from the global variable $data_system, and plays them.
#==============================================================================
module Sound

  @volume = [100,100,100]

  # Low HP sound
  def self.low_hp
    Audio.se_play('Audio/SE/KindomHeart_LowHP', 100, 100)
  end
  
  # Level up SE
  def self.level_up
    Audio.se_play('Audio/SE/LevelUp', 80, 100)
  end
  
  def self.set_volume(bgm, bgs, se)
    @volume[0] = bgm; @volume[1] = bgs; @volume[2] = se;
  end

  def self.volume; @volume; end
  
end

#==============================================================================
# * Bitmap class
#==============================================================================
class Bitmap
  #-----------------------------------------------------------------------------
  attr_reader :source
  #-----------------------------------------------------------------------------
  alias init_source initialize
  def initialize(*args)
    @source = args[0].is_a?(String) ? args[0] : nil
    init_source(*args)
  end
  #-----------------------------------------------------------------------------
  alias draw_text_encoding draw_text
  def draw_text(*args)
    args.each_with_index do |arg, i|
      args[i] = arg.dup.force_encoding($default_encoding) if arg.is_a?(String)
    end
    draw_text_encoding(*args)
  end
  #-----------------------------------------------------------------------------
  # * Implementation of Bresenham's algorithm with dirty hacks
  #-----------------------------------------------------------------------------
  def draw_line(x1,y1,x2,y2,col)
    dx = x2 - x1;
    if(dx == 0)
      # Algo divides by zero otherwise; dirty hack for now
      return draw_vertical_line(x1,y1,y2,col)
    elsif(dx < 0)
      # Algo doesn't support drawing right to left right now; dirty hack
      return draw_line(x2,y2,x1,y1,col);
    end
    dy = y2 - y1;
    sgny = (dy >= 0 ? 1 : -1);
    delta = (dy.to_f / dx.to_f).abs;
    error = 0.0;
    
    y = y1;
    for x in x1.to_i..x2.to_i
      self.set_pixel(x,y,col);
      error += delta;
      while error >= 0.5
        self.set_pixel(x,y,col);
        y = y + sgny;
        error -= 1.0;
      end
    end
  end
  #-----------------------------------------------------------------------------
  def draw_vertical_line(x,y1,y2,col)
    for y in y1..y2
      self.set_pixel(x,y,col);
    end
  end
  #-----------------------------------------------------------------------------
  def swap_font(what_font)
    # I am highly suspicious of obj.dup, and need to check memory usage some time
    temp_font = self.font.dup;    
    self.font = what_font;    
    yield;
    self.font = temp_font;
  end
  #-----------------------------------------------------------------------------
  def draw_paragraph(x,y,w,text)
    cx = x;
    cy = y;
    
    paras = text.split(/\r?\n/); # Split along paragraphs, firstly.
    paras.map!{|x| x.split(" ")}
  
    row_height = text_size("George").height; # probably a better way to do this
    space_width = text_size(" ").width;
    paras.each do |paragraph|
      paragraph.each do |word|
        word = word.strip
        word_size = text_size(word);
        if(cx + word_size.width >= w)
          cx = 0;
          cy += row_height;
        end
        #fill_rect(cx,cy,size.width,size.height,Color.new(rand(255),rand(255),rand(255), 80));
        draw_text(cx,cy,1000,word_size.height,"#{word}");
        cx += word_size.width + space_width;
      end
      cy += row_height;
      cx = 0;
    end
    
    return cy;
  end
  #-----------------------------------------------------------------------------
  def draw_circle(cx, cy, rad, color, thick = 1, start_angle = 0, end_angle = 360)
    rad -= 1
    error   = -rad
    x, y    = rad, 0
    
    while (x >= y)
      if (end_angle >= 270 - (61 * y / rad))
        self.fill_rect(cx + x, cy + y, thick, thick, color)
      end
      
      if (x != 0 && end_angle > 90 + (61 * y / rad))
        self.fill_rect(cx - x, cy + y, thick, thick, color)
      end
      
      if (y != 0 && end_angle > 270 + (61 * y / rad))
        self.fill_rect(cx + x, cy - y, thick, thick, color)
      end
      
      if (x != 0 && y != 0 && end_angle >= 90 - (61 * y / rad))
        self.fill_rect(cx - x, cy - y, thick, thick, color)
      end
    
      if (x != y)
        self.fill_rect(cx + y, cy + x, thick, thick, color) if (end_angle > 180 + (61 * y / rad))
        self.fill_rect(cx - y, cy + x, thick, thick, color) if (y != 0 && end_angle >= 180 - (61 * y / rad))
        self.fill_rect(cx + y, cy - x, thick, thick, color) if (x != 0 && end_angle >= 360 - (61 * y / rad))
        self.fill_rect(cx - y, cy - x, thick, thick, color) if (y != 0 && x != 0 && end_angle > (61 * y / rad))
      end
      
      error += (y << 1) | 1
      y	 += 1
      if (error >= 0)
        error -= (x << 1) + 1
        x	 -= 1
      end
    end # while
  end # def draw_circle
  #-----------------------------------------------------------------------------
  def marshal_dump
    nil
  end
  #-----------------------------------------------------------------------------
  def marshal_load
    nil
  end
  #--------------------------------------------------------------------------
  def deactivate
    self.clear
    super
  end
  #--------------------------------------------------------------------------
end
#==============================================================================
#==============================================================================
# ** Plane
#------------------------------------------------------------------------------
#  Planes are special Sprites that tile bitmap patterns across the entire
# screen and are used to display parallax backgrounds and so on.
#==============================================================================
# Effectus's improvement
Object.send(:remove_const, :Plane)
class Plane < Sprite
  #--------------------------------------------------------------------------
  # * Set Bitmap
  #--------------------------------------------------------------------------
  def bitmap=(new_bitmap)
    return if new_bitmap == @real_bitmap && viewport == @last_viewport
    if @real_bitmap
      @real_bitmap  = nil
      self.bitmap.dispose
    end
    return super(new_bitmap) unless new_bitmap
    vw = viewport ? viewport.rect.width  : Graphics.width
    vh = viewport ? viewport.rect.height : Graphics.height
    @real_width  = new_bitmap.width
    @real_height = new_bitmap.height
    super(Bitmap.new(vw + @real_width, vh + @real_height))
    horizontal = vw / @real_width  + 1 + (vw % @real_width  > 0 ? 1 : 0)
    vertical   = vh / @real_height + 1 + (vh % @real_height > 0 ? 1 : 0)
    horizontal.times do |bx|
      vertical.times do |by|
        bitmap.blt(
          bx * @real_width,
          by * @real_height, new_bitmap,
          new_bitmap.rect
        )
      end
    end
    @last_viewport = viewport
    @real_bitmap   = new_bitmap
  end
  #--------------------------------------------------------------------------
  # * Set Offset X
  #--------------------------------------------------------------------------
  def ox=(value)
    super(@real_bitmap ? value % @real_width  : value)
  end
  #--------------------------------------------------------------------------
  # * Set Offset Y
  #--------------------------------------------------------------------------
  def oy=(value)
    super(@real_bitmap ? value % @real_height : value)
  end
  #--------------------------------------------------------------------------
  # * Bitmap
  #--------------------------------------------------------------------------
  def bitmap
    @real_bitmap ? @real_bitmap : super
  end
  #--------------------------------------------------------------------------
  # * Set Viewport
  #--------------------------------------------------------------------------
  def viewport=(new_viewport)
    if new_viewport != viewport
      super(new_viewport)
      self.bitmap = @real_bitmap if @real_bitmap
    end
  end
  #--------------------------------------------------------------------------
  # * Dispose
  #--------------------------------------------------------------------------
  def dispose
    if @real_bitmap
      @real_bitmap = nil
      self.bitmap.dispose
    end
    super
  end
  #-----------------------------------------------------------------------------
end
#==============================================================================
# * RM default Sprite class
#==============================================================================
class Sprite
  #--------------------------------------------------------------------------
  alias init_linker initialize
  def initialize(viewport = nil)
    Cache.link_sprite(self)
    init_linker(viewport)
  end
  #--------------------------------------------------------------------------
  # * Show
  #--------------------------------------------------------------------------
  def show
    self.visible = true
    self
  end
  #--------------------------------------------------------------------------
  # * Hide
  #--------------------------------------------------------------------------
  def hide
    self.visible = false
    self
  end
  #--------------------------------------------------------------------------
  def deactivate
    self.bitmap.clear
    super
  end
  #-----------------------------------------------------------------------------
  # * Query visibility
  #-----------------------------------------------------------------------------
  def visible?
    self.visible
  end
  #-----------------------------------------------------------------------------
  # * Change bitmap to an icon
  #-----------------------------------------------------------------------------
  def draw_icon(icon_index)
    self.bitmap = Bitmap.new(24, 24) if !self.bitmap
    crect = Rect.new(0,0,24,24)
    bitmap.clear_rect(crect)
    rect  = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
    self.bitmap.blt(0, 0, Cache.iconset, rect)
  end
  #--------------------------------------------------------------------------
  def moveto(sx, sy)
    self.x, self.y = sx, sy
  end
  #-----------------------------------------------------------------------------
  alias dispose_linker dispose
  def dispose
    Cache.unchain_linker(self)
    dispose_linker
  end
  #-----------------------------------------------------------------------------
end
#==============================================================================
class Tilemap
  TILESIZE = 32
  #-----------------------------------------------------------------------------
end

#==========================================================================
# ■ RPG::BaseItem
#--------------------------------------------------------------------------
#   This class is the super class of all database classes
#==========================================================================
class RPG::BaseItem
  include DND::Utility
  #------------------------------------------------------------------------
  # * public instance variables
  #------------------------------------------------------------------------
  # tag: equiparam
  attr_accessor :user_graphic        # Graphic display on user
  attr_accessor :tool_cooldown       # Cooldown after use
  attr_accessor :tool_graphic        # Projectile graphic
  attr_accessor :weapon_skill        # Skill apply when weapon hitted
  attr_accessor :tool_index          # Projectile graphic index
  attr_accessor :tool_distance       # Effective distance
  attr_accessor :tool_effectdelay    # Effect delay after exeucuted (frame)
  attr_accessor :tool_destroydelay   # Graphic removal delay after completed
  attr_accessor :tool_speed          # Projectile speed
  attr_accessor :tool_castime        # Cast time
  attr_accessor :tool_castanimation  # Animation during casting
  attr_accessor :tool_blowpower      # Knockback enemy when hitted
  attr_accessor :tool_piercing       # Pierece amount of effect executed
  
  attr_accessor :tool_animation      # Animation display on collide
  attr_accessor :tool_animmoment     # Animation display moment
                                     # 1: Display on projectile
                                     # 0: Display on recipient
                                      
  attr_accessor :tool_special        # Special attributes
  attr_accessor :tool_special_param  # 0: Nothing
                                     # 1: Projectile jump to neartest next
                                     # target, parameter: max jump count
                                     #
                                     # 2: Projectile will reflect after collide
                                     # parameter: max reflection count
                                      
  attr_accessor :tool_scope          # Effective scope range on execute
  attr_accessor :tool_scopedir       # Effective direction, 0 = same as battler
                                     # direction = 1~9, 5 = all direction
                                     
  attr_accessor :tool_scopeangle     # 0 = all_direction, 1~359 otherwise
  attr_accessor :tool_invoke         # Invoke other skill(id) on execute
  attr_accessor :tool_soundeffect    # Sound effect played on execuute
  attr_accessor :tool_itemcost       # Specified item(id) required
  attr_accessor :tool_itemcost_type  # Item type(id) required
  attr_accessor :tool_through        # Projectile through map obstacles
  attr_accessor :tool_priority       # Graphic priority display, same as event's
  attr_accessor :tool_hitshake       # Screen shake level when hitted (uint)
  attr_accessor :tool_type           # Tool Type, 0 = missile, 1 = bomb
  attr_accessor :tool_combo          # Next Weapon id use after player contiune
                                     # to using this tool(default: in 20 frames)
                                     
  attr_reader   :scope               # Damage::Scope
  attr_reader   :information         # Linked to folder /History
  attr_reader   :action_sequence
  attr_reader   :dmg_saves           # Saving throw type when executed
  #------------------------------------------------------------------------
  attr_reader :saving_throw_adjust
  attr_reader :dc_adjust
  attr_reader :property
  attr_reader :damage_index
  attr_reader :item_own_max
  attr_reader :param_adjust, :thac0, :ac
  #---------------------------------------------------------------------------
  # * Load the attributes of the item form its notes in database
  #---------------------------------------------------------------------------
  def load_notetags_dndattrs
    @feature_value = {}
    apply_default_tool_attrs
    
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #-------------------------------------------------------------------------
      # * Base score ability adjustment when processing saving throws
      when DND::REGEX::SAVING_THROW_ADJUST
        @saving_throw_adjust = $1.split(',').collect{|i| i.to_i}
      #-------------------------------------------------------------------------
      # * Base score ability adjustment when processing difficulty classes
      when DND::REGEX::DC_ADJUST
        @dc_adjust = $1.split(',').collect{|i| i.to_i}
      #-------------------------------------------------------------------------
      # * Base score ability adjustment
      when DND::REGEX::Param_Adjust
        @param_adjust            = $1.split(',').collect{|i| i.to_i}
      #-------------------------------------------------------------------------
      # * Projectile produced by this item whether blocked by event
      when DND::REGEX::PROJ_BLOCK_BY_EVENT; @block_by_event = true
      #-------------------------------------------------------------------------
      # * Item max for EquipItem and Items
      when DND::REGEX::ITEM_MAX;            @item_own_max = $1.to_i
      #-------------------------------------------------------------------------
      # * Damage inflicted by this item
      when DND::REGEX::DAMAGE
        element_id = get_element_id($3)
        time = $1.split('d').at(0)
        face = $1.split('d').at(1)
        mod_id = get_param_id($4)
        @damage_index.push( [time.to_i,face.to_i,$2.to_i,element_id,mod_id])
        puts "[BaseItem Damage]:#{self.name}: #{time}d#{face} + (#{$2.to_i}), element:#{$3}(#{element_id}) modifier: #{$4}(#{mod_id})"
      else
        load_item_property(line)
        load_item_features(line)
      end
    } # self.note.split
    
    # Minor adjusts
    @tool_distance     += 0.4
    @tool_scope        += 0.4
    @information = load_help_information
  end
  #---------------------------------------------------------------------------
  # * Load item's property, presented by a bitset
  #---------------------------------------------------------------------------
  def load_item_property(line)
    case line
    when DND::REGEX::MAGIC_EFFECT
      @property |= PONY::Bitset[0]
    when DND::REGEX::DEBUFF && self.is_a?(RPG::State)
      @property |= PONY::Bitset[1]
    when DND::REGEX::POISON && self.is_a?(RPG::State)
      @property |= PONY::Bitset[2]
    when DND::REGEX::IS_PHYSICAL
      @property |= PONY::Bitset[3]
    when DND::REGEX::IS_MAGICAL
      @property |= PONY::Bitset[4]
    end
  end
  #---------------------------------------------------------------------------
  # * Load core tool item feature
  #---------------------------------------------------------------------------
  def load_item_features(line)
    case line
    when DND::REGEX::Equipment::UserGraphic
      @user_graphic = $1.downcase == 'nil' ? nil : $1
    when DND::REGEX::Equipment::ToolGraphic
      @tool_graphic = $1.downcase == 'nil' ? nil : $1
    when DND::REGEX::Equipment::WeaponEffect;      @weapon_skill       = $1.to_i;
    when DND::REGEX::Equipment::ToolIndex;         @tool_index         = $1.to_i;
    when DND::REGEX::Equipment::CoolDown;          @tool_cooldown      = $1.to_i;
    when DND::REGEX::Equipment::ToolDistance;      @tool_distance      = $1.to_i;
    when DND::REGEX::Equipment::ToolEffectDelay;   @tool_effectdelay   = $1.to_i;
    when DND::REGEX::Equipment::ToolDestroyDelay;  @tool_destroydelay  = $1.to_i;
    when DND::REGEX::Equipment::ToolSpeed;         @tool_speed         = $1.to_f;
    when DND::REGEX::Equipment::ToolCastime;       @tool_castime       = $1.to_i;
    when DND::REGEX::Equipment::ToolCastAnimation; @tool_castanimation = $1.to_i;
    when DND::REGEX::Equipment::ToolBlowPower;     @tool_blowpower     = $1.to_i;
    when DND::REGEX::Equipment::ToolPiercing;      @tool_piercing      = $1.to_i;
    when DND::REGEX::Equipment::ToolAnimation;     @tool_animation     = $1.to_i;    
    when DND::REGEX::Equipment::ToolAnimMoment;    @tool_animmoment    = $1.to_i;
    #---------------------------------------------------------------------------
    when DND::REGEX::Equipment::ToolSpecial
      @tool_special       = $1.to_i
      @tool_special_param = $2.to_i | 0
    #---------------------------------------------------------------------------
    when DND::REGEX::Equipment::ToolScope;         @tool_scope         = $1.to_i;
    when DND::REGEX::Equipment::ToolScopeDir;      @tool_scopedir      = $1.to_i;
    when DND::REGEX::Equipment::ToolScopeAngle;    @tool_scopeangle    = $1.to_i;
    when DND::REGEX::Equipment::ToolInvokeSkill;   @tool_invoke        = $1.to_i;
    when DND::REGEX::Equipment::ToolSE
      @tool_soundeffect[0] = $1 unless $1.strip.downcase == 'nil'
      @tool_soundeffect[1] = $2.to_i if $2
    when DND::REGEX::Equipment::ToolItemCost;      @tool_itemcost      = $1.to_i;
    when DND::REGEX::Equipment::ToolItemCostType;  @tool_itemcost_type = $1.to_i;
    when DND::REGEX::Equipment::ToolThrough;       @tool_through       = $1.to_i.to_bool;
    when DND::REGEX::Equipment::ToolPriority;      @tool_priority      = $1.to_i;
    when DND::REGEX::Equipment::ToolType;          @tool_type          = $1.to_i; 
    when DND::REGEX::Equipment::ToolHitShake;      @tool_hitshake      = $1.to_i;
    when DND::REGEX::Equipment::ToolCombo;         @tool_combo         = $1.to_i;
    when DND::REGEX::Equipment::ApplyAction;       @action_sequence    = $1.to_i;
    when DND::REGEX::Equipment::DamageSavingThrow
      @dmg_saves = [DND::SavingThrow::List[$1], $2]
    end
  end  
  #---------------------------------------------------------------------------
  # * Default attributes for tool item
  #---------------------------------------------------------------------------
  def apply_default_tool_attrs
    @saving_throw_adjust      = Array.new(8, 0)
    @dc_adjust                = Array.new(8, 0)
    @param_adjust             = Array.new(8, 0)
    
    @damage_index             = []
    @property                 = 0
    @item_own_max             = 10
    
    @tool_animation     = 0
    @tool_distance      = 2
    @tool_animmoment    = 0
    @tool_castime       = 0
    @tool_itemcost      = 0
    @tool_itemcost_type = 0
    @tool_scope         = 1
    @tool_scopedir      = 5
    @tool_scopeangle    = 0
    @tool_blowpower     = 0
    @tool_combo         = 0
    @action_sequence    = 0
    @tool_effectdelay   = 0
    @tool_itemcost      = 0
    @tool_itemcost_type = 0
    @dmg_saves          = nil
    @tool_soundeffect   = [nil, 80]
    @block_by_event     = false
  end
  #---------------------------------------------------------------------------
  # *) Load item infos for detailed inforamtion, located at "History/type/id"
  # -> virtual function for inherit
  #---------------------------------------------------------------------------  
  def load_help_information
  end
  #------------------------------------------------------------------------
  # * Super mehtod for characters initialization
  #------------------------------------------------------------------------
  def load_character_attributes
    @feature_value = {}
  end
  #------------------------------------------------------------------------
  # *) Item need consume items
  #------------------------------------------------------------------------  
  def item_required?
    return (@tool_itemcost || 0) > 0 || (@tool_itemcost_type || 0) > 0
  end
  #------------------------------------------------------------------------
  # *) Item is an ammo?
  #------------------------------------------------------------------------  
  def is_ammo?
    return false if !self.is_a?(RPG::Weapon)
    _id = self.wtype_id
    return [11, 12, 13].include?(_id) # arrow, bolt, 
  end
  #------------------------------------------------------------------------
  def is_magic?
    return (@property & PONY::Bitset[0]).to_bool
  end
  #------------------------------------------------------------------------
  def is_debuff?
    return (@property & PONY::Bitset[1]).to_bool
  end
  #------------------------------------------------------------------------
  def is_poison?
    return (@property & PONY::Bitset[2]).to_bool
  end
  #------------------------------------------------------------------------
  # * Whether a virtual flag for leveling
  #------------------------------------------------------------------------
  def for_leveling?
    return (@property & PONY::Bitset[5]).to_bool
  end
  #------------------------------------------------------------------------
  def is_spell?
    return false if self.nil?
  end
  #------------------------------------------------------------------------
  def attack_type
    return :magic  if is_magic?
    return :melee  if melee?
    return :ranged
  end
  #------------------------------------------------------------------------
  def melee?
    return @tool_distance < 2.5
  end
  #--------------------------------------------------------------------------
  def ranged?
    return !melee?
  end
  #---------------------------------------------------------------------------
  def physical?
    return (@property & PONY::Bitset[3]).to_bool
  end
  #---------------------------------------------------------------------------
  def magical?
    return (@property & PONY::Bitset[4]).to_bool
  end
  #--------------------------------------------------------------------------
  def param(id)
    return param_base(id)
  end
  #---------------------------------------------------------------------------
  def param_base(id)
    value = @param_adjust[id]
    value
  end
  #--------------------------------------------------------------------------
  def feature_value(code, data_id)
    key = code * 1000 + data_id
    return @feature_value[key] unless @feature_value[key].nil?
    value = 0
    @features.each do |feat|
      next unless feat.code == code && feat.data_id == data_id
      value += feat.value
    end
    return @feature_value[key] = value
  end
  #--------------------------------------------------------------------------
  def attack_bonus
    return (self.feature_value(22, 0) * 20).to_i
  end
  #--------------------------------------------------------------------------
  def armor_class
    return (self.feature_value(22, 1) * 20).to_i
  end
  #---------------------------------------------------------------------------
  def wield_speed
    return 60 - @tool_cooldown
  end
  #--------------------------------------------------------------------------
  # Item Scope Queries
  #--------------------------------------------------------------------------
  def for_none?; return @scope == 0; end
  def for_opponent?; return [1, 2, 3, 4, 5, 6].include?(@scope); end
  def for_friend?; return [7, 8, 9, 10, 11].include?(@scope); end
  def for_dead_friend?; return [9, 10].include?(@scope); end
  def for_user?; return @scope == 11; end
  def for_one?; return [1, 3, 7, 9, 11].include?(@scope); end
  def for_random?; return [3, 4, 5, 6].include?(@scope); end
  def for_all?; return [2, 8, 10].include?(@scope); end
  #----------------------------------------------------------------------------
  # *) Delete a char at certain position
  #----------------------------------------------------------------------------
  def id_for_filename
    n = @id
    cnt = 0
    while n > 0
      n /= 10
      cnt += 1
    end
    dict = ''
    return sprintf("%s%s%s",dict, '0' * (3 - cnt), @id)
  end
  #------------------------------------------------------------------------
  # * Set hashid
  #------------------------------------------------------------------------
  def hash_self
    base = (@id * 42).to_s(8)
    base += "Actor"  if self.is_a?(RPG::Actor)
    base += "Class"  if self.is_a?(RPG::Class)
    base += "Enemy"  if self.is_a?(RPG::Enemy)
    base += "Item"   if self.is_a?(RPG::Item)
    base += "Weapon" if self.is_a?(RPG::Weapon)
    base += "Armor"  if self.is_a?(RPG::Armor)
    base += "State"  if self.is_a?(RPG::State)
    @hashid = PONY.Sha256(base).to_i(16)
    super
  end
  #-----------------------------------------------------------------------
  # *) Get Attack Element
  #-----------------------------------------------------------------------
  def get_feat_attack_elemet
    elements = []
    @features.each do |feat|
      elements.push(feat.data_id) if feat.code == 31
    end
    
    return elements
  end
  #-----------------------------------------------------------------------
  # *) Get Element Rate
  #-----------------------------------------------------------------------
  def get_element_rate(id)
    @features.each do |feat|
      if feat.code == 11
        if id.is_a?(String)
          return feat.value if id.upcase == $data_system.elements[feat.data_id].upcase
        else
          return feat.value if id == feat.data_id
        end
      end
    end
    return 1
  end
  #---------------------------------------------------------------------------
  def is_skill?;  false; end
  def is_item?;   false; end
  def is_weapon?; false; end
  def is_armor?;  false; end
  #---------------------------------------------------------------------------  
  #--------------------------------------------------------------------------
end

#=======================================================================
# *) RPG::UsableItem
#-----------------------------------------------------------------------
# Quicker way to check the effects
#=======================================================================
class RPG::UsableItem < RPG::BaseItem
  #--------------------------------------------------------------------------
  # * Constants (Effects)
  #--------------------------------------------------------------------------
  EFFECT_RECOVER_HP     = 11              # HP Recovery
  EFFECT_RECOVER_MP     = 12              # MP Recovery
  EFFECT_GAIN_TP        = 13              # TP Gain
  EFFECT_ADD_STATE      = 21              # Add State
  EFFECT_REMOVE_STATE   = 22              # Remove State
  EFFECT_ADD_BUFF       = 31              # Add Buff
  EFFECT_ADD_DEBUFF     = 32              # Add Debuff
  EFFECT_REMOVE_BUFF    = 33              # Remove Buff
  EFFECT_REMOVE_DEBUFF  = 34              # Remove Debuff
  EFFECT_SPECIAL        = 41              # Special Effect
  EFFECT_GROW           = 42              # Raise Parameter
  EFFECT_LEARN_SKILL    = 43              # Learn Skill
  EFFECT_COMMON_EVENT   = 44              # Common Events
  #---------------------------------------------------------------------------
  # * Load the attributes of the item form its notes in database
  #---------------------------------------------------------------------------
  def load_notetags_dndattrs
    @effect_value = {}
    super
  end
  #--------------------------------------------------------------------------
  def effect_value(code, data_id)
    key = code * 1000 + data_id
    return @effect_value[key] unless @effect_value[key].nil?
    eff = Struct.new(:value1, :value2).new(0,0)
    @effects.each do |feat|
      next unless feat.code == code && feat.data_id == data_id
      eff.value1 += feat.value1
      eff.value2 += feat.value2
    end
    return @effect_value[key] = eff
  end
  #-----------------------------------------------------------------------
  # *) Check if state will be added
  #-----------------------------------------------------------------------
  def add_state?(id = 0)
    # check if will add state
    return @effects.any? {|eff| eff.code == EFFECT_ADD_STATE } if id == 0
    # check if will add a specific state
    return @effects.any? {|eff| eff.code == EFFECT_ADD_STATE && effect.data_id == id }
  end
  #-----------------------------------------------------------------------
  # *) Check if state will be removed
  #-----------------------------------------------------------------------
  def remove_state?(id = 0)
    # check if will remove state
    return @effects.any? {|eff| eff.code == EFFECT_REMOVE_STATE } if id == 0
    # check if will remove a specific state
    return @effects.any? {|eff| eff.code == EFFECT_REMOVE_STATE && effect.data_id == id }
  end
  #-----------------------------------------------------------------------
  # *) Check whether will recover hp
  #-----------------------------------------------------------------------
  def hp_recover?
    return true if @damage.recover? && @damage.to_hp?
    return @effects.any?{|eff| eff.code == EFFECT_RECOVER_HP && (eff.value1 > 0 || eff.value2 > 0) }
  end
  #-----------------------------------------------------------------------
  # *) Check whether will recover ep
  #-----------------------------------------------------------------------
  def mp_recover?
    return true if @damage.recover? && @damage.to_mp?
    return @effects.any?{|eff| eff.code == EFFECT_RECOVER_MP && (eff.value1 > 0 || eff.value2 > 0) }
  end
  alias :ep_recover? :mp_recover?
  #--------------------
end
#==============================================================================
# ** RPG::EquipItem
#==============================================================================
class RPG::EquipItem < RPG::BaseItem
  #---------------------------------------------------------------------------
  def param_base(id)
    return super + @params[id]
  end
end
#==========================================================================
# ■ RPG::Actor
#==========================================================================
class RPG::Actor < RPG::BaseItem
  #------------------------------------------------------------------------
  # * instance variables
  #------------------------------------------------------------------------
  #tag: charparam
  #tag: actor
  attr_reader :death_graphic        # Graphic filename when K.O
  attr_reader :death_index          # Graphic index
  attr_reader :death_pattern        # Pattern
  attr_reader :death_direction      # Direction
  attr_reader :death_sound
  attr_reader :casting_graphic
  attr_reader :casting_index
  attr_reader :casting_pattern
  attr_reader :icon_index
  attr_reader :parent_class
  attr_reader :dualclass_id, :race_id, :subrace_id
  attr_reader :class_levelcap
  #--------------------------------------------------------------------------
  # * Attributes setup
  #--------------------------------------------------------------------------
  def load_character_attributes
    super
    apply_default_attributes
    dnd_loading = false
    self.note.split(/[\r\n]+/).each do |line|
      case line
      when DND::REGEX::Character::KOGraphic;   @death_graphic   = $1
      when DND::REGEX::Character::KOIndex;     @death_index     = $1.to_i
      when DND::REGEX::Character::KOPattern;   @death_pattern   = $1.to_i
      when DND::REGEX::Character::KODirection; @death_direction = $1.to_i
      when DND::REGEX::Character::KODirection; @death_sound     = $1.to_i
      when DND::REGEX::Character::CastGraphic; @casting_graphic = $1.to_i
      when DND::REGEX::Character::CastIndex;   @casting_index   = $1.to_i
      when DND::REGEX::Character::CastPattern; @casting_pattern = $1.to_i
      when DND::REGEX::Character::IconIndex;   @icon_index      = $1.to_i
      when DND::REGEX::Character::CastingAnimation; @casting_animation = $1.to_i
      when DND::REGEX::Leveling::LoadStart; dnd_loading = true;
      when DND::REGEX::Leveling::LoadEnd;   dnd_loading = false;
      end
      load_dnd_attribute(line) if dnd_loading
    end
  end
  #--------------------------------------------------------------------------
  def load_dnd_attribute(line)
    case line
    when DND::REGEX::Leveling::Race;      @race_id         = $1.to_i
    when DND::REGEX::Leveling::Subrace;   @subrace_id      = $1.to_i
    when DND::REGEX::Leveling::Class
      # Primary Class selection is loaded from default RM database editor
    when DND::REGEX::Leveling::DualClass
      info          = $1.split(',')
      @dualclass_id = (info.first.to_i || 0)
      @class_levelcap[@dualclass_id][0] = [info.last.to_i, 1].max
    when DND::REGEX::Leveling::HP;           @param_adjust[0]   = $1.to_i
    when DND::REGEX::Leveling::EP;           @param_adjust[1]   = $1.to_i
    when DND::REGEX::Leveling::Strength;     @param_adjust[2]   = $1.to_i
    when DND::REGEX::Leveling::Constitution; @param_adjust[3]   = $1.to_i
    when DND::REGEX::Leveling::Intelligence; @param_adjust[4]   = $1.to_i
    when DND::REGEX::Leveling::Wisdom;       @param_adjust[5]   = $1.to_i
    when DND::REGEX::Leveling::Dexterity;    @param_adjust[6]   = $1.to_i
    when DND::REGEX::Leveling::Charisma;     @param_adjust[7]   = $1.to_i
    end # case
  end
  #--------------------------------------------------------------------------
  def apply_default_attributes
    @death_graphic      = DND::BattlerSetting::KOGraphic
    @death_index        = DND::BattlerSetting::KOIndex
    @death_pattern      = DND::BattlerSetting::KOPattern
    @death_direction    = DND::BattlerSetting::KODirection
    @casting_animation  = DND::BattlerSetting::CastingAnimation
    @race_id            = DND::BattlerSetting::DefaultRaceID
    
    @param_adjust = Array.new(8, 0)
    @subrace_id   = @dualclass_id = 0
    
    # Initial element for classes' init level and level cap
    init_lvl_ele = [0, DND::BattlerSetting::LevelCap]
    @class_levelcap  = Array.new($data_classes.size, init_lvl_ele)
    @class_levelcap[@class_id][0] = @initial_level
  end
  #--------------------------------------------------------------------------
end
#==============================================================================
# ** RPG::Armor
#==============================================================================
class RPG::Armor < RPG::EquipItem
  #---------------------------------------------------------------------------
  # *) Load item infos for detailed inforamtion, located at "History/type/id"
  #---------------------------------------------------------------------------  
  def load_help_information
    path = Vocab.GetDictPath(:armor)
    DataManager.ensure_file_exist(path)
    filename = path + self.id_for_filename
    filename = Dir.glob(filename + '*').at(0)
    info = ""
    return self.description unless (filename && File.exist?(filename))
    File.open(filename, 'r') do |file|
      while(line = file.gets)
        info += line
      end
    end
    return info.size >= description.size ? info : description
  end
  #---------------------------------------------------------------------
  # *) armor class
  #--------------------------------------------------------------------------
  def armor_class
    (self.rarity - 1 + super)
  end
  #---------------------------------------------------------------------------
  def is_armor?; true; end
  #---------------------------------------------------------------------------
end
#==========================================================================
# ■ RPG::Class
#==========================================================================
class RPG::Class < RPG::BaseItem
  #------------------------------------------------------------------------
  # * instance variables
  #------------------------------------------------------------------------
  attr_reader :parent_class
  attr_reader :requirement
  #--------------------------------------------------------------------------
  # * Attributes setup
  #--------------------------------------------------------------------------
  def load_character_attributes
    super
    apply_default_attributes
    dnd_loading = false
    self.note.split(/[\r\n]+/).each do |line|
      case line
      when DND::REGEX::Leveling::LoadStart; dnd_loading = true;
      when DND::REGEX::Leveling::LoadEnd;   dnd_loading = false;
      end
      load_dnd_attribute(line) if dnd_loading
    end
  end
  #--------------------------------------------------------------------------
  def load_dnd_attribute(line)
    case line
    when DND::REGEX::Leveling::ClassParent;  @parent_class    = $1.to_i;
    when DND::REGEX::Leveling::HP;           @param_adjust[0] = $1.to_i;
    when DND::REGEX::Leveling::EP;           @param_adjust[1] = $1.to_i;
    when DND::REGEX::Leveling::Strength;     @param_adjust[2] = $1.to_i;
    when DND::REGEX::Leveling::Constitution; @param_adjust[3] = $1.to_i;
    when DND::REGEX::Leveling::Intelligence; @param_adjust[4] = $1.to_i;
    when DND::REGEX::Leveling::Wisdom;       @param_adjust[5] = $1.to_i;
    when DND::REGEX::Leveling::Dexterity;    @param_adjust[6] = $1.to_i;
    when DND::REGEX::Leveling::Charisma;     @param_adjust[7] = $1.to_i;
    when DND::REGEX::Leveling::Requirement;  load_class_reqs($1);
    end
  end
  #--------------------------------------------------------------------------
  def apply_default_attributes
    @parent_class = 0
    @param_adjust = Array.new(8, 0)
    @requirement  = nil
  end
  #------------------------------------------------------------------------
  def param(id)
    re  = (@param_adjust[id] || 0)
    re += $data_classes[@parant_class].param(id) if @parent_class > 0
    return re
  end
  #--------------------------------------------------------------------------
  # * Get Total EXP Required for Rising to Specified Level
  #--------------------------------------------------------------------------
  def exp_for_level(level)
    return (DND::EXP_FOR_LEVEL[level] * 1000).to_i
  end
  #--------------------------------------------------------------------------
  # * Load class requirements, safer mehtod should turn infix to postfix
  #--------------------------------------------------------------------------
  def load_class_reqs(str)
    str      = str.downcase
    brackets = [0,0]
    str.each_char do |ch|
      case ch
      when '['; brackets[0]   += 1;
      when ']'; brackets[1]   += 1;
      when '('; brackets[0]   += 1;
      when ')'; brackets[1]   += 1;
      end
      
      if brackets[0] < brackets[1]
        msgbox "An critical SyntaxError detected in your database:"
        msg = "Brackets number unequal in:\n" + sprintf("(%03d)%s: %s", id, name,str)
        raise SyntaxError, msg
      end
    end
    @requirement = str.tr('[]','')
  end
  #--------------------------------------------------------------------------
  # * Check score ability whether meet the requirement
  #--------------------------------------------------------------------------
  def class_requirement_meet?(actor)
    req = @requirement.dup
    ['str', 'con', 'dex', 'int', 'wis', 'cha'].each do |score|
      req.gsub!(score, actor.param(get_param_id(score)).to_s)
    end
    eval(req)
  end
  #--------------------------------------------------------------------------
end
#==============================================================================
# ** RPG::Enemy
#------------------------------------------------------------------------------
#  Instance class in database, store enemies data
#==============================================================================
class RPG::Enemy
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  # tag: charparam
  #--------------------------------------------------------------------------
  attr_accessor :default_weapon       # Weapon ID when no primary weapon equipped
  attr_accessor :team_id              # Team ID
  attr_accessor :visible_sight        # Sight range with bare eye
  attr_accessor :blind_sight          # Sight ragne without actuallt see things
  attr_accessor :infravision          # No penalty in dark
  attr_accessor :move_limit           # Back to original position once distance out of this value
  attr_accessor :aggressive_level     # Aggressive Level:
    #--------------------------------------------------------------------------
    # 0: Won't attack no matter what (No attack)
    # 1: Won't attack unless enemy attack first, if in combat, change to 4 (Passive)
    # 2: Attack sighted enemy without chasing (Stand Ground)
    # 3: Chase enemy in short range (7), until enemy out of last sighted spot (Defensive)
    # 4: Chase enemy until target out of last sighted spot, won't corss areas (Aggressive)
    # 5: Chase enemy through local areas until target out of last sighted spot (Striking)
    #--------------------------------------------------------------------------
  attr_reader   :death_animation      # Animation display on death
  attr_reader   :death_switch_self    # Self switch trigger when dead
  attr_reader   :death_switch_global  # Global switch trigger when dead
  attr_reader   :death_var_self       # Self var change when dead
  attr_reader   :death_var_global     # Self var change when dead
  attr_reader   :casting_animation
  
  attr_accessor :weapon_level_prof    # Immune the damage from weapons below than +N level
  attr_accessor :face_name  # Face filename show in map status window
  attr_accessor :face_index # Face index
  attr_accessor :body_size
  
  attr_accessor :secondary_weapon
  #--------------------------------------------------------------------------
  attr_reader :dualclass_id, :race_id, :subrace_id, :class_id
  attr_reader :class_levelcap
  #--------------------------------------------------------------------------
  # * Attributes setup
  #--------------------------------------------------------------------------
  def load_character_attributes
    super
    apply_default_attributes
    self.note.split(/[\r\n]+/).each { |line|
      do_load_enemy_params(line)
    } # self.note.split
    #--------------------------------------------------
  end
  #--------------------------------------------------------------------------
  def do_load_enemy_params(line)
    case line
    when DND::REGEX::Character::DefaultWeapon
      id = $1.to_i
      @default_weapon = $data_weapons[id] if id > 1
      puts "[System]: #{self.name}'s default weapon: #{@default_weapon.name}" if id > 1
    when DND::REGEX::Character::SecondaryWeapon
      id = $1.to_i
      @secondary_weapon = $data_weapons[id] if id > 1
      puts "[System]: #{self.name}'s secondary weapon: #{@secondary_weapon.name}" if id > 1
    when DND::REGEX::Character::SecondaryArmor
      id = $1.to_i
      @secondary_weapon = $data_armors[id] if id > 1
      puts "[System]: #{self.name}'s secondary armor: #{@secondary_weapon.name}" if id > 1
    when DND::REGEX::Character::TeamID
      @team_id = $1.to_i
    when DND::REGEX::Character::DeathSwitchSelf
      @death_switch_self = $1.upcase
    when DND::REGEX::Character::DeathSwitchGlobal
      @death_switch_global = $1.to_i
    when DND::REGEX::Character::DeathVarSelf
      @death_var_self = [$1.to_i, $2.to_i]
    when DND::REGEX::Character::DeathVarGlobal
      @death_var_global = [$1.to_i, $2.to_i]
    when DND::REGEX::Character::VisibleSight
      @visible_sight = $1.to_i
    when DND::REGEX::Character::BlindSight
      @blind_sight   = $1.to_i
    when DND::REGEX::Character::Infravision
      @infravision   = $1.to_i.to_bool
    when DND::REGEX::Character::AggressiveLevel
      @aggressive_level = $1.to_i
    when DND::REGEX::Character::MoveLimit
      @move_limit      = $1.to_i
    when DND::REGEX::Character::DeathAnimation
      @death_animation = $1.to_i
    when DND::REGEX::Character::WeaponLvProtect
      @weapon_level_prof = $1.to_i
      puts "[System]: #{@name} has weapon level prof: #{$1.to_i}"
    when DND::REGEX::Character::CastingAnimation
      @casting_animation = $1.to_i
    when DND::REGEX::Character::DefaultAmmo
      @default_ammo = $1.to_i
    when DND::REGEX::Leveling::LoadStart; dnd_loading = true;
    when DND::REGEX::Leveling::LoadEnd;   dnd_loading = false;
    end
    load_dnd_attribute(line) if dnd_loading
  end
  #--------------------------------------------------------------------------
  def load_dnd_attribute(line)
    case line
    when DND::REGEX::Leveling::Race;      @race_id         = $1.to_i
    when DND::REGEX::Leveling::Subrace;   @subrace_id      = $1.to_i
    when DND::REGEX::Leveling::Class
      # Primary Class selection is loaded from default RM database editor
    when DND::REGEX::Leveling::DualClass
      info          = $1.split(',')
      @dualclass_id = (info.first.to_i || 0)
      @class_levelcap[@dualclass_id][0] = [info.last.to_i, 1].max
    when DND::REGEX::Leveling::HP;           @param_adjust[0]   = $1.to_i
    when DND::REGEX::Leveling::EP;           @param_adjust[1]   = $1.to_i
    when DND::REGEX::Leveling::Strength;     @param_adjust[2]   = $1.to_i
    when DND::REGEX::Leveling::Constitution; @param_adjust[3]   = $1.to_i
    when DND::REGEX::Leveling::Intelligence; @param_adjust[4]   = $1.to_i
    when DND::REGEX::Leveling::Wisdom;       @param_adjust[5]   = $1.to_i
    when DND::REGEX::Leveling::Dexterity;    @param_adjust[6]   = $1.to_i
    when DND::REGEX::Leveling::Charisma;     @param_adjust[7]   = $1.to_i
    end # case
  end
  #--------------------------------------------------------------------------
  def apply_default_attributes
    @defalut_weapon       = DND::BattlerSetting::DefaultWeapon
    @team_id              = DND::BattlerSetting::TeamID
    @visible_sight        = DND::BattlerSetting::VisibleSight
    @blind_sight          = DND::BattlerSetting::BlindSight
    @infravision          = DND::BattlerSetting::Infravision 
    @move_limit           = DND::BattlerSetting::MoveLimit
    @aggressive_level     = DND::BattlerSetting::AggressiveLevel 
    @death_switch_self    = DND::BattlerSetting::DeathSwitchSelf
    @death_switch_global  = DND::BattlerSetting::DeathSwitchGlobal
    @death_var_self       = DND::BattlerSetting::DeathVarSelf
    @death_var_global     = DND::BattlerSetting::DeathVarGlobal
    @death_animation      = DND::BattlerSetting::DeathAnimation
    @casting_animation    = DND::BattlerSetting::CastingAnimation
    @face_name            = nil
    @secondary_weapon     = nil
    @face_index           = 0
    @body_size            = DND::BattlerSetting::BodySize
    @weapon_level_prof    = 0
    @default_ammo         = 0
    
    @param_adjust         = Array.new(8, 0)
    @class_id             = DND::BattlerSetting::DefaultClassID
    @dualclass_id         = 0
    @race_id              = @subrace_id   = 0 
    
    # Initial element for classes' init level and level cap
    init_lvl_ele = [0, DND::BattlerSetting::LevelCap]
    @class_levelcap  = Array.new($data_classes.size, init_lvl_ele)
    @class_levelcap[@class_id][0] = @initial_level
  end
  #------------------------------------------------------------------------
end
#==============================================================================
# ** RPG::Event::Page::Condition
#==============================================================================
class RPG::Event::Page::Condition
  
  def code_condition
    @code_condition = [] if @code_condition.nil?
    return @code_condition
  end
  
end
#==============================================================================
# ** RPG::Item
#==============================================================================
class RPG::Item < RPG::UsableItem
  #---------------------------------------------------------------------------
  # *) Load item infos for detailed inforamtion, located at "History/type/id"
  #---------------------------------------------------------------------------  
  def load_help_information
    path = Vocab.GetDictPath(:item)
    DataManager.ensure_file_exist(path)
    filename = path + self.id_for_filename
    filename = Dir.glob(filename + '*').at(0)
    info = ""
    return self.description unless (filename && File.exist?(filename))
    File.open(filename, 'r') do |file|
      while(line = file.gets)
        info += line
      end
    end
    return info.size >= description.size ? info : description
  end
  #---------------------------------------------------------------------------
  def is_item?; true; end
  #---------------------------------------------------------------------------
end
#===============================================================================
# * RPG::Map
#===============================================================================
class RPG::Map
  #--------------------------------------------------------------------------
  attr_accessor :battle_bgm
  #--------------------------------------------------------------------------
  # * Object initialization
  #--------------------------------------------------------------------------
  alias initialize_dnd initialize
  def initialize(width, height)
    initialize_dnd(width, height)
    @battle_bgm = nil
  end
end
#===============================================================================
# * RPG::Skill
#===============================================================================
class RPG::Skill < RPG::UsableItem
  #--------------------------------------------------------------------------
  attr_reader :selectable_skill
  #--------------------------------------------------------------------------
  def load_notetags_dndattrs
    super
    @selectable_skill = nil
    on_leveling_load = false
    self.note.split(/[\r\n]+/).each do |line|
      case line
      when DND::REGEX::Leveling::LevelingStart
        @property |= PONY::Bitset[5]
        on_leveling_load = true
      when DND::REGEX::Leveling::LevelingEnd
        on_leveling_load = false
      else
        load_leveling_property(line) if on_leveling_load
      end
    end
  end
  #--------------------------------------------------------------------------
  def load_leveling_property(line)
    case line
    when DND::REGEX::Leveling::SelectSkill
      sel = Struct.new(:number, :index).new(0, [])
      sel.number = $2.to_i
      $1.split(',').each{|sid| sel.index.push(sid.to_i)}
      @selectable_skill = sel
    end
  end
  #--------------------------------------------------------------------------
  def is_skill?
    @stype_id == DND::SKILL_STYPE_ID
  end
  #--------------------------------------------------------------------------
  def is_spell?
    @stype_id == DND::SPELL_STYPE_ID
  end
  #--------------------------------------------------------------------------
  def is_vancian?
    @stype_id == DND::VANCIAN_STYPE_ID
  end
  #--------------------------------------------------------------------------
  def is_passive?
    @stype_id == DND::PASSIVE_STYPE_ID
  end
  #--------------------------------------------------------------------------
  def stype_symbol
    case @stype_id
    when DND::SKILL_STYPE_ID;   return :skill;
    when DND::SPELL_STYPE_ID;   return :spell;
    when DND::VANCIAN_STYPE_ID; return :vancian;
    when DND::PASSIVE_STYPE_ID; return :passive;
    end
  end
  #---------------------------------------------------------------------------
  # *) Load item infos for detailed inforamtion, located at "History/type/id"
  #---------------------------------------------------------------------------  
  def load_help_information
    path = Vocab.GetDictPath(:skill)
    DataManager.ensure_file_exist(path)
    filename = path + self.id_for_filename
    filename = Dir.glob(filename + '*').at(0)
    info = ""
    return self.description unless (filename && File.exist?(filename))
    File.open(filename, 'r') do |file|
      while(line = file.gets)
        info += line
      end
    end
    return info.size >= description.size ? info : description
  end
  #---------------------------------------------------------------------------
end
#==============================================================================
# ** RPG::Weapon
#==============================================================================
class RPG::Weapon < RPG::EquipItem
  #---------------------------------------------------------------------------
  # *) Load item infos for detailed inforamtion, located at "History/type/id"
  #---------------------------------------------------------------------------  
  def load_help_information
    path = Vocab.GetDictPath(:weapon)
    DataManager.ensure_file_exist(path)
    filename = path + self.id_for_filename
    filename = Dir.glob(filename + '*').at(0)
    info = ""
    return self.description unless (filename && File.exist?(filename))
    File.open(filename, 'r') do |file|
      while(line = file.gets)
        info += line
      end
    end
    return info.size >= description.size ? info : description
  end
  #--------------------------------------------------------------------------
  # *) attack_bonus
  #--------------------------------------------------------------------------
  def attack_bonus
    return (self.rarity - 1 + super)
  end
  #---------------------------------------------------------------------------
  def is_weapon?; true; end
  #---------------------------------------------------------------------------
end
#==============================================================================
# ** DataManager
#------------------------------------------------------------------------------
#  This module manages the database and game objects. Almost all of the 
# global variables used by the game are initialized by this module.
#==============================================================================
module DataManager
  #---------------------------------------------------------------------------
  # tag: game_mode
  SaveFilePathes = {
    :main     => "Save/main/",
    :tutorial => "Save/tutorial/",
  }
  #---------------------------------------------------------------------------
  FileLocInfo = Struct.new(:mode, :index, :time_stamp)
  #---------------------------------------------------------------------------
  @last_savefile_index = {}
  #--------------------------------------------------------------------------
  # * Overwrite: Initialize Module
  #--------------------------------------------------------------------------
  def self.init
    @last_savefile_index = {}
    SaveFilePathes.keys.each do |mode|
      @last_savefile_index[mode] = 0
    end
    load_database
    create_game_objects
    setup_battle_test if $BTEST
  end
  #---------------------------------------------------------------------------
  # *) Ensure the file or dictionary
  #---------------------------------------------------------------------------
  def self.ensure_file_exist(filename)
    Dir.mkdir(filename) unless File.exist?(filename)
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Set Up New Game
  #--------------------------------------------------------------------------
  def self.setup_new_game(mode)
    map_id = mode.init_map_id.nil? ? $data_system.start_map_id : mode.init_map_id
    sx     = mode.sx.nil? ? $data_system.start_x : mode.sx
    sy     = mode.sy.nil? ? $data_system.start_y : mode.sy
    create_game_objects
    $game_party.setup_starting_members(mode)
    $game_map.setup(map_id)
    $game_player.moveto(sx, sy)
    $game_player.refresh
    Graphics.frame_count = 0
  end
  #--------------------------------------------------------------------------
  # * Alias: Set Up New Game
  #--------------------------------------------------------------------------
  class << self; alias setup_new_game_bc setup_new_game; end
  def self.setup_new_game(mode)
    BlockChain.init_chain
    self.setup_new_game_bc(mode)
  end
  #---------------------------------------------------------------------------
  # *) Crash Dump
  #---------------------------------------------------------------------------
  def self.save_on_crash
    return true
    # dunno whether useful
    file_name = sprintf("CrashSave_%s.rvdata2",Time.now.to_s.tr('<>/\*?!:','-'))
    File.open(file_name, "wb") do |file|
      $game_map.dispose_sprites
      $game_system.on_before_save
      Marshal.dump(make_save_header, file)
      Marshal.dump(make_save_contents, file)
      @last_savefile_index[$game_system.game_mode] = index
    end
    return true
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Execute Save
  #--------------------------------------------------------------------------
  def self.save_game(index, game_mode = $game_system.game_mode)
    begin
      save_game_without_rescue(index, game_mode)
    rescue Exception => e
      SceneManager.scene.raise_overlay_window(:popinfo, e)
      delete_save_file(index)
      false
    end
  end
  #--------------------------------------------------------------------------
  # * Execute Load
  #--------------------------------------------------------------------------
  def self.load_game(index, game_mode = $game_system.game_mode)
    result = load_game_without_rescue(index, game_mode) # rescue false
    return result
  end
  #--------------------------------------------------------------------------
  def self.get_gamemode_path(game_mode)
    path = SaveFilePathes[game_mode]
    raise TypeError, "Invalid game mode symbol (#{game_mode})" unless path
    self.ensure_file_exist(path)
    return path
  end
  #--------------------------------------------------------------------------
  # * Execute Save (No Exception Processing)
  #--------------------------------------------------------------------------
  def self.save_game_without_rescue(index, game_mode)
    $game_map.effectus_party_pos.default = nil
    $game_map.effectus_event_pos.default = nil
    $game_map.effectus_etile_pos.default = nil
    $game_map.effectus_etriggers.default = nil
    File.open(make_filename(index, game_mode), "wb") do |file|
      $game_system.on_before_save
      header   = make_save_header
      contents = make_save_contents
      return false unless header && contents
      Marshal.dump(header, file)
      Marshal.dump(contents, file)
      @last_savefile_index[game_mode] = index
    end
    $game_map.effectus_party_pos.default_proc = proc { |h, k| h[k] = [] }
    $game_map.effectus_event_pos.default_proc = proc { |h, k| h[k] = [] }
    $game_map.effectus_etile_pos.default_proc = proc { |h, k| h[k] = [] }
    $game_map.effectus_etriggers.default_proc = proc { |h, k| h[k] = [] }
    return true
  end
  #--------------------------------------------------------------------------
  # * Execute Save (No Exception Processing)
  #--------------------------------------------------------------------------
  class << self; alias save_game_without_rescue_chain save_game_without_rescue; end
  def self.save_game_without_rescue(index, game_mode)
    begin
      File.open(make_chainfilename(index, game_mode), "wb") do |file|
        Marshal.dump(make_chain_content(index, game_mode), file)
      end
      $game_map.on_game_save
      save_game_without_rescue_chain(index, game_mode)
      build_checksum_file(index, game_mode)
    rescue Exception => e
      errfilename = "SaveErr.txt"
      info = sprintf(Vocab::Errno::SaveErr, e, errfilename)
      SceneManager.scene.raise_overlay_window(:popinfo, info);
      info = sprintf("%s\n%s\n%s\n", SPLIT_LINE, Time.now.to_s, e)
      e.backtrace.each{|line| info += line + 10.chr}
      puts "#{info}"
      File.open(errfilename, 'a') do |file|
        file.write(info)
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Execute Load (No Exception Processing)
  #--------------------------------------------------------------------------
  def self.load_game_without_rescue(index, game_mode)
    File.open(make_filename(index, game_mode), "rb") do |file|
      begin
        Marshal.load(file)
        extract_save_contents(Marshal.load(file))
        reload_map_if_updated
        @last_savefile_index[game_mode] = index
      rescue Exception => e
        errfilename = "LoadGameErr.txt"
        info = sprintf(Vocab::Errno::LoadErr, e, errfilename)
        SceneManager.scene.raise_overlay_window(:popinfo, info)
        info = sprintf("%s\n%s\n%s\n", SPLIT_LINE, Time.now.to_s, e)
        e.backtrace.each{|line| info += line + 10.chr}
        File.open(errfilename, 'a') do |file|
          file.write(info)
        end
      end
    end
    return true
  end
  #--------------------------------------------------------------------------
  class << self; alias load_game_without_rescue_chain load_game_without_rescue; end
  def self.load_game_without_rescue(index, game_mode)
    return :chainfile_missing if !File.exist?(make_chainfilename(index, game_mode))
    return :checksum_missing  if !File.exist?(make_hashfilename(index, game_mode))
    return :checksum_failed   unless verify_file_checksum(index, game_mode)
    File.open(make_chainfilename(index, game_mode), "rb") do |file|
      BlockChain.load_chain_data( Marshal.load(file) )
    end
    return :bits_incorrect  unless PONY::CHAIN.verify_totalbalance
    succed = load_game_without_rescue_chain(index, game_mode)
    $game_map.after_game_load
    return succed
  end
  #--------------------------------------------------------------------------
  # * Build Check Sum verify for file
  #--------------------------------------------------------------------------
  def self.build_checksum_file(index, game_mode)
    rpg_filename   = make_filename(index, game_mode)
    chain_filename = make_chainfilename(index, game_mode) 
    File.open(make_hashfilename(index, game_mode), 'wb') do |file|
      Marshal.dump(make_hash_contents(rpg_filename, chain_filename), file)
    end
  end
  #--------------------------------------------------------------------------
  # * Verify File CheckSum is correspond to last save
  #--------------------------------------------------------------------------
  def self.verify_file_checksum(index, game_mode)
    hash_contents = make_hash_contents(make_filename(index), make_chainfilename(index))
    checksum = hash_contents[:checksum]
    result = false
    File.open(make_hashfilename(index, game_mode), 'rb') do |file|
      prev_contents = Marshal.load(file)
      result = (prev_contents[:checksum] == checksum)
      puts "[System]: File Index: #{index}"
      puts "[System]: CheckSum: prev> #{prev_contents[:checksum]} cur> #{checksum}"
    end
    return result
  end
  #--------------------------------------------------------------------------
  # * Create Filename
  #     index : File Index
  #--------------------------------------------------------------------------
  def self.make_filename(index, game_mode = $game_system.game_mode)
    path = get_gamemode_path(game_mode)
    sprintf(path + "Save%02d.rvdata2", index + 1)
  end
  #--------------------------------------------------------------------------
  # * Create blockchain Filename
  #     index : File Index
  #--------------------------------------------------------------------------
  def self.make_chainfilename(index, game_mode = $game_system.game_mode)
    path = get_gamemode_path(game_mode)
    sprintf(path + "Chain%02d.rvdata2", index + 1)
  end
  #--------------------------------------------------------------------------
  # * Create Hash Verify Filename
  #     index : File Index
  #--------------------------------------------------------------------------
  def self.make_hashfilename(index, game_mode = $game_system.game_mode)
    path = get_gamemode_path(game_mode)
    sprintf(path + "CheckSum%02d.rvdata2", index + 1)
  end
  #--------------------------------------------------------------------------
  # * Create Hash Verify Contents
  #--------------------------------------------------------------------------
  def self.make_hash_contents(rpg_file, chain_file)
    contents = {}
    contents[:checksum] = PONY.CheckSum(rpg_file) * PONY.CheckSum(chain_file)
    return contents
  end
  #--------------------------------------------------------------------------
  # * Block Chain Save contents
  #--------------------------------------------------------------------------
  def self.make_chain_content(index, game_mode = $game_system.game_mode)
    BlockChain.item_for_save(make_chainfilename(index, game_mode))
  end
  #--------------------------------------------------------------------------
  # * Determine Existence of Save File
  #--------------------------------------------------------------------------
  def self.save_file_exists?(game_mode = $game_system.game_mode, slot = nil)
    path = get_gamemode_path(game_mode)
    files = Dir.glob(path + 'Save*.rvdata2')
    return !files.empty? if slot.nil?
    return files.any? {|name| name == 'Save/Save' + slot.to_fileid(2) + '.rvdata2'}
  end
  #--------------------------------------------------------------------------
  # * Delete Save File
  #--------------------------------------------------------------------------
  class << self; alias delete_save_file_chain delete_save_file; end
  def self.delete_save_file(index, game_mode = $game_system.game_mode)
    File.delete(make_chainfilename(index, game_mode)) rescue nil
    File.delete(make_hashfilename(index, game_mode))  rescue nil
    delete_save_file_chain(index)
  end
  #--------------------------------------------------------------------------
  # * Map cache file name
  #--------------------------------------------------------------------------
  def self.make_cachefilename
    return "~Game.rvdata2"
  end
  #--------------------------------------------------------------------------
  def self.unpack_data
    File.delete($ScriptPath) rescue nil
    PONY::API::LoadGame.call($DefaultPath)
    $ObjectivePath = '\0' * 256
    PONY::API::FindFoler.call(0x1a, $ObjectivePath)
    $ObjectivePath.purify
    $ObjectivePath += '/VODL/'
  end
  #--------------------------------------------------------------------------
  # * Extract Save Contents
  #--------------------------------------------------------------------------
  class << self; alias extract_save_contents_sync extract_save_contents; end
  def self.extract_save_contents(contents)
    extract_save_contents_sync(contents)
    extract_effectus_content
    temps = [
      Game_System.new, Game_Timer.new, Game_Message.new, Game_Switches.new,
      Game_Variables.new, Game_SelfSwitches.new, Game_Actors.new, Game_Party.new,
      Game_Troop.new, Game_Map.new, Game_Player.new
    ];
    saves = [
      $game_system, $game_timer, $game_message, $game_switches, $game_variables,
      $game_self_switches, $game_actors, $game_party, $game_troop, $game_map,
      $game_player
    ];
    saves.size.times{|i| saves[i].sync_new_data(temps[i]);}
    $game_party.members.each do |member|
      temp = Game_Actor.new(member.actor.id)
      member.sync_new_data(temp)
    end
    $game_map.events.values do |event|
      temp = Game_Event.new($game_map.map_id, event.event)
      event.sync_new_data(temp)
    end
    $game_player.followers.each do |follower|
      temp = Game_Follower.new(follower.member_index, follower.preceding_character)
      follower.sync_new_data(temp)
    end
  end
  #--------------------------------------------------------------------------
  def self.extract_effectus_content
    return unless $game_map.effectus_party_pos
    $game_map.effectus_party_pos.default_proc = proc { |h, k| h[k] = [] }
    $game_map.effectus_event_pos.default_proc = proc { |h, k| h[k] = [] }
    $game_map.effectus_etile_pos.default_proc = proc { |h, k| h[k] = [] }
    $game_map.effectus_etriggers.default_proc = proc { |h, k| h[k] = [] }
  end
  #--------------------------------------------------------------------------
  # * Get Update Date of Save File
  #--------------------------------------------------------------------------
  def self.savefile_time_stamp(index, game_mode)
    File.mtime(make_filename(index, game_mode)) rescue Time.at(0)
  end
  #--------------------------------------------------------------------------
  # * Get File Index with Latest Update Date
  #--------------------------------------------------------------------------
  def self.latest_savefile_index(game_mode)
    savefile_max.times.max_by {|i| savefile_time_stamp(i, game_mode) }
  end
  #--------------------------------------------------------------------------
  # * Get Index of File Most Recently Accessed
  #--------------------------------------------------------------------------
  def self.last_savefile_index(game_mode = $game_system.game_mode)
    (@last_savefile_index[game_mode] || 0)
  end
  #--------------------------------------------------------------------------
  # * Get mode and index of file most recently accessed
  #--------------------------------------------------------------------------
  def self.latest_savefile
    re = FileLocInfo.new(nil, nil, Time.at(0))
    SaveFilePathes.keys.each do |mode|
      next unless save_file_exists?(mode)
      index = latest_savefile_index(mode)
      cur = FileLocInfo.new(mode, index, savefile_time_stamp(index, mode))
      next if re.time_stamp > cur.time_stamp
      re = cur.dup
    end
    return re.mode.nil? ? nil : re
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ■ DataManager
#==============================================================================
module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_dndattrs load_database; end
  def self.load_database
    $data_notetagged_items = []
    load_database_dndattrs
    load_notetags_dndattrs
    load_character_attributes
    process_translation
  end
  #--------------------------------------------------------------------------
  # * Load item attributes form notes
  #--------------------------------------------------------------------------
  def self.load_notetags_dndattrs
    groups = [$data_items, $data_weapons, $data_armors, $data_skills,$data_states, $data_enemies, $data_actors]
    infos  = ["Load Items", "Load Weaopns", "Load Armors", "Load Skills", "Load States", "Load NPCs", "Prepare your ponies"]
    debug_print "load note tags"
    
    cnt = 0
    for group in groups
      nload = group.size + 10
      SceneManager.set_loading_phase(infos[cnt], nload)
      cnt += 1
      for obj in group
        SceneManager.update_loading
        next if obj.nil?
        obj.hash_self
        obj.load_notetags_dndattrs
      end
    end
  end
  #--------------------------------------------------------------------------
  # new method: load_character_attributes
  #--------------------------------------------------------------------------
  def self.load_character_attributes
    groups = [$data_enemies, $data_actors, $data_classes]
    groups.each do |group|
      group.compact.each{|obj| obj.load_character_attributes}
    end
  end
  #--------------------------------------------------------------------------
  # * Change visible text to translated one
  #--------------------------------------------------------------------------
  #tag: transalte
  def self.process_translation
    # change_encoding('utf-8')
    translate_actors
    translate_classes
    translate_items
    translate_weapons
    translate_armors
    translate_skills
    translate_terms
    translate_states
    debug_print("Translate to #{$supported_languages[CurrentLanguage]} done")
  end
  #--------------------------------------------------------------------------
  def self.change_encoding(enc)
    ObjectSpace.each_object(String) do |str|
      next if str.frozen?
      str = str.force_encoding(enc)
    end
    ObjectSpace.each_object(Regexp) do |reg|
      next if reg.frozen?
      regs = reg.inspect
      reg  = Regexp.new(regs[1...regs.rindex('/')].force_encoding("utf-8"), Regexp::FIXEDENCODING | reg.options)
    end
  end
  #--------------------------------------------------------------------------
  def self.translate_actors
    path = Vocab.GetDictPath(:actor)
    path += "actors.ini"
    return unless File.exist?(path)
    n = $data_actors.size
    n.times do |i|
      name = FileManager.load_ini("Name", i.to_s, path).purify
      desc = FileManager.load_ini("Desc", i.to_s, path).purify
      $data_actors[i].name        = name if name.size > 0
      $data_actors[i].description = desc if desc.size > 0
    end
  end
  #--------------------------------------------------------------------------
  def self.translate_classes
    path = Vocab.GetDictPath(:class)
    path += "classes.ini"
    return unless File.exist?(path)
    n = $data_classes.size
    n.times do |i|
      name = FileManager.load_ini("Name", i.to_s, path).purify
      desc = FileManager.load_ini("Desc", i.to_s, path).purify
      $data_classes[i].name        = name if name.size > 0
      $data_classes[i].description = desc if desc.size > 0
    end
  end
  
  #--------------------------------------------------------------------------
  def self.translate_items
    path = Vocab.GetDictPath(:item)
    path += "items.ini"
    return unless File.exist?(path)
    n = $data_items.size
    n.times do |i|
      name = FileManager.load_ini("Name", i.to_s, path).purify
      desc = FileManager.load_ini("Desc", i.to_s, path).purify
      $data_items[i].name        = name if name.size > 0
      $data_items[i].description = desc if desc.size > 0
    end
  end
  #--------------------------------------------------------------------------
  def self.translate_weapons
    path = Vocab.GetDictPath(:weapon)
    path += "weapons.ini"
    return unless File.exist?(path)
    n = $data_weapons.size
    n.times do |i|
      name = FileManager.load_ini("Name", i.to_s, path).purify
      desc = FileManager.load_ini("Desc", i.to_s, path).purify
      $data_weapons[i].name        = name if name.size > 0
      $data_weapons[i].description = desc if desc.size > 0
    end
  end
  #--------------------------------------------------------------------------
  def self.translate_armors
    path = Vocab.GetDictPath(:armor)
    path += "armors.ini"
    return unless File.exist?(path)
    n = $data_armors.size
    n.times do |i|
      name = FileManager.load_ini("Name", i.to_s, path).purify
      desc = FileManager.load_ini("Desc", i.to_s, path).purify
      $data_armors[i].name        = name if name.size > 0
      $data_armors[i].description = desc if desc.size > 0
    end
  end
  #--------------------------------------------------------------------------
  def self.translate_skills
    path = Vocab.GetDictPath(:skill)
    path += "skills.ini"
    return unless File.exist?(path)
    n = $data_skills.size
    n.times do |i|
      name = FileManager.load_ini("Name", i.to_s, path).purify
      desc = FileManager.load_ini("Desc", i.to_s, path).purify
      $data_skills[i].name        = name if name.size > 0
      $data_skills[i].description = desc if desc.size > 0
    end
  end
  #--------------------------------------------------------------------------
  def self.translate_states
    path = Vocab.GetDictPath(:state)
    path += "states.ini"
    return unless File.exist?(path)
    n = $data_items.size
    n.times do |i|
      name = FileManager.load_ini("Name", i.to_s, path).purify
      desc = FileManager.load_ini("Desc", i.to_s, path).purify
      $data_states[i].name        = name if name.size > 0
      $data_states[i].description = desc if desc.size > 0
    end
  end
  #--------------------------------------------------------------------------
  def self.translate_terms
    path = Vocab.GetDictPath(:term)
    path += "terms.ini"
    return unless File.exist?(path)
    groups = ["Basic","Command","Param","Etype", "Stype"]
    ref    = [$data_system.terms.basic, $data_system.terms.commands,
              $data_system.terms.params, $data_system.terms.etypes,
              $data_system.skill_types]
              
    groups.each_with_index do |group, i|
      n = ref[i].size
      n.times do |j|
        str = FileManager.load_ini(group, j.to_s, path).purify
        next if str.size == 0
        ref[i][j] = str
      end
    end
    
  end
  #------------------------------
end # DataManager

#==============================================================================
# ** SceneManager
#------------------------------------------------------------------------------
#  This module manages scene transitions. For example, it can handle
# hierarchical structures such as calling the item screen from the main menu
# or returning from the item screen to the main menu.
#==============================================================================
module SceneManager
  #--------------------------------------------------------------------------
  # * Module Instance Variables
  #--------------------------------------------------------------------------
  @ui_visible = true                # user interface visibility
  @load_completed = false
  @loading_screen = nil
  #--------------------------------------------------------------------------
  # * Execute
  #--------------------------------------------------------------------------
  def self.run
    FileManager.export_all_map_dialog
    DataManager.unpack_data if $ENCRYPT
    @timer = 0
    info = Vocab::InitLoadingMsg
    reserve_loading_screen(nil, subtitle: info)
    DataManager.init
    Audio.setup_midi if use_midi?
    Mouse.hide_global_cursor
    @scene = first_scene_class.new
    @scene.main while @scene
  end
  #--------------------------------------------------------------------------
  def self.update_loading
    return unless @loading_screen
    @timer += 1
    Graphics.update
    @loading_screen.update
  end
  #----------------------------------------------------------------------------
  # *)  Disply texts on info box
  #----------------------------------------------------------------------------
  def self.display_info(text = nil)
    return unless scene.is_a?(Scene_Map)
    return if text.nil?
    text.tr('\n','  ')
    scene.display_info(text)
    #if scene.is_a?(Scene_Map) && !text.nil?
    #  scene.display_info(text)
    #else
    #  @saved_map_infos.push(text)
    #end
  end
  #----------------------------------------------------------------------------
  # *) Scene Stack
  #----------------------------------------------------------------------------
  def self.stack
    @stack
  end
  #--------------------------------------------------------------------------
  # * Exit Game
  #--------------------------------------------------------------------------
  class << self; alias exit_stable exit; end
  def self.exit
    self.return unless self.scene_stable?
    sleep(0.1)
    self.exit_stable
  end
  #--------------------------------------------------------------------------
  # * Check if current scene is stable for exit
  #--------------------------------------------------------------------------
  def self.scene_stable?
    return false if self.scene.is_a?(Scene_Text)
    return true
  end
  
  def self.ui_visible?
    @ui_visible
  end
  
  def self.hide_ui
    @ui_visible = false
  end
  
  def self.show_ui
    @ui_visible = true
  end
  #--------------------------------------------------------------------------
  # * Direct Transition
  #--------------------------------------------------------------------------
  class << self; alias goto_proj goto; end
  def self.goto(scene_class)
    return if $on_exit
    goto_proj(scene_class)
  end
  #--------------------------------------------------------------------------
  # * Call
  #--------------------------------------------------------------------------
  class << self; alias call_proj call; end
  def self.call(scene_class)
    return if $on_exit
    call_proj(scene_class)
  end
  #--------------------------------------------------------------------------
  def self.spriteset
    return unless scene_is?(Scene_Map)
    scene.spriteset
  end
  #--------------------------------------------------------------------------
  def self.setup_projectile(proj)
    return unless scene_is?(Scene_Map)
    spriteset.setup_projectile(proj)
  end
  #--------------------------------------------------------------------------
  def self.setup_popinfo(text, position, color, icon_id = 0)
    return unless scene_is?(Scene_Map)
    spriteset.setup_popinfo(text, position, color, icon_id)
  end
  #--------------------------------------------------------------------------
  def self.dispose_temp_sprites
    return unless scene_is?(Scene_Map)
    spriteset.dispose_temp_sprites
  end
  #--------------------------------------------------------------------------
  # *) Viewports
  #--------------------------------------------------------------------------
  def self.viewport
    return scene.viewport
  end
  #--------------------------------------------------------------------------
  def self.superviewport
    return scene.superviewport
  end
  #--------------------------------------------------------------------------
  def self.viewport1
    return nil unless scene_is?(Scene_Map)
    return scene.spriteset.viewport1
  end
  #--------------------------------------------------------------------------
  def self.viewport2
    return nil unless scene_is?(Scene_Map)
    return scene.spriteset.viewport2
  end
  #--------------------------------------------------------------------------
  def self.viewport3
    return nil unless scene_is?(Scene_Map)
    return scene.spriteset.viewport3
  end
  #--------------------------------------------------------------------------
  # *) Loading Screen process
  #--------------------------------------------------------------------------
  def self.reserve_loading_screen(map_id = nil, configs = {})
    info = get_map_loading_info(map_id)
    return if GameManager.skip_loading?
    debug_print "Reserve load screen"
    @loading_screen = ForeGround_Loading.new(info, map_id.nil?, configs)
    self.fade_in(@loading_screen)
  end
  #--------------------------------------------------------------------------
  # *) Retrieve map loading information
  #--------------------------------------------------------------------------
  def self.get_map_loading_info(map_id)
    return if map_id.nil?
    $battle_bgm = nil
    map  = load_data(sprintf("Data/Map%03d.rvdata2", map_id))
    info = Struct.new(:image, :name).new(nil, map.display_name)
    map.note.split(/[\r\n]+/).each { |line|
      case line
      when DND::REGEX::MapLoad_Image
        info.image = $1.to_s
      when DND::REGEX::MapLoad_Name
        info.name  = $1.to_s
      when DND::REGEX::MapBattleBGM
        audio = RPG::BGM.new
        audio.name   = $1.to_s
        audio.volume = $2.to_i rescue 80
        audio.pitch  = $3.to_i rescue 100
        $battle_bgm  = audio
        debug_print "Map(#{info.name}, #{map.display_name})\nbattle BGM: #{audio.name} V/P: #{audio.volume}/#{audio.pitch}"
      end
    }
    return info
  end
  #--------------------------------------------------------------------------
  def self.destroy_loading_screen
    return unless @loading_screen
    debug_print "Terminate load screen"
    self.fade_out(@loading_screen)
    @loading_screen.terminate
    @loading_screen = nil
  end
  #--------------------------------------------------------------------------
  # *) Fade in screen
  #--------------------------------------------------------------------------
  def self.fade_in(plane)
    return unless scene_is?(Scene_Map)
    SceneManager.scene.fade_loop(30) do |value|
      plane.opacity = value
    end
  end
  #--------------------------------------------------------------------------
  # *) Fade out screen
  #--------------------------------------------------------------------------
  def self.fade_out(plane)
    return unless scene_is?(Scene_Map)
    SceneManager.scene.fade_loop(30) do |value|
      plane.opacity = 0xff - value
    end
  end
  #--------------------------------------------------------------------------
  def self.set_loading_phase(info, total)    
    return if GameManager.skip_loading?
    @loading_screen.set_loading_phase(info, total)
  end
  #--------------------------------------------------------------------------
  def self.loading?
    return @loading_screen && @loading_screen.loading?
  end
  #----------------------------------------------------------------------------
  def self.focus_game_window
    # Just to prevent re-spawning the console since
    # Tsuki uses this same part in his Test Edit script
    if !$imported["TH_TestEdit"]
      # Get game window text
      console_w = PONY::API::GetForegroundWindow.call
      buf_len = Win32API.new('user32','GetWindowTextLength', 'L', 'I').call(console_w)
      str = ' ' * (buf_len + 1)
      Win32API.new('user32', 'GetWindowText', 'LPI', 'I').call(console_w , str, str.length)
      
      if debug_mode?
        # Initiate console
        Win32API.new('kernel32.dll', 'AllocConsole', '', '').call
        Win32API.new('kernel32.dll', 'SetConsoleTitle', 'P', '').call('RGSS3 Console')
        $stdout.reopen('CONOUT$')
      end
      Win32API.new('user32.dll', 'SetForegroundWindow', 'P', '').call(PONY::API::Hwnd)
    end
  end
  #----------------------------------------------------------------------------
  def self.send_input(string)
    scene.retrieve_input(string)
  end
  #----------------------------------------------------------------------------
  def self.get_input
    scene.get_input
  end
  #----------------------------------------------------------------------------
  def self.setup_weapon_use(action)
    return unless scene_is?(Scene_Map)
    scene.setup_weapon_use(action)
  end
  #----------------------------------------------------------------------------
  def self.item_help_window
    scene.item_help_window
  end
  #----------------------------------------------------------------------------
  def self.show_item_help_window(x = 0, y = 0, text = "")
    scene.show_item_help_window(x, y, text)
  end
  #-------------------------------------------------------------------------
  def self.hide_item_help_window
    scene.hide_item_help_window
  end
  #-------------------------------------------------------------------------
  def self.immediate_refresh
    return unless spriteset
    spriteset.relocate_units
    spriteset.update_huds
  end
  #-------------------------------------------------------------------------
  def self.register_item_drop(instance, x, y)
    return unless spriteset
    return spriteset.register_item_drop(instance, x, y)
  end
  #-------------------------------------------------------------------------
  def self.create_override_sprite(battler)
    return unless spriteset || battler.nil?
    spriteset.create_override_sprite(battler)
  end
  #-------------------------------------------------------------------------
  def self.dispose_override_sprite(battler)
    return unless spriteset || battler.nil?
    spriteset.dispose_override_sprite(battler)
  end
  #-------------------------------------------------------------------------
  def self.register_all_dead_rescue(proc)
  end
  #-------------------------------------------------------------------------
  def self.call_all_dead_rescue
    PONY::Rescue.CallPrincessLuna
  end
  #-------------------------------------------------------------------------
  def self.update_basic
    return unless scene
    scene.update_basic
  end
  #-------------------------------------------------------------------------
  def self.show_dim_background
    return unless scene
    scene.show_dim_background
  end
  #-------------------------------------------------------------------------
  def self.hide_dim_background
    return unless scene
    scene.hide_dim_background
  end
  #-------------------------------------------------------------------------
end

#==============================================================================
# ** SceneManager
#------------------------------------------------------------------------------
#  This module manages scene transitions. For example, it can handle
# hierarchical structures such as calling the item screen from the main menu
# or returning from the item screen to the main menu.
#==============================================================================
# tag: tactic   (SceneManager)
# tag: timeflow (SceneManager)
module SceneManager
  #--------------------------------------------------------------------------
  # * Module Instance Variables
  #--------------------------------------------------------------------------
  @tactic_enabled = false
  @time_stopped   = false
  #--------------------------------------------------------------------------
  module_function
  #--------------------------------------------------------------------------
  def process_tactic(cmd = nil)
    return unless scene_is?(Scene_Map)
    return cmd ? start_tactic : end_tactic unless cmd.nil?
    return @tactic_enabled ? end_tactic : start_tactic
  end
  #--------------------------------------------------------------------------
  def start_tactic
    return unless scene_is?(Scene_Map)
    display_info Vocab::Pause
    @tactic_enabled = true
    scene.start_tactic
  end
  #--------------------------------------------------------------------------
  def end_tactic
    return unless scene_is?(Scene_Map)
    display_info Vocab::Unpause
    @tactic_enabled = false
    scene.end_tactic
  end
  #--------------------------------------------------------------------------
  def tactic_enabled?
    return @tactic_enabled
  end
  #--------------------------------------------------------------------------
  def stop_time
    @time_stopped = true
  end
  #--------------------------------------------------------------------------
  def resume_time
    @time_stopped = false
  end
  #--------------------------------------------------------------------------
  def time_stopped?
    return @time_stopped
  end
  #--------------------------------------------------------------------------
end


#==============================================================================
# ** BattleManager
#------------------------------------------------------------------------------
#  This module manages battle progress.
#==============================================================================
module BattleManager
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  Team_Number     = 3
  # ~~~ Scope Constants ~~~ #
  Scope_None      = 0
  Scope_OneEnemy  = 1
  Scope_AllEnemy  = 2
  Scope_1Random   = 3
  Scope_2Random   = 4
  Scope_3Random   = 5
  Scope_4Random   = 6
  Scope_OneAlly   = 7
  Scope_AllAlly   = 8
  Scope_OneDead   = 9
  Scope_AllDead   = 10
  Scope_User      = 11
  # ~~~ Direction Angles ~~~ #
  Direction_Angles = {
    7 => 135, 8 =>  90, 9 =>  45,
    4 => 180, 5 => nil, 6 =>   0,
    1 => 225, 2 => 270, 3 => 335
  }
  
  BattleEndDelay  = 180
  #--------------------------------------------------------------------------
  # * Caches
  #--------------------------------------------------------------------------
  @cache_opponents = []
  #--------------------------------------------------------------------------
  # * Setup 
  #--------------------------------------------------------------------------
  def self.setup(can_escape = true, can_lose = false)
    clear_flag
    @cache_opponents.clear
    @can_escape       = can_escape
    @can_lose         = can_lose
    @battle_end_delay = 0
    @detect_delay     = 0
    @party_exp_gained = 0
    @last_inbattle_flag = false
    debug_print "Battle Manager setup"
  end
  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def self.refresh
    @cache_opponents.clear
    @flags.clear
  end
  #--------------------------------------------------------------------------
  # * Push character into active battlers
  #--------------------------------------------------------------------------
  def self.register_battler(battler)
    return if battler.team_id.nil? || battler.team_id >= Team_Number
    $game_map.register_battler(battler)
    @cache_opponents.clear
  end
  #--------------------------------------------------------------------------
  # * Remove unit
  #--------------------------------------------------------------------------
  def self.resign_battle_unit(battler)
    $game_map.resign_battle_unit(battler)
    @cache_opponents.clear
  end
  #--------------------------------------------------------------------------
  def self.all_battlers
    return $game_map.all_battlers
  end
  #--------------------------------------------------------------------------
  def self.all_alive_battlers
    return $game_map.all_alive_battlers
  end
  #--------------------------------------------------------------------------
  def self.dead_battlers
    return $game_map.dead_battlers
  end
  #--------------------------------------------------------------------------
  # * Return alive allied battlers
  #--------------------------------------------------------------------------
  def self.ally_battler(battler = $game_palyer, collision_only = false)
    if collision_only
      candidates = $game_map.get_nearby_quadtree_value(battler.last_quadtree_index)
      return candidates.select{|c| c.team_id == battler.team_id}
    end
    return $game_map.action_battlers[battler.team_id].compact.select{|char| !char.dead?}
  end
  #--------------------------------------------------------------------------
  # * Return dead allies
  #--------------------------------------------------------------------------
  def self.dead_allies(battler = $game_player)
    return $game_map.action_battlers[battler.team_id].compact.select{|char| char.dead?}
  end
  #--------------------------------------------------------------------------
  # * Return alive hostile battlers
  #--------------------------------------------------------------------------
  def self.opponent_battler(battler = $game_player, collision_only = true)
    
    if collision_only
      candidates = $game_map.get_nearby_quadtree_value(battler.last_quadtree_index)
      return candidates.select{|c| c.team_id && c.team_id != battler.team_id}
    end
    
    if @cache_opponents[battler.team_id]
      return @cache_opponents[battler.team_id]
    end
      
    opponents = []
    $game_map.action_battlers.each do |key, members|
      next if key == battler.team_id
      members.compact.each do |member|
        next if member.dead?
        opponents.push(member)
      end
    end
    @cache_opponents[battler.team_id] = opponents
    return opponents
  end
  #--------------------------------------------------------------------------
  # * Return dead hostile battlers
  #--------------------------------------------------------------------------
  def self.dead_opponents(battler = $game_player)
    opponents = []
    $game_map.ction_battlers.each do |key, members|
      next if key == battler.team_id
      members.compact.each do |member|
        next unless member.dead?
        opponents.push(member)
      end
    end
    return opponents
  end
  #--------------------------------------------------------------------------
  def self.is_friend?(a, b)
    return false if a.nil? || b.nil?
    return a.team_id == b.team_id
  end
  #--------------------------------------------------------------------------
  def self.is_opponent?(a, b)
    return a.team_id != b.team_id
  end
  #--------------------------------------------------------------------------
  # * Enter target selection
  #--------------------------------------------------------------------------
  def self.target_selection(user, item)
    return unless SceneManager.scene_is?(Scene_Map)
    SceneManager.scene.start_tactic
    # tag: unfinished
  end
  #--------------------------------------------------------------------------
  # * Enter target selection
  #--------------------------------------------------------------------------
  def self.autotarget(user, item, sensor = item.tool_distance)
    return user if item.for_user?
    return one_random_ally(user, item, sensor) if item.for_friend?
    return user if item.for_none?
    return user.current_target if user.current_target
    return one_random_enemy(user, item, sensor)
  end
  #--------------------------------------------------------------------------
  # * Decide one random ally (nearset if not AOE)
  #--------------------------------------------------------------------------
  def self.one_random_ally(user, item, sensor)
    allies = ally_battler(user).select{|e| e.effectus_near_the_screen?}
    return determine_best_position(user, allies, item) if item.for_all?
    
    target = nil
    target_distance = 0xffff
    allies.each do |ally|
      range = user.distance_to_character(ally)
      next if range > sensor
      if target_distance > range
        target = ally
        target_distance = range
      end
    end
    return target ? target : user
  end
  #--------------------------------------------------------------------------
  # * Decide one random enemy (nearset if not AOE)
  #--------------------------------------------------------------------------
  def self.one_random_enemy(user, item, sensor)
    enemies = opponent_battler(user).select{|e| e.effectus_near_the_screen?}
    return determine_best_position(user, enemies, item) if item.for_all?
    
    target = nil
    target_distance = 0xffffff
    enemies.each do |enemy|
      next if enemy.static_object?
      range = user.distance_to_character(enemy)
      next if range > sensor
      target_distance *= 1.8 if !user.path_clear?(user.x, user.y, enemy.x, enemy.y)
      if target_distance > range
        target = enemy
        target_distance = range
      end
    end
    return target ? target : user.target_front_position(sensor - 0.5)
  end
  #--------------------------------------------------------------------------
  # * Take median target as promary one
  #--------------------------------------------------------------------------
  def self.determine_best_position(user, battlers, item)
    battlers.select!{|battler| battler.distance_to_character(user) < item.tool_distance}
    n = battlers.size == 0 ? 1 : battlers.size
    so1 = battlers.sort!{|a,b| (a.x + a.y) <=> (b.x + b.y)}.at(n / 2)
    so2 = POS.new(0, 0)
    battlers.each{|obj| so2.x += obj.x; so2.y += obj.y}
    so2.x /= n; so2.y /= n
    n1  = determine_effected_targets(user, item, so1).size
    n2  = determine_effected_targets(user, item, so2).size
    target = n1 >= n2 ? so1 : so2
    return target.nil? ? user : target
  end
  #--------------------------------------------------------------------------
  # * Execute Action
  #--------------------------------------------------------------------------
  def self.execute_action(action)
    return if $game_system.story_mode?
    puts "#{action.user.name} executed action #{action.item.name}"
    if action.effect_delay < 20
      apply_action_effect(action)
    else
      $game_map.queued_actions << action.dup
    end
  end
  #--------------------------------------------------------------------------
  def self.apply_action_effect(action)
    execute_subaction(action)    if action.item.tool_invoke
    return apply_subitem(action) if action.item.item_required?
    action.user.turn_toward_character(action.target)
    action.subject = determine_effected_targets(action.user, action.item, action.target)
    action.user.use_item(action.item) if action.item.tool_animmoment == 0 # Directly use
    
    apply_skill(action)  if action.item.is_a?(RPG::Skill)
    apply_item(action)   if action.item.is_a?(RPG::Item)
    apply_weapon(action) if action.item.is_a?(RPG::Weapon)
    apply_armor(action)  if action.item.is_a?(RPG::Armor)
  end
  #--------------------------------------------------------------------------
  def self.apply_subitem(action)
    return if action.user.dead?
    action.reassign_item_without_delay(action.user.get_ammo_item(action.item))
    
    if action.target.is_a?(Game_Battler)
      action.target = BattleManager.autotarget(action.user, action.item)
    end
    $game_party.lose_item(action.item, 1, true, nil, nil, false) if action.user.battler.is_a?(Game_Actor)
    
    return unless action.item.tool_graphic
    projs = $game_map.get_idle_proj.send(:initialize, action)
    SceneManager.setup_projectile(proj)
  end
  #--------------------------------------------------------------------------
  def self.execute_subaction(action)
    sid = action.item.tool_invoke
    return unless sid > 0
    subitem = $data_skills[sid]
    subaction = action.dup
    subaction.target = subaction.user.determine_targets(subitem)
    subaction.reassign_item_without_delay(subitem) 
    return unless subaction.user.skill_cost_payable?(subitem)
    subaction.user.process_skill_action(subaction)
  end
  #--------------------------------------------------------------------------
  # * Determine effected targets
  #--------------------------------------------------------------------------
  def self.determine_effected_targets(user, item, target)
    return [user] if item.for_user?
    if item.for_opponent? || item.is_a?(RPG::Weapon)
      candidates = opponent_battler(user).sort {|a,b| a.distance_to_character(target) <=> b.distance_to_character(target)}
    elsif item.for_friend?
      candidates = ally_battler(user).sort {|a,b| a.distance_to_character(target) <=> b.distance_to_character(target)}
    else
      candidates = []
    end
    return [] if target.nil?
    pos = [target.x, target.y]
    
    candidates.select!{|battler| in_attack_range?(user, item, battler, pos)}
    if item.for_one?
      candidates = target.is_a?(POS) ? [candidates.first] : [target]
    end
    candidates.compact!; candidates.select!{|battler| !battler.dead?}
    #names = []
    #candidates.each do |char|
    #  names << char.enemy.name if char.is_a?(Game_Event)    && char.enemy
    #  names << char.actor.name if char.is_a?(Game_Player)   && char.actor
    #  names << char.actor.name if char.is_a?(Game_Follower) && char.actor
    #end
    
    return candidates
  end
  #--------------------------------------------------------------------------
  def self.in_attack_range?(user, item, target, pos)
    return false if item.tool_scopeangle < 1 && item.is_a?(RPG::Weapon)
    return false if target.distance_to(*pos) > item.tool_scope
    return true  if item.tool_scopedir == 5
    dir = item.tool_scopedir == 0 ? user.direction : item.tool_scopedir
    angle1 = (Direction_Angles[dir] + item.tool_scopeangle / 2 + 360) % 360
    angle2 = (Direction_Angles[dir] - item.tool_scopeangle / 2 + 360) % 360
    
    distance = item.tool_scope
    
    re = Math.in_arc?(target.x + 0.5, target.y + 0.5, user.x + 0.5, user.y + 0.5,
                      angle1, angle2, item.tool_scope, dir)
    
    return re
  end
  #--------------------------------------------------------------------------
  # * Apply Skill
  #--------------------------------------------------------------------------
  def self.apply_skill(action)
    invoke_action(action)
  end
  #--------------------------------------------------------------------------
  # * Apply Item
  #--------------------------------------------------------------------------
  def self.apply_item(action)
    invoke_action(action)
  end
  #--------------------------------------------------------------------------
  # * Apply Weapon
  #--------------------------------------------------------------------------
  def self.apply_weapon(action)
    invoke_action(action)
  end
  #--------------------------------------------------------------------------
  # * Apply Armor
  #--------------------------------------------------------------------------
  def self.apply_armor(action)
    invoke_action(action)
  end
  #--------------------------------------------------------------------------
  def self.valid_battler?(battler)
    return false if battler.nil?
    return true  if battler.is_a?(Game_Actor) && $game_party.members.include?(battler)
    return true  if (battler.is_a?(Game_Follower) || battler.is_a?(Game_Player)) && battler.actor && $game_party.members.include?(battler.actor)
    return valid_npc?(battler) if battler.is_a?(Game_Event)
    return false
  end
  #--------------------------------------------------------------------------
  def self.valid_npc?(battler)
    return false if !battler.enemy
    return false if !$game_map.events.include?(battler.id)
    return false if !$game_map.events.values.include?(battler)
    return true
  end
  #--------------------------------------------------------------------------
  # * Invoke Action
  #--------------------------------------------------------------------------
  def self.invoke_action(action)
    item = action.item
    return invoke_action_sequence(action) if item.action_sequence > 0
    action.subject.each do |target|
      next unless valid_battler?(target)
      action.user.map_char.last_hit_target = target
      target.item_apply(action.user, item)
    end
  end
  #--------------------------------------------------------------------------
  # tag: action
  def self.invoke_action_sequence(action)    
    return if action.sequence_finished
    action.execute_sequence
  end
  #--------------------------------------------------------------------------
  # * Apply Substitute
  #--------------------------------------------------------------------------
  def self.apply_substitute(target, item)
    if check_substitute(target, item)
      substitute = substitute_battler(target)
      if substitute && target != substitute
        return substitute
      end
    end
    return target
  end
  #--------------------------------------------------------------------------
  # * Get Substitute Battler
  #   e.g. mirror image
  #--------------------------------------------------------------------------
  def self.substitute_battler
    return nil
  end
  #--------------------------------------------------------------------------
  # * Get Array of Actors Targeted by Item Use
  #--------------------------------------------------------------------------
  def self.item_target_actors(item)
    if !item.for_friend?
      []
    elsif item.for_all?
      $game_party.members
    else
      [$game_party.members[@actor_window.index]]
    end
  end
  #--------------------------------------------------------------------------
  # * Determine if Item is Usable
  #--------------------------------------------------------------------------
  def self.item_usable?(user)
    user.usable?(item) && item_effects_valid?(user)
  end
  #--------------------------------------------------------------------------
  # * Determine if Item Is Effective
  #--------------------------------------------------------------------------
  def self.item_effects_valid?(user)
    item_target_actors.any? do |target|
      target.item_test(user, item)
    end
  end
  #--------------------------------------------------------------------------
  # * Regenerate all battle members
  #--------------------------------------------------------------------------
  def self.regenerate_all
    all_battlers.each do |battler|
      battler.regenerate_all
    end
  end
  #--------------------------------------------------------------------------
  # * Processing at End of Turn, frame time per turn >> PONY::TimeCycle
  #--------------------------------------------------------------------------
  def self.on_turn_end
    all_battlers.each do |battler|
      battler.on_turn_end
    end
    $game_map.refresh_condition_events
  end
  #--------------------------------------------------------------------------
  # * Boss fight?
  #--------------------------------------------------------------------------
  def self.boss_fight?
    return $game_switches[9] || false
  end
  #--------------------------------------------------------------------------
  # * In battle?
  #--------------------------------------------------------------------------
  def self.in_battle?
    return true if boss_fight?
    return false unless @flags
    return @flags[:in_battle] unless @flags[:in_battle].nil?
    
    if @battle_end_delay == 0
      @flags[:in_battle] = opponent_battler($game_player, false).any?{|e| e.current_target && e.current_target.battler.is_a?(Game_Actor)}
      @battle_end_delay  = BattleEndDelay if @flags[:in_battle] == true
    else
      @flags[:in_battle] = true
    end
    return @flags[:in_battle]
  end
  #--------------------------------------------------------------------------
  # * Check if any battler is under process
  #--------------------------------------------------------------------------
  def self.detect_combat
    @flags[:detect_combat] = true if @flags[:detect_combat].nil?
    return unless @flags[:detect_combat]
    @battle_end_delay -= 1 if @battle_end_delay > 0
    @detect_delay     -= 1 if @detect_delay > 0
    return if @detect_delay > 0
    @detect_delay = 15
    result = self.in_battle?
    if result != @last_combat_detect_result
      @last_combat_detect_result = result
      battle_start if result
      battle_end   if !result
    end
  end
  #--------------------------------------------------------------------------
  def self.send_flag(args = {})
    if args[:in_battle] == true
      clear_flag(:in_battle)
      @battle_end_delay  = BattleEndDelay
    elsif args[:in_battle] == false
      clear_flag(:in_battle)
    end
    @flags[:detect_combat] = true
  end
  #--------------------------------------------------------------------------
  def self.battle_start
    puts "[System]: Battle Start"
    if !$game_switches[5]
      save_bgm_and_bgs
      RPG::BGM.fade(60) if @map_bgm
      RPG::BGS.fade(60) if @map_bgs
      play_battle_bgm
    end
    @flags[:detect_combat] = false if all_battlers.any?{ |battler| battler.current_target.is_a?(Game_Actor) }
  end
  #--------------------------------------------------------------------------
  def self.battle_end
    puts "[System]: Battle End"
    @flags[:detect_combat] = false
    replay_bgm_and_bgs if !$game_switches[5]
    $game_party.members.each{|actor| actor.revive if actor.dead?}
    dispute_party_exp
  end
  #--------------------------------------------------------------------------
  def self.clear_flag(symbol = nil)
    if symbol
      @flags.delete(symbol)
    else
      @flags = {}
      @flags[:in_battle]     = false
      @flags[:detect_combat] = true
    end
  end
  #--------------------------------------------------------------------------
  def self.set_flag(symbol, value)
    @flags[symbol] = value
  end
  #--------------------------------------------------------------------------
  def self.play_battle_bgm
    if $game_map.map.battle_bgm
      @combat_bgm = $game_map.map.battle_bgm
    else
      @combat_bgm = $game_system.battle_bgm
    end
    #puts "#{RPG::BGM.last.name} #{@combat_bgm.name} #{RPG::BGM.last.name == @combat_bgm.name}"
    @combat_bgm.play unless RPG::BGM.last.name == @combat_bgm.name
    RPG::BGS.stop
  end
  #--------------------------------------------------------------------------
  # * Resume BGM and BGS
  #--------------------------------------------------------------------------
  def self.replay_bgm_and_bgs
    return if @map_bgm.nil?
    @map_bgm.replay unless $BTEST
    @map_bgs.replay unless $BTEST
  end
  #--------------------------------------------------------------------------
  def self.add_party_exp(amount)
    @party_exp_gained += amount
  end
  #--------------------------------------------------------------------------
  def self.dispute_party_exp
    return if @party_exp_gained < 0
    $game_party.gain_exp(@party_exp_gained)
    @party_exp_gained = 0
  end
  #--------------------------------------------------------------------------
  def self.on_encounter
  end
  #--------------------------------------------------------------------------
  def self.rate_preemptive
  end
  #--------------------------------------------------------------------------
  def self.rate_surprise
  end
  #--------------------------------------------------------------------------
  def self.make_escape_ratio
  end
  #--------------------------------------------------------------------------
  def self.actor
  end
  #--------------------------------------------------------------------------
  def self.next_subject
  end
  
end

#===============================================================================
# * Position
#===============================================================================
class POS
  #------------------------------------------------------------------------
  # *) public instance variables
  #------------------------------------------------------------------------
  attr_accessor :x, :y, :px, :py, :cx, :cy
  attr_reader :hash
  #------------------------------------------------------------------------
  # *) object initialization
  #------------------------------------------------------------------------
  def initialize(x = 0, y = 0)
    @x, @px = x, x * 4
    @y, @py = y, y * 4
    @cx = Pixel_Core::Default_Collision_X
    @cy = Pixel_Core::Default_Collision_Y
    @hash = hashpos
  end
  #------------------------------------------------------------------------
  def hashpos(x = @x, y = @y)
    return x * 4000 + y
  end
  #------------------------------------------------------------------------
  def ==(pos)
    return @x == pos.x && @y == pos.y
  end
  #------------------------------------------------------------------------
  def screen_x
    $game_map.adjust_x(@x) * 32 + 16
  end
  #------------------------------------------------------------------------
  def screen_y
    $game_map.adjust_y(@y) * 32 + 32
  end
  #------------------------------------------------------------------------
  def screen_z
    return 100
  end
  #------------------------------------------------------------------------
  def pos
    self
  end
  #------------------------------------------------------------------------
  def dead?
    false
  end
  #------------------------------------------------------------------------
  def alive?
    return !dead?
  end
  #------------------------------------------------------------------------
end
#==============================================================================
# ** Game_Temp
#------------------------------------------------------------------------------
#  This class handles temporary data that is not included with save data.
# The instance of this class is referenced by $game_temp.
#==============================================================================
class Game_Temp
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :loading_destroy_delay # Cancel loading screen destroy by map.setup
  attr_accessor :effectus_sprites, :effectus_triggers # tag: effectus
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias init_temp_dnd initialize
  def initialize
    @loading_destroy_delay = $game_temp ? $game_temp.loading_destroy_delay : false
    @effectus_sprites  = {}
    @effectus_triggers = []
    init_temp_dnd
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_System
#------------------------------------------------------------------------------
#  This class handles system data. It saves the disable state of saving and 
# menus. Instances of this class are referenced by $game_system.
#==============================================================================
class Game_System
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :skillbar
  attr_accessor :autotarget, :autotarget_aoe
  attr_accessor :loading_pressure
  attr_accessor :time_stopper, :timestop_duration
  attr_reader   :game_mode
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias initialize_system_opt initialize
  def initialize
    @skillbar       = nil
    @autotarget     = true
    @autotarget_aoe = true
    @time_stopper   = nil
    @game_mode      = :main
    @loading_pressure = 0
    @timestop_duration = 0
    initialize_system_opt
  end  
  #--------------------------------------------------------------------------
  # * show roll result?
  #--------------------------------------------------------------------------
  def show_roll_result?
    return $game_switches[15]
  end
  #--------------------------------------------------------------------------
  # * hide huds?
  #--------------------------------------------------------------------------
  def hide_huds?
    re = $game_switches.nil? ? true : $game_switches[16]
    return re || story_mode?
  end
  #--------------------------------------------------------------------------
  def story_mode?
    re = $game_switches.nil? ? true : $game_switches[12]
    return re || $game_message.busy?
  end
  #--------------------------------------------------------------------------
  def hide_huds; $game_switches[16] = true; end
  def show_huds; $game_switches[16] = false; end
  #--------------------------------------------------------------------------
  # * return a rand class value
  #--------------------------------------------------------------------------
  def make_rand
    Random.new_seed
    return Random.new
  end
  #--------------------------------------------------------------------------
  def load_process
    @loading_pressure += 1
  end
  #--------------------------------------------------------------------------
  def load_complete
    @loading_pressure = 0
  end
  #--------------------------------------------------------------------------
  def load_complete?; return @loading_pressure == 0; end
  #--------------------------------------------------------------------------
  def cache_loading
  end
  #--------------------------------------------------------------------------
  alias on_after_load_dnd on_after_load
  def on_after_load
    on_after_load_dnd
    BattleManager.setup
    $game_map.on_after_load
  end
  #--------------------------------------------------------------------------
  def allow_gameover?
    return $game_switches[3]
  end
  #--------------------------------------------------------------------------
  def time_stop(caster, duration)
    @ori_tone = $game_map.screen.tone
    tone = Tone.new(32,32,32,160)
    $game_map.screen.start_tone_change(tone, 0)
    @timestop_duration = duration * 60
    @time_stopper = caster
    debug_print "Time stop: #{caster.name} #{duration}"
    SceneManager.create_override_sprite(caster)
    SceneManager.stop_time
  end
  #--------------------------------------------------------------------------
  def resume_time
    SceneManager.dispose_override_sprite(@time_stopper)
    @time_stopper = nil
    debug_print "Time resume"
    SceneManager.resume_time
    $game_map.screen.start_tone_change(@ori_tone, 0)
  end
  #--------------------------------------------------------------------------
  def game_mode=(mode)
    @game_mode = mode
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Timer
#------------------------------------------------------------------------------
#  This class handles timers. Instances of this class are referenced by 
# $game_timer.
#==============================================================================
class Game_Timer
  
end

#==============================================================================
# ** Game_Message
#------------------------------------------------------------------------------
#  This class handles the state of the message window that displays text or
# selections, etc. The instance of this class is referenced by $game_message.
#==============================================================================
class Game_Message
  
end

#==============================================================================
# ** Game_Switches
#------------------------------------------------------------------------------
#  This class handles switches. It's a wrapper for the built-in class "Array."
# The instance of this class is referenced by $game_switches.
#==============================================================================
# tag: effectus
class Game_Switches
  #--------------------------------------------------------------------------
  # * Set Switch.                                                       [REP]
  #--------------------------------------------------------------------------
  def []=(switch_id, value)
    @data[switch_id] = value
    trigger_symbol = :"switch_#{switch_id}"
    unless $game_temp.effectus_triggers.include?(trigger_symbol)
      $game_temp.effectus_triggers << trigger_symbol
    end
    $game_map.effectus_need_refresh = true
    on_change
  end
  #--------------------------------------------------------------------------
  # * On Change.                                                        [REP]
  #--------------------------------------------------------------------------
  def on_change
    # Kept for compatibility purposes.
  end
  #--------------------------------------------------------------------------
  def size
    return @data.size
  end
  #--------------------------------------------------------------------------
  def item_max
    return 500
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Variables
#------------------------------------------------------------------------------
#  This class handles variables. It's a wrapper for the built-in class "Array."
# The instance of this class is referenced by $game_variables.
#==============================================================================
# tag: effectus
class Game_Variables
  #--------------------------------------------------------------------------
  # * Set Variable.                                                     [REP]
  #--------------------------------------------------------------------------
  def []=(variable_id, value)
    @data[variable_id] = value
    trigger_symbol = :"variable_#{variable_id}"
    unless $game_temp.effectus_triggers.include?(trigger_symbol)
      $game_temp.effectus_triggers << trigger_symbol
    end
    $game_map.effectus_need_refresh = true
    on_change
  end
  #--------------------------------------------------------------------------
  # * On Change.                                                        [REP]
  #--------------------------------------------------------------------------
  def on_change
    # Kept for compatibility purposes.
  end
  #--------------------------------------------------------------------------
  def size
    return @data.size
  end
  #--------------------------------------------------------------------------
  def item_max
    return 1000
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_SelfSwitches
#------------------------------------------------------------------------------
#  This class handles self switches. It's a wrapper for the built-in class
# "Hash." The instance of this class is referenced by $game_self_switches.
#==============================================================================
#tag: effectus
class Game_SelfSwitches
  
  #--------------------------------------------------------------------------
  # * Set SelfSwitch.                                                   [REP]
  #--------------------------------------------------------------------------
  def []=(key, value)
    @data[key] = value
    unless $game_temp.effectus_triggers.include?(key)
      $game_temp.effectus_triggers << key
    end
    $game_map.effectus_need_refresh = true
    on_change
  end
  #--------------------------------------------------------------------------
  # * On Change.                                                        [REP]
  #--------------------------------------------------------------------------
  def on_change
    # Kept for compatibility purposes.
  end
  
end

#==============================================================================
# ** Game_Screen
#------------------------------------------------------------------------------
#  This class handles screen maintenance data, such as changes in color tone,
# flashes, etc. It's used within the Game_Map and Game_Troop classes.
#==============================================================================
class Game_Screen
  
end

#==============================================================================
# ** Game_Picture
#------------------------------------------------------------------------------
#  This class handles pictures. It is created only when a picture of a specific
# number is required internally for the Game_Pictures class.
#==============================================================================
class Game_Picture
  
end

#==============================================================================
# ** Game_Pictures
#------------------------------------------------------------------------------
#  This is a wrapper for a picture array. This class is used within the
# Game_Screen class. Map screen pictures and battle screen pictures are
# handled separately.
#==============================================================================
class Game_Pictures
  
end

#==============================================================================
# ** Game_BaseItem
#------------------------------------------------------------------------------
#  This class uniformly handles skills, items, weapons, and armor. References
# to the database object itself are not retained to enable inclusion in save
# data.
#==============================================================================
class Game_BaseItem
  
  def effects
    object.effects rescue []
  end
  
  def nil?
    return super || is_nil?
  end
  
  alias :is_a_obj? :is_a?
  def is_a?(cls)
    return is_a_obj?(cls) || object.is_a?(cls)
  end
  
  def hashid
    return object.hashid
  end
  
  #---------------------------------------------------------------------------
  # * Method Missing
  # ----------------------------------------------------------------------   
  # DANGER ZONE: Redirect to Actor
  #---------------------------------------------------------------------------
  def method_missing(symbol, *args)
    return nil if nil?
    return object.method(symbol).call(*args) if object.methods.include?(symbol)
    if object.instance_variables.include?(symbol)
      return object.instance_variable_get(symbol)
    end
    super(symbol, args)
  end
  
end

#==============================================================================
# ** Game_Action
#------------------------------------------------------------------------------
#  This class handles battle actions. This class is used within the
# Game_Battler class.
#==============================================================================
class Game_Action
  #--------------------------------------------------------------------------
  Symbol_Name = Vocab::Tactic::Name_Table
  #--------------------------------------------------------------------------
  Symbol_IconID = {
      :attack_mainhoof      => 131,
      :attack_offhoof       => 134,
      :add_command          => PONY::IconID[:plus],
      :target_none          => 1142,
      :hp_most_power        => 2775,
      :hp_least_power       => 2743,
      :ep_most_power        => 2773,
      :ep_least_power       => 2741,
      :set_target           => PONY::IconID[:aim],
      :jump_to              => 2103,
      :move_away            => 8688,
      :move_close           => 8683,
  }
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :time                       # Cast time required
  attr_accessor :interruptible              # Can be interrupted?
  attr_accessor :user                       # Battler who used, may be inverted
  attr_accessor :target                     # Target destiniation
  attr_accessor :target_pos                 # Target position at first place
  attr_accessor :subject                    # Battlers affected
  attr_accessor :sequence_finished          # Flag of Action Sequence has finished
  attr_reader   :started
  attr_reader   :casting                    # Casting flag
  attr_reader   :item                       # Item index
  attr_reader	  :acting                     # Performing flag
  attr_reader	  :done                       # Executed flag
  attr_reader   :ignore_distance
  attr_accessor :effect_delay               # Exexute damage delay
  attr_reader   :symbol_item
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(user, target, item, forcing = false)
  	@user	   = user
    @target  = target
    @subject = []
    @forcing = forcing
    @item 	 = item
    @time    = 0
    @time    = user.item_casting_time(item) if @item.is_a?(RPG::BaseItem)
    @time_needed   = @time
    @target_pos    = target.pos if @target
    @effect_delay  = item.tool_effectdelay rescue 0
    @interruptible = true
    @started       = false
    @casting       = false
    @acting		     = false
    @done		       = false
    @casted        = false
    @symbol_item   = nil
    @sequence_finished = false
  end
  #------------------------------------------------------------------------
  def ==(action)
    return false if action.ruby_class != self.ruby_class
    return @item == action.item && @user == action.user && @target == action.target
  end
  #---------------------------------------------------------------------------
  #  *) Start action
  #---------------------------------------------------------------------------
  def start
    if @time > 10
      anim_id = user.map_char.casting_animation
      anim_id += 1 if anim_id == DND::BattlerSetting::CastingAnimation && @time > 120
      user.map_char.start_animation(anim_id) rescue nil
    end
    @started = true
    @casting = true
  end
  #--------------------------------------------------------------------------
  def initial_casting?
    return false if cast_done?
    return @time < @time_needed - 10
  end
  #---------------------------------------------------------------------------
  #  *) Return interrupt flag, if false, action will be executed anyway
  #---------------------------------------------------------------------------
  def interruptible?
  	return @interruptible
  end
  #---------------------------------------------------------------------------
  #  *) Return if action is undergoing
  #---------------------------------------------------------------------------
  def acting?
    return false unless casted?
  	return !@sequence_finished || @acting
  end
  #---------------------------------------------------------------------------
  #  *) Return action can be executed effectivly
  #---------------------------------------------------------------------------
  def action_impleable?(check_cooldown = true)
    real_item = get_symbol_item
    return true  if real_item.nil?
    return true  if real_item.is_a?(Symbol)
    return true  if @target.hashid == @user.hashid
  	return false if @user.distance_to(@target.x, @target.y) > real_item.tool_distance
    return false if check_cooldown && (!@user.usable?(real_item) || @user.battler.stiff > 0)
  	return @user.path_clear?(@user.x, @user.y, @target.x, @target.y) if real_item.melee?
  	return @user.can_see?(@user.x, @user.y, @target.x, @target.y)
  end
  #---------------------------------------------------------------------------
  #  *) casting process
  # tag: cast
  #---------------------------------------------------------------------------
  def do_casting
  	return if cast_done?
  	@time -= user.csr if @time > 0
    if @time <= 0
      @casting = false
      @time = 0
    end
  end
  #---------------------------------------------------------------------------
  # * Update 
  #---------------------------------------------------------------------------
  def do_acting
    #puts "acting time: #{@time}"
    @time -= 1 if !@waiting && @sequence_finished && @time > 0
    terminate  if !@waiting && @time <= 0
  end
  #---------------------------------------------------------------------------
  # * Frame update
  #---------------------------------------------------------------------------
  def update
    return @user.cancel_action_without_penalty if cancel_action?
    start if !@started && action_impleable?
    if @started
      do_acting  if acting?
      do_casting unless cast_done?
    end
  end
  #---------------------------------------------------------------------------
  def cancel_action?
    return false if @started
    return true  if @target.nil?
    return true  unless @user.effectus_near_the_screen?
    return false if @target.is_a?(POS)
    return true  unless @target.effectus_near_the_screen?
    return true  if target.dead?
    return false
  end
  #---------------------------------------------------------------------------
  # * Set execution flags
  #---------------------------------------------------------------------------
  def execute
    @casting = false
    @casted  = true
    @acting  = true
    @sequence_finished = (item.action_sequence == 0)
    @time    = get_item_acting_time
  end
  #---------------------------------------------------------------------------
  # tag: action
  def execute_sequence
    asid = @item.action_sequence
    puts "#{@user.name} setup action sequence #{asid}"
    @user.setup_action_sequence(DND::SkillSequence::ACTS[asid])
  end
  #---------------------------------------------------------------------------
  def get_item_acting_time
    return @user.action_stiff
  end
  #---------------------------------------------------------------------------
  def terminate
    @acting = false
    @done   = true
  end
  #---------------------------------------------------------------------------
  def casting?
    return false unless @started
    return @casting
  end
  #---------------------------------------------------------------------------
  def cast_done?
    return !@casting && @started
  end
  #---------------------------------------------------------------------------
  def casted?
    return @casted
  end
  #---------------------------------------------------------------------------
  def done?
    return @done
  end
  #---------------------------------------------------------------------------
  def wait
    @waiting = true
  end
  #---------------------------------------------------------------------------
  def resume
    @waiting = false
  end
  #---------------------------------------------------------------------------
  def reassign_item_without_delay(item)
    return if done?
    @item = item
    execute
  end
  #---------------------------------------------------------------------------
  def reassign_item(item)
    @symbol_item  = item.is_a?(Symbol) ? item : nil
    @item         = item
    if @item.is_a?(RPG::BaseItem)
      @time = user.item_casting_time(item)
      @effect_delay = item.tool_effectdelay
    else
      @time = @effect_delay = 0
    end
    @time_needed  = @time
  end
  #---------------------------------------------------------------------------
  def interrupt
    @done = true
    wait
  end
  #---------------------------------------------------------------------------
  def item_valid?
    return @item.is_a?(RPG::BaseItem)
  end
  #---------------------------------------------------------------------------
  def get_item_name
    return @item.name if !@symbol_item && @item.is_a?(RPG::BaseItem)
    name = Symbol_Name[@item]
    return name.nil? ? "<none>" : name
  end
  #---------------------------------------------------------------------------
  def get_icon_id
    return (@item.icon_index || 0) if !@symbol_item && @item.is_a?(RPG::BaseItem)
    id = Symbol_IconID[@item]
    return (id || 0)
  end
  #---------------------------------------------------------------------------
  def get_symbol_item
    case @item
    when :attack_mainhoof
      return @user.primary_weapon
    when :attack_offhoof
      return @user.secondary_weapon
    when :hp_most_power
      potions = $game_party.items.select{|item| item.hp_recover? && !item.mp_recover?}
      potion  = potions.max_by{|item| item.price}
      return potion
    when :hp_least_power
      potions = $game_party.items.select{|item| item.hp_recover? && !item.mp_recover?}
      potion  = potions.min_by{|item| item.price}
      return potion
    when :ep_most_power
      potions = $game_party.items.select{|item| !item.hp_recover? && item.mp_recover?}
      potion  = potions.max_by{|item| item.price}
      return potion
    when :ep_least_power
      potions = $game_party.items.select{|item| !item.hp_recover? && !item.mp_recover?}
      potion  = potions.min_by{|item| item.price}
      return potion
    else
      return @item
    end
  end
  #--------------------------------------------------------------------------
  # * Determination if Action is Valid or Not
  #--------------------------------------------------------------------------
  def valid?
    return false if @item == :add_command
    return false if @item.is_a?(Symbol) && !Vocab::Tactic::Name_Table.include?(@item)
    return true
  end
  #---------------------------------------------------------------------------
  def need_chase?
    return @need_chase_flag unless @need_chase_flag.nil?
    real_item = get_symbol_item
    return @need_chase_flag = false if real_item.nil?
    return @need_chase_flag = false if real_item.is_a?(Symbol)
    return @need_chase_flag = false if @target.hashid == @user.hashid
    return @need_chase_flag = false if real_item.is_a?(RPG::UsableItem) && real_item.for_user?
    return @need_chase_flag = true
  end
  #---------------------------------------------------------------------------
end

#==============================================================================
# ** Game_ActionResult
#------------------------------------------------------------------------------
#  This class handles the results of battle actions. It is used internally for
# the Game_Battler class. 
#==============================================================================
class Game_ActionResult
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :interrupted
  attr_accessor :hitted
  attr_accessor :immune
  #--------------------------------------------------------------------------
  # * Alias :Clear Hit Flags
  #--------------------------------------------------------------------------
  alias clear_hit_flags_dnd clear_hit_flags
  def clear_hit_flags
    @interrupted  = false
    @hitted       = false
    @immune       = false
    clear_hit_flags_dnd
  end
  #--------------------------------------------------------------------------
  # * Overwrite :hit?
  #--------------------------------------------------------------------------
  def hit?
    @used && !@missed && !@evaded && !@interrupted && @hitted && !@immune
  end
  #--------------------------------------------------------------------------
  def result?
    args = {}
    args[:used]        = @used
    args[:missed]      = @missed
    args[:interrupted] = @interrupted
    args[:hitted]      = @hitted
    args[:evaded]      = @evaded
    args[:critical]    = @critical
    args[:immune]      = @immune
    return args
  end
  
end

#==============================================================================
# ** Game_BattlerBase
#------------------------------------------------------------------------------
#  This base class handles battlers. It mainly contains methods for calculating
# parameters. It is used as a super class of the Game_Battler class.
#==============================================================================
class Game_BattlerBase
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :reg_time_count             # regeneration time counter
  attr_reader   :shp                        # HP
  attr_reader   :smp                        # MP
  attr_reader   :class_id
  attr_reader   :dualclass_id, :race_id, :subrace_id
  #--------------------------------------------------------------------------
  # * Access Method by Parameter Abbreviations
  #--------------------------------------------------------------------------
  def ctr;  sparam(3); end     # CTR Casting Time Reducation Rate
                                            # Original: Pharmacology
  def csr;  sparam(5); end     # CSR Casting Speed Rate
                                            # Original: TP Charge Rate
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias initialize_reg_dnd initialize
  def initialize
    @reg_time_count = 0
    initialize_reg_dnd
    @shp = PONY.EncInt(@hp)
    @smp = PONY.EncInt(@mp)
    @dualclass_id = 0
    @race_id = @subrace_id = 0
    @class_objects = []
  end
  #--------------------------------------------------------------------------
  # * Change HP
  #--------------------------------------------------------------------------
  def hp=(hp)
    hp = [[hp, mhp].min, 0].max
    delta = hp.to_i - @hp.to_i
    return if delta == 0
    check_security
    popup_hp_change(delta) if delta != 0
    @hp  = hp.to_i
    refresh
    update_security
  end
  #--------------------------------------------------------------------------
  # * Change MP
  #--------------------------------------------------------------------------
  def mp=(mp)
    mp = [[mp, mmp].min, 0].max
    delta = mp.to_i - @mp.to_i
    return if delta == 0
    check_security
    popup_ep_change(delta) if delta > 30
    @mp  = mp.to_i
    refresh
    update_security
  end
  #--------------------------------------------------------------------------   
  # ● Easier method for check skilll learned
  #--------------------------------------------------------------------------   
  def skill_learned?(id)
    return self.skills.include?($data_skills[id])
  end
  #--------------------------------------------------------------------------
  def setup_dnd_battler(instance)
    @class_objects = []
    
    @class_id     = instance.class_id
    @dualclass_id = instance.dualclass_id
    @race_id      = instance.race_id
    @subrace_id   = instance.subrace_id
    @class_level  = instance.class_levelcap.collect{|lvl| lvl.first}
    
    @level  = @level ? @level : (@class_level[@class_id] || 0)
    @level += @class_level[@dualclass_id] if @dualclass_id > 0
    @class_level[@race_id] = @class_level[@subrace_id] = @level
  end
  #--------------------------------------------------------------------------
  def class_objects
    return @class_objects unless @class_objects.empty?
    re = []
    
    primary = $data_classes[@class_id]
    re << primary
    re << $data_classes[primary.parent_class] if primary.parent_class > 0
    
    if @dualclass_id > 0
      dual = $data_classes[@dualclass_id]
      re << dual
      re << $data_classes[dual.parent_class] if dual.parent_class > 0
    end
    
    re << $data_classes[@race_id]     if @race_id > 0
    re << $data_classes[@subrace_id]  if @subrace_id > 0
    return @class_objects = re
  end
  #--------------------------------------------------------------------------
  def init_skills
    @skills = []
    class_objects.each do |obj|
      next unless obj.id > 0
      learn_class_skills(obj.id)
    end
  end
  #--------------------------------------------------------------------------
  def learn_class_skills(cid)
    return unless cid.to_bool
    $data_classes[cid].learnings.each do |learning|
      next if learning.level > @class_level[cid]
      learn_skill(learning.skill_id)
    end
  end
  #--------------------------------------------------------------------------
  # * Learn Skill
  #--------------------------------------------------------------------------
  def learn_skill(skill_id)
    return if $data_skills[skill_id].for_leveling?
    return if skill_learn?($data_skills[skill_id])
    @skills.push(skill_id)
    @skills.sort!
  end
  #--------------------------------------------------------------------------
  # * Level Up
  #--------------------------------------------------------------------------
  def level_up
    @level += 1
    level_up_class(@race_id)
    level_up_class(@subrace_id)
    $game_map.need_refresh = true
  end
  #--------------------------------------------------------------------------
  def level_up_class(cid)
    return unless cid.to_bool
    @class_level[cid] += 1
    learn_class_skills(cid)
  end
  #---------------------------------------------------------------------------
  def param_base(id)
    return class_objects.inject(0){|sum, obj| sum + obj.param(id)}
  end
  #--------------------------------------------------------------------------
  # * Get Maximum Value of Parameter
  #--------------------------------------------------------------------------
  def param_max(param_id)
    return 9999 if (param_id >> 1) == 0  # MHP/MMP
    return 99 
  end
  #--------------------------------------------------------------------------
  def init_class(cid)
    @class_level[cid] = 0
    level_up_class(cid)
  end
  #--------------------------------------------------------------------------
  def change_class(cid, keep_lvl = true)
    @class_objects.clear
    if keep_lvl
      @class_level[cid] = @class_level[@class_id] if keep_lvl
      @class_id = cid
      learn_class_skills(cid)
    else
      @class_id = cid
      init_class(cid)
    end
    refresh
  end
  #--------------------------------------------------------------------------
  def change_dualclass(cid, keep_lvl = true)
    @class_objects.clear
    if keep_lvl && @dualclass_id > 0
      @class_level[cid] = @class_level[@dualclass_id]
      @dualclass_id = cid
      learn_class_skills(cid)
    else
      @dualclass_id = cid
      init_class(cid)
    end
    refresh
  end
  #--------------------------------------------------------------------------
  def change_race(cid, keep_lvl = true)
    @class_objects.clear
    if keep_lvl
      @class_level[cid] = @class_level[@race_id] if keep_lvl
      @race_id = cid
      learn_class_skills(cid)
    else
      @race_id = cid
      init_class(cid)
    end
    refresh
  end
  #--------------------------------------------------------------------------
  def change_subrace(cid, keep_lvl = true)
    @class_objects.clear
    if keep_lvl
      @class_level[cid] = @class_level[@subrace_id] if keep_lvl
      @subrace_id = cid
      learn_class_skills(cid)
    else
      @subrace_id = cid
      init_class(cid)
    end
    refresh
  end
  #--------------------------------------------------------------------------
  # ● Posioned?
  #--------------------------------------------------------------------------   
  def poisoned?
    return self.states.any?{|state| state.is_poison?}
  end
  #--------------------------------------------------------------------------
  # ● Debuffed?
  #--------------------------------------------------------------------------   
  def debuffed?
    return self.states.any?{|state| state.is_poison?}
  end
  #--------------------------------------------------------------------------
  # ● Dispel Magic
  #--------------------------------------------------------------------------   
  def dispel_magic
    animated = false
    for state in self.states
      next if state.nil?
      animated = true if state.id == 271 # original for animted dead, reservered
                                         # for furture usage
      remove_state(state.id) if state.is_magic?
    end
    die if animated
  end
  #--------------------------------------------------------------------------
  # ● Anti Magic?
  #--------------------------------------------------------------------------   
  def anti_magic?
    
    result = false
    source = 0
    
     if @anti_magic
       result = true; source = 1
     end
     
    if self.mrf > 0.5
      result = true; source = 2 
    end
    
    anti_magic_state = [266,267,288]
    
    for id in anti_magic_state
      if self.state?(id)
        source = id
        result = true
        break
      end
  
    end
    
    return result
  end
  #--------------------------------------------------------------------------
  # Hide HP/MP info
  #--------------------------------------------------------------------------
  def hide_info?
    false
  end
  #--------------------------------------------------------------------------
  # * Check When Skill/Item Can Be Used
  #--------------------------------------------------------------------------
  def occasion_ok?(item)
    SceneManager.scene_is?(Scene_Map) ? item.battle_ok? : item.menu_ok?
  end
  #--------------------------------------------------------------------------   
  def popup_hp_change(value)
    return unless SceneManager.scene_is?(Scene_Map)
    color = value < 0 ? DND::COLOR::HPDamage : DND::COLOR::HPHeal
    popup_info(value.abs.to_s, color)
  end
  #--------------------------------------------------------------------------   
  def popup_ep_change(value)
    return unless SceneManager.scene_is?(Scene_Map)
    color = value < 0 ? DND::COLOR::EPDamage : DND::COLOR::EPHeal
    popup_info(value.abs.to_s, color)
  end
  #--------------------------------------------------------------------------
  # * Determine if Equippable
  #--------------------------------------------------------------------------
  alias :freehoof_equippable? :equippable?
  def equippable?(item)
    return freehoof_equippable?(item)
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Refresh
  #--------------------------------------------------------------------------
  def refresh
    state_resist_set.each {|state_id| erase_state(state_id) }
    @hp = [[@hp, mhp].min, 0].max
    @mp = [[@mp, mmp].min, 0].max
    @hp == 0 ? add_state(death_state_id, self) : remove_state(death_state_id)
  end
  #--------------------------------------------------------------------------
  # * Clear State Information
  #--------------------------------------------------------------------------
  alias clear_states_gbb clear_states
  def clear_states
    @state_enchanter = {}
    clear_states_gbb
  end
  #--------------------------------------------------------------------------
  # * Erase States
  #--------------------------------------------------------------------------
  alias erase_state_gbb erase_state
  def erase_state(state_id)
    @state_enchanter.delete(state_id)
    erase_state_gbb(state_id)
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Battler
#------------------------------------------------------------------------------
#  A battler class with methods for sprites and actions added. This class 
# is used as a super class of the Game_Actor class and Game_Enemy class.
#==============================================================================
#tag: battler
class Game_Battler < Game_BattlerBase
  #--------------------------------------------------------------------------
  OffHoofSkillID  = 5   # Skill id that allow to dual-wield
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :state_steps
  attr_reader   :safe_hash
  attr_reader   :skill_charges
  attr_reader   :map_char     # character on the map
  attr_accessor :stiff        # Stiff time
  attr_accessor :skill_cooldown, :item_cooldown, :weapon_cooldown, :armor_cooldown
  attr_accessor :move_limit
  attr_accessor :aggressive_level
  attr_accessor :team_id
  attr_accessor :last_attacked_action
  attr_accessor :tactic_commands    # tactic commadns
  attr_accessor :action_list
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias init_battler_opt initialize
  def initialize
    @skill_cooldown   = {}
    @item_cooldown    = {}
    @weapon_cooldown  = {}
    @armor_cooldown   = {}
    @skill_charges    = {}
    @tactic_commands  = []
    @action_list      = []
    @map_char         = nil
    @stiff            = 0
    @move_limit       = DND::BattlerSetting::MoveLimit
    @aggressive_level = DND::BattlerSetting::AggressiveLevel
    @last_attacked_action = []
    @passive_skills   = nil
    init_battler_opt
  end
  #--------------------------------------------------------------------------
  def cooldown_ready?(item)
    return @skill_cooldown[item.id] == 0  if item.is_a?(RPG::Skill)  && @skill_cooldown[item.id]
    return @item_cooldown[item.id] == 0   if item.is_a?(RPG::Item)   && @item_cooldown[item.id]
    return @weapon_cooldown[item.id] == 0 if item.is_a?(RPG::Weapon) && @weapon_cooldown[item.id]
    return @armor_cooldown[item.id] == 0  if item.is_a?(RPG::Armor)  && @armor_cooldown[item.id]
    return true
  end
  #--------------------------------------------------------------------------
  # * Determine Skill/Item Usability
  #--------------------------------------------------------------------------
  def usable?(item, ignore_cdt = false)
    return false if !item
    return false if !ignore_cdt && !cooldown_ready?(item)
    return skill_conditions_met?(item)  if item.is_a?(RPG::Skill)
    return item_conditions_met?(item)   if item.is_a?(RPG::Item)
    return false if !item.is_a?(RPG::UsableItem) && !SceneManager.scene_is?(Scene_Map)
    return weapon_conditions_met?(item) if item.is_a?(RPG::Weapon)
    return false
  end
  #--------------------------------------------------------------------------
  # * Weapon Ammo Ready?
  #--------------------------------------------------------------------------
  def weapon_conditions_met?(item)
    if item.item_required?
      return weapon_ammo_ready?(item)
    end
    return true
  end
  #--------------------------------------------------------------------------
  # * Determine if Cost of Using Skill Can Be Paid
  #--------------------------------------------------------------------------
  def skill_cost_payable?(skill)
    re = super(skill)
    item = skill
    if !item.tool_itemcost && item.tool_itemcost > 0
      item = $data_items[itemcost]
      re  &= $game_party.item_number(item)
    elsif item.tool_itemcost_type > 0
      re  &= weapon_ammo_ready?(@equips[0])
    end
    return re
  end
  #--------------------------------------------------------------------------
  # * Damage Processing
  #    @result.hp_damage @result.mp_damage @result.hp_drain
  #    @result.mp_drain must be set before call.
  #--------------------------------------------------------------------------
  alias execute_damage_popup execute_damage
  def execute_damage(user)
    #popup_hp_change(-@result.hp_damage)    if @result.hp_damage != 0
    #popup_ep_change(-@result.mp_damage)    if @result.mp_damage != 0
    #user.popup_hp_change(@result.hp_drain) if @result.hp_drain  != 0
    #user.popup_ep_change(@result.mp_drain) if @result.mp_drain  != 0
    execute_damage_popup(user)
  end
  #--------------------------------------------------------------------------   
  def team_id
    return @team_id | 0
  end
  #--------------------------------------------------------------------------   
  def is_opponent?(charactor)
    return BattleManager.is_opponent?(self, charactor)
  end
  alias is_enemy? is_opponent?
  #--------------------------------------------------------------------------   
  def is_friend?(charactor)
    return BattleManager.is_friend?(self, charactor)
  end
  alias is_ally? is_friend?
  #--------------------------------------------------------------------------
  # * Test Skill/Item Application
  #    Used to determine, for example, if a character is already fully healed
  #   and so cannot recover anymore.
  #--------------------------------------------------------------------------
  def item_test(user, item)
    return false if casting?
    item = item.object if item.methods.include?(:object)
    return true if (item.is_a?(RPG::Weapon) || item.is_a?(RPG::Armor)) && SceneManager.scene_is?(Scene_Map)
    return false if item.for_dead_friend? != dead?
    return true if item.for_opponent?
    return true if item.is_a?(RPG::UsableItem) && item.damage.recover? && item.damage.to_hp? && hp < mhp
    return true if item.is_a?(RPG::UsableItem) && item.damage.recover? && item.damage.to_mp? && mp < mmp
    return true if item.is_a?(RPG::UsableItem) && item_has_any_valid_effects?(user, item)
    return true if item.is_a?(RPG::UsableItem) && !item.damage.none?
    return false
  end
  #--------------------------------------------------------------------------
  # * Alias: die (Knock Out)
  #--------------------------------------------------------------------------
  alias die_dnd die
  def die
    die_dnd
    clear_sequence
    @map_char.kill if @map_char
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Processing at End of Turn
  #--------------------------------------------------------------------------
  def on_turn_end
    @result.clear
    update_state_turns
    update_buff_turns
    remove_states_auto(2)
    @last_attacked_action.shift unless @last_attacked_action.empty?
  end
  #--------------------------------------------------------------------------
  # * Regenerate HP
  #--------------------------------------------------------------------------
  def regenerate_hp
    damage = -(100 * hrg).to_i
    damage *= 10 if !$game_party.in_combat?
    perform_map_damage_effect if $game_party.in_battle && damage > 0
    @result.hp_damage = [damage, max_slip_damage].min
    self.hp -= @result.hp_damage
  end
  #--------------------------------------------------------------------------
  # * Regenerate MP
  #--------------------------------------------------------------------------
  def regenerate_mp
    @result.mp_damage = -(100 * mrg).to_i
    @result.mp_damage *= 10 if !$game_party.in_combat? && (100 * mrg) > 0
    self.mp -= @result.mp_damage
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Add State # tag: state
  #--------------------------------------------------------------------------
  def add_state(state_id, enchanter, duration = nil)
    if state_addable?(state_id)
      add_new_state(state_id) unless state?(state_id)
      reset_state_counts(state_id, duration)
      @state_enchanter[state_id] = enchanter
      if @map_char && self.is_a?(Game_Actor) && PONY::LightStateID.keys.include?(state_id)
        light_id = PONY::LightStateID[state_id]
        @map_char.setup_light(light_id)
      end
      on_state_apply(state_id)
      @result.added_states.push(state_id).uniq!
    end
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Remove State
  #--------------------------------------------------------------------------
  def remove_state(state_id)
    if state?(state_id)
      revive if state_id == death_state_id
      erase_state(state_id)
      @map_char.dispose_light if @map_char && self.is_a?(Game_Actor) && PONY::LightStateID.keys.include?(state_id)
      refresh
      on_state_erase(state_id)
      @result.removed_states.push(state_id).uniq!
    end
  end
  #--------------------------------------------------------------------------
  # * Alias: Determine if States Are Addable
  #--------------------------------------------------------------------------
  alias :magic_state_addable? :state_addable?
  def state_addable?(state_id)
    return false if anti_magic? && $data_states[state_id].is_magic?
    return magic_state_addable?(state_id)
  end
  #--------------------------------------------------------------------------
  # * Alias: Reset State Counts (Turns and Steps)
  #--------------------------------------------------------------------------
  alias reset_state_counts_default reset_state_counts
  def reset_state_counts(state_id, duration = nil)
    state = $data_states[state_id]
    return reset_state_counts_default(state_id) if duration.nil?
    @state_turns[state_id] = duration
    @state_steps[state_id] = state.steps_to_remove
  end
  #--------------------------------------------------------------------------
  # * Use Skill/Item
  #    Called for the acting side and applies the effect to other than the user.
  #--------------------------------------------------------------------------
  def use_item(item)
    pay_skill_cost(item) if item.is_a?(RPG::Skill)
    consume_item(item)   if item.is_a?(RPG::Item)
    return unless item.is_a?(RPG::Skill) || item.is_a?(RPG::Item)
    item.effects.each {|effect| item_global_effect_apply(effect) }
  end
  #--------------------------------------------------------------------------
  # * Alias: Use Skill/Item
  #--------------------------------------------------------------------------
  alias use_item_dnd use_item
  def use_item(item)
    use_item_dnd(item)
    $game_party.skillbar.need_refresh = true
  end
  #--------------------------------------------------------------------------
  # * Alias: Revive from Knock Out
  #--------------------------------------------------------------------------
  alias revive_dnd revive
  def revive
    revive_dnd
    update_security
    erase_state(death_state_id) if state?(death_state_id)
    @map_char.revive_character if @map_char
  end
  #---------------------------------------------------------------------------
  # * Immune weapon enchant level, 0 = none, 1 = below +1 and so on
  #---------------------------------------------------------------------------
  def weapon_level_prof
    return 0
  end
  #---------------------------------------------------------------------------
  # * Update security hash value
  #---------------------------------------------------------------------------
  def update_security
    v = @hp + @mp + exp
    @safe_hash = PONY.MD5(v.to_s)
  end
  #---------------------------------------------------------------------------
  # * Abort if hash check failed
  #---------------------------------------------------------------------------
  # tag: security
  def check_security
    update_security if @safe_hash.nil?
    v = @hp + @mp + exp
    result = ( @safe_hash == PONY.MD5(v.to_s) )
    return true if result
    p SPLIT_LINE
    puts "Name: #{name} Sum: #{v} Safe-hash: #{@safe_hash} Hash: #{PONY.MD5(v.to_s)}"
    PONY::ERRNO.raise(:secure_hash_failed, :exit, nil, name)
    return false
  end
  #---------------------------------------------------------------------------
  # * Max tactic command count
  #---------------------------------------------------------------------------
  def command_limit
    return 20
  end
  #---------------------------------------------------------------------------
  def icon_index
    return 0;
  end
  #--------------------------------------------------------------------------
  # * Recover All
  #--------------------------------------------------------------------------
  def recover_all
    super
    update_security
  end
  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  alias refresh_dndga refresh
  def refresh
    collect_passive_skills
    refresh_dndga
  end
  #--------------------------------------------------------------------------
  def passive_skills
    return @passsive_skills.collect{|id| $data_skills[id]} if @passsive_skills
    collect_passive_skills
    return passive_skills
  end
  #--------------------------------------------------------------------------
  def collect_passive_skills
    @passive_skills = @skills.select{|sid| $data_skills[sid].stype_id == DND::PASSIVE_STYPE_ID}
    @passive_skills ||= []
  end
  #--------------------------------------------------------------------------
  def offhoof_skill_learned?
    return skill_learned?(OffHoofSkillID)
  end
  #--------------------------------------------------------------------------
  def controlable?
    return movable?
  end
  #--------------------------------------------------------------------------
  alias :opposite_teamid :opposite?
  def opposite?(battler)
    tid  = team_id rescue nil
    tid2 = battler.team_id recue nil
    return tid != tid2 if tid && tid2
    return opposite_teamid
  end
  #--------------------------------------------------------------------------
  # * Overwrite: [Add State] Effect: Normal Attack
  #--------------------------------------------------------------------------
  def item_effect_add_state_attack(user, item, effect)
    user.atk_states.each do |state_id|
      chance = effect.value1
      chance *= state_rate(state_id)
      chance *= user.atk_states_rate(state_id)
      chance *= luk_effect_rate(user)
      if rand < chance
        add_state(state_id, user)
        @result.success = true
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Overwrite: [Add State] Effect: Normal
  #--------------------------------------------------------------------------
  def item_effect_add_state_normal(user, item, effect)
    chance = effect.value1
    chance *= state_rate(effect.data_id) if opposite?(user)
    chance *= luk_effect_rate(user)      if opposite?(user)
    if rand < chance
      add_state(effect.data_id, user)
      @result.success = true
    end
  end
  #--------------------------------------------------------------------------
  def battler
    self
  end
  #--------------------------------------------------------------------------
  def current_target
    return nil if @map_char.nil?
    return @map_char.current_target
  end
  #--------------------------------------------------------------------------
  def map_char=(ch)
    @map_char = ch
    set_obj(ch)
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Actor
#------------------------------------------------------------------------------
#  This class handles actors. It is used within the Game_Actors class
# ($game_actors) and is also referenced from the Game_Party class ($game_party).
#==============================================================================
class Game_Actor < Game_Battler
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :dualclass_id        # Second class ID
  attr_accessor :assigned_hotkey     # Instance item in hotkey bar
  attr_reader   :queued_levelings    # Feats waiting to be select & added
  attr_reader   :class_level
  attr_reader   :mhp_plus, :mmp_plus # HP/EP gained through level up
  #------------------------------------------------------------------------
  # * Set hashid
  #------------------------------------------------------------------------
  def hash_self
    @hashid  = actor.hashid
    super
  end
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias init_muticlass initialize
  def initialize(actor_id)
    @team_id = 0
    @assigned_hotkey = Array.new(HotKeys::HotKeys.size){nil}
    @passsive_skills = nil
    @queued_levelings = []
    @mhp_plus = @mmp_plus = 0
    init_muticlass(actor_id)
    hash_self
  end
  #--------------------------------------------------------------------------
  def setup(actor_id)
    @actor_id = actor_id
    @name     = actor.name
    @nickname = actor.nickname
    @level    = nil # will be set in setup_dnd_battler
    init_graphics
    @exp = 0
    @equips = []
    setup_dnd_battler(actor)
    init_exp
    init_skills
    init_equips(actor.equips)
    clear_param_plus
    recover_all
  end
  #--------------------------------------------------------------------------
  alias :is_a_obj? :is_a?
  def is_a?(cls)
    return is_a_obj?(cls) || actor.is_a?(cls)
  end
  #--------------------------------------------------------------------------
  # * Initialize EXP
  #--------------------------------------------------------------------------
  def init_exp
    @exp = 0
  end
  #--------------------------------------------------------------------------
  def exp
    @exp
  end
  #--------------------------------------------------------------------------
  # * Get Class Object
  #--------------------------------------------------------------------------
  def dualclass
    $data_classes[@dualclass_id]
  end
  #--------------------------------------------------------------------------
  # * Get Race Object
  #--------------------------------------------------------------------------
  def race
    $data_classes[@race_id]
  end
  #--------------------------------------------------------------------------
  # * Learn Skill
  #--------------------------------------------------------------------------
  def learn_skill(skill_id)
    return @queued_levelings.push(skill_id) if $data_skills[skill_id].for_leveling?
    super
  end
  #--------------------------------------------------------------------------
  # * Get Array of All Objects Retaining Features
  #--------------------------------------------------------------------------
  alias feature_objs feature_objects
  def feature_objects
    re  = feature_objs
    re << self.dualclass if @dualclass_id > 0
    re
  end
  #--------------------------------------------------------------------------
  # *) Get equipped all items
  #--------------------------------------------------------------------------
  def get_hotkeys(equip_only = false)
    items = [@equips[0], @equips[1]]
    unless equip_only
      @assigned_hotkey.each {|item| items.push(item)}
    end
    return items
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Processing Performed When Player Takes 1 Step
  #--------------------------------------------------------------------------
  def on_player_walk
    #@result.clear
    check_floor_effect
    if $game_player.normal_walk?
      #turn_end_on_map
      states.each {|state| update_state_steps(state) }
      show_added_states
      show_removed_states
    end
  end
  #--------------------------------------------------------------------------
  # * End of Turn Processing on Map Screen
  #--------------------------------------------------------------------------
  def turn_end_on_map
    on_turn_end
    perform_map_damage_effect if @result.hp_damage > 0
  end
  #--------------------------------------------------------------------------
  # * Get general skills for hotkey bar usage
  #--------------------------------------------------------------------------
  def get_valid_skills
    skills.select{|skill| !skill.is_passive? && !skill.is_vancian?}
  end
  #--------------------------------------------------------------------------
  # * Get valid skills for hotkey bar usage
  #--------------------------------------------------------------------------
  def get_vancian_spells
    skills.select{|skill| skill.is_vancian?}
  end
  #--------------------------------------------------------------------------
  def current_ammo
    equips.at(self.class.ammo_slot_id)
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Get Class Object
  #--------------------------------------------------------------------------
  alias :ruby_class :class
  def class
    $data_classes[@class_id]
  end
  #--------------------------------------------------------------------------
  def mhp
    return (super + @mhp_plus).to_i
  end
  #--------------------------------------------------------------------------
  def mmp
    return (super + @mmp_plus).to_i
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Get Base Value of Parameter
  #--------------------------------------------------------------------------
  def param_base(param_id)
    value  = actor.param(param_id) + super(param_id)
    return value if (value || 0).to_bool
    return DND::Base_Param[param_id]
  end
  #--------------------------------------------------------------------------
  # * Get Added Value of Parameter
  #--------------------------------------------------------------------------
  def param_plus(param_id)
    equips.compact.inject(super) {|r, item| r += item.param(param_id) }
  end
  #--------------------------------------------------------------------------
  alias param_plus_dnd param_plus
  def param_plus(param_id)
    value  = param_plus_dnd(param_id)
    
    # mhp, +constitution bonus
    value += [((self.def - 10) * @level / 4).to_i, 0].max if param_id == 0
    return value
  end
  #--------------------------------------------------------------------------
  def aggressive_level
    return @aggressive_level
  end
  #--------------------------------------------------------------------------
  def next_action
    return nil if @map_char.nil?
    @map_char.next_action
  end
  #--------------------------------------------------------------------------
  def action
    return nil if @map_char.nil?
    @map_char.action
  end
  #--------------------------------------------------------------------------
  def death_graphic;    return actor.death_graphic;   end
  def death_index;      return actor.death_index;     end
  def death_pattern;    return actor.death_pattern;   end
  def death_direction;  return actor.death_direction; end
  def death_sound;      return actor.death_sound;     end
  def icon_index;       return actor.icon_index;      end
  #--------------------------------------------------------------------------
  # * Change Equipment
  #     slot_id:  Equipment slot ID
  #     item:    Weapon/armor (remove equipment if nil)
  #--------------------------------------------------------------------------
  # tag: equipment
  def change_equip(slot_id, item)
    return unless trade_item_with_party(item, equips[slot_id])
    if item
      if equip_slots[slot_id] == 1
        return unless offhoof_equippable?(equip_slots[slot_id], item)
      else
        return if equip_slots[slot_id] != item.etype_id
      end
    end
    @equips[slot_id].object = item
    refresh
  end
  #--------------------------------------------------------------------------
  # * Get Total EXP Required for Rising to Specified Level
  #--------------------------------------------------------------------------
  def exp_for_level(level)
    return (DND::EXP_FOR_LEVEL[level] * 1000).to_i
  end
  #--------------------------------------------------------------------------
  # * Change Experience, player need to level up manually form Scene_LevelUp
  #     show : Level up display flag
  #--------------------------------------------------------------------------
  def change_exp(exp, show)
    @exp = [exp, 0].max
    refresh
  end
  #--------------------------------------------------------------------------
  # * Change Experience
  #--------------------------------------------------------------------------
  alias change_exp_security change_exp
  def change_exp(exp, show)
    check_security
    change_exp_security(exp, show)
    update_security
  end
  #--------------------------------------------------------------------------
  # * The real change class in dnd not exist, using for class advance
  #--------------------------------------------------------------------------
  def change_class(class_id, keep_exp = true)
    super
  end
  #--------------------------------------------------------------------------
  def upgradeable?
    return self.exp >= next_level_exp
  end
  #--------------------------------------------------------------------------
  def init_skills
    super
  end
  #--------------------------------------------------------------------------
  # * Overwrite method: Level Up
  #--------------------------------------------------------------------------
  def level_up
    proportion = [@hp.to_f / self.mhp, @mp.to_f / self.mmp]
    super
    @mhp_plus += self.race.param(0) / 5
    @mmp_plus += Math.sqrt(self.race.param(1)) / 10
    self.hp = (proportion[0] * self.mhp).to_i
    self.mp = (proportion[1] * self.mmp).to_i
  end
  #--------------------------------------------------------------------------
  def level_up_class(cid)
    return unless cid > 0
    proportion = [@hp.to_f / self.mhp, @mp.to_f / self.mmp]
    super
    if cid == @class_id && @class_level[cid] > 1
      @mhp_plus += (self.class.param(0) * 0.7).to_i
      @mmp_plus += Math.sqrt(self.class.param(1))
    elsif cid == @dualclass_id && @class_level[cid] > 1
      @mhp_plus += (self.dualclass.param(0) * 0.7).to_i
      @mmp_plus += Math.sqrt(self.dualclass.param(1))
    end
    self.hp = (proportion[0] * self.mhp).to_i
    self.mp = (proportion[1] * self.mmp).to_i
  end
  #---------------------------------------------------------------------------
  # * Method Missing
  # ----------------------------------------------------------------------   
  # DANGER ZONE: Redirect to Actor
  #---------------------------------------------------------------------------
  def method_missing(symbol, *args)
    super(symbol, args) unless @map_char
    super(symbol, args) unless @map_char.methods.include?(symbol)
    @map_char.method(symbol).call(*args)
  end
  
end

#==============================================================================
# ** Game_Enemy
#------------------------------------------------------------------------------
#  This class handles enemies. It used within the Game_Troop class 
# ($game_troop).
#==============================================================================
class Game_Enemy < Game_Battler
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :level
  attr_accessor :rank
  #------------------------------------------------------------------------
  # * Set hashid
  #------------------------------------------------------------------------
  def hash_self
    @hashid  = enemy.hashid + self.hash
    super
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Object Initialization
  #--------------------------------------------------------------------------
  def initialize(index, enemy_id)
    super()
    @index = index
    @enemy_id = enemy_id
    enemy = $data_enemies[@enemy_id]
    @original_name = enemy.name
    @letter = ""
    @plural = false
    @screen_x = 0
    @screen_y = 0
    @battler_name = enemy.battler_name
    @battler_hue = enemy.battler_hue
    @level = 1
    case enemy.note
    when /<Chief>/i;    @rank = :chief;
    when /<Captain>/i;  @rank = :captain;
    when /<Elite>/i;    @rank = :elite;
    when /<Minion>/i;   @rank = :minion;
    when /<Critter>/i;  @rank = :critter;
    else
      @rank = :minion
    end
    @level = enemy.note =~ /<Level = (\d+)>/i ? $1.to_i : 1.to_i unless enemy.nil?
    @event = nil
    setup_dnd_battler(enemy)
    init_skills
    @skills << get_learned_skills
    @hp = mhp
    @mp = mmp
  end
  #--------------------------------------------------------------------------
  alias :is_a_obj? :is_a?
  def is_a?(cls)
    return is_a_obj?(cls) || enemy.is_a?(cls)
  end
  #--------------------------------------------------------------------------   
  def team_id
    @team_id = enemy.team_id if @team_id.nil?
    return @team_id
  end
  #--------------------------------------------------------------------------
  def face_name
    return enemy.face_name
  end
  #--------------------------------------------------------------------------
  def face_index
    return enemy.face_index
  end
  #---------------------------------------------------------------------------
  def get_learned_skills
    enemy.actions.collect{|action| $data_skills[action.skill_id] }
  end
  #---------------------------------------------------------------------------
  def skills
    @skills
  end
  #---------------------------------------------------------------------------
  def weapon_ammo_ready?(weapon)
    return true
  end
  #---------------------------------------------------------------------------
  def weapon_level_prof
    enemy.weapon_level_prof
  end
  #---------------------------------------------------------------------------
  def secondary_weapon
    enemy.secondary_weapon
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Get Base Value of Parameter
  #--------------------------------------------------------------------------
  def param_base(param_id)
    value  = enemy.params[param_id] + super(param_id)
    return value if (value || 0).to_bool
    return DND::Base_Param[param_id]
  end
  #---------------------------------------------------------------------------
  # * Method Missing
  # ----------------------------------------------------------------------   
  # DANGER ZONE: Redirect to Actor
  #---------------------------------------------------------------------------
  def method_missing(symbol, *args)
    super(symbol, args) unless @map_char
    super(symbol, args) unless @map_char.methods.include?(symbol)
    @map_char.method(symbol).call(*args)
  end
  #---------------------------------------------------------------------------
  def determine_skill_usage
    action_list = enemy.actions.select {|a| action_valid?(a) }
    return if action_list.empty?
    list = action_list.sort{|a, b| b.rating <=> a.rating}
    list.select!{|a| item_test(self, $data_skills[a.skill_id]) && usable?($data_skills[a.skill_id])}
    skill = $data_skills[list.first.skill_id] rescue nil
    
    return skill
  end
  #---------------------------------------------------------------------------
  def load_tactic_commands
    @tactic_commands = TacticCommandModule.load_template(:basic, self)
  end
  
end

#==============================================================================
# ** Game_Actors
#------------------------------------------------------------------------------
#  This is a wrapper for an actor array. Instances of this class are referenced
# by $game_actors.
#==============================================================================
class Game_Actors
  
end

#==============================================================================
# ** Game_Unit
#------------------------------------------------------------------------------
#  This class handles units. It's used as a superclass of the Game_Party and
# and Game_Troop classes.
#==============================================================================
class Game_Unit
  
  def in_combat?
    return BattleManager.in_battle?
  end
  
end

#==============================================================================
# ** Game_Party
#------------------------------------------------------------------------------
#  This class handles parties. Information such as gold and items is included.
# Instances of this class are referenced by $game_party.
#==============================================================================
class Game_Party < Game_Unit
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :chromastal                     # Chromastal mined value
  attr_accessor :skillbar
  attr_reader   :encrypted
  attr_reader   :dead_confirm_timer
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias init_chromastal initialize
  def initialize
    @gold = 0
    init_chromastal
    @chromastal = 0.0
    @dead_confirm_timer = 0
    @skillbar = Game_Skillbar.new
    @skillbar.hide
    @encrypted = true
  end
  #--------------------------------------------------------------------------
  # * Consume Items
  #    If the specified object is a consumable item, the number in investory
  #    will be reduced by 1.
  #--------------------------------------------------------------------------
  def consume_item(item)
    lose_item(item, 1, false, nil, nil, false) if item.is_a?(RPG::Item) && item.consumable
  end
  #--------------------------------------------------------------------------
  # * Gold & Max gold
  #--------------------------------------------------------------------------
  def gold(quick_access = true)
    @gold = BlockChain.account_balance(Vocab::Player) if !quick_access
    return @gold
  end
  #--------------------------------------------------------------------------
  def max_gold; return 10 ** 6; end
  #--------------------------------------------------------------------------  
  # * Mining reward
  #--------------------------------------------------------------------------
  def mining_reward(value)
    @chromastal += value
    if @chromastal >= 1.0
      amount = @chromastal.to_i
      @chromastal -= amount
      gain_item($data_items[42], amount)
    end
  end
  #--------------------------------------------------------------------------
  # * Increase Gold
  #--------------------------------------------------------------------------
  def gain_gold(amount, opp = Vocab::Coinbase, info = '')
    return if amount == 0
    amount   = [max_gold - gold(true), amount].min
    overflow = (gold(true) + amount) > max_gold
    source   = amount < 0 ? Vocab::Player : opp
    receiver = amount > 0 ? Vocab::Player : opp
    BlockChain.bits_transaction(amount.abs, source, receiver, info)
    @gold += amount
    $game_player.popup_info(amount.to_s, nil, PONY::IconID[:bit]) if SceneManager.scene_is?(Scene_Map) && amount > 0
    word = amount < 0 ? Vocab::Party::WordLost : Vocab::Party::WordGain
    info = sprintf(Vocab::Party::GoldGain, word, amount.abs, overflow ? Vocab::Party::Limited : "")
    SceneManager.display_info(info)
  end
  #--------------------------------------------------------------------------
  # * Decrease Gold
  #--------------------------------------------------------------------------
  def lose_gold(amount, receiver = Vocab::Coinbase, info = '')
    gain_gold(-amount, receiver, info)
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Get Number of Items Possessed
  #--------------------------------------------------------------------------
  def item_number(item)
    return nil if item.nil?
    container = item_container(item.class)
    container ? container[item.id] || 0 : 0
  end
  #--------------------------------------------------------------------------
  # * Synchronize data with Block Chain
  #--------------------------------------------------------------------------
  def sync_blockchain(item = nil)
    return if BlockChain.node_empty?
    puts "[BlockChain]: Synchronize party container"
    pc = Vocab::Player
    if item.nil?
      data = BlockChain.all_data(pc)
      @items.each do |key, number|
        @items[key] = data[:item][$data_items[key].hashid]
        @items.delete(key) if @items[key] <= 0
      end
      @weapons.each do |key, number|
        @weapons[key] = data[:weapon][$data_weapons[key].hashid]
        @weapons.delete(key) if @weapons[key] <= 0
      end
      @armors.each do |key, number|
        @armors[key] = data[:armor][$data_armors[key].hashid]
        @armors.delete(key) if @armors[key] <= 0
      end
      @gold = data[:gold]
    else
      container = item_container(item.class)
      container[item.id] = BlockChain.item_amount(pc, item)
    end
    encrypt_data
  end
  #--------------------------------------------------------------------------
  # * Increase/Decrease Items
  #     include_equip : Include equipped items
  #--------------------------------------------------------------------------
  alias gain_item_origin gain_item
  def gain_item(item, amount, include_equip = false, opp = Vocab::Coinbase, info = '', display_info = true)
    decrypt_data
    opp  = Vocab::Coinbase if opp.nil?
    info = '' if info.nil?
    container = item_container(item.class)
    return encrypt_data unless container
    last_number = item_number(item)
    new_number  = [[last_number + amount, -1].max, max_item_number(item)].min
    container.delete(item.id) if new_number == 0
    discard_members_equip(item, -new_number) if include_equip && new_number < 0
    new_number = [new_number, 0].max
    $game_party.skillbar.need_refresh = true
    return encrypt_data unless last_number != new_number
    
    # source is who pay the bits, thus source will gain the item
    source   = amount > 0 ? Vocab::Player : opp
    receiver = amount < 0 ? Vocab::Player : opp
    BlockChain.item_transaction(item, (new_number - last_number).abs, source, receiver, info)
    container[item.id] = new_number
    container.delete(item.id) if container[item.id] == 0
    word = amount < 0 ? Vocab::Party::WordLost : Vocab::Party::WordGain
    info = sprintf(Vocab::Party::ItemGain, word, amount.abs)
    SceneManager.display_info(info) if display_info
    
    # tag: effectus
    #trigger_symbol = :"item_id_#{item.id}"
    #unless $game_temp.effectus_triggers.include?(trigger_symbol)
    #  $game_temp.effectus_triggers << trigger_symbol
    #end
    #$game_map.effectus_need_refresh = true
    
    #$game_map.need_refresh = true
    $game_party.skillbar.need_refresh = true
    $game_player.popup_info(item.name, nil, item.icon_index) if SceneManager.scene_is?(Scene_Map) && amount > 0
    encrypt_data
  end
  #--------------------------------------------------------------------------
  # * Lose Items
  #     include_equip : Include equipped items
  #--------------------------------------------------------------------------
  def lose_item(item, amount, include_equip = false, opp = Vocab::Coinbase, info = '', display = true)
    gain_item(item, -amount, true, opp, info, display)  if include_equip
    gain_item(item, -amount, false, opp, info, display) if !include_equip
  end
  #--------------------------------------------------------------------------
  def encrypt_data
    return # tag: queued >> security
    return if @encrypted
    @items.each do |key, number|
      @items[key] = PONY.EncryptInt(@items[key])
    end
    @weapons.each do |key, number|
      @weapons[key] = PONY.EncryptInt(@weapons[key])
    end
    @armors.each do |key, number|
      @armors[key] = PONY.EncryptInt(@armors[key])
    end
    @gold = PONY.EncryptInt(@gold)
    @encrypted = true
  end
  #--------------------------------------------------------------------------
  def decrypt_data
    return # tag: queued >> security
    return unless @encrypted
    @items.each do |key, number|
      @items[key] = PONY.DecryptInt(@items[key])
    end
    @weapons.each do |key, number|
      @weapons[key] = PONY.DecryptInt(@weapons[key])
    end
    @armors.each do |key, number|
      @armors[key] = PONY.DecryptInt(@armors[key])
    end
    @gold = PONY.DecryptInt(@gold)
    @encrypted = false
  end
  #--------------------------------------------------------------------------
  # * Swap order
  #--------------------------------------------------------------------------
  alias swap_order_opt swap_order
  def swap_order(index1, index2)
    @battle_members_array[index1], @battle_members_array[index2] = @battle_members_array[index2], @battle_members_array[index1]
    puts "Battler array: #{index1} #{index2} #{@battle_members_array[index1]} #{@battle_members_array[index2]}"
    members[index1].map_char.swap_member(members[index2].map_char)
    members[index1].map_char, members[index2].map_char = members[index2].map_char, members[index1].map_char
    $game_map.need_refresh = true
    swap_order_opt(index1, index2)
    rearrange_actors
    members.each {|member| member.map_char.process_actor_death if member.dead?}
    $game_player.current_target = nil
    SceneManager.immediate_refresh
  end
  #--------------------------------------------------------------------------
  # * Return usable general items for hotkey usage
  #--------------------------------------------------------------------------
  def get_valid_items
    list = []
    @items.each do |id, number|
      item = $data_items[id]
      list << item if item.for_friend? || item.for_opponent?
    end
    return list
  end
  #--------------------------------------------------------------------------
  # * Change current control character to next alive member
  #--------------------------------------------------------------------------
  def recurrence_leader
    all_members.each_with_index do |member, index|
      next if member.dead?
      next if member == leader
      if !@battle_members_array.include?(member.actor.id)
        @battle_members_array << member.actor.id
      end
      swap_order(0, index)
      puts "recurrence leader: #{all_members[0].name} <=> #{all_members[index].name}"
      break
    end
    $game_player.recurrence_delay = nil
  end
  #--------------------------------------------------------------------------
  # * Make all party member's exp as closer as possible
  #--------------------------------------------------------------------------
  def gain_exp(xp)
    return if xp == 0
    info = sprintf(Vocab::Party::EXPGain, xp)
    SceneManager.display_info(info)
    # Number of pones
    msize  = members.size
    # xp that disputed
    disputed = 0
    # average xp of the party
    xp_avg = 0 
    # average xp for everypony
    xp_gained_avg = (xp / msize).to_i 
    # calculate average xp of the party
    members.each{|member| xp_avg += member.exp}
    xp_avg = (xp_avg / msize).to_i
    # Calculate tandard Deviation of party's xp
    standard_deviation = 0
    members.each do |member|
      standard_deviation += (member.exp - xp_avg) ** 2
    end
    standard_deviation = (Math.sqrt(standard_deviation / msize)).to_f
    # Dispute weighted xp gain
    member_by_min = members.sort{|a, b| a.exp <=> b.exp}
    member_by_min.each do |member|
      standardized  = member.exp - xp_avg
      standardized /= standard_deviation if standard_deviation > 0
      xp_gained     = (xp_gained_avg - standardized * standard_deviation).to_i
      xp_gained = 0 if xp_gained < 0
      xp_gained = (xp - disputed) / 2 if xp_gained > (xp - disputed)
      puts "#{member.name} gained xp: #{xp_gained}"
      disputed += xp_gained
      member.gain_exp(xp_gained)
    end
    # Dispute lefover averagely
    leftover = xp - disputed
    members.each do |member|
      gained = (leftover / msize).to_i
      disputed += gained
      member.gain_exp(gained)
    end
    # Dispute final very very few lefover to leader
    leader.gain_exp(xp - disputed)
  end
  #--------------------------------------------------------------------------
  def gathered?
    members.each do |member|
      next if !member.map_char
      return false if member.map_char.distance_to_character($game_player) > 3
    end
    return true
  end
  #--------------------------------------------------------------------------
  # * Determine if Everyone is Dead
  #--------------------------------------------------------------------------
  def all_dead?(check_only = false)
    return false if !check_only && !$game_system.allow_gameover?
    re = super() && ($game_party.in_battle || members.size > 0)
    @dead_confirm_timer = 0 if @dead_confirm_timer.nil?
    @dead_confirm_timer = re ? @dead_confirm_timer + 1 : 0
    BattleManager.send_flag(in_battle: true) if re
    return re && @dead_confirm_timer > 180
  end
  #--------------------------------------------------------------------------
  # * Add an Actor. tag: effectus                                       [REP]
  #--------------------------------------------------------------------------
  def add_actor(actor_id)
    @actors.push(actor_id) unless @actors.include?(actor_id)
    $game_player.refresh
    trigger_symbol = :"actor_id_#{actor_id}"
    unless $game_temp.effectus_triggers.include?(trigger_symbol)
      $game_temp.effectus_triggers << trigger_symbol
    end
    $game_map.effectus_need_refresh = true
  end
  #--------------------------------------------------------------------------
  # * Remove Actor.                                                     [REP]
  #--------------------------------------------------------------------------
  def remove_actor(actor_id)
    @actors.delete(actor_id)
    $game_player.refresh
    trigger_symbol = :"actor_id_#{actor_id}"
    unless $game_temp.effectus_triggers.include?(trigger_symbol)
      $game_temp.effectus_triggers << trigger_symbol
    end
    $game_map.effectus_need_refresh = true
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Initial Party Setup
  #--------------------------------------------------------------------------
  def setup_starting_members(mode)
    init_actid = mode.init_party || []
    if init_actid.empty?
      @actors = $data_system.party_members.clone
    else
      @actors = init_actid
    end
    #-- validate actors
    @actors.each do |id|
      next if (id || 0).between?(1, $data_actors.size - 1)
      raise "Invalid starting actor id in GameMode #{mode.name}"
    end
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Troop
#------------------------------------------------------------------------------
#  This class handles enemy groups and battle-related data. Also performs
# battle events. The instance of this class is referenced by $game_troop.
#==============================================================================
class Game_Troop < Game_Unit
  
end

#==============================================================================
# ** Game_Map
#------------------------------------------------------------------------------
#  This class handles maps. It includes scrolling and passage determination
# functions. The instance of this class is referenced by $game_map.
#==============================================================================
class Game_Map
  #--------------------------------------------------------------------------
  # * Characters to be added to the end of enemy names
  #--------------------------------------------------------------------------
  LETTER_TABLE_HALF = [' A',' B',' C',' D',' E',' F',' G',' H',' I',' J',
                       ' K',' L',' M',' N',' O',' P',' Q',' R',' S',' T',
                       ' U',' V',' W',' X',' Y',' Z']
  LETTER_TABLE_FULL = ['Ａ','Ｂ','Ｃ','Ｄ','Ｅ','Ｆ','Ｇ','Ｈ','Ｉ','Ｊ',
                       'Ｋ','Ｌ','Ｍ','Ｎ','Ｏ','Ｐ','Ｑ','Ｒ','Ｓ','Ｔ',
                       'Ｕ','Ｖ','Ｗ','Ｘ','Ｙ','Ｚ']
  #--------------------------------------------------------------------------
  #  Constants
  #--------------------------------------------------------------------------
  Battler_Updates   = 20
  ProjPoolSize      = 20
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :map
  attr_reader   :max_width, :max_height
  attr_reader   :enemy_names_count
  attr_accessor :action_battlers, :unit_table
  attr_accessor :timer, :timestop_timer
  attr_accessor :enemies
  attr_accessor :accurate_character_info
  attr_accessor :event_battler_instance, :queued_actions
  attr_reader   :item_drops, :projectile_pool, :cache_projectile
  attr_accessor :fog_enabled                      # Light effect fog
  attr_reader   :active_enemies, :active_enemy_count
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias initialize_opt initialize
  def initialize
    @timer           = 0
    @timestop_timer  = 0
    @item_drops      = {}
    @accurate_character_info = {}
    @event_battler_instance   = {}
    @enemies            = []
    @queued_actions     = []
    @active_enemies     = []
    @projectile_pool    = []
    @cache_projectile   = []
    @flag_after_load    = false
    @fog_enabled        = false
    @enemy_update_index = 0
    @active_enemy_count = 0
    allocate_pools
    init_battle_members
    initialize_opt
    set_max_edge
  end
  #--------------------------------------------------------------------------
  def map
    @map
  end
  #--------------------------------------------------------------------------
  def set_max_edge
    @max_width  = (Graphics.width / 32).truncate
    @max_height = (Graphics.height / 32).truncate
  end
  #--------------------------------------------------------------------------
  def init_battle_members
    @action_battlers   = {}
    @unit_table        = {}
    @enemy_names_count = {}
    BattleManager::Team_Number.times {|key| @action_battlers[key] = Array.new()}
  end
  #--------------------------------------------------------------------------
  def assign_party_battler
    @action_battlers[0] = $game_party.battle_members
    @enemies.each do |battler|
      @action_battlers[0] << battler if battler.team_id == 0
    end
  end
  #--------------------------------------------------------------------------
  # * Setup
  # tag: loading
  #--------------------------------------------------------------------------
  def setup(map_id)
    dispose_sprites
    dispose_item_drops
    save_battler_instance if @map_id > 0
    @event_battler_instance[map_id] = Hash.new if @event_battler_instance[map_id].nil?
    clear_battlers
    SceneManager.dispose_temp_sprites if map_id != @map_id
    BattleManager.setup
    
    debug_print "Setup map: #{map_id}"
    SceneManager.reserve_loading_screen(map_id)
    Graphics.fadein(60)
    SceneManager.set_loading_phase("Mining Block Chain", -1)
    
    @active_enemies.clear
    @active_enemy_count = 0
    BlockChain.mining
    $game_party.sync_blockchain
    setup_battlers
    setup_loading(map_id)
    setup_camera
    load_map_settings
    @item_drops[@map_id] = Array.new if @item_drops[@map_id].nil?
    referesh_vehicles
    setup_events
    setup_scroll
    setup_parallax
    setup_battleback
    @need_refresh = false
    @map.battle_bgm = $battle_bgm
    @backup = nil
    deploy_map_item_drops
    after_setup
  end
  #--------------------------------------------------------------------------
  def setup_loading(map_id)
    @map_id = map_id
    @map = load_data(sprintf("Data/Map%03d.rvdata2", @map_id))
    load_total = 4 + @map.events.size + 10
    load_total = 180 if load_total < 180
    SceneManager.set_loading_phase('Load Map', load_total)
  end
  #--------------------------------------------------------------------------
  def setup_camera
    @tileset_id = @map.tileset_id
    @display_x = 0
    @display_y = 0
  end
  #--------------------------------------------------------------------------
  def load_map_settings
    @fog_enabled = false
    @map.note.split(/[\r\n]+/).each do |line|
      case line
      when DND::REGEX::Map::LightEffect
        @fog_enabled = $1.to_i
      end
    end
    
    if $game_map.fog_enabled
      puts "Fog enabled: #{@fog_enabled}"
      $game_map.effect_surface.change_color(60,0,0,0,@fog_enabled)
    else
      puts "Fog disbled"
      $game_map.effect_surface.change_color(60,255,255,0,0)
    end
  end
  #--------------------------------------------------------------------------
  # * Setup battler
  #--------------------------------------------------------------------------
  def setup_battlers
    $game_party.battle_members[0].map_char = $game_player
    $game_player.followers.each do |follower|
      SceneManager.update_loading # tag: loading
      next if !follower.actor
      follower.actor.map_char = follower
    end
    assign_party_battler
  end
  #--------------------------------------------------------------------------
  # * Event Setup
  #--------------------------------------------------------------------------
  def setup_events
    @events  = {}
    
    @map.events.each do |i, event|
      SceneManager.update_loading # tag: loading
      eve = Game_Event.new(@map_id, event)
      next if eve.terminated?
      @events[i] = eve
    end
    
    @common_events = parallel_common_events.collect do |common_event|
      Game_CommonEvent.new(common_event.id)
    end
    refresh_tile_events
  end
  #--------------------------------------------------------------------------
  # * Processes after setups
  #--------------------------------------------------------------------------
  def after_setup
    $game_player.center($game_player.new_x, $game_player.new_y) if SceneManager.scene_is?(Scene_Map)
    SceneManager.update_loading while SceneManager.loading?
    SceneManager.destroy_loading_screen unless $game_temp.loading_destroy_delay
  end
=begin
  #-----------------------------------------------------------------------------
  # * Overwrite method : Refresh
  # > Moved from Theo Anti-Lag
  #-----------------------------------------------------------------------------
  def refresh
    BattleManager.refresh
    SceneManager.spriteset.refresh rescue nil
    return table_refresh if table_update? && Theo::AntiLag::PageCheck_Enchancer
    @events.each_value {|event| next if event.never_refresh; event.refresh }
    @common_events.each {|event| event.refresh }
    refresh_tile_events
    @need_refresh = false
  end
=end
  #--------------------------------------------------------------------------
  # * Refresh.                                                          [REP]
  #--------------------------------------------------------------------------
  def refresh
    BattleManager.refresh
    SceneManager.spriteset.refresh rescue nil
    @tile_events = []
    @events.each_value do |event|
      event.refresh
      event.tile? && @tile_events << event
    end
    @common_events.each { |event| event.refresh }
    @need_refresh = false
  end
  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  alias refresh_map_dnd refresh
  def refresh
    setup_battlers
    refresh_map_dnd
    debug_print "Map Refreshed"
  end
  #--------------------------------------------------------------------------
  # * Overwrite : Update, moved from effectus for compatible
  #--------------------------------------------------------------------------
  def update(main = false)
    @last_pa = [@parallax_x, @parallax_y]
    refresh                  if @need_refresh
    effectus_trigger_refresh if @effectus_need_refresh
    if main
      update_interpreter 
    else
      update_events
      update_vehicles
    end
    update_scroll
    update_parallax
    @screen.update
    @effectus_dref_display_x = (@display_x * 32).floor / 32.0
    @effectus_dref_display_y = (@display_y * 32).floor / 32.0
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #     main:  Interpreter update flag
  #--------------------------------------------------------------------------
  # tag: timeflow
  alias update_gmap_timer update
  def update(main = false)
    update_timer
    update_drops
    update_queued_actions
    update_enemies
    update_gmap_timer(main)
  end
  #--------------------------------------------------------------------------
  def update_queued_actions
    @queued_actions.each do |action|
      action.effect_delay -= 1
      if action.effect_delay <= 0
        BattleManager.apply_action_effect(action) 
        @queued_actions.delete(action)
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Update timer 
  #--------------------------------------------------------------------------
  def update_timer
    @timer += 1
    process_battler_regenerate if @timer % DND::BattlerSetting::RegenerateTime == 0
    process_timecycle_end      if @timer >= PONY::TimeCycle
  end
  #-----------------------------------------------------------------------------
  # * Overwrite method : Update events
  #-----------------------------------------------------------------------------
  def update_events  
    @events.each_value do |event|
      event.update unless event.frozen?
      terminate_event(event) if event.terminated?
    end
    @common_events.each {|event| event.update}
  end
  #--------------------------------------------------------------------------
  # * Update NPC battler
  #-------------------------------------------------------------------------
  def update_enemies
    @active_enemy_count = [@active_enemy_count, 0].max
    return if @active_enemy_count == 0
    
    battler = @active_enemies[@enemy_update_index]
    if battler.nil?
      @active_enemies = @active_enemies.compact
      @active_enemy_count = @active_enemies.size
    elsif battler.current_target && battler.current_target.dead?
      battler.process_target_dead
    elsif battler.effectus_near_the_screen?
      battler.update_battler
    else
      battler.process_target_missing
    end
    return if @active_enemy_count == 0
    @enemy_update_index = (@enemy_update_index + 1) % @active_enemy_count
  end
  #--------------------------------------------------------------------------
  def remove_active_enemy(enemy)
    @active_enemies.delete(enemy)
    @active_enemy_count -= 1
  end
  #--------------------------------------------------------------------------
  def add_active_enemy(enemy)
    return if @active_enemies.include?(enemy)
    @active_enemies << enemy
    @active_enemy_count += 1
  end
  #--------------------------------------------------------------------------
  def process_battler_regenerate
    BattleManager.regenerate_all
  end
  #--------------------------------------------------------------------------
  def process_timecycle_end
    @timer = 0
    BattleManager.on_turn_end
    BattleManager.clear_flag(:in_battle)
  end
  #--------------------------------------------------------------------------
  def terminate_event(event)
    puts "Terminate event: #{event.id}"
    @events.delete(event.id)
    SceneManager.spriteset.dispose_event(event)
    
    # Theo's anti-lag
    #@cached_events.delete(event) if @cached_events
    #@keep_update_events.delete(event) if @keep_update_events
    #@forced_update_events.delete(event) if @forced_update_events
  end
  #--------------------------------------------------------------------------
  # * Push character into active battlers
  #--------------------------------------------------------------------------
  def register_battler(battler)
    if @unit_table[battler.hashid]
      debug_print "Battler register failed: #{battler}"
      return
    end
    @enemies << battler
    @action_battlers[battler.team_id] << battler
    @unit_table[battler.hashid] = battler
    SceneManager.scene.register_battle_unit(battler) if SceneManager.scene_is?(Scene_Map)
  end
  #--------------------------------------------------------------------------
  # * Remove unit
  #--------------------------------------------------------------------------
  def resign_battle_unit(battler)
    @enemies.delete(battler)
    @action_battlers[battler.team_id].delete(battler)
    @unit_table[battler.hashid] = nil
    debug_print "Battler resigned #{battler}"
    SceneManager.scene.resign_battle_unit(battler) if SceneManager.scene_is?(Scene_Map)
  end
  #--------------------------------------------------------------------------
  def all_battlers
    re = []
    @action_battlers.each do |key, team|
      team.each {|battler| re << battler}
    end
    return re
  end
  #--------------------------------------------------------------------------
  def all_alive_battlers
    re = []
    @action_battlers.each do |key, battlers|
      battlers.each {|battler| re << battler unless battler.dead?}
    end
    return re
  end
  #--------------------------------------------------------------------------
  def dead_battlers
    re = []
    @action_battlers.each do |key, battlers|
      battlers.each {|battler| re << battler if battler.dead?}
    end
    return re
  end
  #--------------------------------------------------------------------------
  # * Return alive allied battlers
  #--------------------------------------------------------------------------
  def ally_battler(battler = $game_palyer)
    return @action_battlers[battler.team_id].compact.select{|char| !char.dead?}
  end
  #--------------------------------------------------------------------------
  # * Return dead allies
  #--------------------------------------------------------------------------
  def dead_allies(battler = $game_player)
    return @action_battlers[battler.team_id].compact.select{|char| char.dead?}
  end
  #--------------------------------------------------------------------------
  # * Return alive hostile battlers
  #--------------------------------------------------------------------------
  def opponent_battler(battler = $game_player)
    opponents = []
    @action_battlers.each do |key, members|
      next if key == battler.team_id
      members.compact.each do |member|
        next if member.dead?
        opponents.push(member)
      end
    end
    return opponents
  end
  #--------------------------------------------------------------------------
  # * Return dead hostile battlers
  #--------------------------------------------------------------------------
  def dead_opponents(battler = $game_player)
    opponents = []
    @action_battlers.each do |key, members|
      next if key == battler.team_id
      members.compact.each do |member|
        next unless member.dead?
        opponents.push(member)
      end
    end
    return opponents
  end
  #--------------------------------------------------------------------------
  # * Add letters (ABC, etc) to enemy characters with the same name
  #--------------------------------------------------------------------------
  def make_unique_names
    @enemies.each do |enemy|
      next unless enemy.alive?
      next unless enemy.letter.empty?
      n = @enemy_names_count[enemy.original_name] || 0
      enemy.letter = letter_table[n % letter_table.size]
      @enemy_names_count[enemy.original_name] = n + 1
    end
    @enemies.each do |enemy|
      n = @enemy_names_count[enemy.original_name] || 0
      enemy.plural = true if n >= 2
    end
  end
  #--------------------------------------------------------------------------
  # * Get Text Table to Place Behind Enemy Name
  #--------------------------------------------------------------------------
  def letter_table
    $game_system.japanese? ? LETTER_TABLE_FULL : LETTER_TABLE_HALF
  end
  #--------------------------------------------------------------------------
  def on_game_save
    dispose_sprites
    dispose_lights
    dispose_item_drops
    @events.each do |key, event|
      hkey = "E" + key.to_s
      pos  = [POS.new(event.real_x, event.real_y),
              POS.new(event.x, event.y),
              POS.new(event.px, event.py)]
              
      dir  = event.direction
      info = {:pos => pos, :dir => dir}
      @accurate_character_info[hkey] = info
    end
    key = 0
    $game_player.followers.each do |follower|
      hkey = "F" + key.to_s
      pos  = [POS.new(follower.real_x, follower.real_y),
              POS.new(follower.x, follower.y), 
              POS.new(follower.px, follower.py)]
              
      dir  = follower.direction
      info = {:pos => pos, :dir => dir}
      @accurate_character_info[hkey] = info
      key += 1
    end
    save_battler_instance
    super_dispose
  end
  #--------------------------------------------------------------------------
  def dispose_sprites
    @events.each do |key, event|
      event.dispose_sprites
    end
  end
  #--------------------------------------------------------------------------
  def after_game_load
    @flag_after_load = true
  end
  #--------------------------------------------------------------------------
  def on_after_load
    @enemy_names_count = {}
    @flag_after_load = false
    relocate_events
    all_battlers.each do |battler|
      resign_battle_unit(battler) if !BattleManager.valid_battler?(battler)
    end
    debug_print "Action battler count: #{all_battlers.size}"
    make_unique_names
    $game_party.members.each do |member|
      member.assigned_hotkey.each_with_index do |item, index|
        next unless item
        member.assigned_hotkey[index] = $data_weapons[item.id] if item.is_weapon?
        member.assigned_hotkey[index] = $data_armors[item.id]  if item.is_armor?
        member.assigned_hotkey[index] = $data_items[item.id]   if item.is_item?
        member.assigned_hotkey[index] = $data_skills[item.id]  if item.is_skill?
      end
    end
  end
  #--------------------------------------------------------------------------
  def clear_battlers
    all_battlers.each do |battler|
      resign_battle_unit(battler)
    end
    init_battle_members
  end
  #--------------------------------------------------------------------------
  def relocate_events
    @accurate_character_info.each do |key, info|
      id = key.dup; id.slice!(0); id = id.to_i;
      pos = info[:pos]
      if key[0] == "E"
        next if @events[id].nil?
        @events[id].load_position(*pos)
        @events[id].set_direction(info[:dir])
        @events[id].setup_quadtree_index
      elsif key[0] == "F"
        next if $game_player.followers[id].nil?
        $game_player.followers[id].load_position(*pos)
        $game_player.followers[id].set_direction(info[:dir])
        $game_player.followers[id].setup_quadtree_index
      end
    end
    @accurate_character_info.clear
  end
  #--------------------------------------------------------------------------
  def update_vehicles
  end
  #--------------------------------------------------------------------------
  def update_drops
    @item_drops[@map_id].each do |drops|
      @item_drops[@map_id].delete(drops) if drops.picked?
      drops.update
    end
  end
  #--------------------------------------------------------------------------
  def deploy_map_item_drops
    @item_drops[@map_id] = Array.new if @item_drops[@map_id].nil?
    @item_drops[@map_id].each do |drops|
      next if drops.sprite_valid?
      deploy_item_drop(drops)
    end
  end
  #--------------------------------------------------------------------------
  def dispose_item_drops
    @item_drops[@map_id] = Array.new if @item_drops[@map_id].nil?
    @item_drops[@map_id].each do |drops|
      drops.dispose
    end
  end
  #--------------------------------------------------------------------------
  def register_item_drop(x, y, gold, loots)
    return if loots.empty? && gold < 1
    @item_drops[@map_id].each do |drop|
      if (drop.x - x).abs < 1 && (drop.y - y).abs < 1
        return drop.merge(gold, loots)
      end
    end
    loots.unshift(gold)
    drops = Game_DroppedItem.new(@map_id, x, y, loots)
    @item_drops[@map_id] << drops
    deploy_item_drop(drops)
  end
  #--------------------------------------------------------------------------
  def deploy_item_drop(drops)
    return if drops.map_id != @map_id
    drops.deploy_sprite
  end
  #--------------------------------------------------------------------------
  def refresh_condition_events
    @events.each_value do |eve|
      eve.refresh if eve.condition_flag
    end
  end
  #--------------------------------------------------------------------------
  def save_battler_instance
    @event_battler_instance[@map_id] = Hash.new if @event_battler_instance[@map_id].nil?
    @events.each do |key, event|
      @event_battler_instance[@map_id][key] = event.enemy if BattleManager.valid_battler?(event) && !event.dead?
    end
  end
  #--------------------------------------------------------------------------
  def all_dead?(team_id)
    return !(@enemies.select{|c| c.team_id == team_id}.any?{|b| !b.dead?})
  end
  #--------------------------------------------------------------------------
  def cache_crash_backup
    @backup = Marshal.dump($game_map) rescue @backup
  end
  #--------------------------------------------------------------------------
  def get_cached_backup
    return @backup
  end
  #--------------------------------------------------------------------------
  def dispose_lights
    @lantern.dispose if @lantern
    @surfaces.each{|s| s.dispose} if @surfaces
    @light_sources.each { |source| source.dispose_light } if @light_sources
    if @light_surface
      @light_surface.bitmap.dispose
      @light_surface.dispose
      @light_surface = nil
    end
  end
  #--------------------------------------------------------------------------
  def super_dispose
    instance_variables.each do |varname|
      ivar = instance_variable_get(varname)
      ivar.dispose if ivar.is_a?(Window) || ivar.is_a?(Sprite) || ivar.is_a?(Bitmap)
    end
  end
  #--------------------------------------------------------------------------
  # * Store projectiles
  #--------------------------------------------------------------------------
  def store_projectile(projs)
    debug_print "Projectile stored (#{projs.size})"
    @cache_projectile = projs.dup
    @cache_projectile.each{|proj| proj.dispose_sprite}
  end
  #--------------------------------------------------------------------------
  # * Retrieve stored cache
  #--------------------------------------------------------------------------
  def get_cached_projectile
    return @cache_projectile
  end
  #--------------------------------------------------------------------------
  def clear_projectiles
    debug_print "Clear projectiles cache (#{@cache_projectile.size})"
    @cache_projectile.clear
  end
  #--------------------------------------------------------------------------
  def allocate_pools
    ProjPoolSize.times{|i| self.allocate_proj}
  end
  #--------------------------------------------------------------------------
  def allocate_proj
    proj = Game_Projectile.allocate
    proj.deactivate
    @projectile_pool << proj
  end
  #--------------------------------------------------------------------------
  def get_idle_proj
    re = @projectile_pool.find{|proj| !proj.active?}
    re
  end
  #--------------------------------------------------------------------------
  def tile_proj_passable?(x, y)
    return ($game_map.region_id(x, y) & PONY::Bitset[2]).to_bool
  end
  #--------------------------------------------------------------------------
  def get_tile_altitude(x,y)
    bits = PONY::Bitset[0] | PONY::Bitset[1]
    return $game_map.region_id(x, y) & bits
  end
  #--------------------------------------------------------------------------
  alias region_id_fixed region_id
  def region_id(x, y)
    rx = ((x * 4 % Pixel_Core::Pixel) > 1 ? x.to_i + 1 : x.to_i)
    ry = ((y * 4 % Pixel_Core::Pixel) > 1 ? y.to_i + 1 : y.to_i)
    rx = [[width-1,rx].min, 0].max; ry = [[height-1,ry].min, 0].max;
    re = region_id_fixed(rx, ry)
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Map
#------------------------------------------------------------------------------
#  This class handles maps. It includes scrolling and passage determination
# functions. The instance of this class is referenced by $game_map.
#==============================================================================
module Effectus
  UsePassable = true
end
class Game_Map
  #--------------------------------------------------------------------------
  SpacePartitionRange = 5
  #--------------------------------------------------------------------------
  # * Public Instance Variables.                                        [NEW]
  #--------------------------------------------------------------------------
  attr_accessor :effectus_event_pos, :effectus_party_pos,
                :effectus_etile_pos, :effectus_hard_events,
                :effectus_events_to_update, :effectus_pass_table,
                :effectus_event_starting, :effectus_etriggers,
                :effectus_tile_events, :effectus_need_refresh
  attr_accessor :collision_quadtree
  #--------------------------------------------------------------------------
  # * Setup.                                                            [REP]
  #--------------------------------------------------------------------------
  alias setup_effectus setup
  def setup(map_id)
    @effectus_dref_display_x   = 0
    @effectus_dref_display_y   = 0
    @effectus_event_starting   = nil
    @effectus_events_to_update = []
    @effectus_hard_events      = []
    @effectus_tile_events      = []
    @effectus_initial_run      = nil
    @effectus_ody              = nil
    @effectus_odx              = nil
    @effectus_party_pos        = Hash.new { |hash, key| hash[key] = [] }
    @effectus_event_pos        = Hash.new { |hash, key| hash[key] = [] }
    @effectus_etile_pos        = Hash.new { |hash, key| hash[key] = [] }
    @effectus_etriggers        = Hash.new { |hash, key| hash[key] = [] }
    @effectus_need_refresh     = false
    setup_effectus(map_id)
    setup_collision_quadtree
    setup_character_quadtree_index
    
    @effectus_pass_table = Table.new($game_map.width, $game_map.height, 4)
    $game_player.followers.each do |follower|
      follower.effectus_position_registered = false
    end
    @effectus_adjx = (width  - screen_tile_x) / 2
    @effectus_adjy = (height - screen_tile_y) / 2
  end
  #--------------------------------------------------------------------------
  # * Refresh Tile Events.                                              [REP]
  #--------------------------------------------------------------------------
  def effectus_refresh_tile_events
    @tile_events = []
    @effectus_tile_events.each { |e| e.tile? && @tile_events << e }
  end
  #--------------------------------------------------------------------------
  # * Overwrite: To make compatible with effectus and The0's anti lag
  #--------------------------------------------------------------------------
  def refresh_tile_events
    @tile_events = []
  end
  #--------------------------------------------------------------------------
  # * Trigger Refresh.                                                  [NEW]
  #--------------------------------------------------------------------------
  def effectus_trigger_refresh
    $game_temp.effectus_triggers.each do |trigger|
      effectus_etriggers[trigger].each { |event| event.refresh }
    end
    effectus_refresh_tile_events
    $game_temp.effectus_triggers.clear
    @effectus_need_refresh = false
  end
  #--------------------------------------------------------------------------
  # * Set Correct Display Values.                                       [NEW]
  #--------------------------------------------------------------------------
  def effectus_dref_set
    @effectus_dref_display_x = (@display_x * 32).floor / 32.0
    @effectus_dref_display_y = (@display_y * 32).floor / 32.0
  end
  #--------------------------------------------------------------------------
  # * Display X.                                                        [REP]
  #--------------------------------------------------------------------------
  def display_x
    @effectus_dref_display_x
  end
  #--------------------------------------------------------------------------
  # * Display Y.                                                        [REP]
  #--------------------------------------------------------------------------
  def display_y
    @effectus_dref_display_y
  end
  #--------------------------------------------------------------------------
  # * Calculate X Coordinate, Minus Display Coordinate.                 [REP]
  #--------------------------------------------------------------------------
  def adjust_x(x)
    if loop_horizontal? && x < @effectus_dref_display_x - @effectus_adjx
      x - @effectus_dref_display_x + @map.width
    else
      x - @effectus_dref_display_x
    end
  end
  #--------------------------------------------------------------------------
  # * Calculate Y Coordinate, Minus Display Coordinate.                 [REP]
  #--------------------------------------------------------------------------
  def adjust_y(y)
    if loop_vertical? && y < @effectus_dref_display_y - @effectus_adjy
      y - @effectus_dref_display_y + @map.height
    else
      y - @effectus_dref_display_y
    end
  end
  #--------------------------------------------------------------------------
  # * Set Display Position.                                             [REP]
  #--------------------------------------------------------------------------
  def set_display_pos(x, y)
    to_update_events = $game_map.effectus_events_to_update
    x = [0, [x, width  - screen_tile_x].min].max unless loop_horizontal?
    y = [0, [y, height - screen_tile_y].min].max unless loop_vertical?
    @display_x = (x + width)  % width
    @display_y = (y + height) % height
    @parallax_x = x
    @parallax_y = y
    to_update_events.each { |event| event.update }
  end
  #--------------------------------------------------------------------------
  # * Setup Starting Map Event.                                         [REP]
  #--------------------------------------------------------------------------
  def setup_starting_map_event
    return nil unless @effectus_event_starting
    event = @effectus_event_starting
    event.clear_starting_flag
    @interpreter.setup(event.list, event.id)
    @effectus_event_starting = nil
    event
  end
  #--------------------------------------------------------------------------
  # * Any Event Starting?                                               [REP]
  #--------------------------------------------------------------------------
  def any_event_starting?
    @effectus_event_starting
  end
#--------------------------------------------------------------------------
# Whether using effectus' pass table
if Effectus::UsePassable
  #--------------------------------------------------------------------------
  # * Tile Events XY.                                                   [REP]
  #--------------------------------------------------------------------------
  def tile_events_xy(x, y)
    @effectus_etile_pos[y * width + x]
  end
  #--------------------------------------------------------------------------
  # * All Tiles.                                                        [REP]
  #--------------------------------------------------------------------------
  def all_tiles(x, y)
    @effectus_etile_pos[y * width + x].collect { |event| event.tile_id } + 
    layered_tiles(x, y)
  end
  #--------------------------------------------------------------------------
  # * Alias Passable?                                                   [NEW]
  #--------------------------------------------------------------------------
  alias_method(:effectus_original_passable?, :passable?)
  #--------------------------------------------------------------------------
  # * Passable?                                                         [MOD]
  #--------------------------------------------------------------------------
  def passable?(x, y, d)
    if @effectus_pass_table[x, y, (d / 2) - 1] == 0
      cd = 10 - d
      cx = d == 4 ? x - 1 : d == 6 ? x + 1 : x
      cy = d == 2 ? y + 1 : d == 8 ? y - 1 : y
      if effectus_original_passable?(x, y, d) &&
        effectus_original_passable?(cx, cy, cd)
        @effectus_pass_table[x, y, (d / 2) - 1] = 1
        @effectus_pass_table[cx, cy, (cd / 2) - 1] = 1
        return true
      else
        @effectus_pass_table[x, y, (d / 2) - 1] = 2
        return false
      end
    end
    @effectus_pass_table[x, y, (d / 2) - 1] == 1
  end
  #--------------------------------------------------------------------------
  # * MS Effectus Release.                                              [NEW]
  #--------------------------------------------------------------------------
  def effectus_release(x, y)
    @effectus_pass_table[x, y, 0] = 0
    @effectus_pass_table[x, y, 1] = 0
    @effectus_pass_table[x, y, 2] = 0
    @effectus_pass_table[x, y, 3] = 0
    @effectus_pass_table[x - 1, y, 0] = 0
    @effectus_pass_table[x - 1, y, 1] = 0
    @effectus_pass_table[x - 1, y, 2] = 0
    @effectus_pass_table[x - 1, y, 3] = 0
    @effectus_pass_table[x + 1, y, 0] = 0
    @effectus_pass_table[x + 1, y, 1] = 0
    @effectus_pass_table[x + 1, y, 2] = 0
    @effectus_pass_table[x + 1, y, 3] = 0
    @effectus_pass_table[x, y - 1, 0] = 0
    @effectus_pass_table[x, y - 1, 1] = 0
    @effectus_pass_table[x, y - 1, 2] = 0
    @effectus_pass_table[x, y - 1, 3] = 0
    @effectus_pass_table[x, y + 1, 0] = 0
    @effectus_pass_table[x, y + 1, 1] = 0
    @effectus_pass_table[x, y + 1, 2] = 0
    @effectus_pass_table[x, y + 1, 3] = 0
  end
  #--------------------------------------------------------------------------
  def setup_collision_quadtree
    @partition_width  = (width  + SpacePartitionRange - 1).to_i / SpacePartitionRange
    @partition_height = (height + SpacePartitionRange - 1).to_i / SpacePartitionRange
    @partition_size   = @partition_width * @partition_height
    @collision_quadtree = {}
    @partition_size.times do |i|
      @collision_quadtree[i] = Array.new
    end
  end
  #--------------------------------------------------------------------------
  def get_quadtree_index(x, y)
    return (y.to_i / SpacePartitionRange * @partition_width).to_i + (x.to_i / SpacePartitionRange).to_i
  end
  #--------------------------------------------------------------------------
  def get_nearby_quadtree_value(leaf_id)
    d5 = leaf_id
    d8 = leaf_id - @partition_width
    d2 = leaf_id + @partition_width
    d4 = leaf_id - 1
    d6 = leaf_id + 1
    d7, d9 = d8 - 1, d8 + 1
    d1, d3 = d2 - 1, d8 + 1
    valid = [d1,d2,d3,d4,d5,d6,d7,d8,d9].select{|id| 0 <= id && id < @partition_size}
    re    = []
    for id in valid
      #@collision_quadtree[id].compact!
      @collision_quadtree[id].each do |battler|
        re << battler
      end
    end
    return re
  end
  #--------------------------------------------------------------------------
  def setup_character_quadtree_index
    characters = @events.values
    $game_player.followers.each{|ch| characters << ch}
    characters << $game_player
    characters.each do |ch|
      ch.setup_quadtree_index
    end
  end
  #--------------------------------------------------------------------------
end # if Effectus::UsePassable
  #--------------------------------------------------------------------------
end

#-------------------------------------------------------------------------------
# * Setup Part (Pixel Movement)
#-------------------------------------------------------------------------------
module Pixel_Core
  
  # Auto Update events with tileset graphics?
  Auto_Refresh_Tile_Events = true
  
  # Auto Update range
  TileEvent_Range = 3
  
  # Auto Multiply event commands?
  # (this option will multiply the event commands by 4 if set to true)
  Multiply_Commands = true
  
  # Commands to multiply (ID)
  Commands = [1,2,3,4,5,6,7,8,9,10,11,12,13]
  
  #-----------------------------------------------------------------------------
  # * Constants - Do not modify!
  #-----------------------------------------------------------------------------
  Pixel = 4
  Tile = (1.0 / Pixel)
  Default_Collision_X = 2
  Default_Collision_Y = 2
  Body_Axis = [0.25,0.25,0.5,0.75]
  Bush_Axis = [0.5,0.75]
  Counter_Axis = [0.25,0.25,0.25,0.25]
  Ladder_Axis = [0.25,0.25]
  Pixel_Range = {2=>[0,0.25],4=>[-0.25,0],6=>[0.25,0],8=>[0,-0.25]}
  Tile_Range  = {2=>[0,1],4=>[-1,0],6=>[1,0],8=>[0,-1]}
  Water_Range = {2=>[0,3],4=>[-3,0],6=>[3,0],8=>[0,-3]}
  Trigger_Range = {2=>[0,2],4=>[-2,0],6=>[2,0],8=>[0,-2]}
  Counter_Range = {2=>[0,3],4=>[-3,0],6=>[3,0],8=>[0,-3]}
  Chase_Axis = {2=>[0,1],4=>[1,0],6=>[1,0],8=>[0,1]}
  
  # Region id
  # bit: 000000~111111 (0~63)
  # index: utility
  # 0~1  : altitude(0~3)(00/01/10/11)
  #  2   : allow projectile pass through if set to 1
  #  3   : reserved
  #  4   : reserved
  #  5   : reserved
end
#-------------------------------------------------------------------------------
# * Game Map
#-------------------------------------------------------------------------------
class Game_Map
  include Pixel_Core
  attr_reader :pixel_table
  #-------------------------------------------------------------------------------
  #
  #-------------------------------------------------------------------------------
  def pixel_valid?(x, y)
    x >= 0 && x <= @pixel_wm && y >= 0 && y <= @pixel_hm
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  alias kp_referesh_vehicles referesh_vehicles
  def referesh_vehicles
    setup_table
    kp_referesh_vehicles
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def setup_table
    @pixel_table = Table.new(width*Pixel, height*Pixel,6)
    for x in 0...(width*Pixel)
      for y in 0...(height*Pixel)
        @pixel_table[x,y,0] = 1
        @pixel_table[x,y,1] = table_skill_collision(x*Tile,y*Tile)
        @pixel_table[x,y,3] = table_ladder(x*Tile,y*Tile)
        @pixel_table[x,y,4] = table_bush(x*Tile+Bush_Axis[0],y*Tile+Bush_Axis[1])
        @pixel_table[x,y,5] = table_counter(x*Tile+Counter_Axis[0],y*Tile+Counter_Axis[1])
      end
    end
    build_map_collision_table
    @pixel_wm = (width-1)*Pixel
    @pixel_hm = (height-1)*Pixel
  end
  #-------------------------------------------------------------------------------
  def build_map_collision_table
    for x in 0...width
      for y in 0...height
        setup_pixel_collision(x, y, 0)
      end
    end
    return unless debug_mode?
    FileManager.build_debug_file("MapCol#{@map_id | 0}.txt", 'w') do |file|
      cnt = 0
      for i in 0...(height*Pixel)
        for j in 0...(width*Pixel)
          file.write("#{@pixel_table[j,i,0]}")
          cnt += 1
          file.write(' ') if cnt % 4 == 0
        end
        file.write(10.chr)
      end
    end
  end
  #-------------------------------------------------------------------------------
  def setup_pixel_collision(x, y, type)
    blocked     = []
    block_rects = [
      #Rect.new( 0, 1, 4, 3), # 2
      #Rect.new(-3,-1, 3, 4), # 4
      #Rect.new( 1,-3, 3, 6), # 6
      #Rect.new( 0,-3, 4, 2)  # 8
      Rect.new( 0, 1, 4, 3), # 2
      Rect.new(-3,-1, 3, 4), # 4
      Rect.new( 1,-3, 3, 6), # 6
      Rect.new( 0,-3, 4, 2)  # 8
    ]
    px = x * Pixel
    py = y * Pixel
    for i in 0...4
      dir = (i+1) << 1
      blocked.push(!check_layer_passage(x, y, dir))
      if blocked[i]
        setup_pixel_collision_rect(px, py, block_rects[i], type, false)
      end #if blocked
    end # for 1~4
    
    if blocked[1] && blocked[3] # 7
      rect = Rect.new(-3,-3,3,3)
      setup_pixel_collision_rect(px, py, rect, type, false)
    end
    if blocked[0] && blocked[1] # 1
      rect = Rect.new(-3,3,3,1)
      setup_pixel_collision_rect(px, py, rect, type, false)
    end
    
  end
  #-------------------------------------------------------------------------------
  def setup_pixel_collision_rect(px, py, rect, type, passable)
    passable = passable.to_i
    for by in 0...rect.height
      for bx in 0...rect.width
        cx = px + rect.x + bx; cy = py + rect.y + by;
        @pixel_table[cx, cy, type] = passable
      end
    end 
  end
  #-------------------------------------------------------------------------------
  def check_layer_passage(x, y, dir)
    bit = (1 << (dir / 2 - 1)) & 0x0f;
    layered_tiles(x, y).each do |tile_id|
      flag = tileset.flags[tile_id]
      if flag & 0x10 != 0                   # [☆]: No effect on passage
        next         if flag & bit == 0     # [○] : Passable but star
        return false if flag & bit == bit   # [×] : Impassable
      else
        return true  if flag & bit == 0     # [○] : Passable
        return false if flag & bit == bit   # [×] : Impassable
      end
    end
    return false                   
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def table_player_collision(x,y)
    return 0 unless table_pp((x+Body_Axis[0]).to_i,(y+Body_Axis[1]).to_i)
    return 0 unless table_pp((x+Body_Axis[2]).to_i,(y+Body_Axis[1]).to_i)
    return 0 unless table_pp((x+Body_Axis[0]).to_i,(y+Body_Axis[3]).to_i)
    return 0 unless table_pp((x+Body_Axis[2]).to_i,(y+Body_Axis[3]).to_i)
    return 1
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def table_skill_collision(x,y)
    return 0 unless table_ps((x+Body_Axis[0]).to_i,(y+Body_Axis[1]).to_i)
    return 0 unless table_ps((x+Body_Axis[2]).to_i,(y+Body_Axis[1]).to_i)
    return 0 unless table_ps((x+Body_Axis[0]).to_i,(y+Body_Axis[3]).to_i)
    return 0 unless table_ps((x+Body_Axis[2]).to_i,(y+Body_Axis[3]).to_i)
    return 1
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def refresh_table(start_x,start_y,end_x,end_y)
    for x in (start_x*Pixel)..(end_x*Pixel)
      for y in (start_y*Pixel)..(end_y*Pixel)
        @pixel_table[x,y,0] = table_pcrf(x*Tile,y*Tile)
        @pixel_table[x,y,1] = table_scrf(x*Tile,y*Tile)
      end
    end
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def refresh_table_px(start_px,start_py,end_px,end_py)
    for x in start_px..end_px
      for y in start_py..end_py
        @pixel_table[x,y,0] = table_pcrf(x*Tile,y*Tile)
        @pixel_table[x,y,1] = table_scrf(x*Tile,y*Tile)
      end
    end
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def table_pcrf(x,y)
    return 0 unless table_pprf((x+Body_Axis[0]).to_i,(y+Body_Axis[1]).to_i)
    return 0 unless table_pprf((x+Body_Axis[2]).to_i,(y+Body_Axis[1]).to_i)
    return 0 unless table_pprf((x+Body_Axis[0]).to_i,(y+Body_Axis[3]).to_i)
    return 0 unless table_pprf((x+Body_Axis[2]).to_i,(y+Body_Axis[3]).to_i)
    return 1
  end
  def table_scrf(x,y)
    return 0 unless table_psrf((x+Body_Axis[0]).to_i,(y+Body_Axis[1]).to_i)
    return 0 unless table_psrf((x+Body_Axis[2]).to_i,(y+Body_Axis[1]).to_i)
    return 0 unless table_psrf((x+Body_Axis[0]).to_i,(y+Body_Axis[3]).to_i)
    return 0 unless table_psrf((x+Body_Axis[2]).to_i,(y+Body_Axis[3]).to_i)
    return 1
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def table_p(x,y,bit)
    
    layered_tiles(x,y).each do |tile_id|
      flag = tileset.flags[tile_id]
      
      next if flag & 0x10 != 0
      return true  if flag & bit == 0
      return false if flag & bit == bit
    end
    return false
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def table_pp(x,y)
    layered_tiles(x,y).each do |tile_id|
      flag = tileset.flags[tile_id]
      next if flag & 0x10 != 0
      return true if flag & 0x0f == 0
      return false if flag & 0x0f == 0x0f
    end
    return false
  end
  #-------------------------------------------------------------------------------
  # * pass table for projectile
  #------------------------------------------------------------------------------
  def table_ps(x,y)
    return true if $game_map.tile_proj_passable?(x,y)
    id_cnt = 0
    layered_tiles(x,y).each do |tile_id|
      flag = tileset.flags[tile_id]
      id_cnt += flag & 0x10
      next if flag & 0x10 != 0
      return true if flag & 0x0400 == 0
      return true if flag & 0x0f == 0
      return false if flag & 0x0f == 0x0f
    end
    return id_cnt == 48
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def table_pprf(x,y)
    all_tiles(x, y).each do |tile_id|
      flag = tileset.flags[tile_id]
      next if flag & 0x10 != 0
      return true if flag & 0x0f == 0
      return false if flag & 0x0f == 0x0f
    end
    return false
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def table_psrf(x,y)
    all_tiles(x,y).each do |tile_id|
      flag = tileset.flags[tile_id]
      next if flag & 0x10 != 0
      return true if flag & 0x0400 == 0
      return true if flag & 0x0f == 0
      return false if flag & 0x0f == 0x0f
    end
    return false
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def table_bush(x,y)
    return layered_tiles_flag?(x.to_i, y.to_i, 0x40) ? 1 : 0
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def table_ladder(x,y)
    return 1 if layered_tiles_flag?(x.to_i,(y+Ladder_Axis[1]).to_i, 0x20)
    return 1 if layered_tiles_flag?((x+Ladder_Axis[0]).to_i, (y+Ladder_Axis[1]).to_i, 0x20)
    return 0
  end
  #-------------------------------------------------------------------------------
  #
  #------------------------------------------------------------------------------
  def table_counter(x,y)
    return 1 if layered_tiles_flag?(x.to_i,y.to_i, 0x80)
    return 1 if layered_tiles_flag?((x+Counter_Axis[2]).to_i,y.to_i, 0x80)
    return 1 if layered_tiles_flag?(x.to_i,(y+Counter_Axis[3]).to_i, 0x80)
    return 1 if layered_tiles_flag?((x+Counter_Axis[2]).to_i,(y+Counter_Axis[3]).to_i, 0x80)
    return 0
  end
#--------------------------------------------------------------------------
# Compatible with effectus' passable function
if Effectus::UsePassable
  #------------------------------------------------------------------------------
  alias_method(:effectus_passable?, :passable?)
  def passable?(x, y, d)
    return @pixel_table[x,y,0].to_bool && effectus_passable?(x,y,d)
  end
else
  #------------------------------------------------------------------------------
  def passable?(x, y, d)
    return @pixel_table[x,y,0].to_bool
  end
end # Use Effectus passable
  #-------------------------------------------
end


#==============================================================================
# ** Game_Map
#------------------------------------------------------------------------------
#  This class handles maps. It includes scrolling and passage determination
# functions. The instance of this class is referenced by $game_map.
#==============================================================================
class Game_Map
  #--------------------------------------------------------------------------
  # * Overwrite: Frame Update
  #--------------------------------------------------------------------------
  alias update_gamemap_lapse update
  def update(main = false)
    return update_tactic(main)   if SceneManager.tactic_enabled?
    return update_timestop       if SceneManager.time_stopped? 
    return update_gamemap_lapse(main)
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  # tag: tactic(game_map update)
  #--------------------------------------------------------------------------
  def update_tactic(main = false)
    refresh if @need_refresh
    update_interpreter if main
    update_scroll
    update_parallax
    @screen.update
  end
  #--------------------------------------------------------------------------
  def update_timestop
    refresh if @need_refresh
    update_scroll
    update_parallax
    @screen.update
    update_drops
    unless $game_system.time_stopper.nil?
      $game_system.time_stopper.update
      $game_system.time_stopper.update_battler
    end
    @timestop_timer += 1
    if @timestop_timer >= $game_system.timestop_duration
      $game_system.resume_time 
      @timestop_timer = 0
    end
  end
  #--------------------------------------------------------------------------
end
#==============================================================================
# ** Game_CommonEvent
#------------------------------------------------------------------------------
#  This class handles common events. It includes functionality for execution of
# parallel process events. It's used within the Game_Map class ($game_map).
#==============================================================================
class Game_CommonEvent
  #--------------------------------------------------------------------------
  # * Initialize.                                                       [REP]
  #--------------------------------------------------------------------------
  def initialize(common_event_id)
    @event = $data_common_events[common_event_id]
    refresh 
    if @event.parallel? || @event.autorun?
      trigger = $game_map.effectus_etriggers[:"switch_#{@event.switch_id}"]
      trigger << self unless trigger.include?(self)
    end
  end
  
end

#==============================================================================
# ** Game_CharacterBase
#------------------------------------------------------------------------------
#  This base class handles characters. It retains basic information, such as 
# coordinates and graphics, shared by all characters.
#==============================================================================
class Game_CharacterBase
  
  attr_reader :animation_queue
  #--------------------------------------------------------------------------
  # * Alias: Initialize Public Member Variables
  #--------------------------------------------------------------------------
  alias init_public_cbmembers init_public_members
  def init_public_members
    init_public_cbmembers
    @move_speed = 4
  end
  #--------------------------------------------------------------------------
  # * Change Direction to Designated Direction
  #     d : Direction (2,4,6,8)
  #--------------------------------------------------------------------------
  def set_direction(d)
    @stop_count = 0
    @direction = d if !@direction_fix && d != 0
    @direction
  end
  #--------------------------------------------------------------------------
  # * Create sprites for multi-animation display, call from Spriteset_Map
  #--------------------------------------------------------------------------
  def create_animation_queue
    @animation_queue = Array.new(3){ |index|
      index = Sprite_Animation.new(nil, self)
    }
  end
  #--------------------------------------------------------------------------
  # * Start animation
  #--------------------------------------------------------------------------
  def start_animation(animation, mirror = false)
    
    if animation.is_a?(Numeric)
      id = animation
      animation = $data_animations[id]
    else
      id = animation.id
    end
    create_animation_queue if @animation_queue.nil?
    if animation_id > 0
      @animation_queue.each {|sprite|
        if !sprite.animation?
          sprite.start_animation(animation, mirror)
          break
        end
      } # check idle animation sprite
    else
      @animation_id = id
    end
    
  end
  #--------------------------------------------------------------------------
  # * Alias: update animation
  #--------------------------------------------------------------------------
  alias update_multi_animation update_animation
  def update_animation
    if @animation_queue
      @animation_queue.each{|sprite| sprite.update if sprite.animation?}
    end
    update_multi_animation
  end  
  #--------------------------------------------------------------------------
  # * Free
  #--------------------------------------------------------------------------
  def dispose_sprites
    return if @animation_queue.nil?
    @animation_queue.each{|sprite| sprite.dispose}
    @animation_queue.clear
  end
  #--------------------------------------------------------------------------
  # * Determine if Dashing
  #--------------------------------------------------------------------------
  def dash?
    return false
  end
  #--------------------------------------------------------------------------
  # * Calculate Move Distance per Frame
  #--------------------------------------------------------------------------
  def distance_per_frame
    re = (2 ** (real_move_speed).to_i / 256.0)
    return re
  end
  #--------------------------------------------------------------------------
  # * Passable?                                                         
  #--------------------------------------------------------------------------
  def passable?(x, y, d)
    ox = d == 4 ? -1 : d == 6 ? 1 : 0
    oy = d == 8 ? -1 : d == 2 ? 1 : 0
    return false unless $game_map.valid?(x + ox, y + oy)
    return true if @through || debug_through?
    return false unless map_passable?(x, y, d)
    return false unless map_passable?(x + ox, y + oy, 10 - d)
    return false if collide_with_characters?(x + ox, y + oy)
    return true
  end
  #--------------------------------------------------------------------------
  def load_position(real_pos, normal_pos, pixel_pos)
    @real_x = real_pos.x
    @real_y = real_pos.y
    @x      = normal_pos.x
    @y      = normal_pos.y
    @px     = pixel_pos.x
    @py     = pixel_pos.y
  end
  #--------------------------------------------------------------------------
  def pos
    return POS.new(@real_x, @real_y)
  end
  #----------------------------------------------------------------------------
  def battler
    return self
  end
  #----------------------------------------------------------------------------
  def path_passable?(x, y, dir, ignore_chars = [])
    px = x * 4; py = y * 4;
    return false unless $game_map.pixel_valid?(px,py)
    return true  if @through || debug_through?
    return false if $game_map.pixel_table[px,py,0] == 0
    return false if character_collided?(px, py, ignore_chars)
    return true
  end
  #----------------------------------------------------------------------------
  def character_collided?(px, py, ignores = [])
    return false if through_character?
    return true  if collide_with_events?(px, py, ignores)
    return true  if collide_with_follower?(px, py, ignores)
    return true  if collide_with_player?(px, py, ignores)
    return false
  end
  #----------------------------------------------------------------------------
  def through_character?
    false || @through
  end
  #--------------------------------------------------------------------------
  # * Collide with Events?                                              [REP]
  #--------------------------------------------------------------------------
  def collide_with_events?(px, py, ignores = [])
    x, y = px * Pixel_Core::Pixel, py * Pixel_Core::Pixel;
    $game_map.effectus_event_pos[y * $game_map.width + x].each do |event|
      next if event == self
      next if event.through_character?
      next unless event.normal_priority?
      next if ignores.include?(event)
      if (event.px - px).abs <= event.cx && (event.py - py).abs <= event.cy
        return true
      end
    end
    return false
  end
  #----------------------------------------------------------------------------
  def collide_with_follower?(px,py,ignores = [])
    $game_player.followers.each do |follower|
      next if ignores.include?(follower) || (follower.actor && ignores.include?(follower.actor))
      next if follower.dead? || follower.through_character?
      return follower if (follower.px - px).abs <= follower.cx && (follower.py - py).abs <= follower.cy
    end
    return false
  end
  #----------------------------------------------------------------------------
  def collide_with_player?(px,py,ignores = [])
    return false if ignores.include?($game_player)
    return false if ($game_player.actor && ignores.include?($game_player.actor))
    return false if $game_player.dead?
    return ($game_player.px - px).abs <= @cx && ($game_player.py - py).abs <= @cy
  end
  #----------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Character
#------------------------------------------------------------------------------
#  A character class with mainly movement route and other such processing
# added. It is used as a super class of Game_Player, Game_Follower,
# GameVehicle, and Game_Event.
#==============================================================================
class Game_Character < Game_CharacterBase
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader     :zoom_x
  attr_reader     :zoom_y
  attr_reader     :knockbacks
  attr_reader     :through_character
  attr_reader     :altitude
  attr_reader     :last_quadtree_index, :quadtree_index
  attr_accessor   :through                  # pass-through
  attr_accessor   :step_anime               # stepping animation
  #--------------------------------------------------------------------------
  # * Initialize Public Member Variables
  #--------------------------------------------------------------------------
  alias init_public_memdnd init_public_members
  def init_public_members
    @zoom_x = @zoom_y = 1.0
    @zoom_duration_x = @zoom_duration_y = 0
    @knockbacks = []
    @through_character = false
    @altitude   = 0
    init_public_memdnd
  end
  #----------------------------------------------------------------------------
  # *) Frame update
  #----------------------------------------------------------------------------
  def update
    super
    update_zoom
    update_quadtree_index
    update_knockback if !@knockbacks.empty?
    @pathfinding_timer -= 1 if @pathfinding_timer > 0
  end
  #----------------------------------------------------------------------------
  # *) Update Zooming
  #----------------------------------------------------------------------------
  def update_zoom
    return unless @zooming
    @zooming = false
    flag = @zoom_delta_x <=> 0
    if @zoom_x * flag > @target_zoom_x * flag
      @zoom_x = @target_zoom_x
    elsif @zoom_x != @target_zoom_x
      @zoom_x += @zoom_delta_x
      @zooming = true
    end
    flag = @zoom_delta_y <=> 0
    if @zoom_y * flag > @target_zoom_y * flag
      @zoom_y = @target_zoom_y
    elsif @zoom_y != @target_zoom_y
      @zoom_y += @zoom_delta_y
      @zooming = true
    end
  end
  #----------------------------------------------------------------------------
  # *) Zoom Character
  #----------------------------------------------------------------------------
  def zoom(x, y, dx = 0, dy = 0)
    @target_zoom_x, @target_zoom_y = x, y
    @zoom_delta_x = (x - @zoom_x).to_f / dx
    @zoom_delta_y = (y - @zoom_y).to_f / dy
    @zooming = true
  end
  #----------------------------------------------------------------------------
  def static_object?
    return false
  end
  #----------------------------------------------------------------------------
  def apply_knockback(direction, power)
    return if power < 1
    return if static_object?
    @knockbacks.clear
    power.times{@knockbacks << direction}
  end
  #----------------------------------------------------------------------------
  # * Update knockbacks
  #----------------------------------------------------------------------------
  def update_knockback
    dir = @knockbacks.shift
    if pixel_passable?(@px, @py, dir)
      @px += Tile_Range[dir][0]
      @py += Tile_Range[dir][1]
      @real_x = @x
      @real_y = @y
      @x += Pixel_Range[dir][0]
      @y += Pixel_Range[dir][1]
    end
  end
  #--------------------------------------------------------------------------
  def obstacle_touched?(x, y, dir = @direction)
    #x += Pixel_Core::Tile_Range[dir][0]
    #y += Pixel_Core::Tile_Range[dir][1]
    px, py = (x*4).to_i, (y*4).to_i;
    return true  if !$game_map.pixel_valid?(px,py) || $game_map.over_edge?(x, y)
    return true  if $game_map.pixel_table[px,py,1] == 0
    return true  if collide_event_objects?(x, y)
    return false
  end
  #----------------------------------------------------------------------------
  def seeable?(x, y, dir = @direction)
    return true if !obstacle_touched?(x, y, dir)
    case dir
    when 6; x += 0.8;
    when 2; y += 0.8;
    end
    return $game_map.get_tile_altitude(x,y) > 0
  end
  #----------------------------------------------------------------------------
  def collide_event_objects?(x, y)
    poshash = y * $game_map.width + x
    for event in $game_map.effectus_event_pos[poshash]
      next if event.through || event == self || event.enemy
      return true if event.static_object?
      return true if event.priority_type == 1
    end
    return false
  end
  #----------------------------------------------------------------------------
  # *) check if path between two dot is clear
  #----------------------------------------------------------------------------
  def path_clear?(x1, y1, x2, y2)
    dx = x2 - x1;
    if(dx == 0)
      return straight_path_clear?(x1,y1,y2)
    elsif(dx < 0)
      return path_clear?(x2,y2,x1,y1);
    end
    
    dy    = y2 - y1;
    sgny  = (dy >= 0 ? 1 : -1);
    delta = (dy.to_f / dx.to_f).abs;
    error = 0.0;
    
    x,y = x1, y1
    while x <= x2
      return false if obstacle_touched?(x, y)
      error += (delta / 4)
      while error >= 0.5
        return false if obstacle_touched?(x, y)
        y     += sgny
        error -= 1.0
      end # while
      x += 0.25
    end # while x
    
    return true
  end
  #----------------------------------------------------------------------------
  # *) check if can see the location
  #----------------------------------------------------------------------------
  def can_see?(*args)
    case args.size
    when 1
      return can_see?(@x, @y, args[0].x, args[0].y)
    when 4
      x1, y1 = args[0], args[1]
      x2, y2 = args[2], args[3]
    else
      raise ArgumentError
    end
    
    dx = x2 - x1;
    if(dx == 0)
      return straight_path_seeable?(x1,y1,y2)
    elsif(dx < 0)
      return can_see?(x2,y2,x1,y1);
    end
    
    dy    = y2 - y1;
    sgny  = (dy >= 0 ? 1 : -1);
    delta = (dy.to_f / dx.to_f).abs;
    error = 0.0;
    
    x,y = x1, y1
    while x <= x2
      return false if !seeable?(x, y)
      error += (delta / 4)
      while error >= 0.5
        return false if !seeable?(x, y)
        y     += sgny
        error -= 1.0
      end # while
      x += 0.25
    end # while x
    
    return true
  end
  #----------------------------------------------------------------------------
  # *) straight path seeable?
  #----------------------------------------------------------------------------
  def straight_path_seeable?(x1, y1, y2)
    y = y1
    while y <= y2
      result = false
      (1..4).each do |i|
        result |= seeable?(x1 , y , i*2 )
      end
      return false if !result
      y += 0.25
    end # for y
    return true
  end
  #----------------------------------------------------------------------------
  # *) straight path clear?
  #----------------------------------------------------------------------------
  def straight_path_clear?(x1, y1, y2)
    y = y1
    while y <= y2
      result = false
      (1..4).each do |i|
        result |= pixel_passable?(x1 , y , i*2 )
      end
      return false if !result    
      y += 0.25
    end # for y
    return true
  end
  #--------------------------------------------------------------------------
  # * Determine if Movement is Possible
  #--------------------------------------------------------------------------
  def movable?
    return false if @move_route_forcing
    return false if $game_message.busy? || $game_message.visible
    return true
  end
  #----------------------------------------------------------------------------
  # * Die when hitpoint drop to zero
  #----------------------------------------------------------------------------
  def kill
    #SceneManager.display_info("#{self.name} - knocked out")
    $game_map.need_refresh = true
    @ori_through = @through
    cancel_action_without_penalty(true)
    @next_action = nil
    set_target(nil)
  end
  #----------------------------------------------------------------------------
  def swap_member(char)
    dir1, dir2 = @direction, char.direction
    pos1 = pos
    pos2 = char.pos
    moveto(pos2.x, pos2.y)
    char.moveto(pos1.x, pos1.y)
    @action, char.action = char.action, @action
    @next_action, char.next_action = char.next_action, @next_action
    @casting_flag, char.casting_flag = char.casting_flag, @casting_flag
    @step_anime, char.step_anime = char.step_anime, @step_anime
    set_direction(dir2); char.set_direction(dir1);
  end
  #----------------------------------------------------------------------------
  def process_event_death
    drop_loots if $game_player.is_opponent?(self)
    apply_event_death_effect
    start_animation(@enemy.death_animation)
  end
  #----------------------------------------------------------------------------
  def apply_event_death_effect
    sws = @enemy.death_switch_self
    swg = @enemy.death_switch_global
    vrsi, vrsv = *@enemy.death_var_self if @enemy.death_var_self
    vrgi, vrgv = *@enemy.death_var_global
    return if sws.nil? && swg + vrsi + vrgi == 0
    if sws
      key = [@map_id, @event.id, sws]
      $game_self_switches[key] = true
    end
    $game_switches[swg] = true    if swg  > 0
    @self_vars[vrsi] = vrsv       if vrsi && vrsv
    $game_variables[vrgi] = vrgv  if vrgi > 0
  end
  #----------------------------------------------------------------------------
  def process_actor_death(se_play = true)
    Sound.play(actor.death_sound) if actor.death_sound && se_play
    @character_name  = actor.death_graphic
    @character_index = actor.death_index
    @pattern         = actor.death_pattern
    @direction       = actor.death_direction
    debug_print "#{actor.name} is knocked out!"
  end
  #----------------------------------------------------------------------------
  def revive_character
    update_security
    @through = @ori_through
    @character_name  = actor.character_name
    @character_index = actor.character_index
    moveto($game_player.x, $game_player.y) if distance_to_player > 2
    set_target(nil)
  end
  #----------------------------------------------------------------------------
  def distance_to_character(charactor)
    return Math.hypot(@x - charactor.x, @y - charactor.y)
  end
  #----------------------------------------------------------------------------
  def distance_to_player
    charactor = $game_player
    return Math.hypot(@x - charactor.x, @y - charactor.y)
  end
  #----------------------------------------------------------------------------
  def id
    return actor.id if methods.include?(:actor)
    return @id
  end
  #----------------------------------------------------------------------------
  def change_team(new_id)
    return unless BattleManager.valid_battler?(self)
    battler.team_id = new_id
    $game_map.resign_battle_unit(self)
    $game_map.register_battler(self)
  end
  #----------------------------------------------------------------------------
  def drop_loots
    exp   = @enemy.exp
    gold  = @enemy.gold
    loots = @enemy.make_drop_items
    BattleManager.add_party_exp(exp)
    loots = [] if loots.nil?
    $game_map.register_item_drop(@x, @y, gold, loots)
  end
  #----------------------------------------------------------------------------
  def map_char
    return self
  end
  #---------------------------------------------------------------------------
  def weapon_level_prof
    return 0 if !BattleManager.valid_battler?(self)
    battler.weapon_level_prof
  end
  #--------------------------------------------------------------------------
  def casting_animation 
    return DND::BattlerSetting::CastingAnimation
  end
  #--------------------------------------------------------------------------
  # * Turn Toward Character
  #--------------------------------------------------------------------------
  def turn_toward_character(character)
    return @direction if character.pos == pos
    sx = distance_x_from(character.x)
    sy = distance_y_from(character.y)
    if sx.abs > sy.abs
      re = set_direction(sx > 0 ? 4 : 6)
    elsif sy != 0
      re = set_direction(sy > 0 ? 8 : 2)
    end
    return re
  end
  #--------------------------------------------------------------------------
  def target_front_position(range)
    pos = POS.new(@x, @y)
    case @direction
    when 2
      pos.y = [pos.y + range, $game_map.height - 1].min
    when 4
      pos.x = [pos.x - range, 0].max
    when 6
      pos.x = [pos.x + range, $game_map.width - 1].min
    when 8
      pos.y = [pos.y - range, 0].max
    end
    return pos
  end
  #--------------------------------------------------------------------------
  # * Don't do anything
  #--------------------------------------------------------------------------
  def halt?
    return true if casting?
    return true if frozen?
    return false
  end
  #--------------------------------------------------------------------------
  def casting?
    return false if @action.nil?
    return true  if @casting_flag
    return true  if @action.casting?
    return false
  end
  #--------------------------------------------------------------------------
  def casting_index
    @character_index
  end
  #--------------------------------------------------------------------------
  def get_ammo_item(item)
  end
  #--------------------------------------------------------------------------
  def secure_hash
    return unless battler
    battler.secure_hash
  end
  #--------------------------------------------------------------------------
  def through_character?
    return true  if @through_character || @through
    return false if battler == self
    return battler.state?(PONY::StateID[:free_movement])
  end
  #--------------------------------------------------------------------------
  def altitude=(_new)
    @altitude = _new
  end
  #--------------------------------------------------------------------------
  def visible_sight
    return 5
  end
  #--------------------------------------------------------------------------
  # * Move away from character if given character can see self
  #--------------------------------------------------------------------------
  def escape_from_threat(threat)
    return if distance_to_character(threat) > threat.visible_sight
    move_away_from_character(threat)
  end
  #--------------------------------------------------------------------------
  def effectus_near_the_screen?
    true
  end
  #--------------------------------------------------------------------------
  def setup_quadtree_index
    @last_quadtree_index = $game_map.get_quadtree_index(@x, @y)
    $game_map.collision_quadtree[@last_quadtree_index] << self
  end
  #--------------------------------------------------------------------------
  def update_quadtree_index
    quadtree = $game_map.collision_quadtree
    new_index = $game_map.get_quadtree_index(@x, @y)
    return if new_index == @last_quadtree_index
    @quadtree_index = new_index
    #puts "#{name} #{@last_quadtree_index}" if self.is_a?(Game_Player) || distance_to_character($game_player) < 5
    begin
      quadtree[new_index] << quadtree[@last_quadtree_index].delete(self)
    rescue Exception => e
      msgbox [name, @last_quadtree_index, new_index]
      raise e
    end
    @last_quadtree_index = new_index
  end
  #----------------------------------------------------------------------------
  def set_pos(nx, ny)
    @x = nx
    @y = ny
    @real_x = nx
    @real_y = ny
    @px = nx * Pixel_Core::Pixel
    @py = ny * Pixel_Core::Pixel
    update_bush_depth
  end
  #--------------------------------------------------------------------------
  def valid_battler?
    return !@map_char.nil?
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Player
#------------------------------------------------------------------------------
#  This class handles the player. It includes event starting determinants and
# map scrolling functions. The instance of this class is referenced by
# $game_player.
#==============================================================================
class Game_Player < Game_Character
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :target_event   # Event auto trigger when touched
  attr_reader   :new_x, :new_y, :action_cancel_timer
  attr_accessor :recurrence_delay
  attr_accessor :free_fire
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias initialize_gapc_opt initialize
  def initialize
    @target_event     = nil
    @recurrence_delay = nil
    @action_cancel_timer = 0
    @free_fire = false
    initialize_gapc_opt
  end
  #--------------------------------------------------------------------------
  # * Disable Dash utility
  #--------------------------------------------------------------------------
  def dash?
    return false
  end
  #--------------------------------------------------------------------------
  # * Clear Transfer Player Information
  #--------------------------------------------------------------------------
  def clear_transfer_info
    @transferring = false            # Player transfer flag
    @new_map_id = 0                  # Destination map ID
    @new_x = 0                      # Destination X coordinate
    @new_y = 0                      # Destination Y coordinate
    @new_direction = 0               # Post-movement direction
  end
  #--------------------------------------------------------------------------
  # * Execute Player Transfer
  #--------------------------------------------------------------------------
  def perform_transfer
    if transfer?
      set_direction(@new_direction)
      if @new_map_id != $game_map.map_id
        $game_map.setup(@new_map_id)
        $game_map.autoplay
      end
      moveto(@new_x, @new_y)
      clear_transfer_info
    end
  end
  #--------------------------------------------------------------------------
  # * Determine if Player Transfer is Reserved
  #--------------------------------------------------------------------------
  def transfer?
    return @transferring
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Determine if Movement is Possible
  #--------------------------------------------------------------------------
  def movable?(for_action = false)
    return false if moving? && !for_action
    return false if @move_route_forcing || @followers.gathering?
    return false if @vehicle_getting_on || @vehicle_getting_off
    return false if $game_message.busy? || $game_message.visible
    return false if vehicle && !vehicle.movable?
    return false if !actor.movable?
    return true
  end
  #---------------------------------------------------------------------------
  # * Method Missing
  # ----------------------------------------------------------------------   
  # DANGER ZONE: Redirect to Actor
  #---------------------------------------------------------------------------
  def method_missing(symbol, *args)
    super(symbol, args) unless actor
    super(symbol, args) unless actor.methods.include?(symbol)
    actor.method(symbol).call(*args)
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Frame Update
  #--------------------------------------------------------------------------
  def update
    last_real_x = @real_x
    last_real_y = @real_y
    last_moving = moving?
    move_by_input unless !movable? || $game_map.interpreter.running?
    super
    update_scroll(last_real_x, last_real_y) if last_real_x != @real_x ||
                                               last_real_y != @real_y
    update_vehicle unless @followers.gathering?
    update_nonmoving(last_moving) unless moving?
    update_target
    @recurrence_delay -= 1 if !@recurrence_delay.nil? && @recurrence_delay > 0
    $game_party.recurrence_leader if @recurrence_delay == 0 #tag: modified
    update_battler
    @followers.update unless SceneManager.time_stopped?
  end
  #--------------------------------------------------------------------------
  # * Scroll Processing
  #--------------------------------------------------------------------------
  def update_scroll(last_real_x, last_real_y)
    ax1 = $game_map.adjust_x(last_real_x)
    ay1 = $game_map.adjust_y(last_real_y)
    ax2 = $game_map.adjust_x(@real_x)
    ay2 = $game_map.adjust_y(@real_y)
    $game_map.scroll_down (ay2 - ay1) if ay2 > ay1 && ay2 > center_y
    $game_map.scroll_left (ax1 - ax2) if ax2 < ax1 && ax2 < center_x
    $game_map.scroll_right(ax2 - ax1) if ax2 > ax1 && ax2 > center_x
    $game_map.scroll_up   (ay1 - ay2) if ay2 < ay1 && ay2 < center_y
    $game_map.effectus_dref_set
  end
  #--------------------------------------------------------------------------
  # * Processing When Not Moving
  #     last_moving : Was it moving previously?
  #--------------------------------------------------------------------------
  def update_nonmoving(last_moving)
    return if $game_map.interpreter.running?
    if last_moving
      $game_party.on_player_walk
      return if check_touch_event
    end
    if movable? && Input.trigger?(:C)
      #return if get_on_off_vehicle
      return if check_action_event
    end
  end
  #----------------------------------------------------------------------------
  # * Can perform action?
  #----------------------------------------------------------------------------
  def actable?
    return false if $game_message.busy?
    return false if !movable?(true)
    return true
  end
  #----------------------------------------------------------------------------
  # * Die when hitpoint drop to zero
  #----------------------------------------------------------------------------
  def kill
    process_actor_death
    $game_player.recurrence_delay = 60
    super
  end
  #--------------------------------------------------------------------------
  def primary_weapon
    return actor.equips[0]
  end
  #--------------------------------------------------------------------------
  def secondary_weapon
    return actor.equips[1]
  end
  #--------------------------------------------------------------------------
  def body_size
    return 1 * @zoom_x
  end
  #--------------------------------------------------------------------------
  def hashid
    return actor.hashid if actor
    return 0
  end
  #----------------------------------------------------------------------------
  def dead?
    return actor.dead?
  end
  #----------------------------------------------------------------------------
  def alive?
    return !dead?
  end
  #--------------------------------------------------------------------------
  def update_vehicle
  end
  #--------------------------------------------------------------------------
  def update_encounter
  end
  #--------------------------------------------------------------------------
  def update_target
    return unless @current_target
    set_target(nil) if @current_target.dead? || !@current_target.effectus_near_the_screen?
  end
  #----------------------------------------------------------------------------
  # * Allow character move freely between characters?
  #----------------------------------------------------------------------------
  def allow_loose_moving?
    return false
  end
  #--------------------------------------------------------------------------
  def team_id
    return @team_id.nil? ? @team_id = 0 : @team_id
  end
  #----------------------------------------------------------------------------
  # * Use item
  #----------------------------------------------------------------------------
  def use_tool(item, target = nil)
    if @free_fire
      if item.ranged?
        pos = Mouse.true_grid_by_pos(false)
        pos = POS.new(pos[0], pos[1])
        pos.x -= 0.125; pos.y -= 0.125;
        target = pos
      else
        dir = toward_mouse_direction
        pos = POS.new(@x, @y)
        case dir
        when 8; pos.y -= 1;
        when 2; pos.y += 1;
        when 4; pos.x -= 1;
        when 6; pos.x += 1;
        end
        target = pos
      end
    end
    super(item, target)
    SceneManager.spriteset.hud_sprite[actor.index].draw_action(@next_action)
  end
  #----------------------------------------------------------------------------
  def setup_light(light_id)
    # tag: light
    #return
    p 'setup lantern'
    $game_map.lantern = $game_map.lantern
    $game_map.lantern.change_owner($game_player)
    $game_map.lantern.set_graphic(Light_Core::Effects[light_id].first)
    $game_map.lantern.set_opacity(180,30)
    $game_map.lantern.show
  end
  #----------------------------------------------------------------------------
  def dispose_light
    $game_map.lantern.hide
  end
  #--------------------------------------------------------------------------
  def casting_index
    actor.actor.casting_index rescue super
  end
  #--------------------------------------------------------------------------
  def casting_animation 
    actor.actor.casting_animation rescue super
  end
  #----------------------------------------------------------------------------
  def set_target(target)
    return @current_target = nil if target.nil?
    return unless target.enemy
    @current_target = target
    cancel_action_without_penalty
  end
  #----------------------------------------------------------------------------
  def get_ammo_item(item)
    if item.is_a?(RPG::Weapon) && item.tool_itemcost_type > 0
      return actor.current_ammo
    elsif (item.tool_itemcost || 0) > 0
      return $data_items[item.tool_itemcost]
    end
  end
  #----------------------------------------------------------------------------
  def battler
    return actor
  end
  #--------------------------------------------------------------------------
  def controlable?
    return super && actor.controlable?
  end
  #--------------------------------------------------------------------------
  def process_weapon_action
    toward_mouse_direction
    super
  end
  #--------------------------------------------------------------------------
  def toward_mouse_direction
    mx, my = *Mouse.true_grid_by_pos
    dx = (@x - mx).abs; dy = (@y - my).abs;
    if dx > dy
      return set_direction(@x < mx ? 6 : 4)
    else
      return set_direction(@y < my ? 2 : 8)
    end
  end
  #----------------------------------------------------------------------------
  def character_collided?(px, py, ignores = [])
    return false if through_character?
    return true  if collide_with_events?(px, py, ignores)
    return false
  end
  #--------------------------------------------------------------------------
  # * Start Map Event.                                                  [REP]
  #--------------------------------------------------------------------------
  def start_map_event(x, y, triggers, normal)
    return if $game_map.interpreter.running?
    $game_map.effectus_event_pos[y * $game_map.width + x].each do |event|
      if event.trigger_in?(triggers) && event.normal_priority? == normal
        event.start
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Collide?                                                          [REP]
  #--------------------------------------------------------------------------
  def collide?(x, y)
    !@through && (pos?(x, y)  ||
    !$game_map.effectus_party_pos[y * $game_map.width + x].empty?)
  end
  #----------------------------------------------------------------------------
  # * Execute action
  #----------------------------------------------------------------------------
  def execute_action
    super
    @action_cancel_timer = 0
  end
  #----------------------------------------------------------------------------
  def chase_target(action = nil, impleable = nil)
  end
  #----------------------------------------------------------------------------
  def valid_battler?
    return true
  end
  #----------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Follower
#------------------------------------------------------------------------------
#  This class handles followers. A follower is an allied character, other than
# the front character, displayed in the party. It is referenced within the
# Game_Followers class.
#==============================================================================
class Game_Follower < Game_Character
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :phase
  attr_accessor :effectus_position_registered
  attr_reader   :member_index
  attr_reader   :preceding_character
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias init_gafo_opt initialize
  def initialize(member_index, preceding_character)
    @phase = DND::BattlerSetting::PhaseIdle
    init_gafo_opt(member_index, preceding_character)
    @combat_mode_timer = 0
    @through = false
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Frame Update
  #--------------------------------------------------------------------------
  def update
    # opacity sync to $game_player is removed
    @move_speed     = $game_player.real_move_speed
    @transparent    = $game_player.transparent
    @walk_anime     = $game_player.walk_anime
    #@step_anime     = $game_player.step_anime
    @direction_fix  = $game_player.direction_fix
    @blend_type     = $game_player.blend_type
    update_movement
    @combat_mode_timer -= 1 if @combat_mode_timer > 0
    super
    update_collision_pos
  end
  #--------------------------------------------------------------------------
  # * Update.                                                           [REP]
  #--------------------------------------------------------------------------
  def update_collision_pos
    if visible?
      events = $game_map.effectus_party_pos
      width  = $game_map.width
      unless @effectus_position_registered
        events[@y * width + @x] << self
        @effectus_last_x = @x
        @effectus_last_y = @y
        @effectus_position_registered = true
      end
      if @x != @effectus_last_x || @y != @effectus_last_y
        events[@y * width + @x] <<
        events[@effectus_last_y * width + @effectus_last_x].delete(self)
        @effectus_last_x = @x
        @effectus_last_y = @y
      end
    else
      if @effectus_position_registered
        @effectus_position_registered = nil
        $game_map.effectus_party_pos[@effectus_last_y *
        $game_map.width + @effectus_last_x].delete(self)
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Combat mode on
  #--------------------------------------------------------------------------
  def process_combat_phase
    @fighting = true
  end
  #--------------------------------------------------------------------------
  # * Combat mode off
  #--------------------------------------------------------------------------
  def retreat_combat
    set_target(nil)
    @fighting = false
    chase_preceding_character
  end
  #---------------------------------------------------------------------------
  def update_movement
    process_pathfinding_movement
  end
  #--------------------------------------------------------------------------
  def body_size
    return 1 * @zoom_x
  end
  #--------------------------------------------------------------------------
  def hashid
    return actor.hashid if actor
    return PONY.Sha256(self.inspect)
  end
  #--------------------------------------------------------------------------
  def primary_weapon
    return nil if !actor
    return actor.equips[0]
  end
  #--------------------------------------------------------------------------
  def secondary_weapon
    return nil if !actor
    return actor.equips[1]
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Determine Visibility
  #--------------------------------------------------------------------------
  def visible?
    super && actor && $game_player.followers.visible
  end
  #----------------------------------------------------------------------------
  # * Die when hitpoint drop to zero
  #----------------------------------------------------------------------------
  def kill
    process_actor_death
    super
  end
  #----------------------------------------------------------------------------
  def dead?
    return true if actor.nil?
    return actor.dead?
  end
  #----------------------------------------------------------------------------
  def alive?
    return !dead?
  end
  #--------------------------------------------------------------------------
  def aggressive_level
    return 0 if actor.nil?
    return actor.aggressive_level
  end
  #--------------------------------------------------------------------------
  # * Determine if Movement is Possible
  #--------------------------------------------------------------------------
  def movable?
    return false if actor && !actor.movable?
    return super
  end
  #---------------------------------------------------------------------------
  # * Method Missing
  # ----------------------------------------------------------------------   
  # DANGER ZONE: Redirect to Game_Enemy
  #---------------------------------------------------------------------------
  def method_missing(symbol, *args)
    super(symbol, *args) if actor.nil?
    actor.method(symbol).call(*args)
  end
  #----------------------------------------------------------------------------
  # * Allow character move freely between characters?
  #----------------------------------------------------------------------------
  def allow_loose_moving?
    return false
  end
  #--------------------------------------------------------------------------
  def team_id
    return @team_id.nil? ? @team_id = 0 : @team_id
  end
  #--------------------------------------------------------------------------
  def update_combat_mode
    return if $game_message.busy?
    return if $game_system.story_mode?
    return if aggressive_level < 2 || @combat_mode_timer > 0
    @combat_mode_timer = 30
    process_combat_phase
  end
  #----------------------------------------------------------------------------
  # * Use item
  #----------------------------------------------------------------------------
  def use_tool(item, target = nil)
    super
    SceneManager.spriteset.hud_sprite[actor.index].draw_action(@next_action)
  end
  #----------------------------------------------------------------------------
  def setup_light(light_id)
    # tag: light
    #return
    $game_map.lantern.change_owner($game_player)
    $game_map.lantern.set_graphic(Light_Core::Effects[light_id])
    $game_map.lantern.set_opacity(180,30)
    $game_map.lantern.show
  end
  #----------------------------------------------------------------------------
  def dispose_light
    $game_map.lantern.hide
  end
  #--------------------------------------------------------------------------
  def casting_index
    actor.actor.casting_index rescue super
  end
  #--------------------------------------------------------------------------
  def casting_animation 
    actor.actor.casting_animation rescue super
  end
  #--------------------------------------------------------------------------
  def get_ammo_item(item)
    if item.is_a?(RPG::Weapon) && item.tool_itemcost_type > 0
      return actor.current_ammo
    elsif (item.tool_itemcost || 0) > 0
      return $data_items[item.tool_itemcost]
    end
  end
  #----------------------------------------------------------------------------
  def battler
    return actor if actor
    return super
  end
  #--------------------------------------------------------------------------
  def controlable?
    return true if !actor
    return super && actor.controlable?
  end
  #----------------------------------------------------------------------------
  def character_collided?(px, py, ignores = [])
    return false if through_character?
    return true  if collide_with_events?(px, py, ignores)
    return false
  end
  #----------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Followers
#------------------------------------------------------------------------------
#  This is a wrapper for a follower array. This class is used internally for
# the Game_Player class. 
#==============================================================================
class Game_Followers
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     leader:  Lead character
  #--------------------------------------------------------------------------
  alias init_dnd initialize
  def initialize(leader)
    @fighting = true
    init_dnd(leader)
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    if gathering?
      move unless moving? || moving?
      @gathering = false if gather?
    end
    each {|follower| follower.update unless follower.nil? || follower.actor.nil?}
  end
  #--------------------------------------------------------------------------
  def toggle_combat
    @fighting ? retreat_fray : into_fray
    $game_party.skillbar.sprite.refresh
  end
  #--------------------------------------------------------------------------
  # * Combat mode on
  #--------------------------------------------------------------------------
  def into_fray
    @fighting = true
    each {|follower| follower.process_combat_phase}
  end
  #--------------------------------------------------------------------------
  # * Combat mode off
  #--------------------------------------------------------------------------
  def retreat_fray
    @fighting = false
    each {|follower| follower.retreat_combat}
  end
  #--------------------------------------------------------------------------
  def combat_mode?
    @fighting
  end
  alias :tactic_enabled? :combat_mode?
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Vehicle
#------------------------------------------------------------------------------
#  This class handles vehicles. It's used within the Game_Map class. If there
# are no vehicles on the current map, the coordinates are set to (-1,-1).
#==============================================================================
class Game_Vehicle < Game_Character
  #--------------------------------------------------------------------------
  # * Determine if Docking/Landing Is Possible.                         [REP]
  #--------------------------------------------------------------------------
  def land_ok?(x, y, d)
    if @type == :airship
      return false unless $game_map.airship_land_ok?(x, y)
      return false unless $game_map.events_xy(x, y).empty?
    else
      x2 = d == 4 ? x - 1 : d == 6 ? x + 1 : x
      y2 = d == 8 ? y - 1 : d == 2 ? y + 1 : y
      return false unless $game_map.valid?(x2, y2) &&
      $game_map.effectus_original_passable?(x2, y2, 10 - 1)
      return false if collide_with_characters?(x2, y2)
    end
    return true
  end
end

#==============================================================================
# ** Game_Event
#------------------------------------------------------------------------------
#  This class handles events. Functions include event page switching via
# condition determinants and running parallel process events. Used within the
# Game_Map class.
#==============================================================================
class Game_Event < Game_Character
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :enemy
  attr_reader   :event
  attr_reader   :terminated
  attr_reader   :sight_timer
  attr_reader   :sight_lost_timer
  attr_reader   :stuck_timer
  attr_accessor :static_object
  #--------------------------------------------------------------------------
  attr_accessor :default_weapon
  attr_accessor :last_target
  attr_accessor :cool_down
  attr_accessor :recover
  attr_accessor :target_switch
  attr_accessor :self_vars
  attr_accessor :aggressive_level
  attr_accessor :condition_flag
  attr_accessor :terminate_cd
  attr_accessor :priority_type
  #--------------------------------------------------------------------------
  # * Overwrite: Object Initialization
  #     event:  RPG::Event
  #--------------------------------------------------------------------------
  def initialize(map_id, event)
    super()
    @map_id = map_id
    @event = event
    @id = @event.id
    @terminate_cd = 0
    moveto(@event.x, @event.y)
    collect_code_conditions
    refresh
  end
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias initialize_event_opt initialize
  def initialize(map_id, event)
    @self_vars        = Array.new(4){|i| i = 0}
    @terminated       = false
    @static_object    = false
    @sight_timer      = 5 + rand(20)
    @sight_lost_timer = 0
    @stuck_timer      = 0
    @code_conditions  = []
    initialize_event_opt(map_id, event)
    hash_self
  end
  #--------------------------------------------------------------------------
  # * Initialize.                                                       [REP]
  #--------------------------------------------------------------------------
  alias init_effectus initialize
  def initialize(map_id, event)
    init_effectus(map_id, event)
    triggers    = $game_map.effectus_etriggers
    tile_events = $game_map.effectus_tile_events
    @event.pages.each do |page|
      condition = page.condition
      if condition.switch1_valid
        trigger_symbol = :"switch_#{condition.switch1_id}"
        unless triggers[trigger_symbol].include?(self)
          triggers[trigger_symbol]  << self 
        end
      end
      if condition.switch2_valid
        trigger_symbol = :"switch_#{condition.switch2_id}"
        unless triggers[trigger_symbol].include?(self)
          triggers[trigger_symbol]  << self 
        end
      end
      if condition.variable_valid
        trigger_symbol = :"variable_#{condition.variable_id}"
        unless triggers[trigger_symbol].include?(self)
          triggers[trigger_symbol]  << self 
        end
      end
      if condition.self_switch_valid
        key = [@map_id, @event.id, condition.self_switch_ch]
        unless triggers[key].include?(self)
          triggers[key] << self
        end
      end
      if condition.item_valid
        trigger_symbol = :"item_id_#{condition.item_id}"
        unless triggers[trigger_symbol].include?(self)
          triggers[trigger_symbol]  << self 
        end
      end
      if condition.actor_valid
        trigger_symbol = :"actor_id_#{condition.actor_id}"
        unless triggers[trigger_symbol].include?(self)
          triggers[trigger_symbol]  << self 
        end
      end
      if page.graphic.tile_id > 0 && page.priority_type == 0
        unless tile_events.include?(self)
          tile_events << self
        end
      end
    end
  end
  #--------------------------------------------------------------------------
  def collect_code_conditions
    @event.pages.each do |page|
      for command in page.list
        condition_push_flag = false
        if command.code == 108
          command.parameters[0].split(/[\r\n]+/).each do |line|
            if line =~ DND::REGEX::Event::Condition
              puts "#{event.name} code condition: #{$1}"
              page.condition.code_condition << $1 
            end
          end # each line in comment
        end # if the command is comment
      end # each command in page list
    end # each page in event
  end
  #--------------------------------------------------------------------------
  # * Determine if Event Page Conditions Are Met
  #--------------------------------------------------------------------------
  alias :code_condition_met? :conditions_met?
  def conditions_met?(page)
    re = code_condition_met?(page)
    return re if !re
    c = page.condition
    if !c.code_condition.empty?
      @condition_flag = true
      re = false
      $event = self
      c.code_condition.each do |code|
        puts "#{$event.id}: #{code} #{eval(code) rescue false}"
        re ||= eval(code) rescue false
      end
      return re
    end
    return true
  end
  #--------------------------------------------------------------------------
  # * Init Public Members.                                              [REP]
  #--------------------------------------------------------------------------
  def init_public_members
    super
    @trigger = 0
    @list = nil
    @starting = false
    if $game_map.effectus_event_starting == self
      $game_map.effectus_event_starting = nil
    end
  end
  #--------------------------------------------------------------------------
  # * Start.                                                            [REP]
  #--------------------------------------------------------------------------
  def start
    return if empty?
    @starting = true
    lock if trigger_in?([0,1,2])
    $game_map.effectus_event_starting = self
  end
  #--------------------------------------------------------------------------
  # * Start Event
  #--------------------------------------------------------------------------
  alias start_gevt_dnd start
  def start
    return if SceneManager.time_stopped?
    start_gevt_dnd
  end
  #--------------------------------------------------------------------------
  # * overwrite method: setup_page_settings
  #--------------------------------------------------------------------------
  def setup_page_settings
    @tile_id          = @page.graphic.tile_id
    @character_name   = @page.graphic.character_name
    @character_index  = @page.graphic.character_index
    
    if @original_direction != @page.graphic.direction
      @direction          = @page.graphic.direction
      @original_direction = @direction
      @prelock_direction  = 0
    end
    
    if @original_pattern != @page.graphic.pattern
      @pattern            = @page.graphic.pattern
      @original_pattern   = @pattern
    end
    
    @move_type          = @page.move_type
    @move_speed         = @page.move_speed
    @move_frequency     = @page.move_frequency
    
    #tag: modified here
    if !@on_path_finding || @on_path_finding.nil?
      @move_route         = @page.move_route
      @move_route_index   = 0               
      @move_route_forcing = false           
    end
    
    @walk_anime         = @page.walk_anime
    @step_anime         = @page.step_anime
    @direction_fix      = @page.direction_fix
    @through            = @page.through
    @priority_type      = @page.priority_type
    @trigger            = @page.trigger
    @list               = @page.list
    @interpreter = @trigger == 4 ? Game_Interpreter.new : nil
  end
  #--------------------------------------------------------------------------
  # * Clear Starting Flag.                                              [REP]
  #--------------------------------------------------------------------------
  def clear_starting_flag
    @starting = false
    if $game_map.effectus_event_starting == self
      $game_map.effectus_event_starting = nil
    end
  end
  #----------------------------------------------------------------------------
  # * Get comments in event page
  #----------------------------------------------------------------------------
  def get_comments
    return unless @list
    comments = ""
    cnt = 0
    listn = @list.size
    while cnt < listn
      if @list[cnt].code == 108
        comments += @list[cnt].parameters[0] + 10.chr
        while cnt < listn && @list[cnt + 1].code == 408
          cnt += 1
          comments += @list[cnt].parameters[0] + 10.chr
        end
      end
      cnt += 1
    end
    
    return comments
  end
  #--------------------------------------------------------
  # *) check if comment is in event page
  #--------------------------------------------------------
  def comment_include?(comment)
    return if comment.nil? || @list.nil?
    comment = comment.to_s
    for command in @list
      if command.code == 108
        return true if command.parameters[0].include?(comment)
      end # if command.code
    end # for command
    return false
  end # def comment
  #-------------------------------------------------------------------------------
  # * Alias: setup page
  #-------------------------------------------------------------------------------
  alias setup_page_dnd setup_page
  def setup_page(new_page)
    setup_page_dnd(new_page)
    setup_enemy(new_page.nil?)
  end
  #-------------------------------------------------------------------------------
  # * Setup enemy
  #-------------------------------------------------------------------------------
  def setup_enemy(invalid)
    if @enemy
      BattleManager.resign_battle_unit(self)
      @enemy = nil
    end
    unless invalid && @list.nil?
      load_npc_attributes
    end
  end
  #-------------------------------------------------------------------------------
  # * Load comment command configs in page
  #-------------------------------------------------------------------------------
  def load_npc_attributes
    comments = get_comments
    npc_config = false
    comments.split(/[\r\n]+/).each do |line|
      case line
      when DND::REGEX::Event::Terminated
        terminate
      when DND::REGEX::Event::Frozen
        freeze
      when DND::REGEX::NPCEvent::Enemy
        spawn_npc_battler($1.to_i)
      when DND::REGEX::NPCEvent::ConfigON
        npc_config = true
      when DND::REGEX::NPCEvent::ConfigOFF
        npc_config = false
      when DND::REGEX::NPCEvent::StaticObject
        @static_object = true
        debug_print "#{event.name} #{@id} is a static object"
      end
      process_npc_event_config(line) if npc_config
    end # each comment line
  end
  #-------------------------------------------------------------------------------
  # * Load params of REGEX::Character in event comment command
  #-------------------------------------------------------------------------------
  def process_npc_event_config(line)
    case line
    when DND::REGEX::Character::DefaultWeapon
      @default_weapon = $data_weapons[$1.to_i]
    when DND::REGEX::Character::TeamID
      @team_id = $1.to_i
    when DND::REGEX::Character::DeathSwitchSelf
      @death_switch_self = $1.upcase
    when DND::REGEX::Character::DeathSwitchGlobal
      @death_switch_global = $1.to_i
    when DND::REGEX::Character::DeathVarSelf
      @death_var_self = [$1.to_i, $2.to_i]
    when DND::REGEX::Character::DeathVarGlobal
      @death_var_global = [$1.to_i, $2.to_i]
    when DND::REGEX::Character::VisibleSight
      @visible_sight = $1.to_i
    when DND::REGEX::Character::BlindSight
      @blind_sight   = $1.to_i
    when DND::REGEX::Character::Infravision
      @infravision   = $1.to_i.to_bool
    when DND::REGEX::Character::AggressiveLevel
      @aggressive_level = $1.to_i
    when DND::REGEX::Character::MoveLimit
      @move_limit      = $1.to_i
    when DND::REGEX::Character::DeathAnimation
      @death_animation = $1.to_i
    end
  end
  #-------------------------------------------------------------------------------
  # * Spawn NPC battler
  #-------------------------------------------------------------------------------
  def spawn_npc_battler(id)
    if $game_map.event_battler_instance[$game_map.map_id][@id]
      @enemy = $game_map.event_battler_instance[$game_map.map_id][@id]
      @enemy = Game_Enemy.new($game_map.enemies.size, id) if @enemy.dead?
      @enemy.map_char = self
    else
      @enemy = Game_Enemy.new($game_map.enemies.size, id)
      @enemy.map_char = self
    end
    
    debug_print "Spawn enemy #{@enemy.name} at event #{@id}"
    BattleManager.register_battler(self)
    $game_map.make_unique_names
    @enemy.load_tactic_commands
  end
  #--------------------------------------------------------------------------
  # * Move Type : Random.                                               [REP]
  #--------------------------------------------------------------------------
  def move_type_random
    case rand(6)
    when 0 then move_random
    when 1 then move_random
    when 2 then move_forward
    when 3 then move_forward
    when 4 then move_forward
    when 5 then @stop_count = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Move Type : Approach.                                             [REP]
  #--------------------------------------------------------------------------
  def move_type_toward_player
    if near_the_player?
      case rand(6)
      when 0 then move_toward_player
      when 1 then move_toward_player
      when 2 then move_toward_player
      when 3 then move_toward_player
      when 4 then move_random
      when 5 then move_forward
      end
    else
      move_random
    end
  end
  #----------------------------------------------------------------------------
  def update_terminate
    @terminate_cd -= 1
    if @terminate_cd <= 0
      @terminated = true
    end
  end
  #----------------------------------------------------------------------------
  # * Permanently delete the event
  #----------------------------------------------------------------------------
  def terminate
    @terminate_cd = 180 if (@terminate_cd || 0) <= 0
  end
  #----------------------------------------------------------------------------
  def terminated?
    @terminated
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  alias update_gvednd update
  def update
    active = MakerSystems::Effectus::PREVENT_OFFSCREEN_UPDATES
    update_terminate if @terminate_cd > 0
    update_gvednd unless active
    if effectus_near_the_screen? || @effectus_wait_for_animation || @balloon_id > 0
      update_gvednd
      update_effectus_sprite
    else
      update_effectus_route
    end
    
    update_position_registeration unless @effectus_position_registered
    update_position_moved if effectus_moved?
  end
  alias effectus_original_update update_gvednd
  #--------------------------------------------------------------------------
  # * Overwrite: Update During Autonomous Movement
  #--------------------------------------------------------------------------
  def update_self_movement
    return if $game_system.story_mode?
    if !@pathfinding_moves.empty?
      process_pathfinding_movement
    #elsif BattleManager.valid_battler?(self) && @current_target
    #  chase_target
    elsif near_the_screen? && @stop_count > stop_count_threshold
      case @move_type
      when 1;  move_type_random
      when 2;  move_type_toward_player
      when 3;  move_type_custom
      end
    end
  end
  #----------------------------------------------------------------------------
  def battler
    return @enemy if @enemy
    return super
  end
  #--------------------------------------------------------------------------
  def controlable?
    return true if !@enemy
    return super && @enemy.controlable?
  end
  #----------------------------------------------------------------------------
  # * Freeze event from update
  #----------------------------------------------------------------------------
  alias ruby_freeze freeze
  def freeze
    @frozen = true
  end
  #----------------------------------------------------------------------------
  def unfreeze
    @frozen = false
  end
  #----------------------------------------------------------------------------
  alias :ruby_frozen? :frozen?
  def frozen?
    @frozen
  end
  #----------------------------------------------------------------------------
  def dead?
    return true if @enemy.nil?
    return @enemy.dead?
  end
  #----------------------------------------------------------------------------
  def alive?
    return !dead?
  end
  #----------------------------------------------------------------------------
  def name(original_event = false)
    return @enemy.name if !original_event && @enemy
    return event.name
  end
  #----------------------------------------------------------------------------
  # * Die when hitpoint drop to zero
  #----------------------------------------------------------------------------
  def kill
    process_event_death
    super
    refresh
    puts "#{event.id} #{event.name} killed"
  end
  #-------------------------------------------------------------------------------
  # * Params to method
  #-------------------------------------------------------------------------------
  def default_weapon
    return @default_weapon             if @default_weapon
    return @enemy.enemy.default_weapon if @enemy
    returnDND::BattlerSetting::DefaultWeapon
  end
  #--------------------------------------------------------------------------
  # * Refresh. tag: effectus                                            [REP]
  #--------------------------------------------------------------------------
  def refresh
    new_page = @erased ? nil : find_proper_page
    setup_page(new_page) if !new_page || new_page != @page
    @effectus_always_update = false
    if @page && @page.list
      @page.list.each do |command|
        next unless command.code == 108
        MakerSystems::Effectus::PATTERNS.each do |string| 
          next unless command.parameters[0].include?(string)
          @effectus_always_update = true                
          break
        end
        break if @effectus_always_update
      end
    end
    @effectus_always_update = true if trigger == 3 || trigger == 4
    if $game_map.effectus_hard_events.include?(self)
      unless @effectus_always_update
        $game_map.effectus_hard_events.delete(self)
      end
    else
      if @effectus_always_update
        $game_map.effectus_hard_events << self
      end
    end
    if tile? || @effectus_tile
      if $game_map.effectus_pass_table
        unless @effectus_tile && tile?
          $game_map.effectus_release(@x, @y)
        end
      end
    end
    @effectus_tile = tile?
    if @effectus_tile
      unless @effectus_tile_registered
        @effectus_tile_registered = true
        $game_map.effectus_etile_pos[@y * $game_map.width + @x] << self
      end
    else
      if @effectus_tile_registered
        $game_map.effectus_etile_pos[@y * $game_map.width + @x].delete(self)
        @effectus_tile_registered = nil
      end
    end
    unless @effectus_position_registered
      $game_map.effectus_event_pos[@y * $game_map.width + @x] << self
      @effectus_last_x = @x
      @effectus_last_y = @y
      @effectus_position_registered = true
    end
    unless @character_name == @effectus_last_character_name
      bitmap = Cache.character(@character_name)
      string = @character_name[/^[\!\$]./]
      if string && string.include?('$')
        @effectus_bw = bitmap.width / 3 
        @effectus_bh = bitmap.height / 4 
      else
        @effectus_bw = bitmap.width / 12
        @effectus_bh = bitmap.height / 8
      end
      @effectus_last_character_name = @character_name
      @effectus_special_calculus = @effectus_bw > 32 || @effectus_bh > 32
    end
  end
  #--------------------------------------------------------------------------
  # * Near the Screen?                                                  [NEW]
  #--------------------------------------------------------------------------
  if MakerSystems::Effectus::SCREEN_TILE_DIVMOD
    def effectus_near_the_screen?
      if @effectus_special_calculus
        sx = (@real_x - $game_map.display_x) * 32 + 16
        sy = (@real_y - $game_map.display_y) * 32 + 32 - shift_y - jump_height
        sx + @effectus_bw > 0 && 
        sx - @effectus_bw < Graphics.width &&
        sy + @effectus_bh > 0 &&
        sy - @effectus_bh < Graphics.height
      else
        @real_x > $game_map.display_x - 1 &&
        @real_x < $game_map.display_x + Graphics.width  / 32 + 1 &&
        @real_y > $game_map.display_y - 1 &&
        @real_y < $game_map.display_y + Graphics.height / 32 + 1
      end
    end
  else
    def effectus_near_the_screen?
      if @effectus_special_calculus
        sx = (@real_x - $game_map.display_x) * 32 + 16
        sy = (@real_y - $game_map.display_y) * 32 + 32 - shift_y - jump_height
        sx + @effectus_bw > 0 && 
        sx - @effectus_bw < Graphics.width &&
        sy + @effectus_bh > 0 &&
        sy - @effectus_bh < Graphics.height
      else
        @real_x > $game_map.display_x - 1 &&
        @real_x < $game_map.display_x + Graphics.width  / 32 &&
        @real_y > $game_map.display_y - 1 &&
        @real_y < $game_map.display_y + Graphics.height / 32
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Determine if Movement is Possible
  #--------------------------------------------------------------------------
  def movable?
    return false if @enemy && !@enemy.movable?
    return super
  end
  #----------------------------------------------------------------------------
  def team_id
    return @team_id = @enemy.team_id if @enemy
    return nil
    #return DND::BattlerSetting::TeamID
  end
  #----------------------------------------------------------------------------
  def death_switch_self
    return @death_switch_self             if @death_switch_self
    return @enemy.enemy.death_switch_self if @enemy
    return DND::BattlerSetting::DeathSwitchSelf
  end
  #----------------------------------------------------------------------------
  def death_switch_global
    return @death_switch_global             if @death_switch_global
    return @enemy.enemy.death_switch_global if @enemy
    return DND::BattlerSetting::DeathSwitchGlobal
  end
  #----------------------------------------------------------------------------
  def death_var_self
    return @death_var_self             if @death_var_self
    return @enemy.enemy.death_var_self if @enemy
    return DND::BattlerSetting::DeathVarSelf
  end
  #----------------------------------------------------------------------------
  def death_var_global
    return @death_var_global             if @death_var_global
    return @enemy.enemy.death_var_global if @enemy
    return DND::BattlerSetting::DeathVarGlobal
  end
  #----------------------------------------------------------------------------
  def visible_sight
    return @visible_sight             if @visible_sight
    return @enemy.enemy.visible_sight if @enemy
    return DND::BattlerSetting::VisibleSight
  end
  #----------------------------------------------------------------------------
  def blind_sight
    return @blind_sight             if @blind_sight
    return @enemy.enemy.blind_sight if @enemy
    return DND::BattlerSetting::BlindSight
  end
  #----------------------------------------------------------------------------
  def infravision
    return @infravision             if @infravision
    return @enemy.enemy.infravision if @enemy
    return DND::BattlerSetting::Infravision
  end
  #----------------------------------------------------------------------------
  def aggressive_level
    return @aggressive_level     if @aggressive_level
    return @aggressive_level = @enemy.enemy.aggressive_level if @enemy
    return DND::BattlerSetting::AggressiveLevel
  end
  #----------------------------------------------------------------------------
  def move_limit
    return @move_limit       if @move_limit
    return @enemy.move_limit if @enemy
    return DND::BattlerSetting::MoveLimit
  end
  #---------------------------------------------------------------------------
  def weapon_level_prof
    return @weapon_level_prof     if @weapon_level_prof
    return @weapon_level_prof = @enemy.weapon_level_prof if @enemy
    return 0
  end
  #----------------------------------------------------------------------------
  def body_size
    return @enemy.enemy.body_size * @zoom_x if @enemy
    return DND::BattlerSetting::BodySize
  end
  #----------------------------------------------------------------------------
  def death_animation
    return @enemy.enemy.death_animation if @enemy
    return DND::BattlerSetting::DeathAnimation
  end
  #--------------------------------------------------------------------------
  def face_name
    return @enemy.face_name if @enemy
    return nil
  end
  #--------------------------------------------------------------------------
  def face_index
    return @enemy.face_index if @enemy
    return 0
  end
  #--------------------------------------------------------------------------
  def weapon_cooldown
    return @enemy.weapon_cooldown if @enemy
    return {}
  end
  #--------------------------------------------------------------------------
  def armor_cooldown
    return @enemy.armor_cooldown if @enemy
    return {}
  end
  #--------------------------------------------------------------------------
  def skill_cooldown
    return @enemy.skill_cooldown if @enemy
    return {}
  end
  #--------------------------------------------------------------------------
  def item_cooldown
    return @enemy.item_cooldown if @enemy
    return {}
  end
  #--------------------------------------------------------------------------
  def hash_self
    base  = (@map_id * 1000 + @id)
    base += @enemy.hashid if @enemy
    base  = base.to_s + self.inspect
    @hashid = PONY.Sha256(base).to_i(16)
    super
  end
  #--------------------------------------------------------------------------
  def default_ammo
    return @default_ammo if @default_ammo
    return @default_ammo = @enemy.default_ammo if @enemy
    return 0
  end
  #--------------------------------------------------------------------------
  def primary_weapon
    return @enemy.default_weapon if @enemy
  end
  #----------------------------------------------------------------------------
  def secondary_weapon
    return @enemy.secondary_weapon if @enemy
  end
  #----------------------------------------------------------------------------
  def static_object?
    return @static_object
  end
  #--------------------------------------------------------------------------
  def casting_animation 
    return super if !@enemy
    return @enemy.enemy.casting_animation rescue super
  end
  #--------------------------------------------------------------------------
  def get_ammo_item(item)
    if item.is_a?(RPG::Weapon) && item.tool_itemcost_type > 0
      return $data_weapons[default_ammo]
    elsif (item.tool_itemcost || 0) > 0
      return $data_items[item.tool_itemcost]
    end
  end
  #--------------------------------------------------------------------------
  # * Detect Collision with Character.                                  [REP]
  #--------------------------------------------------------------------------
  def collide_with_characters?(x, y)
    super || (normal_priority? && $game_player.collide?(x, y))
  end
  #---------------------------------------------------------------------------
  # * Method Missing
  # ----------------------------------------------------------------------   
  # DANGER ZONE: Redirect to Game_Enemy
  #---------------------------------------------------------------------------
  def method_missing(symbol, *args)
    super(symbol, *args) if @enemy.nil?
    @enemy.method(symbol).call(*args)
  end
  
end

#==============================================================================
# ** Game_Event
#------------------------------------------------------------------------------
#  Sperated form original effectus script for better readability
#==============================================================================
class Game_Event < Game_Character
  #----------------------------------------------------------------------------
  # * Update sprite formation
  #----------------------------------------------------------------------------
  def update_effectus_sprite
    @balloon_id > 0
    effectus_original_update if active
      
    unless $game_temp.effectus_sprites[@id]
      $game_temp.effectus_sprites[@id] = 
      Sprite_Character.new(SceneManager.scene.spriteset.viewport1, self)
    end
    
    $game_temp.effectus_sprites[@id].update
    if $game_temp.effectus_sprites[@id].animation?
      unless @effectus_wait_for_animation
        @effectus_wait_for_animation = true
        unless $game_map.effectus_hard_events.include?(self)
          $game_map.effectus_hard_events << self
        end
      end # unless wait for animation
    else
      if @effectus_wait_for_animation
        @effectus_wait_for_animation = nil
        unless @effectus_always_update
          if $game_map.effectus_hard_events.include?(self)
            $game_map.effectus_hard_events.delete(self)
          end
        end # unless always update
      end # if wait for animation
    end # if animationing
    
  end
  #----------------------------------------------------------------------------
  # * update route formation
  #----------------------------------------------------------------------------
  def update_effectus_route
    effectus_original_update if (@effectus_always_update && active) ||
                                      @move_route_forcing
    unless @effectus_always_update
      if @move_route_forcing
        unless @effectus_wait_for_move_route_forcing
          @effectus_wait_for_move_route_forcing = true
          unless $game_map.effectus_hard_events.include?(self)
            $game_map.effectus_hard_events << self
          end
        end
      else
        if @effectus_wait_for_move_route_forcing
          @effectus_wait_for_move_route_forcing = nil
          if $game_map.effectus_hard_events.include?(self)
            $game_map.effectus_hard_events.delete(self)
          end
        end
      end
    end
    
    if $game_temp.effectus_sprites[@id]
      $game_temp.effectus_sprites[@id].dispose
      $game_temp.effectus_sprites.delete(@id)
    end
  end
  #----------------------------------------------------------------------------
  # * Event position occupation
  #----------------------------------------------------------------------------
  def update_position_registeration
    $game_map.effectus_event_pos[@y * $game_map.width + @x] << self
    @effectus_last_x = @x
    @effectus_last_y = @y
    @effectus_position_registered = true
    
  end
  #----------------------------------------------------------------------------
  # * Move to another position cache 
  #----------------------------------------------------------------------------
  def update_position_moved
    events   = $game_map.effectus_event_pos
    width = $game_map.width
    events[@y * width + @x] << events[@effectus_last_y * width + @effectus_last_x].delete(self)
    
    if @effectus_tile
      tiles = $game_map.effectus_etile_pos
      tiles[@y * width + @x] << 
      tiles[@effectus_last_y * width + @effectus_last_x].delete(self)
    end
    @effectus_last_x = @x
    @effectus_last_y = @y
  end
  #----------------------------------------------------------------------------
  def effectus_moved?
    @x != @effectus_last_x || @y != @effectus_last_y
  end
  
end

#==============================================================================
# ** Game_Interpreter
#------------------------------------------------------------------------------
#  An interpreter for executing event commands. This class is used within the
# Game_Map, Game_Troop, and Game_Event classes.
#==============================================================================
class Game_Interpreter
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :eval_passed
  attr_accessor :params
  attr_accessor :transfer_cd
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     depth : nest depth
  #--------------------------------------------------------------------------
  alias initialize_comp initialize
  def initialize(depth = 0)
    initialize_comp(depth)
    @params      = []
    @transfer_cd = 0
    @eval_passed = true
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  alias update_dnd update
  def update
    @transfer_cd = 0  if @transfer_cd.nil?
    @transfer_cd -= 1 if @transfer_cd > 0
    update_dnd
  end
  #--------------------------------------------------------------------------
  # * Event Setup
  #--------------------------------------------------------------------------
  alias setup_gmitopt setup
  def setup(list, event_id = 0)
    $event = $game_map.events[event_id]
    setup_gmitopt(list, event_id)
  end
  #--------------------------------------------------------------------------
  # * Open Menu Screen
  #--------------------------------------------------------------------------
  alias command_351_imagemenu command_351
  def command_351
    Window_MenuImageCommand::init_command_position
    command_351_imagemenu
  end
  #--------------------------------------------------------------------------
  # * Script
  #--------------------------------------------------------------------------
  def command_355
    script = @list[@index].parameters[0] + "\n"
    $event = $game_map.events[@event_id]
    
    while next_event_code == 655
      @index += 1
      script += @list[@index].parameters[0] + "\n"
    end
    @eval_passed = false
    
    begin
      eval(script)
    rescue Exception => e
      errfilename = "InterpreterErr.txt"
      info = sprintf(Vocab::Errno::ScriptErr, e, errfilename)
      SceneManager.display_info("Error: " + e.to_s)
      SceneManager.scene.raise_overlay_window(:popinfo, info)
      info = sprintf("%s\n%s\n%s\n", SPLIT_LINE, Time.now.to_s, e)
      e.backtrace.each{|line| info += line + 10.chr}
      puts "#{info}"
      File.open(errfilename, 'a') do |file|
        file.write(info)
      end
    end
    
    @eval_passed = true
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Shop Processing
  #--------------------------------------------------------------------------
  def command_302
    return if $game_party.in_combat?
    
    goods = [@params]
    while next_event_code == 605
      @index += 1
      goods.push(@list[@index].parameters)
    end
    SceneManager.call(Scene_Shop)
    SceneManager.scene.prepare(goods, @params[4])
    Fiber.yield
  end
  #--------------------------------------------------------------------------
  # * Transfer Player
  #--------------------------------------------------------------------------
  def command_201(params = nil)
    return if @transfer_cd > 0
    if $game_party.in_combat?
      SceneManager.display_info(Vocab::TransferCombat)
      @transfer_cd = 120
      4.times{$game_player.move_straight(10 - $game_player.direction)}
      return
    elsif !$game_party.gathered?
      Audio.se_play("Audio/SE/hint_transfer_gather", 100, 100)
      SceneManager.display_info(Vocab::TransferGather)
      @transfer_cd = 120
      4.times{$game_player.move_straight(10 - $game_player.direction)}
      return
    end
    Fiber.yield while $game_player.transfer? || $game_message.visible
    @params = params unless params.nil?
    @params[5] = 2 if @params[5] == 0
    
    if @params[0] == 0                      # Direct designation
      map_id = @params[1]
      x = @params[2]
      y = @params[3]
    else                                    # Designation with variables
      map_id = $game_variables[@params[1]]
      x = $game_variables[@params[2]]
      y = $game_variables[@params[3]]
    end
    
    $game_player.reserve_transfer(map_id, x, y, @params[4])
    $game_temp.fade_type = @params[5]
    $game_temp.loading_destroy_delay = true
    Fiber.yield while $game_player.transfer? || SceneManager.loading?
    SceneManager.destroy_loading_screen
    $game_temp.loading_destroy_delay = false
  end
  #--------------------------------------------------------------------------
  # * Execute
  #--------------------------------------------------------------------------
  def run
    wait_for_message
    while @list[@index] do
      execute_command
      @index += 1
    end
    @fiber = nil
    Fiber.yield
  end
  #--------------------------------------------------------------------------
  # * Get Target of Screen Command
  #--------------------------------------------------------------------------
  def screen
    return $game_map.screen
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Change State
  #--------------------------------------------------------------------------
  def command_313
    iterate_actor_var(@params[0], @params[1]) do |actor|
      already_dead = actor.dead?
      if @params[2] == 0
        actor.add_state(@params[3], actor) # changed here
      else
        actor.remove_state(@params[3])
      end
      actor.perform_collapse_effect if actor.dead? && !already_dead
    end
    $game_party.clear_results
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Change Enemy State
  #--------------------------------------------------------------------------
  def command_333
    iterate_enemy_index(@params[0]) do |enemy|
      already_dead = enemy.dead?
      if @params[1] == 0
        enemy.add_state(@params[2], enemy) # changed here
      else
        enemy.remove_state(@params[2])
      end
      enemy.perform_collapse_effect if enemy.dead? && !already_dead
    end
  end
  #--------------------------------------------------------------------------
  # * Set Move Route
  #--------------------------------------------------------------------------
  def command_205
    $game_map.effectus_trigger_refresh if $game_map.effectus_need_refresh
    $game_map.refresh if $game_map.need_refresh
    character = get_character(@params[0])
    if character
      character.force_move_route(@params[1])
      Fiber.yield while character.move_route_forcing if @params[1].wait
    end
  end
  #--------------------------------------------------------------------------
  # * Change Actor Graphic
  #--------------------------------------------------------------------------
  def command_322
    actor = $game_actors[@params[0]]
    if actor
      actor.set_graphic(@params[1], @params[2], @params[3], @params[4])
    end
    $game_player.refresh
    return unless SceneManager.scene.is_a?(Scene_Map)
    SceneManager.scene.spriteset.effectus_vanilla_update_sprites
  end
  
end

#==============================================================================
# ** Game_Currency
#------------------------------------------------------------------------------
#  The trade currency; e.g. Bits
#==============================================================================
class Game_Currency
  Normal  = "βits"
  Special = "Chromastal"
  Coin_Name = [Normal, Special]
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :name
  attr_reader   :id
  attr_reader   :hashid
  attr_accessor :value
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(_id, amount = 0)
    @name = Coin_Name[_id]
    @id = _id
    @value = amount.to_i
    hash_object
  end
  #--------------------------------------------------------------------------
  # * Object Hash
  #--------------------------------------------------------------------------
  def hash_object
    prefix = PONY.MD5(@name)
    suffix = PONY.MD5(@value.to_s)
    @hashid = PONY.Sha256(prefix + suffix).to_i(16)
  end
  
  def merge(amount)
    @value += amount
  end
  
end
#==============================================================================
# ** Game_Transaction
#------------------------------------------------------------------------------
#  Transaction in game, or what do you want me to say!?
#==============================================================================
class Game_Transaction
  #--------------------------------------------------------------------------
  # * Instance Vars
  #--------------------------------------------------------------------------
  attr_reader :hashid
  attr_reader :currency
  attr_reader :source
  attr_reader :recipient
  attr_reader :info
  attr_reader :timestamp
  attr_reader :goods
  attr_reader :good_amount
  attr_reader :consumed
  #--------------------------------------------------------------------------
  # * Initialization
  #--------------------------------------------------------------------------
  def initialize(type_id, amount, from, to, goods, good_amount = 1, info = "")
    @currency    = Game_Currency.new(type_id, amount)
    @source      = BlockChain.accounts(from, true)
    @recipient   = BlockChain.accounts(to, true)
    @info        = info
    @goods       = goods if goods
    @good_amount = good_amount
    @timestamp   = Time.now
    @consumed    = false
    @cleansed    = nil
    hash_object
  end
  #--------------------------------------------------------------------------
  # * Merge/Offset Transaction
  #--------------------------------------------------------------------------
  def merge(trans)
    return if trans.source.id    != @source.id && trans.source.id    != @recipient.id 
    return if trans.recipient.id != @source.id && trans.recipient.id != @recipient.id
    return if trans.goods != @goods
    return :checksum_failed unless trans_legal?
    mul = (@source.id == trans.source.id) ? 1 : -1
    @good_amount   += trans.good_amount * mul if @goods
    @currency.merge(trans.value * mul)
    @consumed = (value == 0)
    hash_object
    return @consumed
  end
  
  def hash_object(overwrite = true)
    base  = @goods ? (@goods.hashid + @good_amount).to_s : "bits"
    base += @source.id.to_s + @recipient.id.to_s
    base  = PONY.Sha256(base + @currency.hashid.to_s + @info + @timestamp.to_s).to_i(16)
    @hashid = base if overwrite
    backup         if overwrite
    return base
  end
  
  def trans_legal?
    return @hashid == hash_object(false)
  end
  def backup
    @cleansed = self.dup
  end
  
  def recover
    @currency    = @cleansed.currency.dup
    @source      = @cleansed.source
    @recipient   = @cleansed.recipient
    @info        = @cleansed.info
    @goods       = @cleansed.goods
    @good_amount = @cleansed.good_amount
    @timestamp   = @cleansed.timestamp
    @consumed    = @cleansed.consumed
    hash_object
  end
  
  def dup_currency; @currency = @currency.dup; end
  #--------------------------------------------------------------------------
  # value of this transaction
  def value; return currency.value; end
  #--------------------------------------------------------------------------
  # currency type
  def type;  return currency.id; end
end

#===============================================================================
# * Game_Projectile
#-------------------------------------------------------------------------------
#   Projectiles in the game, game cannot be saved if any projectile exist
#===============================================================================
class Game_Projectile < Game_Character
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :user, :target
  attr_reader   :item
  attr_reader   :sprite
  attr_reader   :action
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(action, move_formula = nil)
    super()
    @user   = action.user
    @target = action.target ? action.target : POS.new(user.x, user.y)
    #puts "Projectile target address: #{target.x} #{target.y}"
    @moved_dis = 0
    @item   = action.item
    @max_range     = item.tool_distance
    @move_speed    = item.tool_speed
    @through       = item.tool_through
    @priority_type = item.tool_priority
    @tool_type     = item.tool_type
    @executed      = false
    @action        = action
    @move_formula  = move_formula
    @substitute    = nil
    @enemies       = BattleManager.opponent_battler(@action.user, true)
    moveto([@user.x, 0].max, [@user.y, 0].max)
    restore
    activate
    self
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    update_movement
    @sprite.update
    super
  end
  #--------------------------------------------------------------------------
  # * Movement process
  #--------------------------------------------------------------------------
  def update_movement
    return if SceneManager.time_stopped?
    execute_action if !process_projectile_move
    @sprite.execute_collide if collision_ready?
  end
  #--------------------------------------------------------------------------
  def collision_ready?
    if @moved_dis >= @max_range
      pos = POS.new(@x, @y)
      @action.target = pos
      return true
    end
    return true if (@x - target.x).abs < 0.2 && (@y - target.y).abs < 0.2
    return true if !@target.is_a?(POS) && self.adjacent?(target.x, target.y)
    return false
  end
  #--------------------------------------------------------------------------
  def process_projectile_move
    return false if @executed
    return wall_rammed if obstacle_touched?
    return process_move_formula if @move_formula
    
    pixelstep = Pixel_Core::Pixel
    len = [Math.hypot(@x -  target.x, @y - target.y), 0.1].max
    dx  = (target.x - @x).to_f / len
    dy  = (target.y - @y).to_f / len
    delta_x = distance_per_frame * dx * pixelstep / 2
    delta_y = distance_per_frame * dy * pixelstep / 2
    @x = $game_map.round_x(@x + delta_x)
    @y = $game_map.round_y(@y + delta_y)
    @real_x = @x - delta_x
    @real_y = @y - delta_y
    @moved_dis += Math.hypot(delta_x, delta_y)
    @direction = (delta_x.abs > delta_y.abs) ? (delta_x > 0 ? 6 : 4) : (delta_y > 0 ? 2 : 8)
    return !(delta_x == 0 && delta_y == 0)
  end
  #--------------------------------------------------------------------------
  def process_move_formula
    # tag: formula
    # link to module PONY::Formula
  end
  #--------------------------------------------------------------------------
  # * Execute Action
  #--------------------------------------------------------------------------
  def execute_action
    return if @executed
    @executed = true
    BattleManager.execute_action(@action)
  end
  #--------------------------------------------------------------------------
  # * Restore bitmap
  #--------------------------------------------------------------------------
  def restore
    dispose_sprite
    @sprite = Sprite_Projectile.new(SceneManager.viewport1, self)
  end
  #--------------------------------------------------------------------------
  def dispose_sprite
    return unless @sprite
    @sprite.dispose unless @sprite.disposed?
    @sprite = nil
  end
  #--------------------------------------------------------------------------
  def obstacle_touched?
    dir = @direction
    nx = @x * 4 + Pixel_Core::Tile_Range[dir][0]
    ny = @y * 4 + Pixel_Core::Tile_Range[dir][1]
    return true  if !$game_map.pixel_valid?(nx,ny) || $game_map.over_edge?(@x, @y)
    return false if @through
    return true  if $game_map.pixel_table[nx,ny,1] == 0
    return true  if check_substitute 
    return false
  end
  #--------------------------------------------------------------------------
  def check_substitute
    @enemies.each do |enemy|
      if adjacent?(enemy.x, enemy.y)
        @substitute = enemy
        return true
      end
    end
    return false
  end
  #--------------------------------------------------------------------------
  def wall_rammed
    @action.target = @substitute ? @substitute : POS.new(@x, @y)
    @sprite.execute_collide
    execute_action
  end
  #--------------------------------------------------------------------------
  def update_quadtree_index
  end
  #--------------------------------------------------------------------------
  def character_name; return item.tool_graphic; end
  def animation_id; return item.animation_id; end
  def update_realtime_action; end
  def dead?; return true; end
  def relocate; @sprite.relocate; end
  #---------------------------------------------------------
end

#===============================================================================
# * PONY::SkillBar
#-------------------------------------------------------------------------------
#   Tool/SkillBar Set up 
#===============================================================================
# tag: hotkey
# tag: skillbar
module PONY::SkillBar
  # Layout graphic
  LayoutImage = "Skillbar"
  
  # Follower attack command icon index
  FollowerIcon      = 11
  FollowerFightIcon = 116
  
  AllSkillIcon = 143
  VancianIcon  = 141
  AllItemIcon  = 1528
  
  PrevPageIcon  = 2238
  NextPageIcon  = 2237
  CancelIcon    = 1142
  
  HotKeySelection = 1
  AllSelection    = 2
  CastSelection   = 3
  
  Follower_Flag = "$game_player.followers.combat_mode? ? FollowerFightIcon : FollowerIcon"
  AllItem_Flag  = AllItemIcon
  AllSkill_Flag = AllSkillIcon
  Vancian_Flag  = VancianIcon
  
  PrevPage_Flag = PrevPageIcon
  NextPage_Flag = NextPageIcon
  Cancel_Flag   = CancelIcon
  
  def self.hide
    $game_system.skillbar_enable = true
  end
  
  def self.show
    $game_system.skillbar_enable = nil
  end
  
  def self.hidden?
    !$game_system.skillbar_enable.nil?
  end
  
  Follower_Flag.trust
  Follower_Flag.untaint
end
#===============================================================================
# * HotKeys
#-------------------------------------------------------------------------------
#   Hot Key Settings
#===============================================================================
module HotKeys
  
  Weapon       = :kR
  Armor        = :kF
  HotKeys      = [:k1, :k2, :k3, :k4, :k5, :k6, :k7, :k8, :k9, :k0]
  AllSkills    = :kTILDE
  AllItems     = :kMINUS
  Vancians     = :kEQUAL
  SwitchMember = [:kF3, :kF4, :kF5]
  QuickSave    = :kF7
  QuickLoad    = :kF8
  Follower     = :kC
  
  SkillBar     = [Weapon, Armor, Follower, AllSkills, HotKeys, AllItems, Vancians].flatten
  SkillBarSize = SkillBar.size
  HotkeyStartLoc = 4
  
  Menu         = :kESC
  Journal      = :kJ
  Inventory    = :kI
  Talents      = :kT
  Pause        = :kSPACE
  
  Letter = {
    :kCOLON => ':',        :kAPOSTROPHE => 39.chr, :kQUOTE => 39.chr,
    :kCOMMA => ',',        :kPERIOD => '.',        :kSLASH => 47.chr,
    :kBACKSLASH => 92.chr, :kLEFTBRACE => '(',     :kRIGHTBRACE => ')',
    :kMINUS => '-',        :kUNDERSCORE => '_',    :kPLUS => '+',
    :kEQUAL => '=',        :kEQUALS => '=',        :kTILDE => '~',
  }
  
  def self.name(key)
    Letter.each do  |name, ch|
      return ch if key == name
    end
    base = key.to_s
    base = base[1].upcase + base[2...base.length].downcase
    return base
  end
  
  def self.tool_index(key)
    return if key.nil?
    n = SkillBar.size
    for i in 0...n
      return i if key == SkillBar[i]
    end
  end
  
  def self.assigned_hotkey_index(index)
    return index - HotkeyStartLoc
  end
  
end
#===============================================================================
# * Game_SkillBar
#-------------------------------------------------------------------------------
#   Skill bar object that handle the actions triggered in skillbar.
#===============================================================================
#tag: skillbar
#tag: hotkey
class Game_Skillbar
  include PONY::SkillBar
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  Phase_Map           = 0
  Phase_Selection     = 1
  #--------------------------------------------------------------------------
  # *) Instance Vars
  #--------------------------------------------------------------------------
  attr_accessor :x, :y, :z
  attr_accessor :actor 
  attr_accessor :stack
  attr_accessor :sprite
  attr_accessor :items
  attr_accessor :monitor
  attr_accessor :phase
  attr_accessor :edit_enabled
  attr_accessor :index
  attr_accessor :need_refresh
  #--------------------------------------------------------------------------
  # *) Object Initialization
  #--------------------------------------------------------------------------
  def initialize(phase = 0)
    @actor          = nil
    @last_actor_id  = 0
    @stack          = []
    @items          = []
    @pages          = []
    @current_page   = 0
    @index          = nil
    @col_max        = HotKeys::SkillBarSize
    @monitor        = nil
    @dragging_index = nil
    @dragging_item  = nil
    @edit_enabled   = false
    @phase          = phase
    @need_refresh   = true
    @displayed_help = nil
    @x = @y = 0
    @z = 500
    clear_page
  end
  #--------------------------------------------------------------------------
  def create_layout(viewport, phase = nil)
    @sprite = Sprite_Skillbar.new(viewport, self)
    @phase  = phase if phase
    @phase  = SceneManager.scene_is?(Scene_Map) ? 0 : 1 unless phase
    @x, @y  = @sprite.x, @sprite.y
    debug_print "Create skillbar"
    refresh
  end
  #--------------------------------------------------------------------------
  def dispose_layout
    return unless sprite_valid?
    @sprite.dispose
    debug_print "Dispose skillbar"
    @sprite = nil
  end
  alias dispose dispose_layout
  #--------------------------------------------------------------------------
  # *) Object Update
  #--------------------------------------------------------------------------
  def update
    current_actor = determine_actor
    refresh_item           if @need_refresh
    refresh(current_actor) if refresh_needed?(current_actor)
    process_input  unless $game_system.story_mode?
    update_edit    if @edit_enabled
    @sprite.update if sprite_valid?
  end
  #--------------------------------------------------------------------------
  def refresh_needed?(current_actor)
    return false if @phase != Phase_Map
    return true  if $game_map.need_refresh
    return false if current_actor.id == @last_actor_id
    return true
  end
  #--------------------------------------------------------------------------
  # * Updates when edit mode is enabled
  #--------------------------------------------------------------------------
  def update_edit
    update_dragging if @dragging_item
    drag_select unless @dragging_item
  end
  #--------------------------------------------------------------------------
  # * Monitoring the item to be dragged
  #--------------------------------------------------------------------------
  def drag_select
    return unless index = get_monitor
    return unless @items[index] && !@items[index].is_a?(Numeric)
    @sprite.drag_icon(index)
    @dragging_item  = @items[index]
    @dragging_index = index
    clear_index(index)
  end
  #--------------------------------------------------------------------------
  # * Update the dragged item
  #--------------------------------------------------------------------------
  def update_dragging
    return unless Mouse.click?(1)
    index = get_monitor
    determine_destination(index)
  end
  #--------------------------------------------------------------------------
  # *) Refresh
  #--------------------------------------------------------------------------
  def refresh(actor = determine_actor)
    @actor = actor
    @last_actor_id = @actor.id
    @stack.clear
    @stack << @actor
    refresh_item
    draw_actor_name unless SceneManager.scene_is?(Scene_Map)
  end
  #--------------------------------------------------------------------------
  # *) Refresh items
  #--------------------------------------------------------------------------
  def refresh_item
    @need_refresh = false
    @current_page = 0
    hotkey_items  = @actor.get_hotkeys
    @primary_tool = hotkey_items.first
    clear_page
    #debug_print("Skillbar stack size: #{@stack.size}")
    case @stack.size
    when HotKeySelection
      #debug_print "Refresh hotkey selection"
      @first_scan_index = 0
      @items = hotkey_items
      @items.push(AllItem_Flag)
      @items.push(Vancian_Flag)
      @items.insert(2, AllSkill_Flag)
      @items.insert(2, Follower_Flag)
      @sprite.refresh if sprite_valid?
    when AllSelection
      #debug_print "Refresh hotkey bar page #{@current_page}"
      @items = @actor.get_hotkeys(true)
      @items.push(Follower_Flag)
      divide_pages(@actor.get_valid_skills)     if @stack.last == AllSkill_Flag
      divide_pages($game_party.get_valid_items) if @stack.last == AllItem_Flag
      divide_pages(@actor.get_vancian_spells)   if @stack.last == Vancian_Flag
      refresh_page
    end
  end
  #--------------------------------------------------------------------------
  # * Refresh current page items
  #--------------------------------------------------------------------------
  def refresh_page
    @items.pop until @items.last == Follower_Flag
    @items.push(PrevPage_Flag)
    @pages[@current_page].each do |item|
      @items.push(item)
    end
    @items.push(NextPage_Flag)
    @items.push(Cancel_Flag)
    @sprite.refresh if sprite_valid?
  end
  #--------------------------------------------------------------------------
  # * Clear page for all selection
  #--------------------------------------------------------------------------
  def clear_page
    @pages.clear
    @pages[0] = Array.new(10)
  end
  #--------------------------------------------------------------------------
  # * Determine skillbar display for which actor
  #--------------------------------------------------------------------------
  def determine_actor
    return @actor       if @actor && @phase == Phase_Selection
    return $game_player if @phase == Phase_Map
  end
  #--------------------------------------------------------------------------
  # *) Process Input
  #--------------------------------------------------------------------------
  def process_input
    return unless button_cooled?
    if Mouse.click?(1) && !Mouse.hover_UI? && SceneManager.scene_is?(Scene_Map) && !SceneManager.tactic_enabled?
      process_item_use(@primary_tool)
    elsif Mouse.click?(2) && @stack.size > HotKeySelection
      fallback
    elsif !Input.press?(:kCTRL)
      for i in @first_scan_index...HotKeys::SkillBarSize
        select(i)    if Input.trigger?(HotKeys::SkillBar[i]) || Mouse.trigger_skillbar?(i)
        show_item_help(i) if Mouse.hover_skillbar?(i) && Input.trigger?(:kTAB)
      end
    end
  end
  #--------------------------------------------------------------------------
  # *) Select item
  #--------------------------------------------------------------------------
  def select(index)
    #debug_print("Hotkey Bar selected: #{index} (#{@items[index]})")
    select_hotkey(index)
    heatup_button
  end
  #--------------------------------------------------------------------------
  # *) Select item in hotkey phase
  #--------------------------------------------------------------------------
  def select_hotkey(index)
    if @phase == Phase_Map
      case @items[index]
      when AllSkill_Flag;   return process_skill_select;
      when AllItem_Flag;    return process_item_select;
      when Vancian_Flag;    return process_vancian_select;
      when PrevPage_Flag;   return page_previous;
      when NextPage_Flag;   return page_next;
      when Cancel_Flag;     return fallback;
      end
      return process_follower_action if Follower_Flag == @items[index]
    end
    @monitor = index if @phase == Phase_Selection && !@items[index].is_a?(Fixnum) && !@items[index].is_a?(String)
    return process_item_use(@items[index]) if @phase == Phase_Map
  end
  #--------------------------------------------------------------------------
  # *) Max items per page
  #--------------------------------------------------------------------------
  def page_item_max
    # @col_max = SkillBarSize (16)
    # 6 = Weapon, Armor, Follower, next/previous page + cancel    
    return @col_max - 6
  end
  #--------------------------------------------------------------------------
  # *) Partation items into each page
  #--------------------------------------------------------------------------
  def divide_pages(all_data)
    @pages.clear
    @pages[0] = Array.new(10) # prevent nothing can be used
    all_data.each_with_index do |item, index|
      @pages[index / 10] = Array.new(10) if !@pages[index / 10]
      @pages[index / 10][index % 10] = item
    end
  end
  #--------------------------------------------------------------------------
  def process_skill_select
    @stack.push(AllSkill_Flag)
    refresh_item
  end
  #--------------------------------------------------------------------------
  def process_item_select
    @stack.push(AllItem_Flag)
    refresh_item
  end
  #--------------------------------------------------------------------------
  def process_vancian_select
    @stack.push(Vancian_Flag)
    refresh_item
  end
  #--------------------------------------------------------------------------
  def process_follower_action
    $game_player.followers.toggle_combat
  end
  #--------------------------------------------------------------------------
  def process_item_use(item)
    if !item.nil? && @actor.item_test(@actor, item)
      @actor.process_tool_action(item)
    else
      Sound.play_buzzer
    end
  end
  #--------------------------------------------------------------------------
  def fallback
    case @stack.size
    when AllSelection
      @stack.pop
      refresh_item
    when CastSelection
      
    end
  end
  #--------------------------------------------------------------------------
  def page_next
    @current_page += 1 if next_page_available?
    refresh_page
  end
  #--------------------------------------------------------------------------
  def page_previous
    @current_page -= 1 if prev_page_available?
    refresh_page
  end
  #--------------------------------------------------------------------------
  def next_page_available?
    return @current_page + 1 < @pages.size
  end
  #--------------------------------------------------------------------------
  def prev_page_available?
    return @current_page - 1 >= 0
  end
  #--------------------------------------------------------------------------
  def cancel_edit(continue = false)
    @sprite.release_drag
    @edit_enabled   = continue
    resume_dragging_item if !continue
    @dragging_item  = nil
    @dragging_index = nil
    refresh
  end
  #--------------------------------------------------------------------------
  def resume_dragging_item
    return unless @dragging_item
    true_index = HotKeys.assigned_hotkey_index(@dragging_index)
    @actor.assigned_hotkey[true_index] = @dragging_item
  end
  #--------------------------------------------------------------------------
  def determine_destination(index)
    if index && hotkey_index?(index)
      new_index = HotKeys.assigned_hotkey_index(index)
      prev_index   = HotKeys.assigned_hotkey_index(@dragging_index)
      @actor.assigned_hotkey[prev_index], @actor.assigned_hotkey[new_index] =
      @actor.assigned_hotkey[new_index], @dragging_item
    end
    refresh
    cancel_edit(true)
  end
  #--------------------------------------------------------------------------
  def clear_index(index)
    @actor.assigned_hotkey[HotKeys.assigned_hotkey_index(index)] = nil
    refresh
  end
  #--------------------------------------------------------------------------
  def hotkey_index?(index)
    return HotKeys::HotKeys.include?(HotKeys::SkillBar[index])
  end
  #--------------------------------------------------------------------------
  def get_monitor
    return unless @monitor
    re = @monitor
    @monitor = nil
    return re
  end
  #--------------------------------------------------------------------------
  def unselect
    return unless sprite_valid?
    @sprite.unselect
  end
  #--------------------------------------------------------------------------
  def hide
    return unless sprite_valid?
    @sprite.hide
  end
  #--------------------------------------------------------------------------
  def show
    return unless sprite_valid?
    @sprite.show
  end
  #--------------------------------------------------------------------------
  def visible?
    return unless sprite_valid?
    return @sprite.visible?
  end
  #--------------------------------------------------------------------------
  def sprite_valid?
    return Kernel.send(:sprite_valid?, @sprite)
  end
  #--------------------------------------------------------------------------
  def show_item_help(index)
    pos = Mouse.pos
    mx, my = *pos
    mx = [Graphics.width - 120, mx].min
    my = [Graphics.height - 68, my].min
    info = get_help_text(index)
    SceneManager.show_item_help_window(mx, my, info)
  end
  #--------------------------------------------------------------------------
  def get_help_text(index)
    if @items[index].is_a?(Fixnum)
      case @items[index]
      when AllSkill_Flag;   return Vocab::Skillbar::AllSkill;
      when Vancian_Flag;    return Vocab::Skillbar::Vancian;
      when AllItem_Flag;    return Vocab::Skillbar::AllItem;
      when PrevPage_Flag;   return Vocab::Skillbar::PrevPage;
      when NextPage_Flag;   return Vocab::Skillbar::NextPage;
      when Cancel_Flag;     return Vocab::Skillbar::Cancel;
      end
    elsif @items[index].is_a?(String) && @items[index] == Follower_Flag
      return Vocab::Skillbar::Follower
    elsif @items[index].is_a?(RPG::BaseItem)
      return @items[index].name
    end
    return Vocab::Skillbar::None
  end
  #--------------------------------------------------------------------------
  def draw_actor_name
    return unless sprite_valid?
    @sprite.draw_actor_name
  end
  #--------------------------------------------------------------------------
  # * Start button cooldown
  #--------------------------------------------------------------------------
  def heatup_button(multipler = 1)
    SceneManager.scene.heatup_button(multipler) rescue false
  end
  #--------------------------------------------------------------------------
  # * Button cooldown finished
  #--------------------------------------------------------------------------
  def button_cooled?
    SceneManager.scene.button_cooled? rescue false
  end
end

#===============================================================================
# * Game_PopInfo
#-------------------------------------------------------------------------------
#   Popup information text
#===============================================================================
class Game_PopInfo
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :x, :y
  attr_accessor :info
  attr_reader   :sprite
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(text, pos, color, icon_id)
    @x, @y = pos.x, [pos.y - 32, 0].max
    @info  = text
    @icon_id = icon_id
    @sprite = Sprite_Base.new(SceneManager.viewport2)
    @time = 60
    @color = color
    create_bitmap
  end
  #--------------------------------------------------------------------------
  def text_width
    return 4 * @info.size
  end
  #--------------------------------------------------------------------------
  # * Create bitmap for textsa
  #--------------------------------------------------------------------------
  def create_bitmap
    @sprite.x, @sprite.y = @x - text_width + 4, @y
    sw  = Font.default_size * @info.size / 2
    sw += 25 if @icon_id > 0
    line_height = 24
    @sprite.bitmap = Bitmap.new(sw, line_height)
    if @icon_id > 0
      rect = Rect.new(@icon_id % 16 * 24, @icon_id / 16 * 24, 24, 24)
      @sprite.bitmap.blt(0, 0, Cache.iconset, rect)
    end
    @sprite.bitmap.font.color.set(@color)
    @sprite.bitmap.draw_text(@icon_id > 0 ? 25 : 0, 0, sw, line_height, @info)
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    return if @time == 0
    @y -= 0.5
    @sprite.y -= 0.5
    @time -= 1
    @sprite.update
    dispose_sprite if @time == 0
  end
  #--------------------------------------------------------------------------
  # * Restore bitmap
  #--------------------------------------------------------------------------
  def restore
    return if @time == 0
    @sprite = Sprite_Base.new(SceneManager.viewport2)
  end
  #--------------------------------------------------------------------------
  # * Sprite disposed?
  #--------------------------------------------------------------------------
  def disposed?
    @sprite.disposed?
  end
  #--------------------------------------------------------------------------
  # * Free Sprite
  #--------------------------------------------------------------------------
  def dispose_sprite
    return unless @sprite
    @sprite.dispose unless @sprite.disposed?
    @sprite = nil
  end
  #---------------------------------------------------------
end

#===============================================================================
# * Game_TacticCursor
#-------------------------------------------------------------------------------
#   Projectiles in the game, game cannot be saved if any projectile exist
#===============================================================================
class Game_TacticCursor
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :x, :y
  attr_accessor :battler
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    @x, @y = 0, 0
    @battler = nil
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    update_movement
  end
  #--------------------------------------------------------------------------
  # * Update movement
  #--------------------------------------------------------------------------
  def update_movement
    update_keyboard_movement
    update_mouse_movement
  end
  #--------------------------------------------------------------------------
  def update_keyboard_movement
    nx, ny = @x, @y
    mul = Input.press?(:kSHIFT) ? 4 : 1
    nx += 0.25 * mul if Input.repeat?(:RIGHT)
    nx -= 0.25 * mul if Input.repeat?(:LEFT)
    ny += 0.25 * mul if Input.repeat?(:DOWN)
    ny -= 0.25 * mul if Input.repeat?(:UP)
    return if over_bound?(nx, ny)
    Sound.play_cursor
    @x, @y = nx, ny
  end
  #--------------------------------------------------------------------------
  def update_mouse_movement
    mx, my = *Mouse.pos
    nx = ((mx + ($game_map.display_x * 32)) / 32).round(6)
    ny = ((my + ($game_map.display_y * 32)) / 32).round(6)
    return if over_bound?(nx, ny)
    @x, @y = nx, ny
  end
  #--------------------------------------------------------------------------
  def out_offset
    return 0
  end
  #--------------------------------------------------------------------------
  # * Check if cursor go beyond the sight
  #--------------------------------------------------------------------------
  def over_bound?(x, y)
    if (x != @x || y != @y) && $game_map.valid?(x, y)
      max_w = $game_map.max_width ; max_h = $game_map.max_height
      screen_x = $game_map.adjust_x(x) * 32 + 16
      screen_y = $game_map.adjust_y(y) * 32 + 32
      sx = (screen_x / 32).to_i; sy = (screen_y / 32).to_i
      if sx.between?(0 - out_offset, max_w + out_offset) && 
         sy.between?(0 - out_offset, max_h + out_offset)
         
        return false
      end # sx, sy
    end # xy != @xy && map_valid
    return true
  end
  #--------------------------------------------------------------------------
  def collide_battler?
    target  = nil
    min_dis = 0xffff
    BattleManager.all_battlers.each do |battler|
      sx = battler.screen_x + 16; sy = battler.screen_y + 16;
      mx,my = screen_x, screen_y
      dx = (mx - sx).abs; dy = (my - sy).abs;
      if dx < 16 && dy < 16
        if dx + dy < min_dis
          target = battler
          min_dis = dx + dy
        end # dx+dy
      end # dx,dy < 16
    end # all battlers
    return target
  end
  #--------------------------------------------------------------------------
  def relocate(battler = @battler)
    @battler = battler.nil? ? $game_player : battler
    @x, @y   = @battler.x + 0.5, @battler.y + 0.5
  end
  #--------------------------------------------------------------------------
  def set_battler(battler)
    @battler = battler
    relocate
  end
  #--------------------------------------------------------------------------
  # * Get Screen X-Coordinates
  #--------------------------------------------------------------------------
  def screen_x
    $game_map.adjust_x(@x) * 32 + 16
  end
  #--------------------------------------------------------------------------
  # * Get Screen Y-Coordinates
  #--------------------------------------------------------------------------
  def screen_y
    $game_map.adjust_y(@y) * 32 + 32
  end
  #--------------------------------------------------------------------------
  def screen_z; 200; end
end

#===============================================================================
# * Game_DroppedItem
#-------------------------------------------------------------------------------
#   The dropped item on the map
#===============================================================================
class Game_DroppedItem
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader :map_id
  attr_reader :loots
  attr_reader :sprite
  attr_accessor :x
  attr_accessor :y
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(map_id, x, y, loots)
    @map_id = map_id
    @x      = x
    @y      = y 
    @loots  = loots
  end
  #--------------------------------------------------------------------------
  def update
    @sprite.update unless @sprite.nil? || @sprite.disposed?
    if $game_player.adjacent?(@x + 0.5, @y + 0.5)
      process_pickup
    end
  end
  #--------------------------------------------------------------------------
  def dispose
    return if @sprite.nil? || @sprite.disposed?
    @sprite.dispose
  end
  #--------------------------------------------------------------------------
  def deploy_sprite
    @sprite = SceneManager.register_item_drop(self, @x, @y)
  end
  #--------------------------------------------------------------------------
  def unlink_sprite
    @sprite = nil
  end
  #--------------------------------------------------------------------------
  def picked?
    @loots.empty?
  end
  #--------------------------------------------------------------------------
  def process_pickup
    @loots.each do |loot|
      if loot.is_a?(Fixnum)
        $game_party.gain_gold(loot, Vocab::Coinbase, Vocab::BlockChain::DropLoot)
      else
        $game_party.gain_item(loot, 1, Vocab::Coinbase, Vocab::BlockChain::DropLoot)
      end
    end
    Audio.se_play('Audio/SE/coin01', 80 * $game_system.volume(:sfx) * 0.01, 100)
    @loots.clear
    dispose
  end
  #--------------------------------------------------------------------------
  def merge(gold, items = [])
    @loots[0] += gold
    @loots << items
  end
  #--------------------------------------------------------------------------
  def sprite_valid?
    return false if @sprite.nil?
    return @sprite.disposed?
  end  
end

#===============================================================================
# * Game_TacticCommand
#-------------------------------------------------------------------------------
#   Tactic command of AI
#===============================================================================
class Game_TacticCommand
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :battler
  attr_accessor :action
  attr_accessor :condition
  attr_accessor :condition_symbol
  attr_accessor :category
  attr_accessor :enabled
  attr_accessor :args
  attr_accessor :target
  attr_accessor :circled
  attr_accessor :jump_command
  attr_reader   :index_id
  attr_reader   :check_timer
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(battler, args = [])
    @battler   = battler
    @action    = nil
    @args      = args
    @target    = nil
    @condition = ""
    @condition_symbol = nil
    @check_timer = 0
    @enabled   = true
    @jump_command = nil
    @circled   = false
    @index_id  = 0
  end
  #--------------------------------------------------------------------------
  def index_id=(id)
    @index_id = id
  end
  #--------------------------------------------------------------------------
  def condition_legel?
    return false if condition.include?('$')
    return false if condition.each_char.any?{|ch| 'A' <= ch && ch <= 'Z'}
    spell_ok = true
    begin
      eval(@condition)
    rescue Exception => err
      spell_ok = false
      return err
    end
    return true
  end
  #--------------------------------------------------------------------------
  def check_condition(forced = false)
    return unless (@enabled && @check_timer == 0) || forced
    return false unless @battler.cooldown_ready?(@action.item)
    #return eval(@condition) if condition_symbol == :code
    @target = nil
    case @category
    when :targeting
      @target = Tactic_Config::Enemy.start_check(@battler, @condition_symbol, @args)
      return @target ? true : false
    when :fighting
      return false unless @battler.current_target
      if @battler.current_target.dead?
        @battler.process_target_dead
        return false
      end
      return Tactic_Config::Target.start_check(@battler, @condition_symbol, @args)
    when :self
      return Tactic_Config::Players.start_check(@battler, @condition_symbol, @args)
    end
  end
  #--------------------------------------------------------------------------
  def get_target
    case @category
    when :targeting
      return @target
    when :fighting
      return @battler.current_target
    when :self
      return @battler
    end
  end
  #--------------------------------------------------------------------------
  def valid?
    return false if @circled
    return false if !@condition_symbol
    return false if @action.item == :jump_to && !@jump_command
    return false if !@action || !@action.valid?
    return true
  end
  #--------------------------------------------------------------------------
  def disabled?
    !@enabled
  end
  #--------------------------------------------------------------------------
  def enabled?
    @enabled
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Game_InteractiveButton
#------------------------------------------------------------------------------
#  Do what it namely does
#==============================================================================
class Game_InteractiveButton
  #------------------------------------------------------------------------------
  TriggerTimer = 4
  Node = Struct.new(:left, :right, :up, :down)
  #------------------------------------------------------------------------------
  attr_reader :symbol, :image
  attr_reader :x, :y, :z
  attr_reader :width, :height
  attr_reader :handler
  attr_reader :active, :group
  attr_reader :sprite
  attr_reader :help
  attr_reader :viewport
  attr_reader :show_text
  attr_reader :hovered, :triggered
  attr_accessor :index, :group_index, :node
  attr_reader :icon_id
  #------------------------------------------------------------------------------
  def initialize(*args)
    @hovered       = false
    @trigger_timer = 0
    @index         = nil
    @group_index   = nil
    @icon_id       = 0
    @node          = Node.new(self, self, self, self)
    if args.size == 1 # hash initializer
      inf = args[0]
      @symbol   = inf.symbol
      @image    = inf.image
      @x, @y    = (inf.x || 0), (inf.y || 0)
      @width    = inf.width  || 0
      @height   = inf.height || 0
      @handler  = inf.handler
      @active   = inf.active || 0
      @group    = inf.group
      @help     = inf.help || ''
      @show_text = inf.show_text || false
    else
      @symbol   = args[0]
      @image    = args[1]
      @x, @y    = (args[2] || 0), (args[3] || 0)
      @width    = args[4] || 0
      @height   = args[5] || 0
      @handler  = args[6]
      @active   = args[7] || false
      @group    = args[8]
      @help     = args[9] || ''
      @show_text = args[10] || false
    end
    if @image.is_a?(Symbol) && @image =~ /(?:icon)_(\d+)/i
      @icon_id = $1.to_i
    end
  end
  #------------------------------------------------------------------------------
  def refresh
    return unless @image
    @sprite.bitmap.clear
    draw_bitmap; draw_text;
  end
  #------------------------------------------------------------------------------
  def active?
    @active
  end
  #------------------------------------------------------------------------------
  def activate
    @active = true
    self
  end
  #------------------------------------------------------------------------------
  def deactivate
    @active = false
    self
  end
  #------------------------------------------------------------------------------
  def unfocus_sprite
    return unless @hovered
    @hovered = false
    @sprite.opacity = active? ? translucent_alpha : translucent_beta
  end
  #------------------------------------------------------------------------------
  def focus_sprite
    return if @hovered
    @hovered = true
    @sprite.opacity = 0xff
  end
  #------------------------------------------------------------------------------
  def call_handler(*args)
    unless @handler
      return PONY::ERRNO.raise(:gib_nil_handler)
    end
    @handler.call(*args)
  end
  #------------------------------------------------------------------------------
  def create_sprite(viewport = nil)
    @sprite = ::Sprite.new(viewport)
    draw_bitmap
    @sprite.opacity = acitve? ? translucent_alpha : translucent_beta
    @sprite
  end
  #------------------------------------------------------------------------------
  def show_text=(enabled)
    @show_text = enabled
    refresh
  end
  #------------------------------------------------------------------------------
  def translucent_alpha
    return 0xc0
  end
  #------------------------------------------------------------------------------
  def translucent_beta
    return 0x60
  end
  #------------------------------------------------------------------------------
  def dispose
    return unless sprite_valid?(@sprite)
    @sprite.dispose
    @sprite = nil
  end
  #------------------------------------------------------------------------------
  def draw_bitmap
    if @icon_id
      draw_icon(@icon_id)
    elsif @image
      @sprite.bitmap = Cache.UI(image)
      @width  = @sprite.bitmap.width
      @height = @sprite.bitmap.height
    else
      @sprite.bitmap = Bitmap.new([@width, 1].max, [@height, 1].max)
    end
  end
  #------------------------------------------------------------------------------
  def draw_text
    return unless @image && @show_text
    rect = Rect.new(0, 0, @sprite.bitmap.text_size(@name).width, line_height)
    rect.y = [@sprite.height - rect.height - 2, 0].max
    @sprite.bitmap.draw_text(rect, @name, 1)
  end
  #------------------------------------------------------------------------------
  def moveto(*args)
    case args.size
    when 1
      pos = args[0]
      @x  = pos.x
      @y  = pox.y
    else
      @x, @y = args[0], args[1]
      @z     = args[2] unless args[2].nil?
    end
    if sprite_valid?
      @sprite.x, @sprite.y = @x, @y
      @sprite.z = @z
    end
  end
  #------------------------------------------------------------------------------
  def viewport=(vp)
    debug_print("Warning: Sprite already has a viewport #{@viewport}") if sprite_valid?(@viewport)
    @viewport = vp
  end
  #------------------------------------------------------------------------------
  def z=(nz)
    @z = nz
    @sprite.z = @z if sprite_valid?
  end
  #------------------------------------------------------------------------------
end

#==============================================================================
# ** Sprite
#==============================================================================
class Sprite
  #--------------------------------------------------------------------------
  # * Sprite visible?
  #--------------------------------------------------------------------------
  def visible?
    return self.visible
  end
  
end
#==============================================================================
# ** Sprite_Base
#------------------------------------------------------------------------------
#  A sprite class with animation display processing added.
#==============================================================================
class Sprite_Base < Sprite
  #--------------------------------------------------------------------------
  attr_reader :ani_sprites
  #--------------------------------------------------------------------------
  # * Frame update
  #--------------------------------------------------------------------------
  def update
    super
    update_animation if animation?
    @@ani_checker.clear
    @@ani_spr_checker.clear
  end
  #--------------------------------------------------------------------------
  # * Update Animation
  #--------------------------------------------------------------------------
  def update_animation
    @ani_duration -= 1
    if @ani_duration % @ani_rate == 0
      if @ani_duration > 0
        frame_index = @animation.frame_max
        frame_index -= (@ani_duration + @ani_rate - 1) / @ani_rate
        animation_set_sprites(@animation.frames[frame_index])
        @animation.timings.each do |timing|
          animation_process_timing(timing) if timing.frame == frame_index
        end
      else
        end_animation
      end # @ani_duration
    end # @ani_dur % rate == 0
  end # def update_ani
  #--------------------------------------------------------------------------
  def change_viewport(vp)
    @viewport = vp
  end
  #--------------------------------------------------------------------------
end # class SpBase

#==============================================================================
# ** Sprite_Character
#------------------------------------------------------------------------------
#  This sprite is used to display characters. It observes an instance of the
# Game_Character class and automatically changes sprite state.
#==============================================================================
class Sprite_Character < Sprite_Base
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  EFFECTUS_RATE = MakerSystems::Effectus::SPRITE_CHARACTER_FULL_UPDATE_RATE
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :old_pos
  attr_accessor :old_pattern
  attr_accessor :old_direction
  #--------------------------------------------------------------------------
  # * Object Initialization
  #     character : Game_Character
  #--------------------------------------------------------------------------
  alias init_spchar_opt initialize
  def initialize(viewport, character = nil)
    init_spchar_opt(viewport, character)
    @old_pos = 0
    @old_pattern = 1
    @translucent = false
    @deployed = false
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  alias update_spchar_opt update
  def update
    sync_characher_zoom
    update_visibility    if @translucent != @character.translucent rescue nil
    return update_object if @character.frozen?
    update_spchar_opt    if update_needed?
  end
  #--------------------------------------------------------------------------
  # * Synchornize zooming with insatnace class
  #--------------------------------------------------------------------------
  def sync_characher_zoom
    return unless @character
    newzoom = POS.new(@character.zoom_x, @character.zoom_y)
    return if @zoomhash && @zoomhash == newzoom
    self.zoom_x = @character.zoom_x
    self.zoom_y = @character.zoom_y
    @zoomhash = newzoom
  end
  #--------------------------------------------------------------------------
  # * Check if sprite should update
  #--------------------------------------------------------------------------
  def update_needed?
    return true  if @character.opacity != self.opacity rescue nil
    return true  if @character.animation_id > 0        rescue nil
    return true  if graphic_changed? || animation?     rescue nil
    return false if !@character
    return true  if @character.pattern != @old_pattern
    return true
  end
  #--------------------------------------------------------------------------
  def update_object
    if !@deployed
      @deployed = true
      update_spchar_opt
    else
      update_position
    end
  end
  #--------------------------------------------------------------------------
  # * Hash position
  #--------------------------------------------------------------------------
  def hash_pos
    return 0 unless @character
    return @character.screen_x * 4000 + @character.screen_y + @character.screen_z
  end
  #--------------------------------------------------------------------------
  # * Update Transfer Origin Rectangle
  #--------------------------------------------------------------------------
  def update_src_rect
    if @tile_id == 0
      return process_large_src_rect if @character_name.include?("%(6)")
      if @character.casting?
        index = @character.casting_index
      else
        index = @character.character_index
      end
      
      pattern = @character.pattern < 3 ? @character.pattern : 1
      sx = (index % 4 * 3 + pattern) * @cw
      sy = (index / 4 * 4 + (@character.direction - 2) / 2) * @ch
      self.src_rect.set(sx, sy, @cw, @ch)
      @old_pattern = pattern
    end
  end
  #----------------------------------------------------------------------------
  def process_large_src_rect
    if @character.moving?
      index = 1 
    elsif @character.casting?
      index = 2
    else
      index = 0
    end
    pattern = @character.pattern < 3 ? @character.pattern : 1
    sx = (index % 4 * 3 + pattern) * @cw
    sy = (index / 4 * 4 + (@character.direction - 2) / 2) * @ch
    self.src_rect.set(sx, sy, @cw, @ch)
    @old_pattern = pattern
  end
  #----------------------------------------------------------------------------
  # * Overwrite update position.
  # To limit screen_x and screen_y to be called many times
  # 
  # moved from Thro anti-lag, merged with effectus
  #----------------------------------------------------------------------------
  def update_position
    sx = (@character.real_x - $game_map.display_x) * 32 + 16
    sy = (@character.real_y - $game_map.display_y) * 32 + 32 -
          @character.shift_y - @character.jump_height
    move_animation(sx - x, sy - y) if @animation && @animation.position != 3
    if sx != @effectus_old_sx
      @effectus_old_sx = sx
      self.x = sx
    end
    if sy != @effectus_old_sy
      @effectus_old_sy = sy
      self.y = sy
    end
    ovz = PONY::SpriteDepth::Table[:override]
    self.z = $game_system.time_stopper == @character ? ovz : @character.screen_z
  end
  #--------------------------------------------------------------------------
  # * Update Position
  #--------------------------------------------------------------------------
  alias update_spchar_position update_position
  def update_position
    update_spchar_position
  end
  #--------------------------------------------------------------------------
  # * Move Animation
  #--------------------------------------------------------------------------
  def move_animation(dx, dy)
    return unless @animation && @animation.position != 3
    @ani_ox += dx
    @ani_oy += dy
    @ani_sprites.each do |sprite|
      sprite.x += dx
      sprite.y += dy
    end
  end # def move_animation
  #--------------------------------------------------------------------------
  def relocate
    @sx = @character.screen_x
    @sy = @character.screen_y
    update_bitmap
    update_src_rect
    update_position
  end
  #--------------------------------------------------------------------------
  # * Vanilla Update.                                                   [NEW]
  #--------------------------------------------------------------------------
  def effectus_vanilla_update
    update_bitmap   if graphic_changed?
    if @tile_id == 0 && (@character.pattern != @effectus_old_pattern ||
        @character.direction != @effectus_old_dir)
      update_src_rect 
    end
    update_position
    update_other
    update_balloon  if @balloon_duration > 0
    setup_new_effect
  end
  #--------------------------------------------------------------------------
  # * Update Transfer Origin Bitmap.                                    [REP]
  #--------------------------------------------------------------------------
  def update_bitmap
    @tile_id = @character.tile_id
    @character_name = @character.character_name
    @character_index = @character.character_index
    @tile_id > 0 ? set_tile_bitmap : set_character_bitmap
    @effectus_old_pattern = nil
  end
  #--------------------------------------------------------------------------
  # * Move Animation.                                                   [REP]
  #--------------------------------------------------------------------------
  def move_animation(dx, dy)
    @ani_ox += dx
    @ani_oy += dy
    @ani_sprites.each do |sprite|
      sprite.x += dx
      sprite.y += dy
    end
  end
  #--------------------------------------------------------------------------
  # * Update Balloon Icon.                                              [REP]
  #--------------------------------------------------------------------------
  def update_balloon
    @balloon_duration -= 1
    if @balloon_duration > 0
      @balloon_sprite.x = x
      @balloon_sprite.y = y - height
      @balloon_sprite.z = z + PONY::SpriteDepth::Table[:ballon]
      sx = balloon_frame_index * 32
      sy = (@balloon_id - 1) * 32
      @balloon_sprite.src_rect.set(sx, sy, 32, 32)
    else
      end_balloon
    end
  end
  #--------------------------------------------------------------------------
end



#==============================================================================
# ** Sprite_Picture
#------------------------------------------------------------------------------
#  This sprite is used to display pictures. It observes an instance of the
# Game_Picture class and automatically changes sprite states.
#==============================================================================
class Sprite_Picture < Sprite
  
  #--------------------------------------------------------------------------
  # * Frame Update.                                                     [REP]
  #--------------------------------------------------------------------------
  def update
    super
    if @picture.name   != @effectus_old_name
      @effectus_old_name = nil
      update_bitmap 
    end
    update_origin if @picture.origin != @effectus_old_origin
    update_position
    if @effectus_old_zoom_x != @picture.zoom_x ||
       @effectus_old_zoom_y != @picture.zoom_y
      update_zoom
    end
    update_other
  end
  #--------------------------------------------------------------------------
  # * Update Transfer Origin Bitmap.                                    [REP]
  #--------------------------------------------------------------------------
  def update_bitmap
    @effectus_old_name = @picture.name
    if @effectus_old_name.empty?
      self.bitmap = nil
    else
      self.bitmap = Cache.picture(@effectus_old_name)
      @effectus_center_x = bitmap.width  / 2
      @effectus_center_y = bitmap.height / 2
    end
  end
  #--------------------------------------------------------------------------
  # * Update Origin.                                                    [REP]
  #--------------------------------------------------------------------------
  def update_origin
    @effectus_old_origin = @picture.origin
    if @effectus_old_origin == 0
      self.ox = 0
      self.oy = 0
    else
      self.ox = @effectus_center_x
      self.oy = @effectus_center_y
    end
  end
  #--------------------------------------------------------------------------
  # * Update Zoom Factor.                                               [REP]
  #--------------------------------------------------------------------------
  def update_zoom
    @effectus_old_zoom_x = @picture.zoom_x
    @effectus_old_zoom_y = @picture.zoom_y
    self.zoom_x = @effectus_old_zoom_x / 100.0
    self.zoom_y = @effectus_old_zoom_y / 100.0
  end
  #--------------------------------------------------------------------------
  # * Update Other.                                                     [REP]
  #--------------------------------------------------------------------------
  def update_other
    if @effectus_old_opacity != @picture.opacity
      @effectus_old_opacity = @picture.opacity
      self.opacity = @effectus_old_opacity
    end
    if @effectus_old_blend_type != @picture.blend_type
      @effectus_old_blend_type = @picture.blend_type
      self.blend_type = @effectus_old_blend_type
    end
    if @effectus_old_angle != @picture.angle
      @effectus_old_angle = @picture.angle
      self.angle = @effectus_old_angle
    end
    if @effectus_old_tone != @picture.tone    
      @effectus_old_tone = @picture.tone.dup
      self.tone.set(@effectus_old_tone)
    end
  end
  
end


#==============================================================================
# ** Spriteset_Weather
#------------------------------------------------------------------------------
#  A class for weather effects (rain, storm, and snow). It is used within the
# Spriteset_Map class.
#==============================================================================
class Spriteset_Weather
  
  #--------------------------------------------------------------------------
  # * Update Screen
  #--------------------------------------------------------------------------
  def update_screen
    dim = dimness
    @viewport.tone.set(-dim, -dim, -dim)
  end
end

#==============================================================================
# ** Spriteset_Map
#------------------------------------------------------------------------------
#  This class brings together map screen sprites, tilemaps, etc. It's used
# within the Scene_Map class.
#==============================================================================
class Spriteset_Map
  #--------------------------------------------------------------------------
  TILESIZE = 32
  EFFECTUS_EMPTY_STR = ''
  #--------------------------------------------------------------------------
  attr_reader :viewport1, :viewport2, :viewport3
  attr_reader :projectiles, :popups
  attr_reader :character_sprites, :unitcir_sprites
  attr_reader :battler_sprite_table
  attr_reader :hud_sprite, :tilemap, :tile_layer
  attr_reader :player_target_sprite
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias init_spsetmap_dnd initialize
  def initialize
    @projectiles = []
    @popups      = []
    @weapon_sprites = {}
    @drop_sprites = []
    @battler_sprite_table = {}
    create_huds
    create_tile_layer
    create_player_target_sprite
    init_spsetmap_dnd
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    update_tileset if @tileset != $game_map.tileset    
    update_tilemap
    update_parallax
    update_characters
    update_shadow
    update_weather
    update_pictures
    update_timer
    update_viewports
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  alias update_spsetmap_opt update
  def update
    update_skillbar
    update_projectiles
    update_popups
    update_huds
    update_weapons
    update_tile_layer
    update_player_target_sprite
    update_spsetmap_opt
  end
  #--------------------------------------------------------------------------
  # * Update Tileset
  #--------------------------------------------------------------------------
  def update_tileset
    load_tileset
    refresh_characters
  end
  #--------------------------------------------------------------------------
  def create_player_target_sprite
    @player_target_sprite = ::Sprite.new(@viewport)
    @player_target_sprite.bitmap = Cache.target_sprite
  end
  #--------------------------------------------------------------------------
  def create_tile_layer
    @tile_layer   = Sprite.new(@viewport1)
    @tile_layer.z = 1
    @tile_layer.bitmap = Bitmap.new($game_map.width * 32, $game_map.height * 32)
  end
  #--------------------------------------------------------------------------
  # *) Create heads-up display on map
  #--------------------------------------------------------------------------
  def create_huds
    $game_party.skillbar.create_layout(@viewport2)
    @hud_sprite = []
    4.times do |index|
      member = $game_party.members[index]
      @hud_sprite << Sprite_Hud.new(member, index, @viewport2)
    end
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Create Character Sprite (group)
  #--------------------------------------------------------------------------
  def create_characters
    @character_sprites = []
    @unitcir_sprites   = []
    @unit_table        = {}
    
    $game_map.events.values.each do |event|
      create_character_sprite(event)
    end
    
    $game_map.enemies.each {|battler| register_battle_unit(battler)}
    
    $game_player.followers.reverse_each do |follower|
      create_character_sprite(follower)
      register_battle_unit(follower)
    end
    
    player_sprite = create_character_sprite($game_player)
    register_battle_unit($game_player)
    
    @map_id = $game_map.map_id
  end
  #-----------------------------------------------------------------------------
  # * Create layout for tactic cursor
  #-----------------------------------------------------------------------------
  def create_tactic_cursor(instance)
    @tactic_cursor = Sprite_TacticCursor.new(@viewport1, instance)
  end
  #--------------------------------------------------------------------------
  def create_character_sprite(character)
    sprite = Sprite_Character.new(@viewport1, character)
    @character_sprites.push(sprite)
    @battler_sprite_table[character.hashid] = sprite
    character.create_animation_queue
    return sprite
  end
  #--------------------------------------------------------------------------
  # * Vanilla Update Sprites.                                           [NEW]
  #--------------------------------------------------------------------------
  def effectus_vanilla_update_sprites
    @character_sprites.each { |sprite| sprite.effectus_vanilla_update }
  end
  #--------------------------------------------------------------------------
  def update_player_target_sprite
    target = $game_player.current_target
    return @player_target_sprite.hide unless target
    @player_target_sprite.show unless @player_target_sprite.visible?
    cx, cy = target.screen_x - 16, target.screen_y - 28
    @player_target_sprite.moveto(cx, cy)
  end
  #--------------------------------------------------------------------------
  def update_skillbar
    $game_party.skillbar.update
  end
  #--------------------------------------------------------------------------
  def update_huds
    @hud_sprite.each{|sp| sp.update}
  end
  #--------------------------------------------------------------------------
  def update_projectiles
    n = @projectiles.size
    for i in 0...n
      if @projectiles[i].nil? || !@projectiles[i].active? || @projectiles[i].sprite.nil?
        @projectiles.delete_at(i); next;
      end
      @projectiles[i].update
      @projectiles.delete_at(i) if @projectiles[i].sprite.disposed?
    end
  end
  #--------------------------------------------------------------------------
  def update_popups
    n = @popups.size
    for i in 0...n
      if @popups[i].nil?
        @popups.delete_at(i); next
      end
      @popups[i].update
      @popups.delete_at(i) if !@popups[i].sprite || @popups[i].sprite.disposed?
    end
  end
  #--------------------------------------------------------------------------
  def update_units
    @unitcir_sprites.each {|sprite| sprite.update}
  end
  #--------------------------------------------------------------------------
  def update_weapons
    @weapon_sprites.values.each do |sprite|
      sprite.update
    end
  end
  #--------------------------------------------------------------------------
  def update_tile_layer
    @tile_layer.ox = $game_map.display_x * 32
    @tile_layer.oy = $game_map.display_y * 32
  end
  #--------------------------------------------------------------------------
  # * Update Tilemap
  #--------------------------------------------------------------------------
  def update_tilemap(main = true)
    @tilemap.map_data = $game_map.data
    @tilemap.ox = $game_map.display_x * 32
    @tilemap.oy = $game_map.display_y * 32
    @tilemap.update if main
  end
  #--------------------------------------------------------------------------
  def relocate_units
    update_tilemap
    @character_sprites.each do |sprite|
      sprite.relocate
    end
    @projectiles.each do |sprite|
      sprite.relocate
    end
    @weapon_sprites.each do |key, sprite|
      sprite.relocate
    end
  end
  #--------------------------------------------------------------------------
  # * Attach sprite a unit circle
  #--------------------------------------------------------------------------
  def register_battle_unit(battler)
    if @unit_table[battler.hashid]
      debug_print "Battler has already registered: #{battler}"
      return
    end
    sprite = Unit_Circle.new(@viewport1, battler)
    @weapon_sprites[battler.battler.hashid] = Sprite_Weapon.new(@viewport1, battler)
    @unitcir_sprites << sprite
    @unit_table[battler.hashid] = @unitcir_sprites.size - 1
    debug_print "Battler registered #{battler}"
  end
  #--------------------------------------------------------------------------
  # * Remove unit circle
  #--------------------------------------------------------------------------
  def resign_battle_unit(battler)
    loc = @unit_table[battler.hashid]
    return if loc.nil?
    sprite  = @unitcir_sprites.delete_at(loc)
    wsprite = @weapon_sprites[battler.hashid]
    dispose_sprite(sprite)
    dispose_sprite(wsprite)
    @unit_table.delete(battler.hashid)
    @weapon_sprites.delete(battler.hashid)
  end
  #--------------------------------------------------------------------------
  # * Free all unit sprites
  #--------------------------------------------------------------------------
  def dispose_units
    @unitcir_sprites.each do |sprite|
      sprite.dispose unless !sprite || sprite.disposed?
    end
    @unitcir_sprites.clear
  end
  #--------------------------------------------------------------------------
  # * Push new projectile sprite
  #--------------------------------------------------------------------------
  def setup_projectile(obj) # final method
    @projectiles.push(obj)
  end
  #--------------------------------------------------------------------------
  # * Setup popup text
  #--------------------------------------------------------------------------
  def setup_popinfo(text, position, color, icon_id)
    @popups.push( Game_PopInfo.new(text, position, color, icon_id) )
  end
  #--------------------------------------------------------------------------
  # * Display unit circles
  #--------------------------------------------------------------------------
  def show_units
    @unitcir_sprites.each do |sprite|
      sprite.show if BattleManager.valid_battler?(sprite.character)
    end
    @tactic_cursor.show if @tactic_cursor
  end
  #--------------------------------------------------------------------------
  # * Set up weapon graphic
  #--------------------------------------------------------------------------
  def setup_weapon_use(action) # final method
    @weapon_sprites[action.user.hashid].setup_action(action)
  end
  #--------------------------------------------------------------------------
  # * Hide unit circles
  #--------------------------------------------------------------------------
  def hide_units
    @unitcir_sprites.each do |sprite|
      sprite.hide
    end
    @tactic_cursor.hide if @tactic_cursor
  end
  #--------------------------------------------------------------------------
  # * Dispose projectiles
  #--------------------------------------------------------------------------
  def dispose_projectiles
    @projectiles.each do |proj|
      proj.dispose_sprite
    end
    @projectiles.clear
  end
  #--------------------------------------------------------------------------
  # * Dispose pop-ups
  #--------------------------------------------------------------------------
  def dispose_popups
    @popups.each do |sprite|
      sprite.dispose_sprite
    end
    @popups.clear
  end
  #--------------------------------------------------------------------------
  # * Restore projectiles
  #--------------------------------------------------------------------------
  def restore_projectile
    @projectiles = $game_map.get_cached_projectile.dup
    @projectiles.each do |proj|
      proj.restore
    end
    $game_map.clear_projectiles
  end
  #--------------------------------------------------------------------------
  def dispose_temp_sprites
    $game_map.save_battler_fibers
    $game_map.store_projectile(@projectiles)
    dispose_projectiles
    dispose_popups
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Free Character Sprite
  #--------------------------------------------------------------------------
  def dispose_characters
    @character_sprites.each do |sprite| 
      dispose_sprite(sprite)
    end
    @character_sprites.clear
    @battler_sprite_table.clear
    $game_temp.effectus_sprites.each_value { |sprite| sprite.dispose }
    $game_temp.effectus_sprites.clear
  end
  #--------------------------------------------------------------------------
  def dispose_huds
    $game_party.skillbar.dispose_layout
    @hud_sprite.each {|sprite| sprite.dispose if sprite && !sprite.disposed?}
    @hud_sprite.clear
  end
  #--------------------------------------------------------------------------
  def dispose_weapons
    @weapon_sprites.values.each do |sprite|
      sprite.dispose
    end
    @weapon_sprites.clear
  end
  #--------------------------------------------------------------------------
  def dispose_sprite(sprite)
    return if sprite.nil?
    if sprite.is_a?(Sprite_Character)
      @battler_sprite_table[sprite.character.hashid] = nil
      sprite.character.dispose_sprites
    end
    sprite.dispose
  end
  #--------------------------------------------------------------------------
  def dispose_event(event)
    return unless event
    sprite = @character_sprites.find {|sp| sp.character == event}
    return unless sprite
    @battler_sprite_table[event.hashid] = nil
    dispose_sprite(sprite)
    @character_sprites.delete(sprite)
    $game_temp.effectus_sprites[event.id].dispose if $game_temp.effectus_sprites[event.id]
    $game_temp.effectus_sprites.delete(event.id)
  end
  #--------------------------------------------------------------------------
  # * Free
  #--------------------------------------------------------------------------
  alias dispose_spmap_opt dispose
  def dispose
    dispose_spmap_opt
    dispose_units
    dispose_temp_sprites
    dispose_huds
    dispose_weapons
    dispose_drops
    dispose_sprite(@player_target_sprite)
    dispose_sprite(@tile_layer)
    dispose_sprite(@tactic_cursor)
  end
  #--------------------------------------------------------------------------
  def event_usable?(character)
    return true unless character.is_a?(Game_Event)
    return character.character_name || character.terminated?
  end
  #--------------------------------------------------------------------------
  def refresh
    @hud_sprite.each {|sprite| sprite.refresh(true)}
  end
  #--------------------------------------------------------------------------
  # * Update Aircraft Shadow Sprite
  #--------------------------------------------------------------------------
  def update_shadow
  end
  #--------------------------------------------------------------------------
  # * Update Viewport
  #--------------------------------------------------------------------------
  def update_viewports
    if @viewport1.tone != $game_map.screen.tone 
      @viewport1.tone.set($game_map.screen.tone)
    end
    @viewport1.ox = $game_map.screen.shake
    if @viewport2.color != $game_map.screen.flash_color
      @viewport2.color.set($game_map.screen.flash_color)
    end
    @viewport3.color.set(0, 0, 0, 255 - $game_map.screen.brightness)
    @viewport1.update
    @viewport2.update
    @viewport3.update
  end
  #--------------------------------------------------------------------------
  # * Update Parallax
  #--------------------------------------------------------------------------
  def update_parallax
    if @parallax_name != $game_map.parallax_name
      @parallax_name = $game_map.parallax_name
      @parallax.bitmap.dispose if @parallax.bitmap
      @parallax.bitmap = Cache.parallax(@parallax_name)
      Graphics.frame_reset
    end
    return if @parallax_name.size == 0
    @parallax.ox = $game_map.parallax_ox(@parallax.bitmap)
    @parallax.oy = $game_map.parallax_oy(@parallax.bitmap)
  end
  #--------------------------------------------------------------------------
  # * Deploy item drop sprite
  #--------------------------------------------------------------------------
  def register_item_drop(instance, x, y)
    sprite = Sprite_Icon.new(instance, @viewport1, PONY::IconID[:loot_drop], x - 0.5, y - 0.5)
    @drop_sprites << sprite
    return sprite
  end
  #--------------------------------------------------------------------------
  def dispose_drops
    @drop_sprites.each do |sprite|
      sprite.dispose unless sprite.disposed?
    end
  end
  #--------------------------------------------------------------------------
  def create_override_sprite(battler)
    @override   = Sprite_Character.new(nil, battler)
    @override.z = PONY::SpriteDepth::Table[:override]
  end
  #--------------------------------------------------------------------------
  def dispose_override_sprite(battler)
    return if @override.nil? || @override.disposed?
    @override.dispose
    @override = nil
  end
  #--------------------------------------------------------------------------
  def draw_tile_picture(x, y, filename)
    bitmap = Cache.tilemap(filename)
    rect   = Rect.new(0, 0, bitmap.width, bitmap.height)
    @tile_layer.bitmap.blt(x * TILESIZE, y * TILESIZE, bitmap, rect)
  end
  #--------------------------------------------------------------------------
  def clear_tile_picture
    @tile_layer.bitmap.clear
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Spriteset_Map
#------------------------------------------------------------------------------
#  This class brings together map screen sprites, tilemaps, etc. It's used
# within the Scene_Map class.
#==============================================================================
# tag: tactic(Spriteset)
# tag: timeflow(Spriteset)
class Spriteset_Map
  #--------------------------------------------------------------------------
  # * Overwrite: Update Character Sprite
  #--------------------------------------------------------------------------
  def update_characters
    refresh_characters if @map_id != $game_map.map_id
    @character_sprites.each do |sprite|
      sprite.update
      sprite.visible = $game_switches[6]
      if sprite.character && !event_usable?(sprite.character)
        @character_sprites.delete(sprite)
      end
    end
  end
  #-----------------------------------------------------------------------------
  def update_timelapse
    return update_tactic if SceneManager.tactic_enabled?
    return update_timestop if SceneManager.time_stopped?
  end
  #-----------------------------------------------------------------------------
  def update_character_popups
    @character_sprites.each do |sprite|
      next unless sprite.character
      sprite.character.update_popups
    end
  end
  #-----------------------------------------------------------------------------
  # * Update when tactic mode
  #-----------------------------------------------------------------------------
  def update_tactic
    update_tilemap(false)
    update_skillbar
    update_tactic_cursor
    update_units
    update_viewports
    update_character_popups
    update_popups
    update_huds
  end
  #-----------------------------------------------------------------------------
  def update_tactic_cursor
    @tactic_cursor.update
  end
  #-----------------------------------------------------------------------------
  def update_timestop
    update_tilemap(false)
    update_skillbar
    update_units
    update_viewports
    update_huds
    update_characters
    update_projectiles
    update_weapons
    update_character_popups
    update_popups
    @override.update unless @override.nil? || @override.disposed?
    return if $game_system.time_stopper.map_char.nil?
  end
  #-----------------------------------------------------------------------------
end


#===============================================================================
# * Sprite_Projectile
#-------------------------------------------------------------------------------
#   Projectiles in the game, game cannot be saved if any projectile exist
#===============================================================================
class Sprite_Projectile < Sprite_Character
  #--------------------------------------------------------------------------
  # * Public character Variables
  #--------------------------------------------------------------------------
  attr_reader   :executed
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(viewport, character)
    @tile_id = character.tile_id
    @character_name  = character.character_name
    @executed = false
    super(viewport, character)
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    update_dispose
  end
  #--------------------------------------------------------------------------
  # * Dispose when executed
  #--------------------------------------------------------------------------
  def update_dispose
    return unless @executed
    return if animation?
    self.dispose
    @character.deactivate
  end
  #--------------------------------------------------------------------------
  def update_deactivate
    return unless @executed
    return if animation?
    deactivate
  end
  #--------------------------------------------------------------------------
  # * Determine if Graphic Changed
  #--------------------------------------------------------------------------
  def graphic_changed?
    @character_index != @character.character_index
  end
  #--------------------------------------------------------------------------
  # * Update Transfer Origin Bitmap
  #--------------------------------------------------------------------------
  def update_bitmap
    if graphic_changed?
      @character_index = @character.character_index
      set_character_bitmap
    end
  end
  #--------------------------------------------------------------------------
  # * Execute effect on collide
  #--------------------------------------------------------------------------
  def execute_collide
    start_collide_animation
    @character.execute_action
  end
  #--------------------------------------------------------------------------
  # * Execute animation when collided
  #--------------------------------------------------------------------------
  def start_collide_animation
    @character.transparent = true
    if !animation? && @character.item.tool_animation > 0
      animation = $data_animations[@character.item.tool_animation]
      start_animation(animation)
    end
    @executed = true
  end
  #--------------------------------------------------------------------------
  # * Set Character Bitmap
  #--------------------------------------------------------------------------
  def set_character_bitmap
    self.bitmap = Cache.Arms(@character_name)
    sign = @character_name[/^[\!\$]./]
    if sign && sign.include?('$')
      @cw = bitmap.width / 3
      @ch = bitmap.height / 4
    else
      @cw = bitmap.width / 12
      @ch = bitmap.height / 8
    end
    self.ox = @cw / 2
    self.oy = @ch
  end
  #--------------------------------------------------------------------------
  # * Set New Effect
  #--------------------------------------------------------------------------
  def setup_new_effect
  end
  
end

#==============================================================================
# ** Sprite_SkillBar
#------------------------------------------------------------------------------
#  Hotkey bar on the bottom of the screen.
#==============================================================================
#tag: skillbar
class Sprite_Skillbar < Sprite
  include PONY::SkillBar
  #--------------------------------------------------------------------------
  # *) Instance Vars
  #--------------------------------------------------------------------------
  attr_reader   :instance
  #--------------------------------------------------------------------------
  # *) Object Initialization
  #--------------------------------------------------------------------------
  def initialize(viewport, instance)
    super(viewport)
    @instance      = instance
    @dragging      = false
    @cooldown_flag = []
    create_layout
    create_text(viewport)
    create_icons(viewport)
    create_hover_bitmap(viewport)
    create_cooldown_sprite(viewport)
    create_dragging_sprite(viewport)
    create_name_sprite(viewport)
    unselect
  end
  #--------------------------------------------------------------------------
  def update
    super
    hide_sprite = $game_system.hide_huds? rescue false
    if hide_sprite && visible?
      hide
    elsif !hide_sprite && !visible?
      show
    end
    update_mouse_hover
    update_dragging
    update_info
  end
  #--------------------------------------------------------------------------
  def refresh
    self.x = @instance.x
    self.y = @instance.y
    self.z = @instance.z
    clear_texts
    @icon_sprite.z      = self.z + 2
    @cooldown_sprite.z  = self.z + 4
    @hover_overlay.z    = self.z + 6
    @text_sprite.z      = self.z + 8
    @cooldown_flag      = []
    rect = Rect.new(0, 0, @icon_sprite.bitmap.width, @icon_sprite.bitmap.height)
    @icon_sprite.bitmap.clear_rect(rect)
    @cooldown_sprite.bitmap.clear
    @name_sprite.bitmap.clear
    draw_item_numbers
    draw_icons
  end
  #--------------------------------------------------------------------------
  def true_x; return (self.x + 4); end
  def true_y; return (self.y + 2); end
  #--------------------------------------------------------------------------
  # *) Create layout image
  #--------------------------------------------------------------------------
  def create_layout
    self.bitmap = Cache.UI(LayoutImage)
    self.x = Graphics.center_width(self.bitmap.width)
    self.y = Graphics.height - self.bitmap.height - 16
  end
  #--------------------------------------------------------------------------
  def create_text(viewport)
    @text_sprite = Sprite.new(viewport)
    @text_sprite.bitmap = Bitmap.new(self.width, self.height)
    @text_sprite.x, @text_sprite.y = self.x, self.y
    @text_sprite.z = self.z + 10
    draw_info_text
  end
  #--------------------------------------------------------------------------
  def create_cooldown_sprite(viewport)
    @cooldown_sprite = Sprite.new(viewport)
    @cooldown_sprite.bitmap = Bitmap.new(self.width, self.height)
    @cooldown_sprite.x, @cooldown_sprite.y = self.x, self.y
    @cooldown_sprite.z = @icon_sprite.z + 1
    @cooldown_sprite.opacity = translucent_alpha
  end
  #--------------------------------------------------------------------------
  def create_dragging_sprite(viewport)
    @drag_sprite = Sprite.new(viewport)
    @drag_sprite.bitmap = Bitmap.new(32, 32)
    @drag_sprite.z = PONY::SpriteDepth.layers(10)
  end
  #--------------------------------------------------------------------------
  def create_name_sprite(viewport)
    @name_sprite = Sprite.new(viewport)
    @name_sprite.bitmap = Bitmap.new(240, 30)
    @name_sprite.x, @name_sprite.y = self.x + 4, self.y - 28
    @name_sprite.z = self.z + 10
  end
  #--------------------------------------------------------------------------
  # *) Draw corresponding interactive key to each hotkey slot
  #--------------------------------------------------------------------------
  def draw_info_text
    letters = HotKeys::SkillBar
    @text_sprite.bitmap.font.size = 16
    @text_sprite.bitmap.font.color.set(DND::COLOR::White)
    cx = 22
    for i in letters
      name = HotKeys.name(i)
      @text_sprite.bitmap.draw_text(cx, 6, 32, 32, name)
      cx += 32
    end
  end
  #--------------------------------------------------------------------------
  # *) Create hover/activated symbol
  #--------------------------------------------------------------------------
  def create_hover_bitmap(viewport)
    size = 24
    @hover_overlay = Sprite.new(viewport)
    @hover_overlay.x = true_x
    @hover_overlay.y = true_y
    @hover_overlay.z = self.z + 2
    @hover_overlay.opacity = 64
    
    rect = Rect.new(0, 0, size, size)
    @hover_overlay.bitmap = Bitmap.new(size, size)
    @hover_overlay.bitmap.fill_rect(rect, DND::COLOR::White)
    @hover_overlay.visible = false
  end
  #--------------------------------------------------------------------------
  def update_mouse_hover
    hovered = false
    for i in 0...HotKeys::SkillBarSize
      if (Mouse.hover_skillbar?(i))
        @hover_overlay.x = true_x + 32 * i
        hovered = true
        break
      end
    end
    @hover_overlay.visible = hovered
  end
  #--------------------------------------------------------------------------
  def create_icons(viewport)
    @icon_sprite = Sprite.new(viewport)
    @icon_sprite.x, @icon_sprite.y = self.x, self.y
    @icon_sprite.z = self.z + 1
    @icon_sprite.bitmap = Bitmap.new(self.width, self.height)
    draw_icons
  end
  #--------------------------------------------------------------------------
  def draw_icons
    cx = 4 - 32
    cy = 2
    @instance.items.each_with_index do |item, index|
      cx += 32
      next if item.nil?
      enabled = true
      if item.is_a?(Numeric) || item.is_a?(String)
        enabled = @instance.prev_page_available? if item == PrevPage_Flag
        enabled = @instance.next_page_available? if item == NextPage_Flag
      else
        enabled = actor.item_test(actor, item) && actor.usable?(item, true)
      end
      
      if item.is_a?(String)
        icon_index = item_hash = eval(item)
      elsif item.is_a?(Fixnum)
        icon_index = item_hash = item
      else
        icon_index = item.icon_index
        item_hash  = item.hashid
      end
      
      rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
      @icon_sprite.bitmap.blt(cx, cy, Cache.iconset, rect, enabled ? 0xff : translucent_alpha)
      @cooldown_flag[index] = true
    end
  end
  #--------------------------------------------------------------------------
  def drag_icon(index)
    item = @instance.items[index]
    icon_index = item.icon_index
    bitmap = Cache.iconset
    rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
    @drag_sprite.bitmap.blt(0, 0, bitmap, rect, 0xff)
    @drag_sprite.x, @drag_sprite.y = *Mouse.pos
    @dragging = true
    @drag_sprite.show
    update_dragging
  end
  #--------------------------------------------------------------------------
  def release_drag
    rect = Rect.new(0, 0, 32, 32)
    @drag_sprite.bitmap.clear_rect(rect)
    @dragging = false
  end
  #--------------------------------------------------------------------------
  def update_dragging
    return unless @dragging
    @drag_sprite.x, @drag_sprite.y = *Mouse.pos
    @drag_sprite.x = [@drag_sprite.x - 16, 0].max
    @drag_sprite.y = [@drag_sprite.y - 16, 0].max
  end
  #--------------------------------------------------------------------------
  def update_info
    @instance.items.each_with_index do |item, index|
      cdt = actor.item_cooldown[item.id]    if item.is_a?(RPG::Item)
      cdt = actor.skill_cooldown[item.id]   if item.is_a?(RPG::Skill)
      cdt = actor.weapon_cooldown[item.id]  if item.is_a?(RPG::Weapon)
      cdt = actor.armor_cooldown[item.id]   if item.is_a?(RPG::Armor)
      next if cdt.nil?
      enabled = actor.cooldown_ready?(item)
      draw_cooldown_slot(index, enabled) if enabled != @cooldown_flag[index]
      draw_cooldown_text(index, item, cdt)
      @cooldown_flag[index] = enabled
    end
  end
  #--------------------------------------------------------------------------
  def draw_item_numbers
    @instance.items.each_with_index do |item, index|
      draw_item_number(index, consumable_item_count(item))
    end
  end
  #--------------------------------------------------------------------------
  def draw_item_number(index, number)
    rect = Rect.new(6 + 32 * index, 12, 16, 16)
    @text_sprite.bitmap.clear_rect(rect)
    return if number.nil?
    @text_sprite.bitmap.font.color.set(DND::COLOR::Green)
    @text_sprite.bitmap.draw_text(rect, number.to_s)
  end
  #--------------------------------------------------------------------------
  def draw_cooldown_slot(index, enabled)
    rect = Rect.new(4 + 32 * index, 2, 24, 24)
    return @cooldown_sprite.bitmap.clear_rect(rect) if enabled
    @cooldown_sprite.bitmap.fill_rect(rect, DND::COLOR::Black)
  end
  #--------------------------------------------------------------------------
  def draw_cooldown_text(index, item, cdt)
    rect = Rect.new(4 + 32 * index, 0, 32, 16)
    @text_sprite.bitmap.clear_rect(rect)
    return if item.tool_cooldown < 60 || (cdt | 0) == 0
    cdt = (cdt / 60.0)
    cdt = cdt < 1 ? cdt.round(1) : cdt.round(0)
    @text_sprite.bitmap.font.color.set(DND::COLOR::Yellow)
    @text_sprite.bitmap.draw_text(rect, cdt.to_s)
  end
  #--------------------------------------------------------------------------
  def draw_actor_name
    return unless @instance.actor
    @name_sprite.bitmap.clear
    name = @instance.actor.name || ""
    cw = @name_sprite.bitmap.font.size / 2 * name.size
    ch = @name_sprite.bitmap.font.size
    rect = Rect.new(0, 0, cw, ch)
    @name_sprite.bitmap.draw_text(rect, name)
  end
  #--------------------------------------------------------------------------
  def clear_texts
    HotKeys::SkillBarSize.times do |index|
      # cooldown text
      rect = Rect.new(4 + 32 * index, 0, 32, 16)
      @text_sprite.bitmap.clear_rect(rect)
      # item numver text
      rect = Rect.new(6 + 32 * index, 12, 16, 16)
      @text_sprite.bitmap.clear_rect(rect)
    end
  end
  #--------------------------------------------------------------------------
  # * Return the value of the item need to be comsumed
  #--------------------------------------------------------------------------
  def consumable_item_count(item)
    if item.is_a?(RPG::BaseItem)
      if item.is_a?(RPG::Item)
        return $game_party.item_number(item)
      elsif item.is_a?(RPG::Weapon) && item.tool_itemcost_type > 0
        n = $game_party.item_number(actor.current_ammo)
        n = n.nil? ? 0 : n + 1
        return n
      elsif (item.tool_itemcost || 0) > 0
        return $game_party.item_number($data_items[item.tool_itemcost])
      end
    end
    return nil
  end
  #--------------------------------------------------------------------------
  def unselect
    @hover_overlay.hide
  end
  #--------------------------------------------------------------------------
  def dispose
    self.bitmap.dispose unless !self.bitmap || !self.bitmap.disposed?
    @icon_sprite.dispose
    @hover_overlay.dispose
    @text_sprite.dispose
    @drag_sprite.dispose
    @cooldown_sprite.dispose
    @name_sprite.dispose
    self.bitmap = nil
    super
  end
  #--------------------------------------------------------------------------
  def hide
    @icon_sprite.hide
    @hover_overlay.hide
    @text_sprite.hide
    @drag_sprite.hide
    @cooldown_sprite.hide
    @name_sprite.hide
    super
  end
  #--------------------------------------------------------------------------
  def show
    @icon_sprite.show
    @hover_overlay.show
    @text_sprite.show
    @drag_sprite.show
    @cooldown_sprite.show
    @name_sprite.show
    unselect
    super
  end
  #--------------------------------------------------------------------------
  # * Get Alpha Value of Translucent Drawing
  #--------------------------------------------------------------------------
  def translucent_alpha
    return 160
  end
  #--------------------------------------------------------------------------
  def actor
    @instance.actor
  end
  
end

#============================================================================
# Unit Circle
#----------------------------------------------------------------------------
# Display under the battler position
#============================================================================
class Unit_Circle < Sprite_Base
  #----------------------------------------------------------------------------
  attr_accessor :character
  #----------------------------------------------------------------------------
  # *) Object initialization
  #----------------------------------------------------------------------------
  def initialize(viewport, character)
    super(viewport)
    @character = character
    self.z = viewport.z
    set_bitmap
    hide
  end
  #----------------------------------------------------------------------------
  # *) Sets the bitmap
  #----------------------------------------------------------------------------
  def set_bitmap
    self.bitmap = Bitmap.new(32, 32)
    if @character.is_a?(Game_Event) && (@character && @character.team_id != 0)
      color = DND::COLOR::Red
      #draw_sight
    else
      color = DND::COLOR::Blue
    end
    self.bitmap.draw_circle( 16, 16, 13, color, 2)
    update_position
  end
  #----------------------------------------------------------------------------
  # * Position update
  #----------------------------------------------------------------------------
  def update_position
    return hide if !BattleManager.valid_battler?(@character)
    self.x = @character.screen_x - 16
    self.y = @character.screen_y - 28
  end
  #----------------------------------------------------------------------------
  # *) Dispose method
  #----------------------------------------------------------------------------
  def dispose
    if self.bitmap != nil && !self.bitmap.disposed?
      self.bitmap.dispose
      self.bitmap = nil
    end
    super
  end
  #----------------------------------------------------------------------------
  def show
    update_position
    self.visible = true
  end
  #----------------------------------------------------------------------------
  def hide
    self.visible = false
  end
  #----------------------------------------------------------------------------
  # *) Update Process
  #----------------------------------------------------------------------------
  def update
    return unless self.visible?
    self.hide if dead?
    update_position
    super
  end
  #----------------------------------------------------------------------------
  # Get direction angle
  #----------------------------------------------------------------------------
  def direction_angle(battler)
    d = battler.direction
    case d
    when 2; return [90,180]
    when 4; return [150, 30]
    when 6; return [330,210]
    when 8; return [300, 60]
    end
  end
  #----------------------------------------------------------------------------
  # * Draw sight limit, useless for now
  #----------------------------------------------------------------------------
  def draw_sight
    #return if @character.sensor.nil?
    #self.bitmap = load_bitmap("Graphics/Lights/", "RS5")
  end
  #----------------------------------------------------------------------------
  def dead?
    return true if @character.is_a?(Game_Event) && @character.enemy.nil?
    return @character.dead?
  end
  #----------------------------------------------------------------------------
  def alive?
    return !dead?
  end
  #----------------------------------------------------------------------------
  def adjacent?(sx, sy)
    return (sx - self.x).abs <= 4 && (sy - self.y).abs <= 4
  end
  #----------------------------------------------------------------------------
end

#==============================================================================
# ** Sprite_TacticCursor
#------------------------------------------------------------------------------
#  Cursor that display the tactic select
#==============================================================================
class Sprite_TacticCursor < Sprite_Base
  #----------------------------------------------------------------------------
  attr_accessor :instance
  #----------------------------------------------------------------------------
  # *) Object initialization
  #----------------------------------------------------------------------------
  def initialize(viewport = nil, instance)
    super(viewport)
    @instance = instance
    create_bitmap
    self.ox = self.bitmap.width / 2
    self.oy = self.bitmap.height
    self.z  = PONY::SpriteDepth::Table[:character]
    update
    hide
  end
  #----------------------------------------------------------------------------
  # *) Update
  #----------------------------------------------------------------------------
  def update
    self.x = (@instance.screen_x - 16).to_i
    self.y = (@instance.screen_y - 16).to_i
  end
  #----------------------------------------------------------------------------
  # *) Create bitmap
  #----------------------------------------------------------------------------
  def create_bitmap
    self.bitmap = Bitmap.new(32,32)
    #upper left corner
    self.bitmap.fill_rect(0,0,15,15,Color.new(0,0,0,255))
    self.bitmap.fill_rect(1,1,13,13,Color.new(255,255,255,255))
    self.bitmap.fill_rect(4,4,10,10,Color.new(0,0,0,255))
    self.bitmap.fill_rect(5,5,13,13,Color.new(0,0,0,0))
    #lower right corner
    self.bitmap.fill_rect(18,18,15,15,Color.new(0,0,0,255))
    self.bitmap.fill_rect(19,19,12,12,Color.new(255,255,255,255))
    self.bitmap.fill_rect(18,18,10,10,Color.new(0,0,0,255))
    self.bitmap.fill_rect(18,18,9,9,Color.new(0,0,0,0))
    #lower left corner
    self.bitmap.fill_rect(0,18,15,15,Color.new(0,0,0,255))
    self.bitmap.fill_rect(1,19,13,12,Color.new(255,255,255,255))
    self.bitmap.fill_rect(4,18,10,10,Color.new(0,0,0,255))
    self.bitmap.fill_rect(5,18,10,9,Color.new(0,0,0,0))
    #upper right corner
    self.bitmap.fill_rect(18,0,15,15,Color.new(0,0,0,255))
    self.bitmap.fill_rect(19,1,12,13,Color.new(255,255,255,255))
    self.bitmap.fill_rect(18,4,10,10,Color.new(0,0,0,255))
    self.bitmap.fill_rect(18,5,9,10,Color.new(0,0,0,0))
  end
  #----------------------------------------------------------------------------
  def character; nil; end
  
end

#==============================================================================
# ** Sprite_Animation
#------------------------------------------------------------------------------
#  Sprite multi-animation display
#==============================================================================
class Sprite_Animation < Sprite_Base
  #--------------------------------------------------------------------------
  attr_accessor :character
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(viewport = nil, character = nil)
    super(viewport)
    @character = character
  end
  #--------------------------------------------------------------------------
  # * Frame update
  #--------------------------------------------------------------------------
  def update
    update_position
    super
  end
  #--------------------------------------------------------------------------
  # * Sync character position
  #--------------------------------------------------------------------------
  def update_position
    return unless @character
    return unless SceneManager.scene_is?(Scene_Map)
    move_animation(@character.screen_x - x, @character.screen_y - y)
    self.x = @character.screen_x
    self.y = @character.screen_y
    self.z = @character.screen_z
  end
  #--------------------------------------------------------------------------
  # * Move Animation
  #--------------------------------------------------------------------------
  def move_animation(dx, dy)
    return if !@animation || @animation.position == 3
    @ani_ox += dx
    @ani_oy += dy
    @ani_sprites.each do |sprite|
      sprite.x += dx
      sprite.y += dy
    end
  end
  #--------------------------------------------------------------------------
  # * Free
  #--------------------------------------------------------------------------
  def dispose
    end_animation
    super
  end
  #--------------------------------------------------------------------------
  def relocate
    return unless @character
    update_position
  end
end

#==============================================================================
# ** Sprite_Hud
#------------------------------------------------------------------------------
#  Sprite for displaying the stat of party members, including hp, ep and action
#==============================================================================
class Sprite_Hud < Sprite_Base
  include PONY::Hud
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  Color_HP = DND::COLOR::HitPoint
  Color_EP = DND::COLOR::EnergyPoint
  #--------------------------------------------------------------------------
  # * Public instance variables
  #--------------------------------------------------------------------------
  attr_reader   :actor
  attr_reader   :party_index
  attr_reader   :hp
  attr_reader   :mp
  attr_reader   :action
  attr_accessor :face_phase
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(actor, party_index, viewport = nil)
    super(viewport)
    @actor         = actor
    @party_index   = party_index
    @hp            = 0
    @mp            = 0
    @mhp           = 1
    @mmp           = 1
    @action        = nil
    @last_hash     = 0
    @last_face     = 0xff
    @face_timer    = 0
    @se_timer      = 0
    @action_timer  = 0
    @actor_changed = true
    @viewport      = viewport
    self.x         = 4
    self.y         = 4 + HudSize.at(1) * party_index
    self.z         = viewport ? viewport.z : PONY::SpriteDepth::Table[:huds]
    create_layout
  end
  #--------------------------------------------------------------------------
  # * Load layout
  #--------------------------------------------------------------------------
  def create_layout
    return if @actor.nil?
    filename         = @party_index == 0 ? LeadLayoutFilename : LayoutFilename
    self.bitmap      = Cache.UI(filename)
    @contents        = Sprite.new(@viewport)
    @contents.bitmap = Bitmap.new(*ContentBitmapSize)
    @face_sprite     = Sprite.new(@viewport)
    @face_sprite.bitmap = Bitmap.new(FaceHudRect.width, FaceHudRect.height)
    @contents.x, @contents.y       = self.x, self.y
    @face_sprite.x, @face_sprite.y = self.x, self.y
    @contents.z = self.z - 1
    @face_sprite.z  = self.z + 1
  end
  #--------------------------------------------------------------------------
  # * Frame update
  #--------------------------------------------------------------------------
  def update
    super
    dectect_actor_change
    update_visibility
    return if @actor.nil?
    update_values
    refresh if @actor_changed || @last_hash != hash_value
    update_timer
  end
  #--------------------------------------------------------------------------
  def dectect_actor_change
    actor = battler
    #actor = $game_party.members[@party_index]
    return unless need_refresh?(actor)
    
    @actor = actor
    create_layout if !@face_sprite
    @actor_changed = true
  end
  #--------------------------------------------------------------------------
  def need_refresh?(actor)
    return true  if @need_refresh
    return false if !@actor_changed && actor == @actor
    return false if actor.nil?
    return true
  end
  #--------------------------------------------------------------------------
  def update_visibility(forced = false)
    return hide if @actor.nil? || ($game_system.hide_huds? && visible?) || forced
    return show if !$game_system.hide_huds? && !visible?
  end
  #--------------------------------------------------------------------------
  # * Update value and bars
  #--------------------------------------------------------------------------
  def update_values
    on_actor_change if @actor_changed
    return hide if @actor.nil?
    @hp     = @actor.hp
    @mp     = @actor.mp
    @mhp    = @actor.mhp
    @mmp    = @actor.mmp
    @action = @actor.next_action.nil? ? @actor.action : @actor.next_action
  end
  #--------------------------------------------------------------------------
  def update_timer
    @se_timer     += 1 if @flag_low_hp
    return if SceneManager.tactic_enabled?
    @face_timer   += 1 if @flag_temp_face
    @action_timer += 1 if @flag_action
    draw_action(@actor.action) if @action_timer >= 90
  end
  #--------------------------------------------------------------------------
  def battler
    if @party_index == 0
      return $game_player.actor
    else
      return $game_player.followers[@party_index - 1].actor
    end
  end
  #--------------------------------------------------------------------------
  # * Hash value
  #--------------------------------------------------------------------------
  def hash_value
    actor = battler
    return -1 if actor.nil?
    value  = actor.mp * 100 + actor.hp * 10 + actor.hashid + @party_index
    value += actor.action.nil? ? 0 : actor.action.item.hashid
    return value
  end
  #--------------------------------------------------------------------------
  def on_actor_change
    @actor = battler
    return hide if @actor.nil?
    @action = nil
    @hp     = @actor.hp
    @mp     = @actor.mp
    @mhp    = @actor.mhp
    @mmp    = @actor.mmp
  end
  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh(redetect = false)
    dectect_actor_change if redetect
    return hide if @actor.nil?
    update_values if redetect || @actor_changed
    draw_name
    draw_hp
    draw_mp
    draw_action
    draw_face
    @last_hash = hash_value
    @actor_changed = false
    update_visibility(true) if $game_system.hide_huds?
  end
  #--------------------------------------------------------------------------
  def draw_name
    return unless @actor_changed
    rect = NameRect
    @contents.bitmap.font.size = 18
    @contents.bitmap.clear_rect(rect)
    color = PONY::Menu_UI::NAME_COLOR[@actor.id] rescue nil
    @contents.bitmap.font.color.set(color) if color
    @contents.bitmap.draw_text(rect, @actor.name, 1) 
    @contents.bitmap.font.color.set(DND::COLOR::White) if color
  end
  #--------------------------------------------------------------------------
  def draw_hp
    rect = HPBarRect.dup
    @contents.bitmap.clear_rect(rect)
    rect.width = rect.width * @hp / @mhp
    @contents.bitmap.fill_rect(rect, DND::COLOR::HitPoint)
  end
  #--------------------------------------------------------------------------
  def draw_mp
    rect = EPBarRect.dup
    @contents.bitmap.clear_rect(rect)
    rect.width = rect.width.to_i * @mp / @mmp
    @contents.bitmap.fill_rect(rect, DND::COLOR::EnergyPoint)
  end
  #--------------------------------------------------------------------------
  def draw_action(action = nil)
    clear_action
    @action = action.dup if action
    return unless @action
    rect = StatRect.dup
    backcolor1 = Color.new(0, 0, 0, 192)
    backcolor2 = Color.new(0, 0, 0, 0)
    @contents.bitmap.gradient_fill_rect(rect, backcolor1, backcolor2)
    draw_icon(@action.item.icon_index, rect.x, rect.y)
    rect.x += 26
    @contents.bitmap.draw_text(rect, @action.item.name)
    @flag_action  = true
  end
  #--------------------------------------------------------------------------
  def clear_action
    rect = StatRect.dup
    @contents.bitmap.clear_rect(rect)
    @flag_action = false
    @action_timer = 0
  end
  #--------------------------------------------------------------------------
  def draw_face
    phase = get_actor_status
    return if phase == @last_face && !@actor_changed
    @last_face = phase
    filename = FaceFilename + @actor.id.to_s
    bitmap   = Cache.UI(filename) rescue nil
    return if bitmap.nil?
    rect     = FaceHudRect
    src_rect = FaceSrcRect.dup
    src_rect.x = phase * src_rect.width
    @face_sprite.bitmap.clear_rect(rect)
    @face_sprite.bitmap.blt(0, 0, bitmap, src_rect)
  end
  #--------------------------------------------------------------------------
  def get_actor_status
    return PONY::Hud::FaceIdle
  end
  #--------------------------------------------------------------------------
  def draw_icon(icon_index, x, y)
    bitmap = Cache.iconset
    rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
    @contents.bitmap.blt(x, y, bitmap, rect)
  end
  #--------------------------------------------------------------------------
  # * Free
  #--------------------------------------------------------------------------
  def dispose
    @face_sprite.dispose if @face_sprite
    @contents.dispose    if @contents
    super
  end
   #--------------------------------------------------------------------------
  def hide
    @face_sprite.hide if @face_sprite
    @contents.hide    if @contents
    super
  end
  #--------------------------------------------------------------------------
  def show
    @face_sprite.show if @face_sprite
    @contents.show    if @contents
    super
  end
  #--------------------------------------------------------------------------
end

#===============================================================================
# * Sprite_Weapon
#-------------------------------------------------------------------------------
#   Disaply the wielding weapon on the Scene_Map
#===============================================================================
class Sprite_Weapon < Sprite
  include DND::Graphics
  OffsetX = { 2 => 0, 4 => -16, 6 => 20, 8 => 0}
  OffsetY = { 4 => -12, 8 => -28, 2 => 8, 6 => -12}
  #--------------------------------------------------------------------------
  # * Public character Variables
  #--------------------------------------------------------------------------
  attr_reader   :attacking
  attr_reader   :animation_sprite
  attr_accessor :timer
  attr_accessor :user
  attr_accessor :action
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(viewport, user)
    @attacking = false
    @user      = user.battler ? user.battler : user
    @timer     = 0 
    @index     = 0
    @animation_sprite = Sprite_Animation.new(viewport)
    super(viewport)
    create_bitmap
  end
  #--------------------------------------------------------------------------
  def create_bitmap
    self.bitmap = Bitmap.new(24,24)
    refresh_weapon(@user.primary_weapon)
    hide
  end
  #--------------------------------------------------------------------------
  def refresh_weapon(item)
    return if !item
    
    if item.user_graphic.upcase.include?("ICON")
      return if item.icon_index == @graphic
      @type = 0
      index = item.icon_index rescue nil
      temp = Cache.iconset
      self.bitmap = Bitmap.new(24, 24)
      self.bitmap.blt(0,0,temp,Rect.new(index % 16 * 24, index / 16 * 24, 24, 24))
      self.src_rect.set(0,0,24,24)
      self.ox    = 22
      self.oy    = 22
      @graphic = index
    elsif item.user_graphic && item.user_graphic != @graphic
      @type = 1
      self.angle = 0
      self.bitmap = Cache.Arms(item.user_graphic)
      @cw = self.bitmap.width  / 3;
      @ch = self.bitmap.height / 4;
      self.src_rect.set(0, 0, @cw, @ch)
      self.ox = @cw / 2
      self.oy = @ch
      @graphic = item.user_graphic
    end
  end
  #--------------------------------------------------------------------------
  def setup_action(action)
    @action = action
    puts "[Warning]: Sprite Weapon has different owner: #{@user.name} #{action.user.name}" if @user.map_char != action.user.map_char
    refresh_weapon(action.item)
    @timer = 0
    @attacking = true
    show
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    return if disposed?
    super
    update_animation
    update_attacking if @attacking
  end
  #--------------------------------------------------------------------------
  def update_animation
    @animation_sprite.update
  end
  #--------------------------------------------------------------------------
  def update_attacking
    if SceneManager.time_stopped?
      return unless $game_system.time_stopper && $game_system.time_stopper.map_char == @user.map_char
    end
    @dir = @user.map_char.direction
    update_icon_sprite  if @type == 0
    update_image_sprite if @type == 1
    @action.time = 3
    @timer += 1
  end
  #--------------------------------------------------------------------------
  def update_icon_sprite
    self.x = @user.map_char.screen_x + Wield_Dir_Offest[@dir][0]
    self.y = @user.map_char.screen_y + Wield_Dir_Offest[@dir][1]
    case @timer
    when 0
      self.angle = Wield_Angles[@dir][0]
      self.z     = Wield_Depth_Correction[@dir]
    when 3
      self.angle = Wield_Angles[@dir][1]
      self.z     = Wield_Depth_Correction[@dir]
    when 6
      self.angle = Wield_Angles[@dir][2]
      self.z     = Wield_Depth_Correction[@dir]
      BattleManager.execute_action(@action)
      setup_animation
    when 9
      self.angle = Wield_Angles[@dir][3]
      self.z     = Wield_Depth_Correction[@dir]
    when 12
      terminate_attack
    end
  end
  #--------------------------------------------------------------------------
  def update_image_sprite
    self.x = @user.map_char.screen_x
    self.y = @user.map_char.screen_y + 22
    sy = (@dir - 2) / 2 * @ch
    case @timer
    when 0
      sx = 0
      self.src_rect.set(sx, sy, @cw, @ch)
    when 4
      sx = @cw
      self.src_rect.set(sx, sy, @cw, @ch)
      BattleManager.execute_action(@action)
      setup_animation
    when 8
      sx = @cw * 2
      self.src_rect.set(sx, sy, @cw, @ch)
    when 12
      terminate_attack
    end
  end
  #--------------------------------------------------------------------------
  def terminate_attack
    @attacking = false
    @action.resume
    hide
  end
  #--------------------------------------------------------------------------
  def setup_animation
    animation_id = @action.item.tool_animation
    return unless animation_id > 0
    dir = @user.map_char.direction
    pos = POS.new(@user.map_char.real_x + OffsetX[dir] / 32.0, @user.map_char.real_y + OffsetY[dir] / 32.0)
    @animation_sprite.character = pos 
    animation = $data_animations[animation_id]
    @animation_sprite.start_animation(animation, @dir == 6 || @dir == 2)
  end
  #--------------------------------------------------------------------------
  def dispose
    @animation_sprite.dispose
    super
  end
  #--------------------------------------------------------------------------
  def relocate
    @dir = @user.direction
    if @type == 0
      self.x = @user.map_char.screen_x + Wield_Dir_Offest[@dir][0]
      self.y = @user.map_char.screen_y + Wield_Dir_Offest[@dir][1]
    else
      self.x = @user.map_char.screen_x
      self.y = @user.map_char.screen_y + 22
    end
    @animation_sprite.relocate
  end
  #--------------------------------------------------------------------------
end

#===============================================================================
# * Sprite_Weapon
#-------------------------------------------------------------------------------
#   Disaply the wielding weapon on the Scene_Map
#===============================================================================
class Sprite_Icon < Sprite
  #--------------------------------------------------------------------------
  attr_reader :icon_id
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(instance, viewport, icon_id, game_x = 0, game_y = 0)
    @icon_id = icon_id
    super(viewport)
    @instance   = instance
    @instance_x = game_x
    @instance_y = game_y
    create_bitmap
  end
  #--------------------------------------------------------------------------
  def create_bitmap
    self.bitmap = Bitmap.new(24, 24)
    draw_icon(@icon_id)
  end
  #--------------------------------------------------------------------------
  def change_icon(id)
    @icon_id = id
    draw_icon(@icon_id)
  end
  #--------------------------------------------------------------------------
  def update
    super
    self.x = screen_x
    self.y = screen_y
  end
  #--------------------------------------------------------------------------
  # * Get Screen X-Coordinates
  #--------------------------------------------------------------------------
  def screen_x
    $game_map.adjust_x(@instance_x) * 32 + 16
  end
  #--------------------------------------------------------------------------
  # * Get Screen Y-Coordinates
  #--------------------------------------------------------------------------
  def screen_y
    $game_map.adjust_y(@instance_y) * 32 + 32
  end
  #--------------------------------------------------------------------------
  def dispose
    super
    @instance.unlink_sprite
    @instance = nil
  end
end

#==============================================================================
# ** Pony
#------------------------------------------------------------------------------
#  Pony should poni pony
#==============================================================================
$imported = {} if $imported.nil?
module PONY
	module Menu_UI
		First_Item_Position =  [168, 20]
		Second_Item_Position = [10, 35]
    
    NAME_COLOR = {
      1 => Color.new(215, 170, 225),
      2 => Color.new(245, 140,  90),
      4 => Color.new(255, 255, 255),
      5 => Color.new( 60, 175, 230),
      6 => Color.new(250, 145, 250),
      7 => Color.new(235, 235, 140),
    }
    
	end
end
#==============================================================================
# ** Window_Base
#------------------------------------------------------------------------------
#  This is a super class of all windows within the game.
#==============================================================================
class Window_Base < Window
  include PONY::Menu_UI
  #--------------------------------------------------------------------------
  attr_reader :child_sprite
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y, width, height)
    super
    self.windowskin = Cache.system(WindowSkin::Default) if !self.windowskin
    update_padding
    update_tone
    create_contents
    @child_sprite = []
    @opening = @closing = false
  end
  #--------------------------------------------------------------------------
  def swap_skin(skin = WindowSkin::Default)
    return unless WindowSkin::Enable
    self.windowskin = skin.is_a?(String) ? Cache.system(skin) : skin
  end
  #--------------------------------------------------------------------------
  alias draw_text_encoding draw_text
  def draw_text(*args)
    args.each_with_index do |arg, i|
      if arg.is_a?(String)
        args[i] = arg.dup.force_encoding($default_encoding)
      end
    end
    draw_text_encoding(*args)
  end
  #--------------------------------------------------------------------------
  # * Draw Text with Control Characters
  #--------------------------------------------------------------------------
  alias draw_text_ex_encoding draw_text_ex
  def draw_text_ex(x, y, text)
    draw_text_ex_encoding(x, y, text.force_encoding($default_encoding))
  end
  #--------------------------------------------------------------------------
  # * Draw text in static position
  #--------------------------------------------------------------------------
  def draw_code_text(x, y, text)
    width = (Font.default_size * 0.5).to_i
    cnt = 0
    text = "" unless text
    text.each_char do |char|
      bsize = [char.bytesize, 2].min
      rect = Rect.new(x + width * cnt, y, width * bsize, line_height)
      if char.ord == 10
        cnt = 0
        y += line_height
      else
        draw_text(rect, char)
        cnt += bsize
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Start button cooldown
  #--------------------------------------------------------------------------
  def heatup_button(multipler = 1)
    SceneManager.scene.heatup_button(multipler) rescue false
  end
  #--------------------------------------------------------------------------
  # * Button cooldown finished
  #--------------------------------------------------------------------------
  def button_cooled?
    SceneManager.scene.button_cooled? rescue false
  end
  #--------------------------------------------------------------------------
  # * Window visible? tag: modified
  #--------------------------------------------------------------------------
  def visible?
    return visible rescue false
  end
  #--------------------------------------------------------------------------
  # * Window Active
  #--------------------------------------------------------------------------
  def active?
    return active rescue false
  end
  #--------------------------------------------------------------------------
  # * Icon Sprite Creation
  #--------------------------------------------------------------------------
  def create_icon_sprite(x, y, z, icon_index)
    sprite        = Sprite.new
    sprite.x      = x
    sprite.y      = y
    sprite.z      = z
    sprite.bitmap = Bitmap.new(24,24)
    rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
    sprite.bitmap.blt(0, 0, Cache.iconset, rect)
    return sprite
  end
  #--------------------------------------------------------------------------
  def text_width_for_rect(text)
    return contents.text_size(text).width + contents.font.size
  end
  #--------------------------------------------------------------------------
  def select_cursor_needed?
    return false
  end
  #--------------------------------------------------------------------------
  # * Draw Name
  #--------------------------------------------------------------------------
  def draw_actor_name(actor, x, y, width = 112)
    change_color(NAME_COLOR[actor.id])
    draw_text(x, y, width, line_height, actor.name)
  end
  #--------------------------------------------------------------------------
  # * Draw Class
  #--------------------------------------------------------------------------
  def draw_actor_class(actor, x, y, width = 200, dualwrap = false)
    change_color(normal_color)
    text = sprintf("%s %d", actor.class.name, actor.class_level[actor.class_id])
    if actor.dualclass_id > 0
      dt = sprintf("%s %d",actor.dualclass.name, actor.class_level[actor.dualclass_id])
      if dualwrap
        draw_text(x, y + line_height, width, line_height, dt)
      else
        text += '/' + dt
      end
    end
    draw_text(x, y, width, line_height, text)
  end
  #--------------------------------------------------------------------------
  def set_pos(nx = nil, ny = nil, nz = nil)
    set_x(nx); set_y(ny); set_z(nz)
  end
  #--------------------------------------------------------------------------
  def set_x(nx)
    self.x = nx if nx
  end
  #--------------------------------------------------------------------------
  def set_y(ny)
    self.y = ny if ny
  end
  #--------------------------------------------------------------------------
  def set_z(nz)
    self.z = nz if nz
  end
  #--------------------------------------------------------------------------
  alias show_child show
  def show
    @child_sprite.each{|sp| sp.show}
    show_child
  end
  #--------------------------------------------------------------------------
  alias hide_child hide
  def hide
    @child_sprite.each{|sp| sp.hide}
    hide_child
  end
  #--------------------------------------------------------------------------
  alias dispose_child dispose
  def dispose
    @child_sprite.each do |sp|
      next unless sp && !sp.disposed?
      sp.dispose
    end
    @child_sprite.clear
    dispose_child
  end
  #--------------------------------------------------------------------------
  # * Update Open Processing
  #--------------------------------------------------------------------------
  def update_open
    self.openness += 48
    if open?
      @opening = false
      show
    end
  end
  #--------------------------------------------------------------------------
  # * Update Close Processing
  #--------------------------------------------------------------------------
  def update_close
    self.openness -= 48
    if close?
      @closing = false
      hide
    end
  end
  #--------------------------------------------------------------------------
  alias open_vis open
  def open
    if !visible?
      show_child; self.openness = 0;
    end
    open_vis
  end
  #--------------------------------------------------------------------------
  alias close_vis close
  def close
    @child_sprite.each{|sp| sp.hide}
    close_vis
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_Selectable
#------------------------------------------------------------------------------
#  This window class contains cursor movement and scroll functions.
#==============================================================================
class Window_Selectable < Window_Base
  #--------------------------------------------------------------------------
  DefaultMouseTimer = 2
  DefaultHandlers   = [:ok, :cancel, :DOWN, :UP, :LEFT, :RIGHT, :pagedown, 
                       :pageup, :moreinfo]
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :overlayed
  attr_reader   :last_index
  attr_accessor :scroll_enable
  #--------------------------------------------------------------------------
  # * Object Initialization
  #-------------------------------------------------------------------------
  alias initialize_overlay initialize
  def initialize(x, y, width, height)
    @overlayed    = false
    @self_overlay = false
    @last_index      = nil
    @overlay_window  = nil
    @stacked_command = nil
    @stacked_args    = nil
    @scroll_enable   = false
    @help_text       = []             # selection help text
    @mouse_timer     = 0
    initialize_overlay(x, y, width, height)
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  alias update_overlayed update
  def update
    process_overlay_handling if button_cooled?
    if @overlayed
      self_overlay? ? update_overlay(update_overlayed) : update_overlay
    else
      update_overlayed
    end
    
    if @last_index != @index
      if @index_flag
        @index_flag = false
      else
        @last_index = @index
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Set Cursor Position
  #--------------------------------------------------------------------------
  def index=(index)
    @index_flag = true
    @last_index = @index
    @index = index
    update_cursor
    call_update_help
  end
  #--------------------------------------------------------------------------
  # * Item alignment the center
  #--------------------------------------------------------------------------
  def centralize?
    false
  end
  #--------------------------------------------------------------------------
  # * Deactivate self when overlayed
  #--------------------------------------------------------------------------
  def overlay_deactivate?
    true
  end
  #--------------------------------------------------------------------------
  # * Check if self overlayed
  #--------------------------------------------------------------------------
  def self_overlay?
    @self_overlay
  end
  #--------------------------------------------------------------------------
  # * Raise ovrelay window
  #--------------------------------------------------------------------------
  def raise_overlay(info = nil, stack_commandname = nil, args = nil)
    @overlay_window.info = info if info
    @stacked_command = self.method(stack_commandname) rescue nil
    @stacked_args    = args.is_a?(Array) ? args : [args]
    self.deactivate unless self_overlay?
    @overlay_window.activate
    @overlayed = true
  end
  #--------------------------------------------------------------------------
  # * Deactivate overlay window
  #--------------------------------------------------------------------------
  def close_overlay(continue = false)
    @overlay_window.deactivate
    self.activate   unless self_overlay?
    self.deactivate if self_overlay?
    call_stacked_command if continue
    @stacked_command, @stacked_args = nil, nil
    @overlayed = false
    PONY::ERRNO.close_errno_window
  end
  #--------------------------------------------------------------------------
  # * Call stacked method
  #--------------------------------------------------------------------------
  def call_stacked_command
    return if @stacked_command.nil?
    puts "Call: #{@stack_command}"
    arg_number = [@stacked_command.parameters.size, @stacked_args.compact.size].min
    @stacked_command.call(*@stacked_args)  
  end
  #--------------------------------------------------------------------------
  # * Update overlay window
  #--------------------------------------------------------------------------
  def update_overlay(continue = nil)
    return nil if @overlay_window.nil?
    unless self_overlay?
      continue = @overlay_window.update
      continue = @overlay_window.confirm_status if continue.nil?
    end
    close_overlay(continue) unless continue.nil?
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Right
  #--------------------------------------------------------------------------
  def cursor_right(wrap = false)
    if col_max >= 2 && (index < item_max - 1 || (wrap && horizontal?))
      select((index + 1) % item_max)
    elsif item_max > 1 && col_max >= 2
      select(0)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Left
  #--------------------------------------------------------------------------
  def cursor_left(wrap = false)
    if col_max >= 2 && (index > 0 || (wrap && horizontal?))
      select((index - 1 + item_max) % item_max)
     elsif col_max >= 2
      select(item_max - 1)
    end
  end
  #--------------------------------------------------------------------------
  # * Alias: Determine if Cursor is Moveable
  #--------------------------------------------------------------------------
  alias overlay_cursor_movable? cursor_movable?
  def cursor_movable?
    return false if (@overlayed && !self_overlay?)
    overlay_cursor_movable?
  end
  #--------------------------------------------------------------------------
  # * Self already a overlay window class
  #--------------------------------------------------------------------------
  def self_overlay
    @overlay_window = self
    @self_overlay   = true
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Handling Processing for OK and Cancel Etc.
  #--------------------------------------------------------------------------
  def process_handling
    return unless open? && active
    return if (@overlayed && !self_overlay?)
    call_item_help          if Input.trigger?(:kTAB)
    return unless button_cooled?
    return process_ok       if ok_enabled?        && Input.trigger?(:C)
    return process_cancel   if cancel_enabled?    && Input.trigger?(:B)
    return process_pagedown if handle?(:pagedown) && Input.trigger?(:R)
    return process_pageup   if handle?(:pageup)   && Input.trigger?(:L)
  end
  #--------------------------------------------------------------------------
  # * Process overlay window handling
  #--------------------------------------------------------------------------
  def process_overlay_handling
  end
  #--------------------------------------------------------------------------
  # Alias: wheel cursor move
  alias process_cursor_move_wheel process_cursor_move
  def process_cursor_move
    return unless cursor_movable?
    wheel_pagedown   if !handle?(:pagedown) && $mouse_cursor && Mouse.scroll_down?
    wheel_pageup     if !handle?(:pageup)   && $mouse_cursor && Mouse.scroll_up?
    process_cursor_move_wheel
  end
  
  # Mouse wheel page down
  def wheel_pagedown
    if contents.height > self.height && self.oy - contents.height < -self.height + 32
      self.top_row = self.top_row + 1
      @index = [@index, self.top_row].max
      select(@index)
    end
  end
  
  # Mouse wheel page up
  def wheel_pageup
    if contents.height > self.height
      self.top_row = self.top_row - 1
      @index = [@index, self.top_row].min
      select(@index)
    end
  end
  #--------------------------------------------------------------------------
  def index_changed?
    @last_index != @index
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Down
  #--------------------------------------------------------------------------
  def cursor_down(wrap = false)
    mul = Input.press?(:kSHIFT) && item_max > 5 ? 5 : 1
    if index < item_max - col_max || (wrap && col_max == 1)
      cursor_next(index + col_max * mul)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Up
  #--------------------------------------------------------------------------
  def cursor_up(wrap = false)
    mul = Input.press?(:kSHIFT) && item_max > 5 ? 5 : 1
    if index >= col_max || (wrap && col_max == 1)
      cursor_last(index - col_max * mul + item_max)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Right
  #--------------------------------------------------------------------------
  def cursor_right(wrap = false)
    mul = Input.press?(:kSHIFT) && item_max > 5 ? 5 : 1
    if col_max >= 2 && (index < item_max - 1 || (wrap && horizontal?))
      cursor_next(next_index = index + 1 * mul)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Left
  #--------------------------------------------------------------------------
  def cursor_left(wrap = false)
    mul = Input.press?(:kSHIFT) && item_max > 5 ? 5 : 1
    if col_max >= 2 && (index > 0 || (wrap && horizontal?))
      cursor_last(index - 1 * mul + item_max)
    end
  end
  #--------------------------------------------------------------------------
  def cursor_next(next_index)
    next_index = [item_max - 1, next_index].min if index + 1 != item_max
    next_index = 0                              if index + 1 == item_max
    select(next_index % item_max)
  end
  #--------------------------------------------------------------------------
  def cursor_last(next_index)
    next_index = [next_index, item_max].max if index != 0
    next_index = item_max - 1               if index == 0
    select(next_index % item_max)
  end
  #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index, help = nil)
    @help_text[index] = help
  end
  #--------------------------------------------------------------------------
  # * Check window if has previos entrance
  #--------------------------------------------------------------------------
  def has_parent?
    return true if self.is_a?(Window_ItemList)
    return true if self.is_a?(Window_FileAction)
    return true if self.is_a?(Window_MenuStatus)
    return false
  end
  #--------------------------------------------------------------------------
  # * Check window if should be auto select by mouse
  #--------------------------------------------------------------------------
  def autoselect?
    return true if SceneManager.scene.is_a?(Scene_File)
    return false
  end
  #--------------------------------------------------------------------------
  # * Display selection help window
  #--------------------------------------------------------------------------
  def call_item_help(index = @index)
    pos = Mouse.pos
    if pos
      mx, my = *pos
      mx = [Graphics.width - 120, mx].min
      my = [Graphics.height - 68, my].min
    else
      rect = cursor_rect
      mx, my = (rect.x + rect.width) / 2, (rect.y + rect.height) / 2
      mx += self.x; my += self.y;
    end
    
    if @help_text[index]
      info = @help_text[index] 
    elsif !@list.nil? && @list[index]
      info = @list[index][:name]
    else
      info = ""
    end
    SceneManager.show_item_help_window(mx, my, info)
  end
  #--------------------------------------------------------------------------
  # * Call Handler
  #--------------------------------------------------------------------------
  alias call_handler_dnd call_handler
  def call_handler(symbol)
    SceneManager.hide_item_help_window
    call_handler_dnd(symbol)
  end
  #--------------------------------------------------------------------------
  def select_cursor_needed?
    return item_max > 0
  end
  #--------------------------------------------------------------------------
  def dispose
    @overlay_window.dispose if @overlay_window
    super
  end
  #--------------------------------------------------------------------------
  def overlayed?; @overlayed; end
end

#==============================================================================
# ** Window_Command
#------------------------------------------------------------------------------
#  This window deals with general command choices.
#==============================================================================
class Window_Command < Window_Selectable
  #--------------------------------------------------------------------------
  attr_reader :list
  #--------------------------------------------------------------------------
  alias :current_item :current_data
  #--------------------------------------------------------------------------
  # * Add Command
  #     name    : Command name
  #     symbol  : Corresponding symbol
  #     enabled : Activation state flag
  #     ext     : Arbitrary extended data
  #--------------------------------------------------------------------------
  def add_command(name, symbol, enabled = true, ext = nil, help = nil)
    @list.push({:name=>name, :symbol=>symbol, :enabled=>enabled, :ext=>ext, :help => help})
  end
  #--------------------------------------------------------------------------
  # * Get Command Help
  #--------------------------------------------------------------------------
  def command_help(index)
    return @list[index][:help]
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
    # got to tag: modified - ICON
  end
  #--------------------------------------------------------------------------
  # * Update Help Window
  #--------------------------------------------------------------------------
  def update_help
    super
    @help_window.set_text(current_data[:help]) rescue nil
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_HorzCommand
#------------------------------------------------------------------------------
#  This is a command window for the horizontal selection format.
#==============================================================================
class Window_HorzCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # * Alias: contents width
  #--------------------------------------------------------------------------
  alias contents_width_cent contents_width
  def contents_width
    centralize? ? super : contents_width_cent
  end
  #--------------------------------------------------------------------------
  # * Alias: contents height
  #--------------------------------------------------------------------------
  alias contents_height_cent contents_height
  def contents_height
    centralize? ? super : contents_height_cent
  end
  #--------------------------------------------------------------------------
  # * Item alignment the center
  #--------------------------------------------------------------------------
  def centralize?
    false
  end
  #--------------------------------------------------------------------------
  # * Update Padding
  #--------------------------------------------------------------------------
  def update_padding
    super unless centralize?
  end
  #--------------------------------------------------------------------------
  # * Alias method: item_rect
  #--------------------------------------------------------------------------
  alias normal_item_rect item_rect
  def item_rect(index)
   centralize? ? central_item_rect(index) : normal_item_rect(index)
  end
  #--------------------------------------------------------------------------
  # * Item align center
  #--------------------------------------------------------------------------
  def central_item_rect(index)
    rect = Rect.new
    rect.width = item_width
    rect.height = item_height
    row_item_num = [col_max, item_max].min
    pos = index % row_item_num
    pos += 1
    spac_width = (contents_width - row_item_num * item_width) / (row_item_num + 1)
    rect.x = ((window_width / [item_max, 1].max + spac_width) * pos - item_width) / 2
    rect.y = (window_height / [item_max, 1].max / col_max * item_height * (index / col_max + 1)) / 8
    rect
  end
  
end

#==============================================================================
# ** Window_Help
#------------------------------------------------------------------------------
#  This window shows skill and item explanations along with actor status.
#==============================================================================
class Window_Help < Window_Base
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(line_number = 2, width = Graphics.width)
    super(0, 0, width, fitting_height(line_number))
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Set Text
  #--------------------------------------------------------------------------
  def set_text(text)
    text = (text || '')
    if text != @text
      @text = text.dup
      if text.is_a?(Array)
        @text = modify_text
      elsif text_size(text).width > contents.width
        @text = FileManager.textwrap(text, contents.width)
        @text = modify_text
      else
        @text = @text.force_encoding($default_encoding)
      end
      refresh
    end
  end
  #--------------------------------------------------------------------------
  def modify_text
    @text = @text.inject(""){|str, line| str += line + 10.chr}
    @text = @text.force_encoding($default_encoding)
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_Gold
#------------------------------------------------------------------------------
#  This window displays the party's gold.
#==============================================================================
class Window_Gold < Window_Base
  attr_reader :type
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(_type = 1) # 0 = both, 1 = bit, 2 = chromastal
    @type = _type
    super(0, 0, window_width, fitting_height(@type == 0 ? 2 : 1))
    refresh
  end
  #--------------------------------------------------------------------------
  # * Get Window Width
  #--------------------------------------------------------------------------
  def window_width
    return 120
  end
  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    cy = 0
    if type < 2
      begin
        draw_common_currency_value(value, 4, cy, contents.width - 8)
      rescue Expection => e
        puts e
      end
      cy += line_height
    end
    s_value = BlockChain.item_amount(Vocab::Player, $data_items[42])
    draw_special_currency_value(s_value, 4, cy, contents.width - 8) if type != 1 && visible?
  end
  #--------------------------------------------------------------------------
  # * Draw Number (Gold Etc.) with Currency Unit
  #--------------------------------------------------------------------------
  def draw_common_currency_value(value, x, y, width)
    change_color(normal_color)
    draw_icon(PONY::IconID[:bit],0,0)
    draw_text(x, y, width - 2, line_height, value, 2)
    change_color(system_color)
  end
  #--------------------------------------------------------------------------
  # * Draw Special Currency Value, which can't be obtained normally
  #--------------------------------------------------------------------------
  def draw_special_currency_value(value, x, y, width)
    change_color(crisis_color)
    draw_icon(PONY::IconID[:chromastal],0,line_height)
    draw_text(x, y, width - 2, line_height, value, 2)
    change_color(system_color)
  end
  #--------------------------------------------------------------------------
  # * Get Party Gold
  #--------------------------------------------------------------------------
  def value
    #PONY.DecryptInt($game_party.gold(true))
    $game_party.gold(false)
  end
end

#==============================================================================
# ** Window_ImageCommand
#------------------------------------------------------------------------------
#  This window deals with graphic command choices.
#==============================================================================
class Window_ImageCommand < Window_Command
  #--------------------------------------------------------------------------
  # * Create Window Contents
  #--------------------------------------------------------------------------
  def create_contents
    contents.dispose
    if contents_width > 0 && contents_height > 0
      self.contents = Bitmap.new(contents_width, contents_height )
    else
      self.contents = Bitmap.new(1, 1)
    end
  end
  #--------------------------------------------------------------------------
  # * Get Rectangle for Drawing Items
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = Rect.new
    rect.width = item_width
    rect.height = item_height
    rect.x = (index % col_max) * (item_width + spacing)
    rect.y = (index / col_max) * (item_height + spacing)
    rect
  end
  #--------------------------------------------------------------------------
  # * Calculate Width of Window Contents
  #--------------------------------------------------------------------------
  def contents_width
    col_max * (item_width + spacing) + spacing
  end
  #--------------------------------------------------------------------------
  # * Calculate Height of Window Contents
  #--------------------------------------------------------------------------
  def contents_height
    (item_width + spacing) * item_max + spcaing * 2
  end
  #--------------------------------------------------------------------------
  # * Add Command
  #     name    : Command name
  #     symbol  : Corresponding symbol
  #     image   : Path to the image
  #     enabled : Activation state flag
  #     ext     : Arbitrary extended data
  #     help    : Text displayed in tab-help window
  #--------------------------------------------------------------------------
  #def add_command(name, symbol, image, enabled = true, ext = nil, help = nil)
  def add_command(*args)
    case args.size
    when 1 # Hash initializer
      args = args[0]
      content = {
        :name     => args[:name],
        :symbol   => args[:symbol],
        :enabled  => args[:enabled].nil? ? true : args[:enabled],
        :ext      => args[:ext],
        :help     => args[:help],
        :image    => args[:image],
      }
    else
      name    = args[0]; symbol = args[1]; 
      image   = args[2];
      enabled = args[3].nil? ? true  : args[3];
      ext     = args[4]
      help    = args[5]
      content = {:name=>name, :symbol=>symbol, :enabled => enabled,
                 :ext=>ext, :help => help, :image => image}
      #----
    end
                      
    if !content[:symbol] || !content[:name] || !content[:image]
      errinfo = "Invalid parameter given:\nName: %s\nSymbol: %s\nImage: %s\n"
      errinfo = sprintf(errinfo, content[:name], content[:symbol], content[:image])
      raise ArgumentError, errinfo
    end
    
    @list.push(content)
  end
  #--------------------------------------------------------------------------
  # * Get Image file of Command
  #--------------------------------------------------------------------------
  def command_image(index)
    Cache.UI(@list[index][:image])
  end
  #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
    @help_text[index] = @list[index][:help]
    enabled = command_enabled?(index)
    change_color(normal_color, enabled)
    rect = item_rect_for_text(index)
    bitmap = command_image(index)
    draw_command_image(index, bitmap, enabled)
  end
  #--------------------------------------------------------------------------
  # * Draw Image
  #--------------------------------------------------------------------------
  def draw_command_image(index, bitmap, enabled = true)
    irect = item_rect(index)
    brect = Rect.new(0, 0, item_width, item_height)
    contents.blt(irect.x, irect.y, bitmap, brect, enabled ? 255 : 155)
    debug_print("Draw command image #{index}: #{irect}")
    bitmap.dispose
  end
  #--------------------------------------------------------------------------
  # * Scroll Cursor to Position Within Screen
  #--------------------------------------------------------------------------
  def ensure_cursor_visible
    self.top_row    = row if row < top_row
    self.bottom_row = row if row > bottom_row
  end
  
end

#==============================================================================
# ** Window_ImageHorzCommand
#------------------------------------------------------------------------------
#  This window deals with graphic command choices.
#==============================================================================
class Window_ImageHorzCommand < Window_ImageCommand
  #--------------------------------------------------------------------------
  # * Get Number of Lines to Show
  #--------------------------------------------------------------------------
  def visible_line_number
    return 1
  end
  #--------------------------------------------------------------------------
  # * Get Digit Count
  #--------------------------------------------------------------------------
  def col_max
    return ((window_width - standard_padding * 2) / (item_width + spacing)).to_i
  end
  #--------------------------------------------------------------------------
  # * Get Spacing for Items Arranged Side by Side
  #--------------------------------------------------------------------------
  def spacing
    return 8
  end
  #--------------------------------------------------------------------------
  # * Get Leading Digits
  #--------------------------------------------------------------------------
  def top_col
    ox / (item_width + spacing)
  end
  #--------------------------------------------------------------------------
  # * Set Leading Digits
  #--------------------------------------------------------------------------
  def top_col=(col)
    col = 0 if col < 0
    col = col_max - 1 if col > col_max - 1
    self.ox = col * (item_width + spacing)
  end
  #--------------------------------------------------------------------------
  # * Get Trailing Digits
  #--------------------------------------------------------------------------
  def bottom_col
    top_col + col_max - 1
  end
  #--------------------------------------------------------------------------
  # * Set Trailing Digits
  #--------------------------------------------------------------------------
  def bottom_col=(col)
    self.top_col = col - (col_max - 1)
  end
   #--------------------------------------------------------------------------
  # * Get Rectangle for Displaying Items
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = super
    rect.x = index * (item_width + spacing)
    rect.y = 0
    rect
  end
  #--------------------------------------------------------------------------
  # * Get Alignment
  #--------------------------------------------------------------------------
  def alignment
    return 1
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Down
  #--------------------------------------------------------------------------
  def cursor_down(wrap = false)
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Up
  #--------------------------------------------------------------------------
  def cursor_up(wrap = false)
  end
  #--------------------------------------------------------------------------
  # * Move Cursor One Page Down
  #--------------------------------------------------------------------------
  def cursor_pagedown
  end
  #--------------------------------------------------------------------------
  # * Move Cursor One Page Up
  #--------------------------------------------------------------------------
  def cursor_pageup
  end
  #--------------------------------------------------------------------------
  # * Calculate Width of Window Contents
  #--------------------------------------------------------------------------
  def contents_width
    (item_width + spacing) * item_max + spacing
  end
  #--------------------------------------------------------------------------
  # * Calculate Height of Window Contents
  #--------------------------------------------------------------------------
  def contents_height
    item_height
  end
  #--------------------------------------------------------------------------
  # * Scroll Cursor to Position Within Screen
  #--------------------------------------------------------------------------
  def ensure_cursor_visible
    self.top_col    = index if index < top_col
    self.bottom_col = index if index > bottom_col
  end
end

#==============================================================================
# ** Window_MenuCommand
#------------------------------------------------------------------------------
#  This command window appears on the menu screen.
#==============================================================================
class Window_MenuImageCommand < Window_ImageHorzCommand
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  MENU_ICON_WIDTH  = 50
  MENU_ICON_HEIGHT = 50

  # Levelup command
  COMMAND_LEVELUP = {
    :name   => Vocab::LevelUp,
    :symbol => :levelup,
    :image  => "Menu_Levelup"
  }
  #--------------------------------------------------------------------------
  # * Initialize Command Selection Position (Class Method)
  #--------------------------------------------------------------------------
  def self.init_command_position
    @@last_command_symbol = nil
  end
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0)
    select_last
  end
  #--------------------------------------------------------------------------
  # * Get Window Width
  #--------------------------------------------------------------------------
  def window_width
    return Graphics.width - 120 # gold window width
  end
  #--------------------------------------------------------------------------
  # * Get Window Height
  #--------------------------------------------------------------------------
  def window_height
    return 80
  end
  #--------------------------------------------------------------------------
  # * Get Number of Lines to Show
  #--------------------------------------------------------------------------
  def visible_line_number
    item_max
  end
  #--------------------------------------------------------------------------
  # * Create Command List
  #--------------------------------------------------------------------------
  def make_command_list
    add_main_commands
    add_formation_command
    add_original_commands
    add_save_command
    add_game_end_command
  end
  #--------------------------------------------------------------------------
  # * Add Main Commands to List
  #--------------------------------------------------------------------------
  def add_main_commands
    add_command(Vocab::item,   :item,   main_commands_enabled)
    add_command(Vocab::skill,  :skill,  main_commands_enabled)
    add_command(Vocab::equip,  :equip,  main_commands_enabled)
    add_command(Vocab::status, :status, main_commands_enabled)
  end
  #--------------------------------------------------------------------------
  # * Add Formation to Command List
  #--------------------------------------------------------------------------
  def add_formation_command
    add_command(Vocab::formation, :formation, formation_enabled)
  end
  #--------------------------------------------------------------------------
  # * For Adding Original Commands
  #--------------------------------------------------------------------------
  def add_original_commands
  end
  #--------------------------------------------------------------------------
  # * Add Save to Command List
  #--------------------------------------------------------------------------
  def add_save_command
    add_command(Vocab::save, :save, save_enabled)
  end
  #--------------------------------------------------------------------------
  # * Add Exit Game to Command List
  #--------------------------------------------------------------------------
  def add_game_end_command
    add_command(Vocab::game_end, :game_end)
  end
  #--------------------------------------------------------------------------
  # * Get Activation State of Main Commands
  #--------------------------------------------------------------------------
  def main_commands_enabled
    $game_party.exists
  end
  #--------------------------------------------------------------------------
  # * Get Activation State of Formation
  #--------------------------------------------------------------------------
  def formation_enabled
    $game_party.members.size >= 2 && !$game_system.formation_disabled
  end
  #--------------------------------------------------------------------------
  # * Get Activation State of Save
  #--------------------------------------------------------------------------
  def save_enabled
    !$game_system.save_disabled
  end
  #--------------------------------------------------------------------------
  # * Processing When OK Button Is Pressed
  #--------------------------------------------------------------------------
  def process_ok
    @@last_command_symbol = current_symbol
    super
  end
  #--------------------------------------------------------------------------
  # * Restore Previous Selection Position
  #--------------------------------------------------------------------------
  def select_last
    select_symbol(@@last_command_symbol)
  end
  #--------------------------------------------------------------------------
  # * Get Item Height
  #--------------------------------------------------------------------------
  def item_height
    MENU_ICON_HEIGHT
  end
  #--------------------------------------------------------------------------
  def item_width
    MENU_ICON_WIDTH
  end
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = super
    rect.x += 4
    rect
  end
  #--------------------------------------------------------------------------
  # * Add Level up commmand
  #--------------------------------------------------------------------------
  def add_levelup_command
    info = COMMAND_LEVELUP
    add_command(info[:name], info[:symbol], info[:image], levelup_command_enabled, nil, info[:name])
  end
  #--------------------------------------------------------------------------
  # * Add Main Commands to List
  #--------------------------------------------------------------------------
  def add_main_commands
    # Names are obtained after data loaded so can't use constants
    names   = [Vocab::item, Vocab::skill, Vocab::equip, Vocab::status, Vocab::Quest]
    symbols = [:item, :skill, :equip, :status, :quest]
    images  = ["Menu_Bag", "Menu_Skill", "Menu_Gears", "Menu_Status", "Menu_Quest"]

    names.size.times do |i|
      add_command(names[i], symbols[i], images[i], main_commands_enabled, nil, names[i])
    end
  end
  #--------------------------------------------------------------------------
  # * Add Formation to Command List
  #--------------------------------------------------------------------------
  def add_formation_command
    add_command(Vocab::formation, :formation, "Menu_Party", main_commands_enabled, nil, Vocab::formation)
  end
  #--------------------------------------------------------------------------
  # * For Adding Original Commands
  #--------------------------------------------------------------------------
  def add_original_commands
  end
  #--------------------------------------------------------------------------
  # * Add Save to Command List
  #--------------------------------------------------------------------------
  def add_save_command
    add_command(Vocab::save, :save, "Menu_Save", save_enabled?, nil, Vocab::SaveDec)
  end
  #--------------------------------------------------------------------------
  # * Add Exit Game to Command List
  #--------------------------------------------------------------------------
  def add_game_end_command
    add_command(Vocab::game_end, :game_end, "Menu_System", true, nil, Vocab::SystemDec)
  end
  #--------------------------------------------------------------------------
  def levelup_command_enabled
    return false if BattleManager.in_battle?
    return true
  end
  #--------------------------------------------------------------------------
  def save_enabled?
    return false if @header.nil? && SceneManager.scene_is?(Scene_Load)
    return false if SceneManager.scene_is?(Scene_Load)
    return false if $game_system.save_disabled
    #return false if at_special_slot?
    return false if BattleManager.in_battle?
    return true
  end
  
end

#==============================================================================
# ** Window_MenuStatus
#------------------------------------------------------------------------------
#  This window displays party member status on the menu screen.
#==============================================================================
class Window_MenuStatus < Window_Selectable
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :pending_index            # Pending position (for formation)
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y)
    super(x, y, window_width, window_height)
    @pending_index = -1
    refresh
  end
  #--------------------------------------------------------------------------
  # * Draw All Items
  #--------------------------------------------------------------------------
  def draw_all_items
    item_max.times {|i| draw_item(i) }
  end
  #--------------------------------------------------------------------------
  # * Erase Item
  #--------------------------------------------------------------------------
  def clear_item(index)
    contents.clear_rect(item_rect(index))
  end
  #--------------------------------------------------------------------------
  # * Redraw Item
  #--------------------------------------------------------------------------
  def redraw_item(index)
    clear_item(index) if index >= 0
    draw_item(index)  if index >= 0
  end
  #--------------------------------------------------------------------------
  # * Redraw Selection Item
  #--------------------------------------------------------------------------
  def redraw_current_item
    redraw_item(@index)
  end
  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    draw_all_items
  end
  #--------------------------------------------------------------------------
  # * Get Window Width
  #--------------------------------------------------------------------------
  def window_width
    Graphics.width - 160
  end
  #--------------------------------------------------------------------------
  # * Get Window Height
  #--------------------------------------------------------------------------
  def window_height
    Graphics.height
  end
  #--------------------------------------------------------------------------
  # * Get Number of Items
  #--------------------------------------------------------------------------
  def item_max
    $game_party.members.size
  end
  #--------------------------------------------------------------------------
  # * Get Spacing for Items Arranged Side by Side
  #--------------------------------------------------------------------------
  def spacing
    return 32
  end
  #--------------------------------------------------------------------------
  # * Get Item Width
  #--------------------------------------------------------------------------
  def item_width
    (width - standard_padding * 2 + spacing) / col_max - spacing
  end
  #--------------------------------------------------------------------------
  # * Get Item Height
  #--------------------------------------------------------------------------
  def item_height
    (height - standard_padding * 2) / 4
  end
  #--------------------------------------------------------------------------
  # * Get Rectangle for Drawing Items
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = Rect.new
    rect.width = item_width
    rect.height = item_height
    rect.x = index % col_max * (item_width + spacing)
    rect.y = index / col_max * item_height / 1
    rect
  end
  #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
    actor = $game_party.members[index]
    enabled = $game_party.battle_members.include?(actor)
    rect = item_rect(index)
    draw_item_background(index)
    draw_actor_face(actor, rect.x + 1, rect.y + 1, enabled)
    draw_actor_simple_status(actor, rect.x + 108, rect.y + line_height / 2)
  end
  #--------------------------------------------------------------------------
  # * Draw Background for Item
  #--------------------------------------------------------------------------
  def draw_item_background(index)
    if index == @pending_index
      contents.fill_rect(item_rect(index), pending_color)
    end
  end
  #--------------------------------------------------------------------------
  # * Processing When OK Button Is Pressed
  #--------------------------------------------------------------------------
  def process_ok
    super
    $game_party.menu_actor = $game_party.members[index]
  end
  #--------------------------------------------------------------------------
  # * Restore Previous Selection Position
  #--------------------------------------------------------------------------
  def select_last
    select($game_party.menu_actor.index || 0)
  end
  #--------------------------------------------------------------------------
  # * Set Pending Position (for Formation)
  #--------------------------------------------------------------------------
  def pending_index=(index)
    last_pending_index = @pending_index
    @pending_index = index
    redraw_item(@pending_index)
    redraw_item(last_pending_index)
  end
end

#==============================================================================
# ** Window_MenuStatus
#------------------------------------------------------------------------------
#  This window displays party member status on the menu screen.
#==============================================================================
class Window_ImageMenuStatus < Window_MenuStatus
  include PONY::Menu_UI
  attr_reader :index_list
  attr_reader :list_indicator
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y)
  	create_index_list
    @y = y
  	super(x, y)
  end
  
  #--------------------------------------------------------------------------
  def create_index_list
  	@list_indicator = 0
    _max = item_max
    if _max > 1
      @index_list = [1]
      for i in 0...item_max
        next if i == 1
        @index_list.push(i)
      end
    else
      @index_list = [0]
    end
  end
  #--------------------------------------------------------------------------
  # * Calculate Height of Window Contents
  #--------------------------------------------------------------------------
  def contents_height
    Graphics.height
  end
  #--------------------------------------------------------------------------
  # * Get Window Width
  #--------------------------------------------------------------------------
  def window_width
    Graphics.width
  end
  #--------------------------------------------------------------------------
  # * Get Window Height
  #--------------------------------------------------------------------------
  def window_height
    Graphics.height - (@y / 2)
  end
  #--------------------------------------------------------------------------
  # * Get corresponding character image
  #--------------------------------------------------------------------------
  def get_actor_image(id, leader)
    leader = false
    image_filename = leader ? "Lead" : ""
  	image_filename += "Char_" + id.to_s
  	Cache.UI(image_filename) rescue nil
  end
  #--------------------------------------------------------------------------
  # * Get Item Width
  #--------------------------------------------------------------------------
  def item_width
    150
  end
  #--------------------------------------------------------------------------
  # * Get Item Height
  #--------------------------------------------------------------------------
  def item_height
    200
  end
  #--------------------------------------------------------------------------
  # * Get Image Height
  #--------------------------------------------------------------------------
  def image_height
    220
  end
  #--------------------------------------------------------------------------
  # * Get Position for Item
  #--------------------------------------------------------------------------
  def item_position(index, for_image = false, img_width = 0)
  	case index
  	when 0
  		cx = (for_image && img_width > 155) ? First_Item_Position[0] - img_width / 16 : First_Item_Position[0]
      cy = First_Item_Position[1]
  	when 1
      cx = Second_Item_Position[0]
      cy = Second_Item_Position[1]
  	else
      cx = First_Item_Position[0] + 145 * (index - 1)
      cx = First_Item_Position[0] + (145 - img_width / 8) * (index - 1) if for_image && img_width > 155
      cy = First_Item_Position[1] + 15 * (index - 1)
  	end
    [cx, cy]
  end
  #--------------------------------------------------------------------------
  # * Get Rectangle for Drawing Items
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = Rect.new
    rect.width = item_width
    rect.height = item_height
    rect.x = item_position(index).at(0)
    rect.y = item_position(index).at(1)
    rect
  end
  #--------------------------------------------------------------------------
  # * Get Rectangle for Ccursor
  #--------------------------------------------------------------------------
  def item_rect_for_cursor(index)
    rect = item_rect(index)
    rect.x += 6
    rect.y  = 0
    rect.height = fitting_height(0) + 6
    rect.width  = 148
    rect
  end
 
  #--------------------------------------------------------------------------
  # * Get Number of Lines to Show
  #--------------------------------------------------------------------------
  def visible_line_number
    return 1
  end
  #--------------------------------------------------------------------------
  # * Get Digit Count
  #--------------------------------------------------------------------------
  def col_max
    return 4
  end
  #--------------------------------------------------------------------------
  # * Get Spacing for Items Arranged Side by Side
  #--------------------------------------------------------------------------
  def spacing
    return 8
  end
  #--------------------------------------------------------------------------
  # * Get Leading Digits
  #--------------------------------------------------------------------------
  def top_col
    ox / (item_width + spacing)
  end
  #--------------------------------------------------------------------------
  # * Set Leading Digits
  #--------------------------------------------------------------------------
  def top_col=(col)
    col = 0 if col < 0
    col = col_max - 1 if col > col_max - 1
    self.ox = col * (item_width + spacing)
  end
  #--------------------------------------------------------------------------
  # * Get Trailing Digits
  #--------------------------------------------------------------------------
  def bottom_col
    top_col + col_max - 1
  end
  #--------------------------------------------------------------------------
  # * Set Trailing Digits
  #--------------------------------------------------------------------------
  def bottom_col=(col)
    self.top_col = col - (col_max - 1)
  end
  #--------------------------------------------------------------------------
  # * Scroll Cursor to Position Within Screen
  #--------------------------------------------------------------------------
  def ensure_cursor_visible
    self.top_col = index if index < top_col
    self.bottom_col = index if index > bottom_col
  end
  #--------------------------------------------------------------------------
  # * Get Alignment
  #--------------------------------------------------------------------------
  def alignment
    return 1
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Down
  #--------------------------------------------------------------------------
  def cursor_down(wrap = false)
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Up
  #--------------------------------------------------------------------------
  def cursor_up(wrap = false)
  end
  #--------------------------------------------------------------------------
  # * Move Cursor One Page Down
  #--------------------------------------------------------------------------
  def cursor_pagedown
  end
  #--------------------------------------------------------------------------
  # * Move Cursor One Page Up
  #--------------------------------------------------------------------------
  def cursor_pageup
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Right
  #--------------------------------------------------------------------------
  def cursor_right(wrap = false)
    if col_max >= 2 && (@list_indicator < item_max - 1 || (wrap && horizontal?))
      @list_indicator = (@list_indicator + 1) % item_max
      select(@index_list[@list_indicator])
    elsif @list_indicator == item_max - 1
      @list_indicator = 0
      select(@index_list[@list_indicator])
    end
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Left
  #--------------------------------------------------------------------------
  def cursor_left(wrap = false)
    if col_max >= 2 && (@list_indicator > 0 || (wrap && horizontal?))
      @list_indicator = (@list_indicator - 1 + item_max) % item_max
      select(@index_list[@list_indicator])
    elsif @list_indicator == 0
      @list_indicator = item_max - 1
      select(@index_list[@list_indicator])
    end
  end
  #--------------------------------------------------------------------------
  # * Deselect Item
  #--------------------------------------------------------------------------
  def unselect
    self.index = -1
    @list_indicator = 0
  end
  #--------------------------------------------------------------------------
  # * Update Cursor
  #--------------------------------------------------------------------------
  def update_cursor
    if @cursor_all
      cursor_rect.set(0, 0, contents.width, row_max * item_height)
      self.top_row = 0
    elsif @index < 0
      cursor_rect.empty
    else
      ensure_cursor_visible
      cursor_rect.set(item_rect_for_cursor(@index))
    end
  end
  #--------------------------------------------------------------------------
  # * Draw All Items
  #--------------------------------------------------------------------------
  def draw_all_items
    n = item_max
    item_max.times {|i| draw_item(n - 1 - i) }
  end
   #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
    actor = $game_party.members[index]
    return if actor.nil?
    enabled = $game_party.battle_members.include?(actor)
    rect = item_rect(index)
    
    #draw_item_background(index)
    draw_actor_image(actor.id, index, index == 0)
    draw_actor_simple_status(actor, rect.x + 12, 0)
    draw_upgradeable_hint(actor, rect)
  end
  
  #--------------------------------------------------------------------------
  # * Draw Actor Image
  #--------------------------------------------------------------------------
  def draw_actor_image(id, index, leader)
  	bitmap = get_actor_image(id, leader)
    cx     = item_position(index, true, bitmap.width).at(0)
  	cy 		 = window_height - fitting_height(2) - bitmap.height - 5
  	rect 	 = Rect.new(0, 0, bitmap.width, bitmap.height)
    contents.blt(cx, cy, bitmap, rect)
    bitmap.dispose
  end
  #--------------------------------------------------------------------------
  # * Draw Simple Status
  #--------------------------------------------------------------------------
  def draw_actor_simple_status(actor, x, y)
    draw_actor_name(actor, x, y)
    draw_actor_class(actor, x, y + line_height, 168, true)
    draw_actor_hp(actor, x, y + line_height * 3)
    draw_actor_mp(actor, x, y + line_height * 4)
    draw_actor_icons(actor, x, window_height - fitting_height(2))
  end
  #--------------------------------------------------------------------------
  def draw_upgradeable_hint(actor, rect)
    return unless actor.upgradeable?
    cx = rect.x + rect.width - 28; cy = rect.y + line_height / 2;
    draw_icon(PONY::IconID[:level_up], cx, cy)
  end
end



#==============================================================================
# ** Window_ItemList
#------------------------------------------------------------------------------
#  This window displays a list of party items on the item screen.
#==============================================================================
class Window_ItemList < Window_Selectable
  #--------------------------------------------------------------------------
  attr_reader :data
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias init_dnd initialize
  def initialize(x, y, width, height)
    @actor = $game_player
    init_dnd(x, y, width, height)
  end
  #--------------------------------------------------------------------------
  # * Handling Processing for OK and Cancel Etc.
  #--------------------------------------------------------------------------
  def process_handling
    super
    return prev_actor if handle?(:prev_actor) && Input.trigger?(:R)
    return next_actor if handle?(:next_actor) && Input.trigger?(:L)
  end
  #--------------------------------------------------------------------------
  def actor=(n_actor)
    @actor = n_actor
  end
  #--------------------------------------------------------------------------
  def prev_actor
    Sound.play_cursor
    call_handler(:prev_actor)
  end
  #--------------------------------------------------------------------------
  def next_actor
    Sound.play_cursor
    call_handler(:next_actor)
  end
  #--------------------------------------------------------------------------
end



#==============================================================================
# ■ Window_SkillList
#==============================================================================
class Window_SkillList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # Overwrite: draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    skill = @data[index]
    return if skill.nil?
    rect = item_rect(index)
    rect.width -= 4
    draw_item_name(skill, rect.x, rect.y, true, rect.width - 24)
    draw_skill_cost(rect, skill)
  end
  
  #--------------------------------------------------------------------------
  # * Get Activation State of Selection Item
  #--------------------------------------------------------------------------
  def current_item_enabled?
    true
  end
  
end # Window_SkillList

#==============================================================================
# ** Window_ItemAction
#------------------------------------------------------------------------------
#  Displaying the actions of an item when selected
#==============================================================================
class Window_ItemAction < Window_Command
  #--------------------------------------------------------------------------
  attr_accessor :item
  attr_accessor :actor
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x = 0, y = 0)
    super
    self.windowskin = Cache.system(WindowSkin::ItemAction)
    @actor  = nil
    @item   = nil
    unselect
    hide
  end
  #--------------------------------------------------------------------------
  # * Create Command List
  #--------------------------------------------------------------------------
  def make_command_list
    add_command(Vocab::Skillbar::Use, :use_ok, item_usable?)
    add_command(Vocab::Skillbar::Hotkey, :sel_hotkey, item_targetable?)
    add_command(Vocab::MoreInfo, :moreinfo, item_data_included?)
  end
  #--------------------------------------------------------------------------
  def activate(item = @item, actor = @actor)
    @item  = item
    @actor = actor
    super()
    self.opacity = 255
    refresh
  end
  #--------------------------------------------------------------------------
  # * Determine if item is usable
  #--------------------------------------------------------------------------
  def item_usable?
    return false unless @item
    return @actor ? @actor.usable?(@item) : $game_player.usable?(@item)
  end
  #--------------------------------------------------------------------------
  def item_targetable?
    return false unless @item
    return @item.scope != 0
  end
  #--------------------------------------------------------------------------
  def item_data_included?
    return false unless @item
    return true if @item.is_a?(RPG::Item)
    return true if @item.is_a?(RPG::Weapon)
    return true if @item.is_a?(RPG::Armor)
    return false
  end
  #--------------------------------------------------------------------------
end



#==============================================================================
# ** Window_EquipSlot
#------------------------------------------------------------------------------
#  This window displays items the actor is currently equipped with on the
# equipment screen.
#==============================================================================
class Window_EquipSlot < Window_Selectable
  #-----------------------------------------------------------------------------
  MouseTimer = 8
  #-----------------------------------------------------------------------------
  def get_mouse_timer
    return MouseTimer
  end
  #-----------------------------------------------------------------------------
end


#==============================================================================
# ** Window_Status
#------------------------------------------------------------------------------
#  This window displays full status specs on the status screen.
#==============================================================================
class Window_Status < Window_Selectable
  #--------------------------------------------------------------------------
  # * Overwrite: Draw Description
  #--------------------------------------------------------------------------
  def draw_description(x, y)
    desc = FileManager.textwrap(@actor.description, contents.width, contents)
    draw_text_ex(x, y, desc)
  end
end





#==============================================================================
# ** Window_ShopNumber
#------------------------------------------------------------------------------
#  This window is for inputting quantity of items to buy or sell on the shop
# screen.
#==============================================================================
class Window_ShopNumber < Window_Selectable
  #--------------------------------------------------------------------------
  # * Update Quantity
  #--------------------------------------------------------------------------
  def update_number
    mul = Input.press?(:kSHIFT) ? 5 : 1
    change_number( 1  * mul) if Input.repeat?(:RIGHT)
    change_number(-1  * mul) if Input.repeat?(:LEFT)
    change_number( 10 * mul) if Input.repeat?(:UP)
    change_number(-10 * mul) if Input.repeat?(:DOWN)
  end
end







#==============================================================================
# ** Window_Message
#------------------------------------------------------------------------------
#  This message window is used to display text.
#==============================================================================
class Window_Message < Window_Base
  #--------------------------------------------------------------------------
  # * Public instance variables
  #--------------------------------------------------------------------------
  attr_reader :fiber
  
end

#==============================================================================
# ** Window_ScrollText
#------------------------------------------------------------------------------
#  This window is for displaying scrolling text. No frame is displayed, but it
# is handled as a window for convenience.
#==============================================================================
class Window_ScrollText < Window_Base
  #--------------------------------------------------------------------------
  # * Public instance variables
  #--------------------------------------------------------------------------
  attr_reader :text
  
end

#==============================================================================
# ** Window_MapName
#------------------------------------------------------------------------------
#  This window displays the map name.
#==============================================================================
class Window_MapName < Window_Base
  #--------------------------------------------------------------------------
  # * Public instance variables
  #--------------------------------------------------------------------------
  attr_reader :show_count
  
end









#==============================================================================
# ** Window_TitleCommand
#------------------------------------------------------------------------------
#  This window is for selecting New Game/Continue on the title screen.
#==============================================================================
class Window_TitleCommand < Window_Command
  #--------------------------------------------------------------------------
  attr_accessor :ready
  #--------------------------------------------------------------------------
  # * Overwrite: Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0)
    update_placement
    select_symbol(:continue) if continue_enabled
    self.openness = 0xff
    self.visible = false
    @ready = false
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Change order and new commands
  #--------------------------------------------------------------------------
  def make_command_list
    add_command(Vocab::continue, :continue, continue_enabled, nil, Vocab::Continue)
    add_command(Vocab::new_game, :start_game, true, nil, Vocab::StartGame)
    add_command(Vocab::Option,   :option,     true, nil, Vocab::Option)
    add_command(Vocab::Credits,  :credits,    true, nil, Vocab::Credits)
    add_command(Vocab::shutdown, :shutdown,   true, nil, Vocab::ShutDown)
  end
  #--------------------------------------------------------------------------
  # * Get Activation State of Continue
  #--------------------------------------------------------------------------
  def continue_enabled
    return !DataManager.latest_savefile.nil?
  end
  #--------------------------------------------------------------------------
  def current_item_enabled?
    return super && @ready
  end
  #--------------------------------------------------------------------------
end


#==============================================================================
# ** Window_DebugLeft
#------------------------------------------------------------------------------
#  This window designates switch and variable blocks on the debug screen.
#==============================================================================
class Window_DebugLeft < Window_Selectable
  #--------------------------------------------------------------------------
  attr_reader :category, :content_data
  #--------------------------------------------------------------------------
  # * Get Mode
  #--------------------------------------------------------------------------
  def mode
  end
  #--------------------------------------------------------------------------
  def refresh
    create_contents
    draw_all_items
  end
  #--------------------------------------------------------------------------
  def set_category(_cat, content_data)
    @category = _cat
    self.oy   = 0
    @content_data = content_data
    @item_max     = [get_content_size, 1].max
    @right_window.set_category(_cat, content_data) if @right_window
    refresh
    update
  end
  #--------------------------------------------------------------------------
  def get_content_size
    case @category
    when :switch
      bas = @content_data.size == 0 ? $game_switches.item_max : @content_data.size
      return (bas + 9) / 10
    when :variable
      bas = @content_data.size == 0 ? $game_variables.item_max : @content_data.size
      return (bas + 9) / 10
    end
    return @content_data.size
  end
  #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
    case @category
    when :variable
      n = index * 10
      text = sprintf("V [%04d-%04d]", n+1, n+10)
    when :switch
      n = index * 10
      text = sprintf("S [%04d-%04d]", n+1, n+10)
    when :sprite
      text = @content_data[index].bitmap.source rescue nil
      text = @content_data[index].inspect unless text
    end
    draw_text(item_rect_for_text(index), text)
  end
  #--------------------------------------------------------------------------
  def cursor_pagedown
    return call_handler(:pagedown) if handle?(:pagedown)
    super
  end
  #--------------------------------------------------------------------------
  def cursor_pageup
    return call_handler(:pageup) if handle?(:pageup)
    super
  end
  #--------------------------------------------------------------------------
  def top_id
    return index * 10 + 1
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_DebugRight
#------------------------------------------------------------------------------
#  This window displays switches and variables separately on the debug screen.
#==============================================================================
class Window_DebugRight < Window_Selectable
  #--------------------------------------------------------------------------
  BitmapNegativeSpeed = 10
  #--------------------------------------------------------------------------
  attr_reader :category
  attr_reader :data
  #--------------------------------------------------------------------------
  # * Object Initialization
  #-------------------------------------------------------------------------
  alias init_debug initialize
  def initialize(x, y, width)
    init_debug(x, y, width)
    self.arrows_visible = false
  end
  #--------------------------------------------------------------------------
  alias :mode :category
  #--------------------------------------------------------------------------
  def contents_width
    return Graphics.width
  end
  #--------------------------------------------------------------------------
  def contents_right
    return Gracphis.height
  end
  #--------------------------------------------------------------------------
  def refresh
    unselect if @category == :sprite
    super
  end
  #--------------------------------------------------------------------------
  def set_category(_cat, data)
    @category = _cat
    @data     = data
    refresh
  end
  #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
    return unless @category
    data_id = @top_id + index
    id_text = sprintf("%04d:", data_id)
    id_width = text_size(id_text).width
    case @category
    when :sprite
      return darw_bitmap_item((@top_id - 1) / 10)
    when :switch
      name   = $data_system.switches[data_id]
      status = data[data_id] ? "[ON]" : "[OFF]"
    when :variable
      name   = $data_system.variables[data_id]
      status = data[data_id]
    end
    name = "" unless name
    rect = item_rect_for_text(index)
    change_color(normal_color)
    draw_text(rect, id_text)
    rect.x += id_width
    rect.width -= id_width + 60
    draw_text(rect, name)
    rect.width += 60
    draw_text(rect, status, 2)
  end
  #--------------------------------------------------------------------------
  def darw_bitmap_item(index)
    return unless @data[index]
    data = @data[index].bitmap
    if data.disposed?
      contents.draw_text(0, 0, 240, line_height, "Disposed Bitmap")
    else
      rect = Rect.new(0, 0, data.width, data.height)
      contents.blt(0, 0, data, rect)
    end    
  end
  #--------------------------------------------------------------------------
  # * Update Cursor
  #--------------------------------------------------------------------------
  def update_cursor
    return cursor_rect.empty if @category == :sprite
    return super
  end
  #--------------------------------------------------------------------------
  def display_bot
    dx = [contents.width  - width  - standard_padding, 0].max
    dy = [contents.height - height - standard_padding, 0].max
    return POS.new(dx, dy)
  end
  #--------------------------------------------------------------------------
  def cursor_right(wrap = false)
    return super unless @category == :sprite
    self.ox = [self.ox + BitmapNegativeSpeed, display_bot.x].min
  end
  #--------------------------------------------------------------------------
  def cursor_left(wrap = false)
    return super unless @category == :sprite
    self.ox = [self.ox - BitmapNegativeSpeed, 0].max
  end
  #--------------------------------------------------------------------------
  def cursor_up(wrap = false)
    return super unless @category == :sprite
    self.oy = [self.oy - BitmapNegativeSpeed, 0].max
  end
  #--------------------------------------------------------------------------
  def cursor_down(wrap = false)
    return super unless @category == :sprite
    self.oy = [self.oy + BitmapNegativeSpeed, display_bot.y].min
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_Overlay
#------------------------------------------------------------------------------
#   Super class of overlay windows, which will display above the scene, this
#  class has the first priority of all actions.
#==============================================================================
class Window_Overlay < Window_HorzCommand
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :info
  attr_accessor :force_execute # force execute command procedure
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y, width, line_number, information, overlay_self)
    @info = information
    @force_execute = false
    @width = width ? width : 300
    line_number = line_number ? line_number : 5
    @height = fitting_height(line_number)
    x = Graphics.center_width(window_width) unless x
    y = Graphics.center_height(window_height) unless y
    super(x, y)
    self.windowskin = Cache.system(WindowSkin::Pinkie) if WindowSkin::Enable
    assign_handler
    self.opacity = 255
    self.z = PONY::SpriteDepth::Table[:overlays]
    refresh
    self_overlay if overlay_self
    deactivate
  end
  #--------------------------------------------------------------------------
  # * Get Window Width
  #--------------------------------------------------------------------------
  def window_width
    return @width
  end
  #--------------------------------------------------------------------------
  # * Get Window Height
  #--------------------------------------------------------------------------
  def window_height
    return @height
  end
  #--------------------------------------------------------------------------
  # * Item alignment the center
  #--------------------------------------------------------------------------
  def centralize?
    true
  end
  #--------------------------------------------------------------------------
  # * Activate Window
  #--------------------------------------------------------------------------
  def activate
    SceneManager.show_dim_background
    self.show
    refresh
    super
  end
  #--------------------------------------------------------------------------
  # * Deactivate self when overlayed
  #--------------------------------------------------------------------------
  def overlay_deactivate?
    false
  end
  #--------------------------------------------------------------------------
  # * Deactivate Window
  #--------------------------------------------------------------------------
  def deactivate
    SceneManager.hide_dim_background
    self.hide
    @overlayed = false if @self_overlay
    process_terminate
    super
  end
  #--------------------------------------------------------------------------
  # * Raise ovrelay window
  #--------------------------------------------------------------------------
  def raise_overlay(info = nil, stack_commandname = nil, args = nil, forced = false)
    @force_execute = forced
    super(info, stack_commandname, args)
    refresh
  end
  #--------------------------------------------------------------------------
  # * refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    draw_info_text
  end  
  #--------------------------------------------------------------------------
  # * Terminate window
  #--------------------------------------------------------------------------
  def process_terminate
    reactivate_last_window
  end
  #--------------------------------------------------------------------------
  # * Create Command List
  #--------------------------------------------------------------------------
  def make_command_list
  end
  #--------------------------------------------------------------------------
  # * Assign Mehtod to command
  #--------------------------------------------------------------------------
  def assign_handler
  end
  #--------------------------------------------------------------------------
  # * Deactivate overlay window
  #--------------------------------------------------------------------------
  def close_overlay(continue = false)
    super(continue)
    reactivate_last_window
  end
  #--------------------------------------------------------------------------
  # * Reactivate last window before overlay
  #--------------------------------------------------------------------------
  def reactivate_last_window
    return if @last_window.nil?
    @last_window.activate if @last_window.is_a?(Window_Selectable)
    @last_window = nil
  end
  #--------------------------------------------------------------------------
  # * Assign last window if self overlay
  #--------------------------------------------------------------------------
  def assign_last_window(window)
    puts "Last window: #{window}"
    @last_window = window
  end
  #--------------------------------------------------------------------------
  # * Draw Extra Information
  #--------------------------------------------------------------------------
  def draw_info_text
    rect = item_rect_for_text(0)
    draw_modified_text(rect)
  end
  #--------------------------------------------------------------------------
  def get_text_y(rect, tsize)
    return [rect.y - line_height * (tsize + 1) - (line_height / 4).to_i, 0].max
  end
  #--------------------------------------------------------------------------
  # * Modified Texts
  #--------------------------------------------------------------------------
  def draw_modified_text(rect)
    line_width = contents.width
    texts   = FileManager.textwrap(@info, line_width - 4, contents)    
    cy = get_text_y(rect, texts.size)
    draw_text_lines(texts, 4, cy, line_width)
  end
  #--------------------------------------------------------------------------
  # * Draw array of text lines
  #--------------------------------------------------------------------------
  def draw_text_lines(texts, cx, cy, line_width)
    texts.each do |line|
      draw_text(cx, cy, line_width, line_height, line, alignment)
      cy += line_height
    end
  end
  #------------------
end

#==============================================================================
# ** Window_PopInfo
#------------------------------------------------------------------------------
#  Pop-up information window
#==============================================================================
class Window_PopInfo < Window_Overlay
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :countdown
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x = nil, y = nil, width = 300, ln = 5, information = '', 
                  exist_time = sec_to_frame(5), overlay_self = false)
    @exist_time = exist_time
    @countdown  = exist_time
    super(x, y, width, ln, information, overlay_self)
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    unselect
    @countdown -= 1 if @countdown > 0
    close_overlay(@force_execute) if @countdown <= 0 && @exist_time > 0
  end
  #--------------------------------------------------------------------------
  # * Assign Mehtod to command
  #--------------------------------------------------------------------------
  def assign_handler
    set_handler(:ok, method(:deactivate) )
    set_handler(:cancel, method(:deactivate) )
  end
  #--------------------------------------------------------------------------
  # * Determine if Cursor is Moveable
  #--------------------------------------------------------------------------
  def cursor_movable?
    return false
  end
  #--------------------------------------------------------------------------
  # * Get Number of Items
  #--------------------------------------------------------------------------
  def item_max
    return 1
  end
  #--------------------------------------------------------------------------
  # * Get Activation State of Selection Item
  #--------------------------------------------------------------------------
  def current_item_enabled?
    return true
  end
  #--------------------------------------------------------------------------
  # * Raise ovrelay window
  #--------------------------------------------------------------------------
  def raise_overlay(*args)
    @countdown = @exist_time
    
    if args.size == 1 && args[0].is_a?(Hash)# hash initializer
      args = args[0]
      info = args[:info]; stack_commandname = args[:method];
      call_args = args[:args]; forced = (args[:forced] || false);
      @countdown = args[:time]
    else
      info = args[0]
      stack_commandname = args[1]
      call_args = args[2]
      forced = (args[3] || false)
    end
    
    unselect
    SceneManager.process_tactic(true) unless SceneManager.tactic_enabled?
    super(info, stack_commandname, call_args, forced)
  end
  #--------------------------------------------------------------------------
  # * Update Cursor
  #--------------------------------------------------------------------------
  def update_cursor
  end
  #--------------------------------------------------------------------------
  def index
    return -1
  end
  #--------------------------------------------------------------------------
  def select_cursor_needed?
    return false
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_Confirm
#------------------------------------------------------------------------------
#  Overlayed on Selectable to confirm actions
#==============================================================================
class Window_Confirm < Window_Overlay
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor   :info
  attr_accessor   :confirm_status
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x = nil, y = nil, width = 300, ln = 5,
                information = "Sure?", overlay_self = false)
    @confirm_status = nil
    @static = false
    super(x, y, width, ln, information, overlay_self)
  end
  #--------------------------------------------------------------------------
  # * Determine if Cursor is Moveable
  #--------------------------------------------------------------------------
  def cursor_movable?
    active && open?
  end
  #--------------------------------------------------------------------------
  # * Activate Window
  #--------------------------------------------------------------------------
  def activate
    super
    select(0)
    @map_paused = SceneManager.tactic_enabled?
    SceneManager.start_tactic
  end
  #--------------------------------------------------------------------------
  # * Deactivate Window
  #--------------------------------------------------------------------------
  def deactivate
    @confirm_status = nil
    super
  end
  #--------------------------------------------------------------------------
  # * Call Handler
  #--------------------------------------------------------------------------
  def call_handler(symbol)
    @confirm_status = super(symbol)
  end
  #--------------------------------------------------------------------------
  # * Deactivate overlay window
  #--------------------------------------------------------------------------
  def close_overlay(continue = false)
    super(continue)
    if $on_exit
      $on_exit = false
      SceneManager.process_tactic(@map_paused)
    end
  end
  #--------------------------------------------------------------------------
  # * refresh
  #--------------------------------------------------------------------------
  def refresh
    super
    draw_split_line
    draw_all_items
  end
  #--------------------------------------------------------------------------
  # * Create Command List
  #--------------------------------------------------------------------------
  def make_command_list
    add_command("Yes", :continue)
    add_command("NO" , :block)
  end
  #--------------------------------------------------------------------------
  # * Assign Mehtod to command
  #--------------------------------------------------------------------------
  def assign_handler
    set_handler(:continue, method(:continue_action) )
    set_handler(:block,    method(:block_action) )
    set_handler(:ok,       method(:continue_action) )
    set_handler(:cancel,   method(:block_action) )
  end
  #--------------------------------------------------------------------------
  def get_text_y(rect, tsize)
    draw_height = contents.height - item_height - 12
    return [(draw_height - line_height * (tsize + 1)) / 2, 0].max
  end
  #--------------------------------------------------------------------------
  # * Item align center
  #--------------------------------------------------------------------------
  def central_item_rect(index)
    rect = super(index)
    rect.y = contents_height - item_height - 12
    rect
  end
  #--------------------------------------------------------------------------
  # * Draw Split Line
  #--------------------------------------------------------------------------
  def draw_split_line
    x1 = 24
    y  = contents_height - item_height - 24
    x2 = contents_width - 24
    contents.draw_line(x1,y,x2,y, DND::COLOR::White)
  end
  #--------------------------------------------------------------------------
  # * Return action flag
  #--------------------------------------------------------------------------
  def continue_action; close_overlay(true); end
  def block_action;    return false; end
  
end

#==============================================================================
# ** ForeGround_Loading
#------------------------------------------------------------------------------
#   Display loading status 
#==============================================================================
class ForeGround_Loading
  attr_accessor :opacity
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(info = nil, animate_sprite = true, configs = {})
    @opacity  = 0
    @image    = info ? info.image : nil
    @title    = info ? info.name  : nil
    @subtitle = configs[:subtitle]
    create_viewport
    create_background
    create_loading_sprite
    create_text_sprite
    create_title_sprite
    create_subtitle_sprite
    @enable_sprite = animate_sprite
    @timer  = 0
    @goal   = 0
    @loaded = 0
    @phase  = ''
    @need_loaded = 0
    @src_rect = Rect.new(0, 0, 200, 200)
    @index = 0
  end
  #--------------------------------------------------------------------------
  # * Get Bitmap Width
  #--------------------------------------------------------------------------
  def bitmap_width
    return 200
  end
  #--------------------------------------------------------------------------
  # * Get Bitmap Height
  #--------------------------------------------------------------------------
  def bitmap_height
    return 200
  end
  #--------------------------------------------------------------------------
  # * Sprite change frequency
  #--------------------------------------------------------------------------
  def frequency
    return 4
  end
  #--------------------------------------------------------------------------
  def text_width(text, text_width = Font.default_size)
    return 1 if !text
    return [[(text.size * text_width / 2), 1].max, Graphics.width - 24].min
  end
  #--------------------------------------------------------------------------
  # *) Opacity
  #--------------------------------------------------------------------------
  def opacity=(value)
    @opacity = value
    @background.opacity   = value
    @sprite.opacity       = value if @sprite
    @text_sprite.opacity  = value
    @title_sprite.opacity = value if @title_sprite
  end
  #--------------------------------------------------------------------------
  # * Create Background
  #--------------------------------------------------------------------------
  def create_background
    @background = Plane.new
    if @image
      @background.bitmap = Cache.background(@image)
    else
      @background.bitmap = Cache.background("blank_black")
    end
    @background.z = PONY::SpriteDepth::Table[:foreground_ov]
  end
  #--------------------------------------------------------------------------
  # * Create Viewport
  #--------------------------------------------------------------------------
  def create_viewport
    @viewport = Viewport.new
    @viewport.z = PONY::SpriteDepth::Table[:foreground_ov] + 1
  end
  #--------------------------------------------------------------------------
  # * Create Loading Sprites
  #--------------------------------------------------------------------------
  def create_loading_sprite
    @sprite = Sprite.new(@viewport)
    @sprite.bitmap = get_load_sprite
    @sprite.x = Graphics.center_width(bitmap_width)
    @sprite.y = Graphics.center_height(bitmap_height * 1.3)
    @sprite.visible = false
  end
  #--------------------------------------------------------------------------
  # * Create Text Sprites
  #--------------------------------------------------------------------------
  def create_text_sprite
    bw = bitmap_width * 1.5
    @text_sprite = Sprite.new(@viewport)
    @text_sprite.bitmap = Bitmap.new(bw, Font.default_size)
    @text_sprite.x = Graphics.center_width(bw)
    @text_sprite.y = @sprite.y + bitmap_height
    @text_rect = Rect.new( 0, 0, bw, Font.default_size)
  end
  #--------------------------------------------------------------------------
  # * Create Title Text Sprites
  #--------------------------------------------------------------------------
  def create_title_sprite
    return unless @title
    fs = 48 # Font size for title
    tw = text_width(@title, fs)
    @title_sprite = Sprite.new(@viewport)
    @title_sprite.bitmap = Bitmap.new(tw, fs)
    @title_sprite.x = Graphics.center_width(tw)
    @title_sprite.y = Graphics.height / 10
    @title_sprite.bitmap.font.size = fs
    rect = Rect.new(0, 0, tw, fs)
    @title_sprite.bitmap.draw_text(rect, @title, 1)
  end
  #--------------------------------------------------------------------------
  def create_subtitle_sprite
    return unless @subtitle
    fs = 24
    tw = text_width(@subtitle, fs)
    texts = FileManager.textwrap(@subtitle, tw)
    lines = texts.size
    
    @subtitle_sprite = Sprite.new(@viewport)
    @subtitle_sprite.bitmap = Bitmap.new(tw, fs * lines)
    @subtitle_sprite.x = Graphics.center_width(tw)
    @subtitle_sprite.y = Graphics.height / 6
    @subtitle_sprite.bitmap.font.size = fs
    
    rect = Rect.new(0, 0, tw, fs)
    texts.each do |text|
      @subtitle_sprite.bitmap.draw_text(rect, text, 1)
      rect.y += fs
    end
  end
  #--------------------------------------------------------------------------
  def get_load_sprite
    filename = "$twilight_gallop_left"
    
    return Cache.character(filename)
  end  
  #--------------------------------------------------------------------------
  # * Frame update
  #--------------------------------------------------------------------------
  def update(loaded = 1)
    return if GameManager.skip_loading?
    @timer  += 1
    @timer   = 0 if @timer == 120
    @loaded += loaded
    update_sprite
    update_text
  end
  #--------------------------------------------------------------------------
  # * Update Sprite
  #--------------------------------------------------------------------------
  def update_sprite
    return unless @sprite
    @sprite.visible = @enable_sprite
    @sprite.update
    @index += 1
    @index  = 0 if @index == 12 * frequency
    sx = (@index / frequency % 3) * bitmap_width
    sy = (@index / frequency / 3) * bitmap_height
    @sprite.src_rect.set(sx, sy, bitmap_width, bitmap_height)
  end
  #--------------------------------------------------------------------------
  # * Update Sprite
  #--------------------------------------------------------------------------
  def update_text
    @text_sprite.bitmap.clear_rect(@text_rect)
    draw_info_text
  end
  #--------------------------------------------------------------------------
  def loading_info
    re = sprintf("%s%s", @phase ? @phase : 'Loading', '.' * (@timer / 30))
    re += sprintf(" (%d)%", [(@loaded * 100 / @need_loaded).to_i, 100].min) if @need_loaded > 0
    re
  end
  #--------------------------------------------------------------------------
  def set_loading_phase(phase, total = 0)
    @phase = phase
    @need_loaded = total
    @loaded = 0
  end
  #--------------------------------------------------------------------------
  # * Draw Texts
  #--------------------------------------------------------------------------
  def draw_info_text
    cy = @sprite.y + bitmap_height + Font.default_size
    @text_sprite.bitmap.draw_text(@text_rect, loading_info, 1)
  end
  #--------------------------------------------------------------------------
  # * Terminate
  #--------------------------------------------------------------------------
  def terminate
    @viewport.dispose
    @background.dispose
    @text_sprite.dispose
    @sprite.dispose          if @sprite
    @title_sprite.dispose    if @title_sprite
    @subtitle_sprite.dispose if @subtitle_sprite
  end
  #--------------------------------------------------------------------------
  # * Loading?
  #--------------------------------------------------------------------------
  def loading?
    return true if @need_loaded == -1
    return @loaded <= @need_loaded + 10
  end
  
end

#==============================================================================
# ** Window_Input
#------------------------------------------------------------------------------
#   Allow user to input texts via Windows build-in mehtod
#==============================================================================
class Window_Input < Window_Base
  include PONY::API
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  WS_POPUP        = 0x80000000
  WS_CHILD        = 0x40000000
  WS_VISIBLE      = 0x10000000
  WS_DISABLED     = 0x08000000
  ES_AUTOHSCROLL  = 0x00000080
  ES_NUMBER       = 0x00002000
  ES_MULTILINE    = 0x00000004
  EM_SETSEL       = 0xb1
  EM_GETSEL       = 0xb0
  
  AutoScroll_ChatLimit = 256
  #--------------------------------------------------------------------------
  Number_Full = "０１２３４５６７８９"
  Number_Half = "0123456789"
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :hwnd
  attr_accessor :index
  attr_accessor :focus
  #--------------------------------------------------------------------------
  def get_windowstyle(args)
    ws  = WS_CHILD
    #ws |= ES_MULTILINE
    ws |= WS_POPUP        if args[:popup]
    ws |= WS_DISABLED     if args[:visible]
    ws |= ES_NUMBER       if args[:number]
    ws |= ES_AUTOHSCROLL  if args[:autoscroll]
    return ws
  end
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x = 0, y = 0, width = Graphics.width - 40, attributes = {})
    #-----------------------------------------------------------------------
    # > init vars
    @window_width    = width
    @viewport        = SceneManager.superviewport
    @char_limit      = attributes[:autoscroll] ? AutoScroll_ChatLimit : @display_width / item_width
    @char_limit      = attributes[:limit] if attributes[:limit]
    @last_str        = ""
    @last_len        = 0
    @last_index      = 0
    @last_select     = 0
    @index           = 0
    @select_start    = 0
    @select_end      = 0
    @select_ori      = 0
    @enter_cnt       = 0
    @display_bot     = 0
    @display_top     = 0
    @wchar_num       = 0
    @index_width     = []
    @keyboard_action = []
    @arrow_sprites   = []
    @focus           = true
    @number_only     = attributes[:number]
    @entered         = false
    @need_refresh    = true
    @display_bot_index = 0
    @display_top_index = 0
    #-----------------------------------------------------------------------
    super(x, y, width, window_height)
    self.windowskin = Cache.system(WindowSkin::InputBox)
    wstyle  = get_windowstyle(attributes)
    @hwnd = CreateWindowEx.call(1, "Edit", "", wstyle,
                                x, y, width, height, Hwnd, 0, 
                                GetModuleHandle.call(nil), 0)
    $input_hwnd = @hwnd
    ObjectSpace.define_finalizer(self, proc{on_object_destroy})
    #-----------------------------------------------------------------------
    self.ox = 0
    self.z  = @viewport.z
    @display_width = contents.width - spacing * 2
    #-----------------------------------------------------------------------
    create_sprites
    create_background if attributes[:dim_background]
    draw_title(attributes[:title])
    SetFocus.call(@hwnd) if focus
  end
  #--------------------------------------------------------------------------
  def on_object_destroy
    $input_hwnd = nil
  end
  #--------------------------------------------------------------------------
  def spacing
    return 4
  end
  #--------------------------------------------------------------------------
  def window_height
    line_height * 2
  end
  #--------------------------------------------------------------------------
  def window_width
    @window_width
  end
  #--------------------------------------------------------------------------
  def item_width
    Font.default_size / 2
  end
  #--------------------------------------------------------------------------
  def create_sprites
    self.arrows_visible = false
    create_second_viewport
    create_cursor(x, y)
    create_arrows
    create_text_sprite
  end
  #--------------------------------------------------------------------------
  def create_second_viewport
    @viewport2   = Viewport.new
    @viewport2.z = @viewport.z + PONY::SpriteDepth.layers(1)
  end
  #--------------------------------------------------------------------------
  def create_background
    @background_sprite = Sprite.new(@viewport)
    @background_sprite.bitmap = Bitmap.new(Graphics.width, Graphics.height)
    @background_sprite.opacity = 128
    @background_sprite.z = self.z - 1
    color = Color.new(16,16,16)
    @background_sprite.bitmap.fill_rect(0, 0, Graphics.width, Graphics.height, color)
  end
  #--------------------------------------------------------------------------
  def create_text_sprite
    @text_sprite = Sprite.new(@viewport2)
    @text_sprite.bitmap = Bitmap.new(Graphics.width, line_height * 2)
    @text_sprite.x = 0
    @text_sprite.y = self.y - line_height
    @text_sprite.z = self.z + 1
  end
  #--------------------------------------------------------------------------
  # * Create Cursor Sprite
  #--------------------------------------------------------------------------
  def create_cursor(cx, cy)
    @cursor = Sprite.new(@viewport2)
    
    @cursor.bitmap = Bitmap.new(4, item_width * 2)
    @cursor.bitmap.fill_rect(0, 0, 1, item_width * 2, DND::COLOR::White)
    @cursor.x, @cursor.y = cx, cy + spacing * 3
  end
  #--------------------------------------------------------------------------
  # * Create hint arrow for existance of other undisplayed text
  #--------------------------------------------------------------------------
  def create_arrows
    bx, by = 80, 16
    bw, bh = 8, 16
    2.times do |i|
      sprite = Sprite.new(@viewport2)
      sprite.bitmap = Bitmap.new(bw, bh)
      sx     = (i == 0 ? bx : (bx + bw + bh)) # 0 for left, 1 for right arrow
      rect   = Rect.new(sx, by + bw, bw, bh)
      sprite.bitmap.blt(0, 0, self.windowskin, rect)
      sprite.y = self.y + (window_height - bh) - spacing * 4 
      sprite.x = i == 0 ? self.x + 2 : self.x + window_width - bw
      @arrow_sprites.push(sprite.hide)
    end
  end
  #--------------------------------------------------------------------------
  def draw_title(title)
    return unless title
    cw = [text_width_for_rect(title), Graphics.width].min
    cx = [[(Graphics.width - cw) / 2, 0].max, Graphics.width].min
    rect = Rect.new(cx, 0, cw, line_height)
    @text_sprite.bitmap.draw_text(rect, title)
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    return unless update_focus
    super
    update_keyboard
    sync_window
    return if disposed?
    return if @index > @char_limit || (@index_width.size != @strlen+2)
    update_cursor
    update_selection
  end
  #--------------------------------------------------------------------------
  def update_focus
    focus_window if active? || !@focus && Mouse.click?(1) &&  Mouse.collide_sprite?(self)
    wfocus = (GetFocus.call(0) == @hwnd) if @focus
    kill_focus   if !wfocus || (@focus && Mouse.click?(1) && !Mouse.collide_sprite?(self))
    return @focus
  end
  #--------------------------------------------------------------------------
  # * Free
  #--------------------------------------------------------------------------
  def dispose
    @background_sprite.dispose if @background_sprite
    @text_sprite.dispose
    @cursor.dispose
    @arrow_sprites.each {|sprite| sprite.dispose}
    @viewport2.dispose
    super
  end
  #--------------------------------------------------------------------------
  # * Synchorize index with Win32 window
  #--------------------------------------------------------------------------
  def sync_window
    buffer = get_window_text
    @lpstr = EasyConv::s2u(buffer)
    @lpstr_asc = EasyConv::s2u(buffer)
    @lpstr = @lpstr.force_encoding($default_encoding)
    @strlen = @lpstr.length
    return process_limited if @strlen > @char_limit + 1
    terminated = process_ok if @last_len == @strlen
    return if @last_str == @lpstr || terminated
    @need_refresh = true
    clear_awaits
    update_contents
  end
  #--------------------------------------------------------------------------
  def get_window_text
    @last_str = (@lpstr || '')
    @strlen = (GetWindowTextLength.call(@hwnd) + 1) | 0
    buffer  = '\0' * @strlen
    GetWindowText.call(@hwnd, buffer, @strlen)
    return buffer
  end
  #--------------------------------------------------------------------------
  def update_contents
    calc_index_width
    update_index
    refresh
  end
  #--------------------------------------------------------------------------
  def update_index
    @index += @strlen - @last_len
    @last_len = @strlen
    @last_str = @lpstr
  end
  #--------------------------------------------------------------------------
  # * Set Win32 edit window text to in-game text if max out numbercap
  #--------------------------------------------------------------------------
  def process_limited
    @lpstr  = @lpstr[0...@char_limit]
    @strlen = @char_limit
    @index  = @char_limit
    SetWindowText.call(@hwnd, EasyConv::u2s(@lpstr))
    SendMessage.call(@hwnd, EM_SETSEL, @strlen, @strlen)
  end
  #--------------------------------------------------------------------------
  # * Refresh 
  #--------------------------------------------------------------------------
  def refresh
    return unless @need_refresh
    @need_refresh = false
    contents.clear
    rect = Rect.new(spacing / 2, 0, @index_width[@strlen], line_height)
    rect.width += contents.font.size
    draw_text(rect, @lpstr[@display_bot_index..@display_top_index])
  end
  #--------------------------------------------------------------------------
  # * DP the texts width for faster query
  #--------------------------------------------------------------------------
  def calc_index_width
    @last_index_width = (@index_width || [0])
    @index_width = [0]
    text = ""
    for i in 0..@strlen
      text += (@lpstr[i] || '')
      if @last_str[i] == @lpstr[i]
        @index_width[i+1] = @last_index_width[i+1]
      else
        @index_width[i+1] = self.contents.text_size(text).width
      end
    end 
  end
  #--------------------------------------------------------------------------
  # * Gets the texts width in range
  #--------------------------------------------------------------------------
  def index_width(start, rear)
    rear, start = start,rear if start > rear
    rear = @strlen - 1 if rear > @strlen - 1
    return @index_width[rear] - @index_width[start]
  end
  #--------------------------------------------------------------------------
  # * Update Cursor
  #--------------------------------------------------------------------------
  def update_cursor
    @cursor.visible = (Time.now.sec & 1).to_bool
    unpack_message(SendMessage.call(@hwnd, EM_GETSEL, 0, 0))
    
    clear_awaits if @last_index != @index
    @cursor.show if @last_index != @index
    update_cursor_position
    @last_index = @index
    refresh
  end
  #--------------------------------------------------------------------------
  def update_cursor_position
    ensure_cursor_visible
    update_padding
    offset_x = index_width(@display_bot_index, @index)
    @cursor.x = self.x + spacing * 2 + offset_x + 2
  end
  #--------------------------------------------------------------------------
  def get_display_selection_bot
    offset = @display_width
    cur    = @index
    while offset > 0 && cur > 0
      width   = @index_width[cur] - @index_width[cur - 1]
      offset -= width
      return cur + 1 if offset < 0
      cur    -= 1
    end
    return cur
  end
  #--------------------------------------------------------------------------
  def get_display_selection_top
    offset = @display_width
    cur    = @index
    while offset > 0 && cur < @strlen
      width   = @index_width[cur + 1] - @index_width[cur]
      offset -= width
      cur    += 1
    end
    return cur
  end
  #--------------------------------------------------------------------------
  # * Ensure cursor index is visible and auto sctoll
  #--------------------------------------------------------------------------
  def ensure_cursor_visible
    next_cursor_x = @index_width[@index]
    return if next_cursor_x.nil?
    
    if next_cursor_x > @display_top
      @display_bot = next_cursor_x - @display_width
      @display_bot_index = get_display_selection_bot
      @display_top_index = @index
    elsif next_cursor_x < @display_bot
      @display_bot = next_cursor_x
      @display_bot_index = @index
      @display_top_index = get_display_selection_top
    else
      bt_width = index_width(@display_bot_index, @display_top_index)
      bs_width = index_width(@display_bot_index, @strlen)
      @display_bot_index = [@display_bot_index, 0].max
      @display_top_index = [@display_top_index, @index].max
      if bt_width <= bs_width && bs_width < @display_width
        prev_top_index = @display_top_index
        @display_top_index = [@display_top_index, @strlen].max
        @need_refresh ||= @display_top_index != prev_top_index
      end
    end
    @display_top = @display_bot + @display_width
  end
  #--------------------------------------------------------------------------
  def update_padding
    return unless @display_width && @index_width[@strlen]
    
    @display_bot > 0 ? @arrow_sprites[0].show : @arrow_sprites[0].hide
    @display_top < @index_width[@strlen] ? @arrow_sprites[1].show : @arrow_sprites[1].hide
  end
  #--------------------------------------------------------------------------
  def unpack_message(msg)
    bt = msg.to_s(2)
    @select_start = bt[[bt.length - 16, 0].max...bt.length].to_i(2)
    @select_end   = msg >> 16
    if @select_start == @select_end
      @need_refresh = true if @index != @select_end
      @index      = @select_end
      @select_ori = @select_end if Input.press?(:kSHIFT)
    else
      @need_refresh = true if @index != @select_end || @index != @select_end
      @index = @select_start < @select_ori ? @select_start : @select_end
    end
  end
  #--------------------------------------------------------------------------
  # * Return text
  #--------------------------------------------------------------------------
  def text
    @lpstr
  end
  #--------------------------------------------------------------------------
  def update_keyboard
    return if Input.trigger?(:kENTER) || Input.trigger?(:kESC)
    return unless Keyboard.press_any_key || Input.trigger?(:kDEL) || Input.trigger?(:kBACKSPACE)
    @keyboard_action.push(true)
    clear_awaits if Input.trigger?(:kDEL) || Input.trigger?(:kBACKSPACE)
    clear_awaits if @last_select != hash_select
    @last_select = hash_select
  end
  #--------------------------------------------------------------------------
  def update_selection
    return cursor_rect.empty if @select_start == @select_end
    if @select_end > @select_start && @select_start < @display_bot_index
      width = [index_width(@select_end, @display_bot_index) + 2, contents.width].min
    else
      width = [index_width(@select_end, @select_start) + 2, contents.width].min
    end
    
    if @select_start > @display_bot_index
      cx  = index_width(@select_start, @display_bot_index)
    else
      cx  = 0
    end
    cursor_rect.set(cx, 0, width, 24)
  end
  #--------------------------------------------------------------------------
  def focus_window
    activate
    SetFocus.call(@hwnd)
    @focus = true
  end
  #--------------------------------------------------------------------------
  def kill_focus
    deactivate
    SetFocus.call(Hwnd)
    @focus = false
    @cursor.visible = false
  end
  #--------------------------------------------------------------------------
  def clear_awaits
    @keyboard_action.clear
    @enter_cnt = 0
  end
  #--------------------------------------------------------------------------
  def hash_select
    @select_start * 1000 + @select_end
  end
  #--------------------------------------------------------------------------
  def process_ok
    @enter_cnt += 1 if Input.trigger?(:kENTER) || Input.trigger?(:kESC)
    return if !@keyboard_action.empty? && @enter_cnt < 3
    if Input.trigger?(:kENTER)
      return process_terminate
    elsif Input.trigger?(:kESC)
      @lpstr = ""
      return process_terminate
    end
    return false
  end
  #--------------------------------------------------------------------------
  def replace_chars
    @lpstr = @lpstr.tr(Number_Full, Number_Half)
    # @lpstr_asc.gsub!(/[^0123456789]/, '') if @number_only
    # @lpstr = @lpstr_asc.force_encoding($default_encoding)
  end
  #--------------------------------------------------------------------------
  def process_terminate
    replace_chars
    kill_focus
    dispose
    debug_print "String received from win32 window: ", @lpstr
    @enter_cnt = 0
    SceneManager.send_input(@lpstr)
    SceneManager.scene.heatup_button(5)
    return true
  end
end

#==============================================================================
# ** Window_TacticStatus
#------------------------------------------------------------------------------
#   Window display the selected battler's status on upper-right conrner in 
# tactic mode.
#==============================================================================
class Window_TacticStatus < Window_Base
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  BarLayout = "HPEP_Layout"
  HP_Meter  = "HP_Meter"
  EP_Meter  = "EP_Meter"
  HP_Number = "HP_Number"
  EP_Number = "EP_Number"
  HPEP_Rect = Rect.new(0,0,160,60)
  BarRect   = Rect.new(0,0,128,8)
  DigitRect = Rect.new(0,0,18,21)
  HPBarRect = Rect.new(27,6,128,8)
  EPBarRect = Rect.new(27,44,128,8)
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :battler
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x = Graphics.width - window_width, y = 0)
    super(x, y, window_width, window_height)
    @battler = nil
    create_layout
    hide
  end
  #--------------------------------------------------------------------------
  def window_width
    return 280
  end
  #--------------------------------------------------------------------------
  def window_height
    return 160
  end
  #--------------------------------------------------------------------------
  def contents_width
    width - standard_padding * 2
  end
  #--------------------------------------------------------------------------
  def contents_height
    height - standard_padding * 2
  end
  #--------------------------------------------------------------------------
  def update
    super
    return if @battler.nil?
    update_hp_effect
    update_mp_effect
  end
  #--------------------------------------------------------------------------
  # * Set current battler
  #--------------------------------------------------------------------------
  def setup_battler(battler)
    return if @battler == battler
    name = battler.nil? ? "nil" : battler.name
    @battler = battler
    refresh
  end
  #--------------------------------------------------------------------------
  def spacing
    return 8
  end
  #--------------------------------------------------------------------------
  # * Refresh contents
  #--------------------------------------------------------------------------
  def refresh
    clear_contents
    if BattleManager.valid_battler?(@battler)
      show
    else
      hide; return;
    end
    draw_battler_face
    draw_battler_name
    draw_battler_hp
    draw_battler_mp
    draw_battler_states
  end
  #--------------------------------------------------------------------------
  def create_layout
    @layout = Sprite.new
    @layout.bitmap = Cache.UI(BarLayout)
    @layout.x, @layout.y = self.x + spacing, self.y + line_height * 2 + spacing
    @layout.z = self.z + 1
    @fill_sprite = Sprite.new
    @fill_sprite.bitmap = Bitmap.new(@layout.width, @layout.height)
    @fill_sprite.x, @fill_sprite.y = @layout.x, @layout.y
    @fill_sprite.z = @layout.z + 1
    @text_sprite = Sprite.new
    @text_sprite.bitmap = Bitmap.new(@layout.width, @layout.height + line_height)
    @text_sprite.x, @text_sprite.y = @layout.x, @layout.y - line_height
    @text_sprite.z = @fill_sprite.z + 1
  end
  #--------------------------------------------------------------------------
  def draw_battler_face
    face_name  = @battler.face_name
    face_index = @battler.face_index
    x = window_width - 120 # 96 = face src rect width
    y = 0
    draw_face(face_name, face_index, x, y) if face_name && face_index
  end
  #--------------------------------------------------------------------------
  def draw_battler_name
    name = @battler.name rescue ""
    rect = Rect.new(8, 0, width, line_height)
    draw_text(rect, name, 0)
  end
  #--------------------------------------------------------------------------
  def draw_battler_hp
    mhp = battler.mhp == 0 ? 1 : battler.mhp
    @hp_cw = (battler.hp.to_f * HPBarRect.width / mhp).ceil
    @front_hp_rect  = BarRect.dup;
    @rear_hp_rect   = BarRect.dup;
    @rear_hp_rect.width = 0
    draw_hp_value
  end
  #--------------------------------------------------------------------------
  def draw_battler_mp
    mmp = battler.mmp == 0 ? 1 : battler.mmp
    @mp_cw = (battler.mp.to_f * EPBarRect.width / mmp).ceil
    @front_mp_rect  = BarRect.dup;
    @rear_mp_rect   = BarRect.dup;
    @rear_mp_rect.width = 0
    draw_mp_value
  end
    #--------------------------------------------------------------------------
  def draw_hp_value
    drect = HPBarRect.dup
    drect.y -= 2
    drect.height = line_height
    info = sprintf("%d/%d", battler.hp, battler.mhp)
    @text_sprite.bitmap.draw_text(drect, info, 2)
  end
    #--------------------------------------------------------------------------
  def draw_mp_value
    drect = EPBarRect.dup
    drect.height = line_height
    info = sprintf("%d/%d", battler.mp, battler.mmp)
    @text_sprite.bitmap.draw_text(drect, info, 2)
  end
  #--------------------------------------------------------------------------
  def draw_battler_states
    dx = spacing
    dy = contents_height - 32
    icons = @battler.state_icons
    reaction = PONY::StateID[:aggressive_level][@battler.aggressive_level]
    icons.unshift($data_states[reaction].icon_index)
    icons.each do |index|
      draw_icon(index, dx, dy)
      dx += 24
    end
  end
  #--------------------------------------------------------------------------
  def update_hp_effect
    return unless @hp_cw
    @fill_sprite.bitmap.clear_rect(HPBarRect)
    return if @hp_cw == 0
    bitmap = Cache.UI(HP_Meter)
    dx = HPBarRect.x; dy = HPBarRect.y;
    @rear_hp_rect.width  = (@rear_hp_rect.width + 1) % BarRect.width
    @front_hp_rect.width = BarRect.width - @rear_hp_rect.width
    @rear_hp_rect.x      = @front_hp_rect.width
    
    @fill_sprite.bitmap.blt(dx + @rear_hp_rect.width, dy, bitmap, @front_hp_rect)
    @fill_sprite.bitmap.blt(dx, dy, bitmap, @rear_hp_rect)
    crect = HPBarRect.dup
    crect.width -= @hp_cw; crect.x = dx + @hp_cw;
    @fill_sprite.bitmap.clear_rect(crect)
  end
  #--------------------------------------------------------------------------
  def update_mp_effect
    return unless @mp_cw
    @fill_sprite.bitmap.clear_rect(EPBarRect)
    return if @mp_cw == 0
    bitmap = Cache.UI(EP_Meter)
    dx = EPBarRect.x; dy = EPBarRect.y;
    @rear_mp_rect.width  = (@rear_mp_rect.width + 1) % BarRect.width
    @front_mp_rect.width = BarRect.width - @rear_mp_rect.width
    @rear_mp_rect.x      = @front_mp_rect.width
    
    @fill_sprite.bitmap.blt(dx + @rear_mp_rect.width, dy, bitmap, @front_mp_rect)
    @fill_sprite.bitmap.blt(dx, dy, bitmap, @rear_mp_rect)
    crect = EPBarRect.dup
    crect.width -= @mp_cw; crect.x = dx + @mp_cw;
    @fill_sprite.bitmap.clear_rect(crect)
  end
  #--------------------------------------------------------------------------
  def clear_contents
    contents.clear
    @text_sprite.bitmap.clear
  end
  #--------------------------------------------------------------------------
  def show
    @layout.show
    @fill_sprite.show
    @text_sprite.show
    super
  end
  #--------------------------------------------------------------------------
  def hide
    @layout.hide
    @fill_sprite.hide
    @text_sprite.hide
    super
  end
  #--------------------------------------------------------------------------
  def dispose
    @layout.dispose
    @fill_sprite.dispose
    @text_sprite.dispose
    super
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_TacticCommand
#------------------------------------------------------------------------------
#   After a battler is selected in tactic mode, this window will display the 
# commands for controlable battler.
#==============================================================================
class Window_TacticCommand < Window_Command
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  Command_Move        = Vocab::Tactic::CmdMove
  Command_Follow      = Vocab::Tactic::CmdFollow
  Command_Guard       = Vocab::Tactic::CmdGuard
  Command_Patrol      = Vocab::Tactic::CmdPatrol
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :battler
  attr_reader   :phase
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y)
    x = Graphics.width - window_width
    super(x,y)
    @battler = nil
    @last_index = 0
    hide
  end
  #--------------------------------------------------------------------------
  def update
    super
  end
  #--------------------------------------------------------------------------
  # * Create Command List
  #--------------------------------------------------------------------------
  def make_command_list
    add_command(Command_Move, :move, tactic_command_enabled?, nil, Vocab::Tactic::DecMove)
    add_command(get_moving_name, :hold, tactic_command_enabled?, nil, Vocab::Tactic::DecMHing)
    add_command(get_reaction_name, :reaction, tactic_command_enabled?, nil, Vocab::Tactic::DecReaction)
    # unfinished
    add_command(Command_Follow, :follow, false, nil, Vocab::Tactic::DecFollow)
    # unfinished
    add_command(Command_Guard, :guard, false, nil, Vocab::Tactic::DecGuard)
    # unfinished
    add_command(Command_Patrol, :patrol, false, nil, Vocab::Tactic::DecPatrol)
  end
  #--------------------------------------------------------------------------
  def tactic_command_enabled?
    return false if @battler.nil? || @battler.dead?
    return false if @battler.is_a?(Game_Player)
    return false if @battler == $game_party.leader
    return true
  end
  #--------------------------------------------------------------------------
  def get_moving_name
    return Vocab::Tactic::CmdMHing    if !@battler || !@battler.movement_command
    return Vocab::Tactic::CmdHolding  if @battler.command_holding?
    return Vocab::Tactic::CmdMoving
  end
  #--------------------------------------------------------------------------
  # * Get current battler's aggressive level
  #--------------------------------------------------------------------------
  def get_reaction_name
    return "" unless @battler
    return "" unless @battler.aggressive_level
    return ":" + $data_states[PONY::StateID[:aggressive_level][@battler.aggressive_level]].name
  end
  #--------------------------------------------------------------------------
  def setup_battler(battler)
    @battler = battler
    refresh
    activate
    show
  end
  #--------------------------------------------------------------------------
  def fallback
    @battler     = nil
    @@last_index = 0
    hide
    deactivate
  end
  #--------------------------------------------------------------------------
  def call_handler(symbol)
    @last_index = index
    super(symbol)
  end
  #--------------------------------------------------------------------------
  def show
    super
    select(@last_index)
  end
  #--------------------------------------------------------------------------
  def hide
    unselect
    super
  end
  
end

#==============================================================================
# ** Window_TacticList
#------------------------------------------------------------------------------
#  This window lists the battler's current tactics
#==============================================================================
# tag: command (Tactic List
class Window_TacticList < Window_Selectable
  include Vocab::TacticConfig
  #--------------------------------------------------------------------------
  attr_accessor :data
  attr_reader   :actor
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y)
    super(x, y, window_width - x, window_height - y)
    @actor = nil
    @data  = []
  end
  #--------------------------------------------------------------------------
  def window_width
    return Graphics.width
  end
  #--------------------------------------------------------------------------
  def window_height
    return Graphics.height
  end
  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    detect_jump_circle
    make_item_list
    create_contents
    draw_split_line
    draw_all_items
  end
  #--------------------------------------------------------------------------
  # * Get Number of Items
  #--------------------------------------------------------------------------
  def item_max
    return @data ? @data.size : 1
  end
  #--------------------------------------------------------------------------
  def actor=(_actor)
    @actor = _actor
    @data  = @actor.tactic_commands.dup
    refresh
  end
  #--------------------------------------------------------------------------
  # * Create Item List
  #--------------------------------------------------------------------------
  def make_item_list
    return if @actor.nil?
    @data = @actor.tactic_commands.dup
    push_add_command if @data.size < @actor.command_limit
  end
  #--------------------------------------------------------------------------
  def push_add_command
    command_add = Game_TacticCommand.new(@actor)
    command_add.action = Game_Action.new(@actor, nil, :add_command)
    command_add.category = :new
    command_add.index_id = @data.size
    @data << command_add
  end
  #--------------------------------------------------------------------------
  def draw_split_line(rect = nil)
    cx    = self.width / 2
    color = DND::COLOR::White
    if rect
      contents.draw_line(cx, rect.y, cx, rect.y + rect.height, color)
    else
      cy = 8
      fy = self.height - 8
      exy = item_height
      list_num = (self.height / exy)
      extra_num = [item_max - list_num, 0].max
      contents.draw_line(cx, cy, cx, fy + exy * extra_num, color)
    end
  end
  #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    
    if item
      item.index_id = index
      rect = item_rect(index)
      contents.clear_rect(rect)
      draw_split_line(rect)
      
      if !item.valid?
        contents.font.color.set(DND::COLOR::Red)
      elsif item.disabled?
        contents.font.color.set(DND::COLOR::Black)
      else
        contents.font.color.set(DND::COLOR::Green)
      end
      draw_order(index, rect)
      contents.font.color.set(DND::COLOR::White)
      rect.width /= 2
      rect.width -= 4
      draw_command(item, rect)
    end
  end
  #--------------------------------------------------------------------------
  # * Get Item
  #--------------------------------------------------------------------------
  def item
    @data && index >= 0 ? @data[index] : nil
  end
  #--------------------------------------------------------------------------
  # * Restore Previous Selection Position
  #--------------------------------------------------------------------------
  def select_last
    select(0)
  end
  #--------------------------------------------------------------------------
  def draw_order(index, rect)
    return if index >= @actor.tactic_commands.size
    text = sprintf("[%02d]", index)
    rect.width = 32
    draw_text(rect, text)
    rect.x = 32
    rect.width = item_width
  end
  #--------------------------------------------------------------------------
  # * Draw command
  #--------------------------------------------------------------------------
  def draw_command(command, rect)
    cx = rect.x
    cy = rect.y
    case command.category
    when :targeting
      contents.font.color.set(DND::COLOR::Orange)
      draw_condition(:targeting, rect, command)
      rect.x = self.width / 2 + 4
      draw_action_item(rect, command)
    when :fighting
      draw_condition(:fighting, rect, command)
      rect.x = self.width / 2 + 4
      draw_action_item(rect, command)
    when :self
      contents.font.color.set(DND::COLOR::Green)
      draw_condition(:self, rect, command)
      rect.x = self.width / 2 + 4
      draw_action_item(rect, command)
    when :new
      draw_icon(PONY::IconID[:plus], cx, cy)
      rect.x += 26
      contents.font.color.set(DND::COLOR::Yellow)
      name = Name_Table[:new_command]
      draw_text(rect, name)
      draw_action_item(rect, command)
    end
    change_color(normal_color)
  end
  #--------------------------------------------------------------------------
  def draw_condition(symbol, rect, command)
    icon_id = 0
    if command.condition_symbol == :has_state && command.args.first.to_bool
      icon_id = $data_states[command.args.first].icon_index
    elsif command.args.first.is_a?(Game_Actor)
      icon_id = command.args.first.icon_index
    else
      icon_id = PONY::IconID[symbol]
    end
    draw_icon(icon_id, rect.x, rect.y)
    rect.x += 26
    name = sprintf("%s %s",Name_Table[symbol], Name_Table[command.condition_symbol])
    name = get_condition_args_name(command.condition_symbol, command.args, name) 
    if name.bytesize > 31
      temp = ""
      bsize = 0
      name.each_char do |ch|
        break if bsize > 30
        bsize += [ch.bytesize, 1.9].min
        temp += ch
      end
      name = temp + "..." unless temp.bytesize == name.bytesize
    end
    draw_text(rect, name)
  end
  #--------------------------------------------------------------------------
  def get_condition_args_name(symbol, args, text)
    return text + args.first.name if args.first.is_a?(RPG::BaseItem)
    return text + Vocab::TacticConfig::Name_Table[:player] if args.first == :player
    return text if ArgDec_Table[symbol].nil?
    
    case symbol
    when :has_state
      name = ""
      name = $data_states[args.first].name if args.first.to_bool
      return text + ' ' + sprintf(ArgDec_Table[:has_state], name)
    else
      info = ArgDec_Table[args.first] if args.first.is_a?(Symbol)
      info = Name_Table[args.first]   if info.nil?
      info = args.first               if info.nil?
      return text + ' ' + sprintf(ArgDec_Table[symbol], info)
    end
  end
  #--------------------------------------------------------------------------
  def draw_action_item(rect, command)
    action = command.action
    rect.x  = self.width / 2 + 4
    icon_id = action.get_icon_id
    draw_icon(icon_id, rect.x, rect.y) if icon_id > 0
    rect.x += 26
    name = action.get_item_name
    if action.item == :jump_to
      name += command.jump_command ? sprintf("%02d", command.jump_command.index_id) : " X"
    end
    draw_text(rect, name)
  end
  #--------------------------------------------------------------------------
  def apply_tactic_change
    return if @data.nil?
    @actor.tactic_commands = @data.select{|cmd| cmd.category && cmd.category != :new}
  end
  #--------------------------------------------------------------------------
  # * Handling Processing for OK and Cancel Etc.
  #--------------------------------------------------------------------------
  def process_handling
    super
    return unless open? && active
    process_dragging if Input.trigger?(:kSHIFT)
    toggle_enable    if Input.trigger?(:kCTRL)
  end
  #--------------------------------------------------------------------------
  def toggle_enable
    @data[index].enabled ^= true
    draw_item(index)
    Sound.play_ok
  end
  #--------------------------------------------------------------------------
  def process_dragging
    if @dragging
      call_handler(:on_dragging_cancel) if handle?(:on_dragging_cancel)
      Sound.play_cancel
      @dragging = false
      apply_tactic_change
      refresh
    elsif @data[index].category != :new
      call_handler(:on_dragging_ok) if handle?(:on_dragging_ok)
      Sound.play_ok
      @dragging = true
    else
      Sound.play_buzzer
    end
    heatup_button
  end
  #--------------------------------------------------------------------------
  # * Select Item
  #--------------------------------------------------------------------------
  def select(index)
    last_index = self.index
    new_index  = index
    super(index)
    return unless @dragging && new_index != last_index && new_index >= 0
    return if @data[new_index].category == :new || @data[last_index].category == :new
    swap_order(last_index, new_index)
  end
  #--------------------------------------------------------------------------
  # * Swap command priority/order
  #--------------------------------------------------------------------------
  def swap_order(last_index, new_index)
    @data[new_index], @data[last_index] = @data[last_index], @data[new_index]
    @data[new_index].index_id, @data[last_index].index_id = new_index, last_index
    draw_item(new_index)
    draw_item(last_index)
  end
  #--------------------------------------------------------------------------
  # * Processing When OK Button Is Pressed
  #--------------------------------------------------------------------------
  def process_ok
    return super unless @dragging
    process_dragging
  end
  #--------------------------------------------------------------------------
  # * Processing When Cancel Button Is Pressed
  #--------------------------------------------------------------------------
  def process_cancel
    return super unless @dragging
    process_dragging
  end
  #--------------------------------------------------------------------------
  # * Check the jump to command formed a looping circle
  #   Using Topological Sort algorithm
  #--------------------------------------------------------------------------
  def detect_jump_circle
    node = {}
    @data.each_with_index do |cmd, i|
      cmd.circled = false
      cmd.jump_command = nil unless @data.include?(cmd.jump_command)
      node[i] = cmd.jump_command.index_id if cmd.jump_command
    end
    
    while !node.empty?
      puts "#{node}"
      start  = node.keys.find{|k| !node.values.include?(k)}
      puts "delete #{start}"
      node.delete(start) if start
      break if start.nil?
    end
    
    debug_print("Circled command id: #{node.keys}")
    node.keys.each do |i|
      @data[i].circled = true
    end
    
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_TacticAction
#------------------------------------------------------------------------------
#  Displaying the action for tactic commands when selected
#==============================================================================
# tag: command (Tactic Action
class Window_TacticAction < Window_Command
  #--------------------------------------------------------------------------
  attr_accessor :command
  attr_accessor :actor
  attr_reader   :symbol
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x = 0, y = 0)
    super
    self.windowskin = Cache.system(WindowSkin::ItemAction)
    make_default_handler
    @actor    = nil
    @command  = nil
    deactivate
    unselect
    hide
  end
  #--------------------------------------------------------------------------
  def update
    super 
    if @item_window && !@ok_called
      @item_window.category = current_symbol
      @item_window.command  = @command
    end
  end
  #--------------------------------------------------------------------------
  # * Processing When OK Button Is Pressed
  #--------------------------------------------------------------------------
  def process_ok
    if current_item_enabled?
      Sound.play_ok 
      Input.update
      deactivate unless @symbol.nil?
      call_ok_handler
    else
      Sound.play_buzzer
    end
  end
  #--------------------------------------------------------------------------
  # * Processing When Cancel Button Is Pressed
  #--------------------------------------------------------------------------
  def process_cancel
    Sound.play_cancel
    Input.update
    deactivate if @symbol.nil?
    @symbol = nil
    call_cancel_handler
  end
  #--------------------------------------------------------------------------
  # * Create Command List
  #--------------------------------------------------------------------------
  def make_command_list
    if @symbol == :condition
      add_command(Vocab::Tactic::Targeting, :targeting)
      add_command(Vocab::Tactic::Fighting, :fighting)
      add_command(Vocab::Tactic::Self, :self)
    elsif @symbol == :action
      add_command(Vocab::Tactic::Item, :item)
      add_command(Vocab::Tactic::Skill, :skill)
      add_command(Vocab::Tactic::General, :general)
    else
      add_command(Vocab::Tactic::EdCondition, :call_condition)
      add_command(Vocab::Tactic::EdAction, :call_action)
      add_command(Vocab::Tactic::Delete, :call_delete)
    end
  end
  #--------------------------------------------------------------------------
  def make_default_handler
    set_handler(:call_condition, method(:on_condition_ok))
    set_handler(:call_action,    method(:on_action_ok))
  end
  #--------------------------------------------------------------------------
  def on_condition_ok
    @symbol = :condition
    refresh
  end
  #--------------------------------------------------------------------------
  def on_action_ok
    @symbol = :action
    refresh
  end
  #--------------------------------------------------------------------------
  def activate(command = nil, actor = nil)
    @command = command
    @actor   = actor
    @symbol  = nil
    @ok_called = false
    super()
    self.opacity = 255
    refresh
  end
  #--------------------------------------------------------------------------
  def deactivate
    super
    @ok_called = true
  end
  #--------------------------------------------------------------------------
  # * Set Item Window
  #--------------------------------------------------------------------------
  def item_window=(item_window)
    @item_window = item_window
    update
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_TacticItemList
#------------------------------------------------------------------------------
#  List the valid item for tactic command
#==============================================================================
# tag: command ( Tactic Item List
class Window_TacticItemList < Window_ItemList
  #--------------------------------------------------------------------------
  attr_accessor :symbol
  attr_reader   :command
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y, width, height)
    super
    self.windowskin = Cache.system(WindowSkin::Fluttershy)
    @subwindow = nil
  end
  #--------------------------------------------------------------------------
  def init(_data)
    @ori_category = @command.category rescue nil
    @tactic_data  = _data
  end
  #--------------------------------------------------------------------------
  # * Get Digit Count
  #--------------------------------------------------------------------------
  def col_max
    return 1
  end
  #--------------------------------------------------------------------------
  def command=(new_cmd)
    @last_command = @command.dup if @command
    @command = new_cmd
  end
  #--------------------------------------------------------------------------
  # * Include in Item List?
  #--------------------------------------------------------------------------
  def include?(item)
    case @category
    when :general
      return Tactic_Config::General_Actions.include?(item)
    when :targeting
      return Tactic_Config::Enemy::Condition_Table.include?(item)
    when :fighting
      return Tactic_Config::Target::Condition_Table.include?(item)
    when :self
      return Tactic_Config::Self::Condition_Table.include?(item)
    else
      return super
    end
  end
  #--------------------------------------------------------------------------
  # * Create Item List
  #--------------------------------------------------------------------------
  def make_item_list
    @data = [] 
    @symbol = :action
    return super if [:item, :skill].include?(@category)
    case @category
    when :general
      @data = Tactic_Config::General_Actions.keys
    when :targeting
      @data = Tactic_Config::Enemy::Condition_Table.keys
      @command.category = :targeting
      @symbol = :condition
    when :fighting
      @data = Tactic_Config::Target::Condition_Table.keys
      @command.category = :fighting
      @symbol = :condition
    when :self
      @data = Tactic_Config::Players::Condition_Table.keys
      @command.category = :self
      @symbol = :condition
    else
      @symbol = nil
    end
  end
  #--------------------------------------------------------------------------
  # * Display in Enabled State?
  #--------------------------------------------------------------------------
  def enable?(item)
    return super if item.is_a?(RPG::UsableItem)
    return true
  end
  #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    rect = item_rect(index)
    rect.width -= 4
    if item.is_a?(RPG::UsableItem)
      name = item.name
      icon_id = item.icon_index
    else
      name = Vocab::TacticConfig::Name_Table[item]
      icon_id = (PONY::IconID[item] || 0)
    end
    name = "<none>" if name.nil?
    draw_icon(icon_id, rect.x, rect.y) if icon_id > 0
    draw_text(rect.x + 24, rect.y, item_width, line_height, name)
  end
  #--------------------------------------------------------------------------
  # * Call OK Handler
  #--------------------------------------------------------------------------
  def call_ok_handler
    if @command
      case @symbol
      when :condition
        cond = item
        result = call_subwindow(item)
        return call_cancel_handler if !result
        return call_cancel_handler if result.is_a?(Array) && !result.first
        @command.args = result
        if item.is_a?(Symbol)
          @command.condition_symbol = item
          @command.condition = ""
        else
          @command.condition_symbol = :code
          @command.condition = item
        end
      when :action
        @command.action.reassign_item(item)
        if item == :jump_to
          re = call_subwindow(:jump_to).first
          if re
            re = @tactic_data.find{|c| c.index_id == re.index_id}
            @command.jump_command = re ? re : nil
            debug_print "jump command id: #{@command.jump_command.index_id}"
          end
        else
          @command.jump_command = nil
        end
      end # when is selecting an action
    end
    super
  end
  #--------------------------------------------------------------------------
  def call_cancel_handler
    @command.category = @ori_category if @ori_category
    super
  end
  #--------------------------------------------------------------------------
  def call_subwindow(item)
    help_text = Vocab::TacticConfig::InputHelp[item]
    return [true] if help_text.nil?
    if Tactic_Config::Condition_Symbol[item]
      @subwindow = create_select_window
      @subwindow.category = item
      set_jmp_command_item if item == :jump_to
      @subwindow.activate
      @subwindow.select(0) if @subwindow.data[0]
    else
      @subwindow = create_input_window(help_text)
      @subwindow.activate
      @subwin_flag = :input
    end
    re = update_subwindow(item) # Infinity loop until input processed
    @subwindow.dispose
    @subwindow   = nil
    @subwin_flag = nil
    return re
  end
  #--------------------------------------------------------------------------
  def set_jmp_command_item
    subwindow_items = []
    @tactic_data.each_with_index do |cmd|
      subwindow_items.push(cmd) if cmd.valid?
    end
    @subwindow.set_data(subwindow_items)
  end
  #--------------------------------------------------------------------------
  def create_input_window(help_text)
    cw = 120
    cx = Graphics.center_width(cw)
    cy = Graphics.center_height(48)
    attrs = {
      autoscroll: true,
      limit: 2,
      number: true,
      dim_background: true,
      title: help_text
    }
    return window = Window_Input.new(cx, cy, cw, attrs)
  end
  #--------------------------------------------------------------------------
  def create_select_window
    cw = 240
    ch = 240
    cx = Graphics.center_width(cw)
    cy = Graphics.center_height(ch)
    window = Window_TacticConfigList.new(cx, cy, cw, ch)
    window.set_handler(:ok, method(:on_select_ok))
    window.set_handler(:cancel, method(:on_subwindow_cancel))
    return window
  end
  #--------------------------------------------------------------------------
  def update_subwindow(item)
    re = nil
    loop do
      SceneManager.update_basic
      if @subwin_flag == :input
        @subwindow.update
        re = SceneManager.get_input
        re = re.empty? ? false : [[(re.to_i || 0), 0].max, 100].min if re
        re = :nil if @subwindow.disposed? && !re
      else
        re = @subwindow.update
        if re && item == :has_state
          re = re.id rescue :nil
        end
      end
      break if re
    end
    re = false if re == :nil
    return [re]
  end
  #--------------------------------------------------------------------------
  def on_select_ok
    @last_command = @command.dup if @command
  end
  #--------------------------------------------------------------------------
  def on_subwindow_cancel
    @command = @last_command ? @last_command.dup : nil
  end
  
end

#==============================================================================
# ** Window_InstanceItemList
#------------------------------------------------------------------------------
#  Just like item list, but return the selected item after ok processed
#==============================================================================
# tag: command ( Instance Item List
class Window_InstanceItemList < Window_ItemList
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y, width, height)
    super(x, y, width, height)
    @return_item = nil
  end
  #--------------------------------------------------------------------------
  def update
    super
    return process_terminate if @return_item && !active?
  end
  #--------------------------------------------------------------------------
  # * Get Activation State of Selection Item
  #--------------------------------------------------------------------------
  def current_item_enabled?
    return !@data[index].nil?
  end
  #--------------------------------------------------------------------------
  # * Create Item List
  #--------------------------------------------------------------------------
  def make_item_list
  end # def make item list
  #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
  end
  #--------------------------------------------------------------------------
  def include?(item)
    return true
  end
  #--------------------------------------------------------------------------
  def call_ok_handler
    super
    @return_item = @data[index]
  end
  #--------------------------------------------------------------------------
  def call_cancel_handler
    super
    @return_item = :nil
  end
  #--------------------------------------------------------------------------
  def process_terminate
    begin
      re = @return_item.dup
    rescue Exception
      re = @return_item
    end
    @return_item = nil
    debug_print "Instance Item List return: #{re}"
    return re
  end
end

#==============================================================================
# ** Window_TacticConfigList
#------------------------------------------------------------------------------
#  Display in Scene_Tactic for available configs
#==============================================================================
# tag: command ( Instance Item List
class Window_TacticConfigList < Window_InstanceItemList
  #--------------------------------------------------------------------------
  attr_reader :preset_data
  #--------------------------------------------------------------------------
  def col_max
    return 1
  end  
  #--------------------------------------------------------------------------
  # * Create Item List
  #--------------------------------------------------------------------------
  def make_item_list
    if @preset_data
      @data = @preset_data.dup
      @preset_data = nil
      return
    end
    temp  = Tactic_Config::Condition_Symbol[@category]
    @data = []
    @data = [:player] if [:player_party_members].include?(temp)
    temp  = Tactic_Config.call_function(temp) if temp.is_a?(Symbol)
    @data += temp if temp
  end # def make item list
  #--------------------------------------------------------------------------
  def set_data(data)
    @preset_data = data || []
    refresh
  end
  #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    icon_id = 0
    rect = item_rect(index)
    rect.width -= 4
    if item.is_a?(RPG::BaseItem)
      name = item.name
      icon_id = item.icon_index
    elsif @category == :jump_to
      name = sprintf("Jump to tactic: #%02d", item.index_id)
    else
      name = Vocab::TacticConfig::Name_Table[item]
      icon_id = (PONY::IconID[item] || 0)
    end
    name = "<none>" if name.nil?
    draw_icon(icon_id, rect.x, rect.y) if icon_id > 0
    draw_text(rect.x + 24, rect.y, item_width, line_height, name)
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_LanguageList
#------------------------------------------------------------------------------
#  Display in Scene_System for supported languages
#==============================================================================
class Window_LanguageList < Window_InstanceItemList
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y, width, height)
    super
    self.windowskin = Cache.system(WindowSkin::Celestia)
  end
  #--------------------------------------------------------------------------
  # * Create Item List
  #--------------------------------------------------------------------------
  def make_item_list
    @data = $supported_languages.keys
  end # def make item list
  #--------------------------------------------------------------------------
  # * Draw Item
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    if item
      rect = item_rect(index)
      rect.width -= 4
      name = $supported_languages[item]
      draw_text(rect, name, 1)
    end
  end
end

#==============================================================================
# ** Window_MultiCommand
#------------------------------------------------------------------------------
#  This window deals with general command choices with depth level manage 
#  ability.
#==============================================================================
class Window_MultiCommand < Window_Command
  #--------------------------------------------------------------------------
  attr_reader   :category_stack
  attr_reader   :current_category
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y)
    @current_category = :main
    @category_stack   = []
    super
  end
  #--------------------------------------------------------------------------
  def current_category
    @current_category
  end
  #--------------------------------------------------------------------------
  def entry_categories
    [:main]
  end
  #--------------------------------------------------------------------------
  # * Get Number of Items
  #--------------------------------------------------------------------------
  def item_max(cat = current_category)
    @list[cat].size
  end
  #--------------------------------------------------------------------------
  # * Clear Command List
  #--------------------------------------------------------------------------
  def clear_command_list
    @list = {}
    @list[:main] = []
  end
  #--------------------------------------------------------------------------
  # * Create Command List
  #--------------------------------------------------------------------------
  def make_command_list
  end
  #--------------------------------------------------------------------------
  # * Add Command
  #     name    : Command name
  #     symbol  : Corresponding symbol
  #     enabled : Activation state flag
  #     ext     : Arbitrary extended data
  #     help    : Help window when hit tab
  #--------------------------------------------------------------------------
  #   add_command(name, symbol, enabled = true, ext = nil, help = nil, cat = main, child = nil)
  def add_command(*args)
    case args.size
    when 1 # Hash initializer
      args = args[0]
      cat = args[:category] ? args[:category] : :main
      content = {
        :name     => args[:name],
        :symbol   => args[:symbol],
        :enabled  => args[:enabled].nil? ? true : args[:enabled],
        :ext      => args[:ext],
        :help     => args[:help],
        :child    => args[:child],
      }
    else
      name    = args[0]; symbol = args[1]; 
      enabled = args[2].nil? ? true  : args[2];
      ext     = args[3]
      help    = args[4]
      cat     = args[5].nil? ? :main : args[5];
      child   = args[6]
      content = {:name=>name, :symbol=>symbol, :enabled => enabled,
                        :ext=>ext, :help => help, :child => child}
    end
    (@list[cat] ||= []) << content
  end
  #--------------------------------------------------------------------------
  # * Get Command Name
  #--------------------------------------------------------------------------
  def command_name(index, cat = current_category)
    @list[cat][index][:name]
  end
  #--------------------------------------------------------------------------
  # * Get Command Help
  #--------------------------------------------------------------------------
  def command_help(index, cat = current_category)
    return @list[cat][index][:help]
  end
  #--------------------------------------------------------------------------
  # * Get Activation State of Command
  #--------------------------------------------------------------------------
  def command_enabled?(index, cat = current_category)
    @list[cat][index][:enabled]
  end
  #--------------------------------------------------------------------------
  # * Get Command Data of Selection Item
  #--------------------------------------------------------------------------
  def current_data
    index >= 0 ? @list[current_category][index] : nil
  end
  #--------------------------------------------------------------------------
  # * Get Activation State of Selection Item
  #--------------------------------------------------------------------------
  def current_item_enabled?
    current_data ? current_data[:enabled] : false
  end
  #--------------------------------------------------------------------------
  # * Get Symbol of Selection Item
  #--------------------------------------------------------------------------
  def current_symbol
    current_data ? current_data[:symbol] : nil
  end
  #--------------------------------------------------------------------------
  # * Get Extended Data of Selected Item
  #--------------------------------------------------------------------------
  def current_ext
    current_data ? current_data[:ext] : nil
  end
  #--------------------------------------------------------------------------
  # * Move Cursor to Command with Specified Symbol
  #--------------------------------------------------------------------------
  def select_symbol(symbol, cat = current_category)
    @list[cat].each_index {|i| select(i) if @list[cat][i][:symbol] == symbol }
  end
  #--------------------------------------------------------------------------
  # * Move Cursor to Command with Specified Extended Data
  #--------------------------------------------------------------------------
  def select_ext(ext, cat = current_category)
    @list[cat].each_index {|i| select(i) if @list[cat][i][:ext] == ext }
  end
  #--------------------------------------------------------------------------
  # * Call Cancel Handler
  #--------------------------------------------------------------------------
  def call_cancel_handler
    return call_handler(:cancel) if entry_categories.include?(@current_category)
    return return_top_category
  end
  #--------------------------------------------------------------------------
  def set_category(cat)
    @category_stack.push(@current_category)
    @current_category = cat
    refresh_item
    activate
  end
  #--------------------------------------------------------------------------
  def return_top_category
    set_category(@category_stack.pop)
  end
  #--------------------------------------------------------------------------
  def refresh
    @current_category = :main
    @category_stack   = []
    super
    set_default_handlers
  end
  #--------------------------------------------------------------------------
  def refresh_item
    contents.clear
    draw_all_items
    select(0)
  end
  #--------------------------------------------------------------------------
  def set_default_handlers
  end
  #--------------------------------------------------------------------------
  # * Call OK Handler
  #--------------------------------------------------------------------------
  def call_ok_handler
    return set_category(current_data[:child]) if current_data[:child]
    return super
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_LevelUpCommands
#------------------------------------------------------------------------------
#  This window is for selecting category of level up command or skill tree
#==============================================================================
class Window_LevelUpCommands < Window_MultiCommand
  include Vocab::Leveling
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :actor
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y, _actor)
    @actor = _actor
    super(x, y)
  end
  #--------------------------------------------------------------------------
  def actor=(_actor)
    @actor = _actor
    refresh
  end
  #--------------------------------------------------------------------------
  # * Get Window Width
  #--------------------------------------------------------------------------
  def window_width
    160
  end
  #--------------------------------------------------------------------------
  # * Get Number of Lines to Show
  #--------------------------------------------------------------------------
  def visible_line_number
    return 4
  end
  #--------------------------------------------------------------------------
  # * Create Command List
  #--------------------------------------------------------------------------
  def make_command_list
    add_command(name: Vocab::LevelUp, symbol: :levelup, 
                enabled: levelup_enabled?, help: Helps[:level_up])
                
    add_command(name: Vocab::Skilltree, symbol: :skilltree, child: :skilltree,
                help: Helps[:skilltree])
                
    make_skilltree_list if @actor
  end
  #--------------------------------------------------------------------------
  def make_skilltree_list
    cat = :skilltree
    names = [@actor.name, @actor.race.name, @actor.class.name]
    syms  = [:unique, :race, :class]
    helps = [Helps[:unique], Helps[:race], Helps[:class]]
    if @actor.dualclass_id > 0
      names.push(@actor.dualclass.name)
      syms.push(:dualclass)
      helps.push(Helps[:dualclass])
    end
    
    names.size.times do |i|
      add_command(name: names[i], symbol: syms[i], help: helps[i], category: cat)
    end
    
  end
  #--------------------------------------------------------------------------
  def levelup_enabled?
    return false if !@actor
    return @actor.upgradeable?
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_LevelUpIndex
#------------------------------------------------------------------------------
#  Index item for level up feats selection or skill tree index
#==============================================================================
# tag: level up
class Window_LevelUpIndex < Window_MultiCommand
  include Vocab::Leveling
  include DND::Utility
  #--------------------------------------------------------------------------
  attr_reader :actor
  attr_reader :category
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y, width, height, _actor)
    @width, @height = width, height
    @actor = _actor
    super(x, y)
    self.actor = _actor
    create_confirm_window
    unselect
    deactivate
  end
  #--------------------------------------------------------------------------
  def create_confirm_window
    @overlay_window = Window_Confirm.new
  end
  #--------------------------------------------------------------------------
  def actor=(actor)
    @actor = actor
    refresh
  end
  #--------------------------------------------------------------------------
  def window_width
    @width
  end
  #--------------------------------------------------------------------------
  def window_height
    @height
  end
  #--------------------------------------------------------------------------
  def contents_height
    line_height * DND::ClassID::PrimaryPathes.size
  end
  #--------------------------------------------------------------------------
  def entry_categories
    super + [:levelup]
  end
  #--------------------------------------------------------------------------
  # * Set Category
  #--------------------------------------------------------------------------
  def set_category(cat)
    self.oy = 0
    super
  end
  #--------------------------------------------------------------------------
  def make_command_list
    list_for_levelup
  end
  #--------------------------------------------------------------------------
  def list_for_levelup
    cat = :levelup
    add_command(name: @actor.class.name, symbol: :levelup_main, category: cat,
                help: Helps[:level_up_main])
    
    if @actor.dualclass_id == 0
      add_command(name: DualClass, symbol: :dualclass, child: :dualclass_list,
                help: Helps[:set_dualclass], category: cat)
                
      make_dualclass_list 
    else
      add_command(name: @actor.class.name, symbol: :levelup_dual, 
                help: Helps[:level_up_dual], category: cat)
    end
  end
  #--------------------------------------------------------------------------
  def make_dualclass_list
    cat = :dualclass_list
    class_id = DND::ClassID::PrimaryPathes.collect{|c| c.first}
    @dualclass_symbols = []
    
    class_id.each do |id|
      nam = $data_classes[id].name
      sym = nam.downcase.to_sym
      hel = $data_classes[id].description
      if hel && @help_window
        hel = FileManager.textwrap(hel, @help_window.width - 32)
      else
        hel = $data_classes[id].requirement
      end
      ena = class_requirement_meet?(id)
      
      if DND::ClassID::Wizard.include?(id)
        ena = false if DND::NoWizardry.include?(@race_id)
      end
      
      ena = false if id == @actor.class_id
      ena = false if id == @actor.class.parent_class if @actor.class
      
      add_command(name: nam, symbol: sym, help: hel, category: cat, ext: id, enabled: ena)
      @dualclass_symbols.push(sym)
    end
  end
  #--------------------------------------------------------------------------
  def make_feat_commands(feat_skillid)
    leveling_skill = $data_skills[feat_skillid]
    cat = :select_feat
    @feat_select_number   = leveling_skill.selectable_skill.number
    @selected_feat_symbol = []
    leveling_skill.selectable_skill.index.each do |sid|
      skill = $data_skills[sid]
      add_command(category: cat, name: skill.name, symbol: skill.name.to_sym,
                  help: skill.description, ext: skill.id)
                  
      set_handler(skill.name.to_sym, method(:select_new_skill))
    end
    
  end
  #--------------------------------------------------------------------------
  def set_default_handlers
    set_handler(:levelup_main, method(:levelup_main))
    set_handler(:levelup_dual, method(:levelup_dual))
    @dualclass_symbols.each do |sym|
      set_handler(sym, method(:set_dualclass))
    end
  end
  #--------------------------------------------------------------------------
  def levelup_main
    return unless @actor
    @actor.level_up_class(@actor.class_id)
    process_levelup
  end
  #--------------------------------------------------------------------------
  def levelup_dual
    return unless @actor
    @actor.level_up_class(@actor.dualclass_id)
    process_levelup
  end
  #--------------------------------------------------------------------------
  def set_dualclass
    return unless @actor
    class_id = current_data[:ext]
    unless (class_id || 0).to_bool
      raise "cannot find class id for symbol: #{current_data[:symbol]}"
    end
    @actor.change_dualclass(class_id, false)
    process_levelup
  end
  #--------------------------------------------------------------------------
  def process_levelup
    @actor.level_up
    Sound.level_up
    call_handler(:on_levelup_finish)
  end
  #--------------------------------------------------------------------------
  def cancel_enabled?
    return false if current_category == :select_feat
    return super
  end
  #--------------------------------------------------------------------------
  def class_requirement_meet?(id)
    return $data_classes[id].class_requirement_meet?(@actor)
  end
  #--------------------------------------------------------------------------
  def select_new_skill
    skill_id = current_data[:ext]
    @actor.learn_skill(skill_id)
    @feat_select_number -= 1
    if @feat_select_number > 0
      @list[current_category].delete(current_data)
      refresh_item
    else
      call_handler(:on_feat_ok)
    end
  end
  #--------------------------------------------------------------------------
  def call_ok_handler
    case current_symbol
    when :set_dualclass
      info = sprintf(Confirm_Dualclass, current_data[:name])
      raise_overlay(info, :call_handler, current_symbol)
    when :select
      info = sprintf(Confirm_LearnSkill, current_data[:name])
      raise_overlay(info, :call_handler, current_symbol)
    else
      super
    end
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_TacticInfo
#------------------------------------------------------------------------------
#  Very big help information window in Scene_Tactic
#==============================================================================
class Window_TacticInfo < Window_Selectable
	#--------------------------------------------------------------------------
	InitDrawX = 4
	InitDrawY = 0
	#--------------------------------------------------------------------------
	attr_reader :lines
	#--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
	def initialize(x, y, width = window_width, height = window_height)
		@lines = Vocab::Tactic::Hints
		super(x, y, width, height)	
		deactivate
		hide
	end
	#--------------------------------------------------------------------------
	def window_width
		return Graphics.width
	end
	#--------------------------------------------------------------------------
	def window_height
		return Graphics.height
	end
	#--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
   	draw_all_items
  end
  #--------------------------------------------------------------------------
  def item_max
  	return @lines.size
  end
  #--------------------------------------------------------------------------
  def draw_item(index)
  	x = InitDrawX
  	y = InitDrawY + line_height * index
  	draw_text_ex(x, y, @lines[index])
  end
	#--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_DebugPanel
#------------------------------------------------------------------------------
#  This window class handles debug information, should not appear unless it's
# in debug mode. Calling this will not start a new scene.
#==============================================================================
class Window_DebugPanel < Window_Base
  #--------------------------------------------------------------------------
  CategoryList = [:switch, :variable, :sprite]
  #--------------------------------------------------------------------------
  attr_reader :select_window, :content_window
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    super(0, 0, Graphics.width, Graphics.height)
    self.z = PONY::SpriteDepth::Table[:win_debug]
    @current_index = 0
    create_windows
    deactivate
    hide
  end
  #--------------------------------------------------------------------------
  def item_max
    CategoryList.size
  end
  #--------------------------------------------------------------------------
  def create_windows
    create_selecting_window
    create_content_window
    create_help_window
    @select_window.right_window = @content_window
  end
  #--------------------------------------------------------------------------
  def create_selecting_window
    @select_window = Window_DebugLeft.new(0,0)
    @select_window.set_handler(:ok,       method(:on_left_ok))
    @select_window.set_handler(:cancel,   method(:hide))
    @select_window.set_handler(:pagedown, method(:next_category))
    @select_window.set_handler(:pageup,   method(:prev_category))
    @select_window.z = self.z + 1
  end
  #--------------------------------------------------------------------------
  def create_content_window
    wx = @select_window.width
    ww = Graphics.width - wx
    @content_window = Window_DebugRight.new(wx, 0, ww)
    @content_window.set_handler(:cancel, method(:on_right_cancel))
    @content_window.z = self.z + 1
  end
  #--------------------------------------------------------------------------
  def create_help_window
    wx = @content_window.x
    wy = @content_window.height
    ww = @content_window.width
    wh = Graphics.height - wy
    @help_window   = Window_Base.new(wx, wy, ww, wh)
    @help_window.z = self.z + 1
  end
  #--------------------------------------------------------------------------
  # * Left [OK]
  #--------------------------------------------------------------------------
  def on_left_ok
    @content_window.activate
    @content_window.select(0)
    refresh_help_window
  end
  #--------------------------------------------------------------------------
  # * Right [Cancel]
  #--------------------------------------------------------------------------
  def on_right_cancel
    @select_window.activate
    @content_window.unselect
    refresh_help_window
  end
  #--------------------------------------------------------------------------
  # * Refresh Help Window
  #--------------------------------------------------------------------------
  def refresh_help_window
    @help_window.contents.clear
    @help_window.draw_text_ex(4, 0, help_text)
  end
  #--------------------------------------------------------------------------
  # * Get Help Text
  #--------------------------------------------------------------------------
  def help_text
    case @select_window.category
    when :switch
      return @content_window.active? ? Vocab::Debug::SwitchHelp : Vocab::Debug::Switch;
    when :variable
      return @content_window.active? ? Vocab::Debug::VariableHelp : Vocab::Debug::Variable;
    when :sprite
      return @content_window.active? ? Vocab::Debug::SpriteHelp : Vocab::Debug::Sprite;
    end
    return ""
  end
  #--------------------------------------------------------------------------
  def get_category_data(category)
    case category
    when :switch;   return $game_switches;
    when :variable; return $game_variables;
    when :sprite;   return Cache.undisposed_sprites;
    end
    return []
  end
  #--------------------------------------------------------------------------
  def prev_category
    @current_index = (@current_index - 1 + item_max) % item_max
    set_category(@current_index)
  end
  #--------------------------------------------------------------------------
  def next_category
    @current_index = (@current_index + 1) % item_max
    set_category(@current_index)
  end
  #--------------------------------------------------------------------------
  def set_category(index)
    category = CategoryList[@current_index]
    @select_window.set_category(category, get_category_data(category))
    @content_window.unselect
    @content_window.deactivate
    @select_window.activate
    @select_window.select(0)
    refresh_help_window
  end
  #--------------------------------------------------------------------------
  def update
    super
    @help_window.update
    @select_window.update
    @content_window.update
  end
  #--------------------------------------------------------------------------
  def raise_overlay(args = {})
    show
  end
  #--------------------------------------------------------------------------
  def active?
    @select_window.active? || @content_window.active?
  end
  #--------------------------------------------------------------------------
  def show
    @help_window.show
    @select_window.show
    @content_window.show
    set_category(0)
    @select_window.activate
    super
  end
  #--------------------------------------------------------------------------
  def hide
    @help_window.hide if @help_window
    [@select_window, @content_window].each do |window|
      next unless window
      window.unselect
      window.hide
      window.deactivate
    end
    super
  end
  #--------------------------------------------------------------------------
  def dispose
    @help_window.dispose
    @select_window.dispose
    @content_window.dispose
    super
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_GameMode
#------------------------------------------------------------------------------
#  For selecting game mode in title screen, mostly are main/DLC/tutorial
#==============================================================================
class Window_GameMode < Window_ImageCommand
  include PONY::GameMode
  #------------------------------------------------------------------------------
  def initialize(x, y)
    super(x, y)
    self.back_opacity = 0xff
    swap_skin(WindowSkin::ModeWindow)
    create_cursor_sprite
  end
  #------------------------------------------------------------------------------
  def contents_width
    return Graphics.width
  end
  #------------------------------------------------------------------------------
  def contents_height
    return (item_height + standard_padding) * item_max + spacing
  end
  #------------------------------------------------------------------------------
  def window_height
    Graphics.height - 68
  end
  #-----------------------------------------------------------------------------
  def window_width
    Graphics.width + standard_padding * 2
  end
  #-----------------------------------------------------------------------------
  def item_height
    return 128
  end
  #-----------------------------------------------------------------------------
  def item_width
    Graphics.width
  end
  #-----------------------------------------------------------------------------
  def make_command_list
    for mode in Modes
      add_command(mode.name, mode.symbol, mode.image, mode.enabled, nil, mode.help)
    end
  end
  #-----------------------------------------------------------------------------
  def item_rect(index)
    rect = super
    rect.y += index * standard_padding
    rect
  end
  #-----------------------------------------------------------------------------
  def draw_item(index)
    rect = item_rect(index)
    bmp = Cache.UI(@list[index][:image])
    src = Rect.new(0, 0, item_width, item_height)
    enabled = @list[index][:enabled]
    contents.blt(rect.x, rect.y, bmp, src, enabled ? 255 : translucent_alpha)
    bmp.dispose
    #-- draw mode name
    text_width = text_size(@list[index][:name]).width + 8
    offset = POS.new(38, 12)
    rect.x = rect.width - text_width - offset.x;
    rect.y = rect.y + rect.height - line_height - offset.y
    rect.width = text_width
    rect.height = line_height
    contents.draw_text(rect, @list[index][:name])
  end
  #-----------------------------------------------------------------------------
  def help_window=(hw)
    super
    refresh
  end
  #------------------------------------------------------------------------------
  def update_cursor(forced = false)
    return unless @cursor_sprite && (index_changed? || forced)
    rect = item_rect(@index)
    @cursor_sprite.x = self.x + rect.x + standard_padding
    @cursor_sprite.y = self.y + rect.y + standard_padding - self.oy
    Sound.play_cursor if active?
    case @index
    when 0
      @cursor_sprite.tone.set(Tone_VODL)
    when 1
      @cursor_sprite.tone.set(Tone_Tutorial)
    end
  end
  #--------------------------------------------------------------------------
  # * Update Tone: Not needed
  #--------------------------------------------------------------------------
  def update_tone
  end
  #------------------------------------------------------------------------------
  def create_cursor_sprite
    @cursor_sprite = Sprite.new
    @cursor_sprite.bitmap = Cache.UI(CursorImage)
    @cursor_sprite.z = self.z + 1
    @child_sprite << @cursor_sprite
  end
  #------------------------------------------------------------------------------
  def set_z(nz)
    return unless nz
    super
    @cursor_sprite.z = nz + 1
  end
  #------------------------------------------------------------------------------
  def cursor_sprite
    @cursor_sprite
  end
  #------------------------------------------------------------------------------  
end

#==============================================================================
# ** Window_ProgressSelection
#------------------------------------------------------------------------------
#  This command window determines new game or load a save file in title screen
#==============================================================================
class Window_ProgressSelection < Window_HorzCommand
  #--------------------------------------------------------------------------
  NewGame      = "new_journey"    # Image name of New Game
  LoadGame     = "load_progress"  # Image name of Load Game
  NGOutline    = "newj_outline"   # Outline for NewGame Sprite
  LoadOutline  = "load_outline"   # Outline for LoadGame Sprite
  IconRect     = Rect.new(0, 0, 266, 250)
  WinWidth     = 640              # Window Width
  WinHeight    = 480              # Window Height
  UpdateCycle  = 60               # Frames to complete a full update cycle
  DeltaTheta   = 180.0 / UpdateCycle
  #--------------------------------------------------------------------------
  def initialize(x, y)
    self.class.const_set(:WinWidth, Graphics.width)
    super(x, y)
    self.back_opacity = 250
    self.arrows_visible = false
    swap_skin(WindowSkin::BBoarder)
    @anim_index = 0
    @anim_timer = 0
    create_newgame_sprite
    create_loadgame_sprite
    create_text_sprite
    create_mode_sprite
  end
  #--------------------------------------------------------------------------
  def window_width;     WinWidth;   end
  def window_height;    WinHeight;  end
  #--------------------------------------------------------------------------
  def contents_width;   WinWidth;   end
  def contents_height;  WinHeight;  end
  #--------------------------------------------------------------------------
  def item_height
    IconRect.height
  end
  #--------------------------------------------------------------------------
  def item_width
    IconRect.width
  end
  #--------------------------------------------------------------------------
  def draw_item(index)
    
  end
  #--------------------------------------------------------------------------
  def update_cursor
  end
  #--------------------------------------------------------------------------
  def make_command_list
    add_command(Vocab::NewGame,  :new_game,  true, nil, Vocab::NewGame)
    add_command(Vocab::LoadGame, :load_game, true, nil, Vocab::LoadGame)
  end
  #--------------------------------------------------------------------------
  # * Reset src_rect of animated icon sprite
  #--------------------------------------------------------------------------
  def reset_animated_icon(sprite, outline, text)
    sprite.opacity = 0xff
    text.opacity   = 0xff
    @anim_index    = 0
    outline.show
  end
  #--------------------------------------------------------------------------
  def unselect_icon(sprite, outline, text)
    sprite.opacity = translucent_alpha
    text.opacity   = translucent_alpha
    outline.hide
  end
  #--------------------------------------------------------------------------
  def update_animated_icon(sprite)
    @anim_index = (@anim_index + 1) % UpdateCycle
    mul = Math.sin((90 + @anim_index * DeltaTheta).to_rad).abs
    opa = (0xff * mul).to_i
    sprite.opacity = opa
  end
  #--------------------------------------------------------------------------
  def update
    super
    return unless visible?
    update_sprites
  end
  #--------------------------------------------------------------------------
  def update_tone; end
  #--------------------------------------------------------------------------
  def update_sprites
    case @index
    when 0
      if index_changed?
        reset_animated_icon(@newgame_sprite, @newgame_outline, @ng_text_sprite)
        unselect_icon(@loadgame_sprite, @loadgame_outline, @lg_text_sprite)
      end
      update_animated_icon(@newgame_outline)
    when 1
      if index_changed?
        reset_animated_icon(@loadgame_sprite, @loadgame_outline, @lg_text_sprite)
        unselect_icon(@newgame_sprite, @newgame_outline, @ng_text_sprite)
      end
      update_animated_icon(@loadgame_outline)
    end
  end
  #--------------------------------------------------------------------------
  def create_newgame_sprite
    @newgame_sprite   = Sprite.new
    @newgame_sprite.x = self.x + spacing * 2
    @newgame_sprite.y = (self.y + spacing * 4 + window_height - IconRect.height) / 2
    @newgame_sprite.bitmap = Cache.UI(NewGame)
    
    @newgame_outline = Sprite.new
    @newgame_outline.x = @newgame_sprite.x
    @newgame_outline.y = @newgame_sprite.y
    @newgame_outline.bitmap = Cache.UI(NGOutline)
    
    @child_sprite << @newgame_sprite << @newgame_outline
  end
  #--------------------------------------------------------------------------
  def create_loadgame_sprite
    @loadgame_sprite   = Sprite.new
    @loadgame_sprite.x = self.x + window_width - spacing * 2 - IconRect.width
    @loadgame_sprite.y = (self.y + spacing * 4 + window_height - IconRect.height) / 2
    @loadgame_sprite.bitmap = Cache.UI(LoadGame)
    
    @loadgame_outline = Sprite.new
    @loadgame_outline.x = @loadgame_sprite.x
    @loadgame_outline.y = @loadgame_sprite.y
    @loadgame_outline.bitmap = Cache.UI(LoadOutline)
    
    @child_sprite << @loadgame_sprite << @loadgame_outline
  end
  #--------------------------------------------------------------------------
  def create_text_sprite
    @ng_text_sprite = Sprite.new
    @ng_text_sprite.x = @newgame_sprite.x + 4
    @ng_text_sprite.y = @newgame_sprite.y + IconRect.height + 8
    twidth = @newgame_sprite.width
    @ng_text_sprite.bitmap = Bitmap.new(twidth + 8, line_height * 2)
    trect = Rect.new(0, 0, twidth, line_height)
    FileManager.textwrap(@list[0][:help], twidth).each do |line|
      @ng_text_sprite.bitmap.draw_text(trect, line, 1)
      trect.y += line_height
    end
    
    @lg_text_sprite = Sprite.new
    @lg_text_sprite.x = @loadgame_sprite.x + 4
    @lg_text_sprite.y = @loadgame_sprite.y + IconRect.height + 8
    twidth = @loadgame_sprite.width
    @lg_text_sprite.bitmap = Bitmap.new(twidth + 8, line_height * 2)
    trect = Rect.new(0, 0, twidth, line_height)
    FileManager.textwrap(@list[1][:help], twidth).each do |line|
      @lg_text_sprite.bitmap.draw_text(trect, line, 1)
      trect.y += line_height
    end
    
    @child_sprite << @ng_text_sprite << @lg_text_sprite
  end
  #--------------------------------------------------------------------------
  def create_mode_sprite
    @mode_sprite = Sprite.new
    @mode_sprite.bitmap = Bitmap.new(Graphics.width, 128)
    @child_sprite << @mode_sprite
  end
  #--------------------------------------------------------------------------
  def show
    super
    @mode_sprite.bitmap.clear
    mode = nil
    case $game_system.game_mode
    when :main;     mode = PONY::GameMode::Modes[0]
    when :tutorial; mode = PONY::GameMode::Modes[1]
    end
    
    unselect_icon(@loadgame_sprite, @loadgame_outline, @lg_text_sprite)
    unselect_icon(@newgame_sprite, @newgame_outline, @ng_text_sprite)
    
    if mode
      rect = Rect.new(0, 0, Graphics.width, 128)
      @mode_sprite.bitmap.blt(0, 0, Cache.UI(mode[:image]), rect)
      #-- draw mode name
      text_width = text_size(mode[:name]).width + 8
      offset = POS.new(38, 12)
      rect.x = rect.width - text_width - offset.x;
      rect.y = rect.y + rect.height - line_height - offset.y
      rect.width = text_width
      rect.height = line_height
      @mode_sprite.bitmap.draw_text(rect, mode[:name])
    end
  end
  #--------------------------------------------------------------------------
  def set_z(nz)
    return unless nz
    super
    @mode_sprite.z = nz
    @newgame_outline.z = @loadgame_outline.z = nz + 1
    @newgame_sprite.z  = @loadgame_sprite.z  = nz + 2
    @ng_text_sprite.z  = @lg_text_sprite.z   = nz + 3
  end
  #---------------------------------------------------------------------------
  def item_rect(index)
    hgw = Graphics.width / 2; gh = Graphics.height
    return Rect.new(0, 0, hgw, gh) if index == 0
    return Rect.new(hgw, 0, hgw, gh) if index == 1
    return super
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_MouseUIBase
#------------------------------------------------------------------------------
#  A totally mouse-oriented UI
#==============================================================================
class Window_MouseUIBase < Window_Base
  #--------------------------------------------------------------------------
  attr_reader :buttons
  attr_reader :currnent_index, :current_group
  attr_reader :index
  attr_reader :groups
  attr_reader :help_window
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(x, y, width, height)
    super
    @index = 0
    @index_changed = false
    @buttons = []
    @groups  = {}
    @button_symbol_table = {}
    @mouse_hovered = Mouse.collide_sprite?(self)
    unselect
  end
  #-----------------------------------------------------------------------------
  # * Functions that not used
  #-----------------------------------------------------------------------------
  def update_tone; end
  #-----------------------------------------------------------------------------
  def unselect
    select(-1)
  end
  #-----------------------------------------------------------------------------
  def select(sig)
    return select_index(sig.index)  if sig.is_a?(Game_InteractiveButton)
    return select_index(sig)        if sig.is_a?(Numeric)
    return select_symbol(sig)       if sig.is_a?(Symbol)
    debug_print("[Warning]: Invalid datatype for #{self} selection")
  end
  #-----------------------------------------------------------------------------
  def select_index(_index)
    return if _index && _index == @index
    unfocus_item(buttons[@index])
    @index = _index
    hilight_item(buttons[@index])
    update_help_window
    @index_changed = true
  end
  #-----------------------------------------------------------------------------
  def select_symbol(sym)
    select_index(@buttons.find_index{|but| but.symbol == sym}.index)
  end
  #-----------------------------------------------------------------------------
  def hilight_item(item)
    item.focus_sprite if item
  end
  #-----------------------------------------------------------------------------
  def unfocus_item(item)
    item.unfocus_sprite if item
  end
  #-----------------------------------------------------------------------------
  def current_item
    @buttons[@index]
  end
  #-----------------------------------------------------------------------------
  def current_group
    @groups[current_item.group] || []
  end
  #-----------------------------------------------------------------------------
  def index_changed?
    @index_changed
  end
  #-----------------------------------------------------------------------------
  def update
    @index_changed = false
    super
    return unless visible?
    update_mouse
    update_keyboard if active?
  end
  #------------------------------------------------------------------------------
  def update_help_window
    return unless @help_window
    @help_window.set_text(current_item.help || '')
  end
  #------------------------------------------------------------------------------
  def update_mouse_selection
    @buttons.each_with_index do |but, i|
      next unless but.active? && but.sprite_valid?(but.sprite)
      next unless @index != i && Mouse.collide_sprite?(but.sprite) 
      select_index(i)
    end
  end
  #-----------------------------------------------------------------------------
  def update_mouse
    update_mouse_selection if Mouse.moved?
  end
  #-----------------------------------------------------------------------------
  def update_keyboard
    update_navigate
    update_trigger
  end
  #-----------------------------------------------------------------------------
  def update_navigate
    cur = current_item
    return unless cur && (cur.up rescue false) && (cur.down rescue false) && 
                  (cur.left rescue false) && (cur.right rescue false)
    cur = cur.up    if Input.trigger?(:UP)
    cur = cur.down  if Input.trigger?(:DOWN)
    cur = cur.right if Input.trigger?(:RIGHT)
    cur = cur.left  if Input.trigger?(:LEFT)
    select_index(cur.index)
  end
  #-----------------------------------------------------------------------------
  def update_trigger
    process_trigger(current_item) if button_cooled? && Input.trigger?(:C)
  end
  #-----------------------------------------------------------------------------
  def refresh
    contents.clear
    draw_all_items
  end
  #-----------------------------------------------------------------------------
  def item_max
    @buttons.size
  end
  #-----------------------------------------------------------------------------
  def draw_all_items
    item_max.times do |i|
      draw_item(i)
    end
  end
  #-----------------------------------------------------------------------------
  def draw_item(i)
    @buttons[i].refresh
  end
  #-----------------------------------------------------------------------------
  def process_trigger(button)
    return if button.handler.nil?
    heatup_button
    button.handler.call(get_button_args(button))
  end
  #-----------------------------------------------------------------------------
  def add_button(*args)
    button = Game_InteractiveButton.new(args)
    button.create_sprite
    _index = @buttons.size
    button.index = _index
    @button_symbol_table[button.symbol] = _index
    add_group(button) if button.group
    @buttons.push(button)
  end
  #-----------------------------------------------------------------------------
  def add_group(button)
    (@groups[button.group] ||= []) << button
    button.group_index = @groups[button.group].size - 1
    build_group_nodemap(button)
  end
  #-----------------------------------------------------------------------------
  def build_group_nodemap(button)
    group = @groups[button.group]
    return if group.size == 1
    cur = group.first
    group.each do |node|
      build_nodemap(node, button)
    end
  end
#-----------------------------------------------------------------------------
  def build_nodemap(node, button)
    cur = node
    while true
      # if button is at right of current node
      if button.x > cur.x
        # iterate next if node->right has item and button also at right of it
        if cur.right != cur && cur.right.x < button.x
          cur = cur.right
          next
        # either node->right point node itself or button in at middle of node and node->right
        else
          button.left = cur
          cur.right.left = button
          cur.right, button.right = button, cur.right
          break
        end
      # if button is at left of current node
      elsif button.x < cur.x
        # iterate next if node->left has item and button also at left of it
        if cur.left != cur && cur.left.x > button.x
          cur = cur.left
          next
        # either node->left point node itself or button in at middle of node and node->left
        else
          button.right = cur
          cur.left.right = button
          cur.left, button.left = button, cur.left
          break
        end
      # if button is at up of current node
      elsif button.y > cur.y
        if cur.up != cur && cur.up.y < button.y
          cur = cur.up
          next
        else
          button.up = cur
          cur.up.down = button
          cur.up, button.up = button, cur.up
          break
        end
      # if button is at down of current node
      elsif button.y < cur.y
        if cur.down != cur && cur.down.y > button.y
          cur = cur.down
          next
        else
          button.down = cur
          cur.down.up = button
          cur.down, button.down = button, cur.down
          break
        end
      else
        debug_print("[Warning]: Can't find proper place to insert node #{button} where at (#{button.x}, #{button.y})")
        break
      end
    end # while true
  end
  #-----------------------------------------------------------------------------
  def dispose
    dispose_all_buttons
    super
  end
  #-----------------------------------------------------------------------------
  def dispose_all_buttons
    @buttons.each do |but| but.dispose end
  end
  #-----------------------------------------------------------------------------
  def get_button_args(button)
  end
  #-----------------------------------------------------------------------------
  def help_window=(win)
    debug_print("#{self} already has a help window #{@help_window}") if @help_window
    @help_window = win
  end
end

#==============================================================================
# ** Window_InformationLog
#------------------------------------------------------------------------------
#  This window is for displaying something happened in map, e.g. a trap is
# triggered, state added, spell cast etc.
# Use SceneManager.display_info( text ) to show the information(s).
#==============================================================================
class Window_InformationLog < Window_Selectable
  #--------------------------------------------------------------------------
  WatchLogIconID = 2141
  Opacity_Min    = 55
  Opacity_Max    = 0xff
  #--------------------------------------------------------------------------
  attr_reader :button_sprite
  attr_reader :visible_line_number
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(data = [])
    @visible_line_number = 3
    super(Graphics.width  - window_width  - 100, 
          Graphics.height - window_height - 50 , 
          window_width, window_height)
          
    self.z = PONY::SpriteDepth::Table[:viewport3]
    self.opacity = 255
    @hovered = false
    @ori_opacity = opacity
    @lines = data ? data : []
    create_back_bitmap
    create_back_sprite
    create_active_icons
    create_evasion_rect
    deactivate
    self.windowskin = Cache.system(WindowSkin::MapInfo)  if WindowSkin::Enable
    contents.font.size = 16
    refresh
  end
  #--------------------------------------------------------------------------
  # * The rect defines the area where won't collided by mouse
  #--------------------------------------------------------------------------
  def create_evasion_rect
    rx = @icon_less.x
    ry = @icon_less.y
    rw = [@icon_less, @icon_more, @button_sprite].inject(0){|s, icon| s + icon.width}
    rh = @icon_less.height
    @evasion_rect = Rect.new(rx, ry, rw, rh)
  end
  #--------------------------------------------------------------------------
  # * Frame update
  #--------------------------------------------------------------------------
  def update
    hide_sprite = $game_system.hide_huds?
    if hide_sprite && visible?
      hide
    elsif !hide_sprite && !visible?
      show
    end
    update_mouse_hover if Mouse.moved?
    update_active_icon
    super if active?
  end
  #--------------------------------------------------------------------------
  # * Activate trigger detect
  #--------------------------------------------------------------------------
  def update_active_icon
    update_deactivate     if active?
    return unless button_cooled?
    change_watch_activity if Mouse.trigger_sprite?(@button_sprite)
    return if active?
    lesser_opacity        if Mouse.trigger_sprite?(@icon_less)
    more_opacity          if Mouse.trigger_sprite?(@icon_more)
  end
  #--------------------------------------------------------------------------
  def update_deactivate
    return deactivate if Mouse.click?(2)
    return deactivate if Mouse.click?(1) && !Mouse.collide_sprite?(self)
    return deactivate if Mouse.distance_to_sprite(self) > 50
  end
  #--------------------------------------------------------------------------
  def update_mouse_hover
    if Mouse.collide_sprite?(self) && !Mouse.collide_sprite?(@evasion_rect)
      return if @hovered
      @hovered = true
      @ori_opacity = opacity
      change_opacity(Opacity_Min)
    elsif @hovered
      @hovered = false
      change_opacity(@ori_opacity)
    end
  end
  #--------------------------------------------------------------------------
  def change_watch_activity
    heatup_button
    active? ? deactivate : activate
  end
  #--------------------------------------------------------------------------
  def more_opacity
    heatup_button
    opa = [self.opacity + 50, Opacity_Max].min
    change_opacity(opa)
  end
  #--------------------------------------------------------------------------
  def lesser_opacity
    heatup_button
    opa = [self.opacity - 50, Opacity_Min].max
    change_opacity(opa)
  end
  #--------------------------------------------------------------------------
  def change_opacity(opa)
    return unless opa
    self.opacity           = opa
    @button_sprite.opacity = self.opacity
    @icon_more.opacity     = self.opacity
    @icon_less.opacity     = self.opacity
    refresh(true)
  end
  #--------------------------------------------------------------------------
  # * Free
  #--------------------------------------------------------------------------
  def dispose
    super
    dispose_back_bitmap
    dispose_back_sprite
    dispose_button
  end
  #--------------------------------------------------------------------------
  # * Calculate Height of Window Suited to Specified Number of Lines
  #--------------------------------------------------------------------------
  def fitting_height(line_number)
    line_number * line_height + standard_padding * 2
  end
  #--------------------------------------------------------------------------
  # * Get Window Width
  #--------------------------------------------------------------------------
  def window_width
    Graphics.width - 200
  end
  #--------------------------------------------------------------------------
  # * Get Window Height
  #--------------------------------------------------------------------------
  def window_height
    fitting_height(visible_line_number)
  end
  #--------------------------------------------------------------------------
  def visible_line_number
    @visible_line_number
  end
  #--------------------------------------------------------------------------
  # * Create Background Bitmap
  #--------------------------------------------------------------------------
  def create_back_bitmap
    @back_bitmap = Bitmap.new(width, height)
  end
  #--------------------------------------------------------------------------
  # * Create Background Sprite
  #--------------------------------------------------------------------------
  def create_back_sprite
    @back_sprite = Sprite.new
    @back_sprite.bitmap = @back_bitmap
    @back_sprite.y = y
    @back_sprite.z = z - 1
  end
  #--------------------------------------------------------------------------
  def create_active_icons
    create_watch_icon
    create_resize_icon
  end
  #--------------------------------------------------------------------------
  def create_watch_icon
    sx = x + window_width  - 26
    sy = y + window_height - 26
    sz = z + 1
    @button_sprite = create_icon_sprite(sx, sy, sz, WatchLogIconID)
  end
  #--------------------------------------------------------------------------
  def create_resize_icon
    @icon_more = create_icon_sprite(@button_sprite.x - 28, @button_sprite.y,
                  @button_sprite.z, PONY::IconID[:plus])
                  
    @icon_less = create_icon_sprite(@icon_more.x - 28, @icon_more.y,
                  @icon_more.z, PONY::IconID[:minus])
  end
  #--------------------------------------------------------------------------
  # * Free Background Bitmap
  #--------------------------------------------------------------------------
  def dispose_back_bitmap
    @back_bitmap.dispose
  end
  #--------------------------------------------------------------------------
  # * Free Background Sprite
  #--------------------------------------------------------------------------
  def dispose_back_sprite
    @back_sprite.dispose
  end
  #--------------------------------------------------------------------------
  # * Free Button Sprite
  #--------------------------------------------------------------------------
  def dispose_button
    @button_sprite.dispose
    @icon_more.dispose
    @icon_less.dispose
  end
  #--------------------------------------------------------------------------
  # * Clear
  #--------------------------------------------------------------------------
  def clear
    @num_wait = 0
    @lines.clear
    refresh
  end
  #--------------------------------------------------------------------------
  # * Get Number of Data Lines
  #--------------------------------------------------------------------------
  def line_number
    @lines.size
  end
  #--------------------------------------------------------------------------
  # * Go Back One Line
  #--------------------------------------------------------------------------
  def back_one
    @lines.pop
    refresh
  end
  #--------------------------------------------------------------------------
  # * Return to Designated Line
  #--------------------------------------------------------------------------
  def back_to(line_number)
    @lines.pop while @lines.size > line_number
    refresh
  end
  #--------------------------------------------------------------------------
  # * Add Text
  #--------------------------------------------------------------------------
  def add_text(text)
    return unless text
    lines = FileManager.textwrap(text, contents_width, contents)
    lines.each do |line|
      @lines.shift if item_max > item_limit
      @lines.push(line.dup.force_encoding($default_encoding)) if line.size > 0
    end
    refresh(true)
  end
  #--------------------------------------------------------------------------
  # * Get Text From Last Line
  #--------------------------------------------------------------------------
  def last_line
    @lines[-1]
  end
  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  def refresh(lazy = false)
    contents.clear
    contents.dispose
    create_contents
    draw_all_items(lazy)
  end
  #--------------------------------------------------------------------------
  # * Activate Window
  #--------------------------------------------------------------------------
  def activate
    super
    @ori_opacity = self.opacity
    select(@lines.size - 1)
    change_opacity(0xff)
    refresh
  end
  #--------------------------------------------------------------------------
  # * Deactivate Window
  #--------------------------------------------------------------------------
  def deactivate
    change_opacity(@ori_opacity)
    select(@lines.size - 1) if @lines
    unselect
    super
  end
  #--------------------------------------------------------------------------
  # * Get Background Rectangle
  #--------------------------------------------------------------------------
  def back_rect
    Rect.new(0, padding, width, line_number * line_height)
  end
  #--------------------------------------------------------------------------
  # * Get Background Color
  #--------------------------------------------------------------------------
  def back_color
    Color.new(0, 0, 0, back_opacity)
  end
  #--------------------------------------------------------------------------
  # * Get Background Opacity
  #--------------------------------------------------------------------------
  def back_opacity
    return 64
  end
  #--------------------------------------------------------------------------
  # * Get Rectangle for Drawing Items
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = Rect.new
    rect.width = item_width
    rect.height = 18
    rect.x = index % col_max * (item_width + spacing)
    rect.y = index / col_max * 18
    rect
  end
  #--------------------------------------------------------------------------
  # * Get Item Height
  #--------------------------------------------------------------------------
  def item_height
    return 18
  end
  #--------------------------------------------------------------------------
  # * Item limit
  #--------------------------------------------------------------------------
  def item_limit
    100
  end
  #--------------------------------------------------------------------------
  # * Item max
  #--------------------------------------------------------------------------
  def item_max
    return 0 if @lines.nil?
    @lines.size
  end
  #--------------------------------------------------------------------------
  # * Remove the excess line
  #--------------------------------------------------------------------------
  def clean_excess
    n_times = item_max - item_limit
    n_times.times { @lines.shift }
  end
  #--------------------------------------------------------------------------
  # * Draw Line
  #--------------------------------------------------------------------------
  def draw_line(line_number)
    rect = item_rect_for_text(line_number)
    #draw_text(0, rect.y, 320, 20, @lines[line_number])
    draw_text_ex(0, rect.y, @lines[line_number])
  end
  #--------------------------------------------------------------------------
  # * Draw All Items
  #--------------------------------------------------------------------------
  def draw_all_items(lazy = false)
    self.contents.font.color = Color.new(255,255,255, [self.opacity ,150].max)
    if lazy && item_max > visible_line_number
      n = visible_line_number + 1
      n.times do |i|
        draw_item(item_max - i - 1)
      end
    else
      item_max.times {|i| draw_item(i) }
    end
    self.index = item_max - 1
    self.index = -1
  end
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    text = @lines[index]
    return if text.nil?
    rect = item_rect_for_text(index)
    draw_text_ex(rect.x, rect.y, text)
  end
  #--------------------------------------------------------------------------
  # * Draw Text with Control Characters
  #--------------------------------------------------------------------------
  def draw_text_ex(x, y, text)
    self.contents.font.size = 18
    y -= 4
    text = convert_escape_characters(text)
    pos = {:x => x, :y => y, :new_x => x, :height => calc_line_height(text)}
    process_character(text.slice!(0, 1), text, pos) until text.empty?
  end
  #--------------------------------------------------------------------------
  # * Check if character is behind window
  #--------------------------------------------------------------------------
  def behind_toolbar?
    px = ($game_player.screen_x / 32)
    py = ($game_player.screen_y / 32)
    return ( ((3 - px) < 0 && px <= 17) && (10.5 - py) < 0 ) ? true : false
  end
  #--------------------------------------------------------------------------
  # * Show the window
  #--------------------------------------------------------------------------
  def show
    return hide if $game_system.story_mode?
    super
    @back_sprite.show
    @button_sprite.show
    @icon_more.show
    @icon_less.show
    #activate
    #select([item_max - 1, 0].max)
    unselect
  end
  #--------------------------------------------------------------------------
  def hide
    @back_sprite.hide
    @button_sprite.hide
    @icon_more.hide
    @icon_less.hide
    super
  end
  #--------------------------------------------------------------------------
  # *) data
  #--------------------------------------------------------------------------
  def data
    return @lines
  end
  #-------------------------------------------------------------------------
end
#==============================================================================
# ** SceneManager
#------------------------------------------------------------------------------
#  This module manages scene transitions. For example, it can handle
# hierarchical structures such as calling the item screen from the main menu
# or returning from the item screen to the main menu.
#==============================================================================
module SceneManager
  #--------------------------------------------------------------------------
  # * Module Instance Variables
  #--------------------------------------------------------------------------
  @saved_map_infos = []
  #--------------------------------------------------------------------------
  # * Save map informations
  #--------------------------------------------------------------------------
  def self.save_map_infos(data)
    return if data.nil?
    @saved_map_infos = data
  end
  #--------------------------------------------------------------------------
  # * Clear map informations
  #--------------------------------------------------------------------------
  def self.clear_map_infos
    @saved_map_infos.clear
  end
  #--------------------------------------------------------------------------
  # * Resume map informations
  #--------------------------------------------------------------------------
  def self.resume_map_info
    return if @saved_map_infos.empty?
    re = @saved_map_infos.dup
    @saved_map_infos.clear
    return re
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Window_Selectable
#------------------------------------------------------------------------------
#  This window class contains cursor movement and scroll functions.
#==============================================================================
class Window_Selectable < Window_Base
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader :info_window
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias initialize_dnd initialize
  def initialize(x, y, width, height)
    create_info_window
    initialize_dnd(x, y, width, height)
    set_handler(:moreinfo, method(:process_moreinfo))
  end
  #--------------------------------------------------------------------------
  # * Create Info Window
  #--------------------------------------------------------------------------
  def create_info_window
    @info_window = Window_Moreinfo.new(0, 0, Graphics.width, Graphics.height)
  end
  #--------------------------------------------------------------------------
  # * Handling Processing for OK and Cancel Etc.
  #--------------------------------------------------------------------------
  alias update_moreinfo update
  def update
    if @info_window.visible?
      process_overlay_handling
      @info_window.update
    end
    update_moreinfo
  end
  #--------------------------------------------------------------------------
  # * Process overlay window handling
  #--------------------------------------------------------------------------
  def process_overlay_handling
    if moreinfo_enabled?
      if Input.trigger?(:kTAB) || Mouse.click?(3)
        process_moreinfo(:kTAB)
      elsif Input.trigger?(:B)
        process_moreinfo(:B)
      end # Input.trigger?
    end # @button cooldown
  end
  #--------------------------------------------------------------------------
  # *) Moreinfo is enabled?
  #--------------------------------------------------------------------------
  def moreinfo_enabled?
    handle?(:moreinfo) && (active? || @info_window.visible?)
  end
  #--------------------------------------------------------------------------
  # * Processing show/hide more info window
  #--------------------------------------------------------------------------
  def process_moreinfo(key = :kTAB)
    item = show_moreinfo?
    return if !item
    @info_window.set_item(item) if !@info_window.visible?
    if @info_window.visible?
      @info_window.hide
      Sound.play_cancel
      heatup_button
      @overlayed = false
      activate
    elsif key == :kTAB
      @info_window.show
      Audio.se_play("Audio/SE/BG_Select", 90, 100)
      heatup_button
      @overlayed = true
      deactivate
    end
  end
  #--------------------------------------------------------------------------
  # * Show more info?
  #--------------------------------------------------------------------------
  def show_moreinfo?
    item = @data[index] if !@data.nil? && @data[index]
    item = self.item    if !item && self.methods.include?(:item)
    item = nil unless (item.is_a?(RPG::EquipItem) || item.is_a?(RPG::UsableItem))
    return item
  end
  #--------------------------------------------------------------------------
end
#==============================================================================
# ** Window_Moreinfo
#------------------------------------------------------------------------------
#  This window class display the detail information of selected item
#==============================================================================
class Window_Moreinfo < Window_Base
  include DND::Utility
  #--------------------------------------------------------------------------
  IndexColor = Color.new(240, 225, 185)
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :index                    # cursor position
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(x, y, width, height)
    super(x, y, width, height)
    @item              = nil
    @display_category  = nil
    @actor             = nil
    @pages             = []
    @first_page_offset = 0
    @index = -1
    @handler = {}
    create_background
    self.windowskin = Cache.system(WindowSkin::MapInfo) if WindowSkin::Enable
    self.opacity = 255
    self.hide
    self.z = PONY::SpriteDepth::Table[:win_info]
    refresh
  end
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh(index = 0)
    return if @item.nil?
    contents.clear
    if    @item.is_a?(RPG::Item);   draw_item_info(index)
    elsif @item.is_a?(RPG::Weapon); draw_weapon_info(index)
    elsif @item.is_a?(RPG::Armor);  draw_armor_info(index)
    elsif @item.is_a?(RPG::Skill);  draw_skill_info(index)
    end
    draw_page_number
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    process_cursor_move
    update_mouse
  end 
  #--------------------------------------------------------------------------
  def update_mouse
  end
  #--------------------------------------------------------------------------
  # * Create Background
  #--------------------------------------------------------------------------
  def create_background
    @background_sprite = Sprite.new
    @background_sprite.bitmap = Cache.background("scroll")
    @background_sprite.z = self.z - 10
  end
  #--------------------------------------------------------------------------
  # * Free Background
  #--------------------------------------------------------------------------
  def dispose_background
    @background_sprite.dispose
  end
  #--------------------------------------------------------------------------
  # * Show window
  #--------------------------------------------------------------------------
  def show
    create_background
    super
  end
  #--------------------------------------------------------------------------
  # * Hide window
  #--------------------------------------------------------------------------
  def hide
    dispose_background
    super
  end
  #--------------------------------------------------------------------------
  # * Determine if Cursor is Moveable
  #--------------------------------------------------------------------------
  def cursor_movable?
    return active && open? && @pages.size > 1
  end
  #--------------------------------------------------------------------------
  # *) Set item
  #--------------------------------------------------------------------------
  def set_item(item, actor = nil)
    @pages = []
    @index = 0
    @item  = item
    @actor = actor
    @first_page_offset = get_item_param_lines
    setup_description_pages
    refresh(@index)
  end
  #--------------------------------------------------------------------------
  # * Move Cursor One Page Down
  #--------------------------------------------------------------------------
  def cursor_pagedown
    return if @index + 1 >= @pages.size
    @index += 1
    Audio.se_play("Audio/SE/Book2",80,100)
    refresh(@index)
  end
  #--------------------------------------------------------------------------
  # * Move Cursor One Page Up
  #--------------------------------------------------------------------------
  def cursor_pageup
    return if @index - 1 < 0
    @index -= 1
    Audio.se_play("Audio/SE/Book2",80,100)
    refresh(@index)
  end
  #--------------------------------------------------------------------------
  # * Cursor Movement Processing
  #--------------------------------------------------------------------------
  def process_cursor_move
    return unless cursor_movable?
    cursor_pagedown   if Input.trigger?(:DOWN) || Mouse.scroll_down?
    cursor_pageup     if Input.trigger?(:UP)   || Mouse.scroll_up?
  end
  #--------------------------------------------------------------------------
  # *) Draw Page Number
  #--------------------------------------------------------------------------
  def draw_page_number
    info = sprintf("Page: %2d/%2d", @index + 1, @pages.size)
    px = (self.width / 2) - (info.size * 8)
    py = self.height - line_height * 2
    draw_text(px, py, contents.width, line_height, info , 4)
  end
  #--------------------------------------------------------------------------
  # *) Draw Item Info
  #--------------------------------------------------------------------------
  def draw_item_info(index)
    if index == 0
      cy = 0
      DND::ItemParamDec[:item].each do |param|
        cy = draw_param(param, cy)
      end
    end
    draw_description(index)
  end
  #--------------------------------------------------------------------------
  # *) Draw Weapon Info
  #--------------------------------------------------------------------------
  def draw_weapon_info(index)
    if index == 0
      cy = 0
      DND::ItemParamDec[:weapon].each do |param|
        draw_param(param, cy)
        cy += line_height
      end
    end
    draw_description(index)
  end
  #--------------------------------------------------------------------------
  # *) Draw Armor Info
  #--------------------------------------------------------------------------
  def draw_armor_info(index)
    if index == 0
      cy = 0
      DND::ItemParamDec[:armor].each do |param|
        draw_param(param, cy)
        cy += line_height
      end
    end
    draw_description(index)
  end
  #--------------------------------------------------------------------------
  # *) Draw Skill Info
  #--------------------------------------------------------------------------
  def draw_skill_info(index)
    if index == 0
      cy = 0
      DND::ItemParamDec[:skill].each do |param|
        draw_param(param, cy)
        cy += line_height
      end
    end
    draw_description(index)
  end
  #--------------------------------------------------------------------------
  def get_item_param_lines
    return DND::ItemParamDec[:skill].size  if @item.is_a?(RPG::Skill)
    return DND::ItemParamDec[:weapon].size if @item.is_a?(RPG::Weapon)
    return DND::ItemParamDec[:armor].size  if @item.is_a?(RPG::Armor)
    return DND::ItemParamDec[:item].size   if @item.is_a?(RPG::Item)
    return 0
  end
  
  #--------------------------------------------------------------------------
  # *) setup_description_pages
  #--------------------------------------------------------------------------
  def setup_description_pages
    page_cnt = 0; cnt = @first_page_offset + 1;
    info = @item.information
    @pages[page_cnt] = []
    texts = FileManager.textwrap(info, contents_width, contents)
    texts.each do |line|
      if (self.y + (cnt + 2) * line_height) >= self.height
        page_cnt += 1; @pages[page_cnt] = []; cnt = 1;
      end
      @pages[page_cnt].push(line)
      cnt += 1
    end
  end
  #--------------------------------------------------------------------------
  # *) Draw Item params
  #--------------------------------------------------------------------------
  def draw_param(param, cy)
    
    rect = Rect.new(0, cy, contents.width, line_height)
    change_color(DND::COLOR::Tan)
    case param
    when :wtype
      draw_text(rect, Vocab::Equipment::Type)
      text = sprintf("%s", Vocab::DND::WEAPON_TYPE_NAME[@item.wtype_id])
    when :atype
      draw_text(rect, Vocab::Equipment::Type)
      text = sprintf("%s", Vocab::DND::ARMOR_TYPE_NAME[@item.atype_id])
    when :stype
      draw_text(rect, Vocab::Equipment::Type)
      if @item.scope == BattleManager::Scope_None || BattleManager::Scope_User
        text = Vocab::None
      else
        text = sprintf("%s", Vocab::DND::SKILL_TYPE_NAME[@item.stype_id])
      end
    when :ac
      draw_text(rect, Vocab::Equipment::AC)
      text = sprintf("%s", @item.armor_class)
    when :speed
      draw_text(rect, Vocab::Equipment::Speed)
      if @item.scope == BattleManager::Scope_None
        text = Vocab::None
      else
        text = sprintf("%s", @item.wield_speed)
      end
    when :range
      draw_text(rect, Vocab::Equipment::Range)
      text = sprintf("%s", @item.tool_distance)
    when :damage
      return if @item.damage_index.nil?
      @item.damage_index.each do |feat|
        change_color(DND::COLOR::Tan)
        draw_text(rect, Vocab::Equipment::Damage)
        info = sprintf("%dd%d +(%d), %s; %s",feat[0],feat[1],feat[2], get_element_name(feat[3]), get_param_name(feat[4]))
        change_color(normal_color)
        draw_text(rect, info, 2)
        cy += line_height
      end
      return cy
    when :casting
      draw_text(rect, Vocab::Equipment::CastingTime)
      if (@item.tool_castime | 0) > 10
        text = sprintf("%s sec", (@item.tool_castime / 60.0).round(2))
      else
        text = Vocab::None
      end
    when :cost
      draw_text(rect, Vocab::Equipment::Cost)
      text = sprintf("%s", @item.mp_cost)
    when :cooldown
      draw_text(rect, Vocab::Equipment::Cooldown)
      if @item.tool_cooldown
        text = sprintf("%s sec", (@item.tool_cooldown / 60.0).round(2))
      else
        text = Vocab::None
      end
    when :save
      draw_text(rect, Vocab::Equipment::SavingThrow)
      if @item.dmg_saves
        text = sprintf("%s, %s", get_saving_name(@item.dmg_saves), get_param_name(get_param_id(@item.dmg_saves.last)))
      else
        text = Vocab::None
      end
    else
      return cy
    end
    change_color(normal_color)
    draw_text(rect, text, 2)
    return cy + line_height
  end
  #--------------------------------------------------------------------------
  # *) Draw Item Info
  #--------------------------------------------------------------------------
  def draw_description(page_id)
    cy = @first_page_offset * line_height
    w  = contents.width
    change_color(system_color)
    draw_text(0, cy, w, line_height, "Description:")
    
    change_color(index_color)
    cnt = 1
    @pages[page_id].each do |line|
      draw_text(0, (cy + cnt * line_height), w, line_height, line , 1)
      cnt += 1
    end
    change_color(normal_color)
  end
  #--------------------------------------------------------------------------
  def index_color
    IndexColor
  end
end
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
# ** Scene_Base
#------------------------------------------------------------------------------
#  This is a super class of all scenes within the game.
#==============================================================================
class Scene_Base
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor   :overlay_windows
  attr_reader     :overlayed
  attr_reader     :viewport, :superviewport
  attr_reader     :item_help_window
  #--------------------------------------------------------------------------
  # * Main
  #--------------------------------------------------------------------------
  def main
    @@overlay_windows   = {}
    @@button_cooldown   = 0
    @@overlayed         = false
    $on_exit            = false
    create_debug_window if debug_mode?
    #-------------------------------
    start
    create_overlay_windows
    create_item_help_window
    create_dim_background
    post_start
    #-------------------------------
    loop do
      break if scene_changing?
      update
    end
    
    pre_terminate
    terminate
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Frame Update
  #--------------------------------------------------------------------------
  def update
    update_basic
    update_all_windows unless @@overlayed
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Update Frame (Basic)
  #--------------------------------------------------------------------------
  def update_basic
    #sleep(0.1) until PONY::API::GetForegroundWindow.call == PONY::API::Hwnd
    @@button_cooldown -= 1 unless button_cooled?
    Graphics.update
    Input.update
    GameManager.update_focus
    update_mutex
    update_errno
    update_global_help_window
  end
  #--------------------------------------------------------------------------
  def update_mutex
    error = PONY::ERRNO.error_occurred?
    flag_error(error) if error
  end
  #--------------------------------------------------------------------------
  def update_errno
    PONY::ERRNO.raise_errno if PONY::ERRNO.errno_occurred?
  end
  #--------------------------------------------------------------------------
  def update_verify
    return unless $verify_countdown
    $verify_countdown -= 1 
    return if $verify_countdown > 0
    result = PONY.DoVerifyCode if $giftcode_verify
    
    if result == true
      info = Vocab::Errno::APISymbol_Table[true]
    else
      info = sprintf(Vocab::Errno::APIErr, Vocab::Errno::APISymbol_Table[result])
    end
    raise_overlay_window(:popinfo, info)
  end
  #--------------------------------------------------------------------------
  # * Post-Start Processing
  #--------------------------------------------------------------------------
  alias post_start_scbase post_start
  def post_start
    SceneManager.update_loading while SceneManager.loading?
    debug_print "Post Start"
    post_start_scbase
    $game_system.load_complete
    debug_print "Load Complete"
  end
  #--------------------------------------------------------------------------
  # * Start Processing
  #--------------------------------------------------------------------------
  alias start_scbase start
  def start
    Cache.clear_sprite
    create_superviewport
    start_scbase
  end
  #--------------------------------------------------------------------------
  # * Termination Processing
  #--------------------------------------------------------------------------
  alias terminate_chain terminate
  def terminate
    dispose_item_help_window
    PONY::CHAIN.verify_totalbalance unless self.is_a?(Scene_Map)
    terminate_chain
  end
  #--------------------------------------------------------------------------
  # * Create Super Viewport
  #--------------------------------------------------------------------------
  def create_superviewport
    @superviewport = Viewport.new
    @superviewport.z = PONY::SpriteDepth::Table[:overlays]
  end
  #--------------------------------------------------------------------------
  # * Overlay Window
  #--------------------------------------------------------------------------
  def create_overlay_windows
    if self.is_a?(SceneManager.first_scene_class)
      $confirm_exit_win = Window_Confirm.new(nil, nil, nil, nil, Vocab::ExitConfirm, true)
      $confirm_win = Window_Confirm.new(nil, nil, nil, nil, '', true)
      t = sec_to_frame(5)
      $popup_win = Window_PopInfo.new(nil, nil, nil, nil, "", t, true)
    end
    @@overlay_windows[:exit_confirm] = $confirm_exit_win
    @@overlay_windows[:confirm] = $confirm_win
    @@overlay_windows[:popinfo] = $popup_win
  end
  #----------------------------------------------------------------------------
  # * Item help window
  #----------------------------------------------------------------------------
  def create_item_help_window
    @help_window_timer = 0
    @item_help_window = Sprite.new(@superviewport)
    @item_help_text   = Sprite.new(@superviewport)
    bitmap = Cache.UI("item_help_scroll")
    @item_help_window.bitmap = bitmap
    @item_help_text.bitmap = Bitmap.new(bitmap.width, bitmap.height)
    @item_help_window.hide
    @item_help_text.hide
  end
  #----------------------------------------------------------------------------
  def create_dim_background
    @dim_background = Sprite.new(@superviewport)
    @dim_background.bitmap = Bitmap.new(Graphics.width, Graphics.height)
    @dim_background.opacity = 128
    @dim_background.z = @superviewport.z - 0x10
    color = Color.new(16,16,16)
    @dim_background.bitmap.fill_rect(0, 0, Graphics.width, Graphics.height, color)
    @dim_background.hide
  end
  #----------------------------------------------------------------------------
  def create_debug_window
    $debug_window = Window_DebugPanel.new
    @@overlay_windows[:debug] = $debug_window
  end
  #----------------------------------------------------------------------------
  def dispose_item_help_window
    @item_help_window.dispose
    @item_help_text.dispose
    @item_help_window = nil
    @item_help_text   = nil
  end
  #--------------------------------------------------------------------------
  # * Free Viewport
  #--------------------------------------------------------------------------
  alias dispose_all_viewports dispose_main_viewport
  def dispose_main_viewport
    @dim_background.dispose
    @superviewport.dispose    
    dispose_all_viewports
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  alias update_scbase update
  def update
    update_terminate
    update_overlay
    update_debug_window if debug_mode? && button_cooled?
    update_console      if debug_mode? && button_cooled?
    update_scbase
    update_verify
  end
  #--------------------------------------------------------------------------
  # * Update Alt + F4 exit
  #--------------------------------------------------------------------------
  def update_terminate
    return if @@overlay_windows[:exit_confirm].overlayed
    return unless Input.trigger?(:kF4)  || Input.press?(:kF4)
    return unless Input.trigger?(:kALT) || Input.press?(:kALT) 
    self.heatup_button
    $on_exit = true
    raise_overlay_window(:exit_confirm , nil, :exit)
  end
  #--------------------------------------------------------------------------
  # * Update All Windows
  #--------------------------------------------------------------------------
  def update_all_windows
    instance_variables.each do |varname|
      ivar = instance_variable_get(varname)
      ivar.update if ivar.is_a?(Window) && !ivar.disposed?
    end
  end
  #--------------------------------------------------------------------------
  # * Free All Windows
  #--------------------------------------------------------------------------
  def dispose_all_windows
    instance_variables.each do |varname|
      ivar = instance_variable_get(varname)
      if ivar.is_a?(Window)
        ivar.dispose_all_windows rescue nil
        ivar.dispose unless !ivar || ivar.disposed?
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Update global help window
  #--------------------------------------------------------------------------
  def update_global_help_window
    return if @help_window_timer == 0
    @help_window_timer -= 1 if @help_window_timer > 0
    hide_item_help_window if @help_window_timer == 0
  end
  #--------------------------------------------------------------------------
  def update_debug_window
    return unless Input.trigger?(:kF9)
    heatup_button
    window = @@overlay_windows[:debug]
    if window.visible?
      window.hide
    else
      SceneManager.process_tactic(true) unless SceneManager.tactic_enabled?
      window.show
    end
  end
  #--------------------------------------------------------------------------
  # * Raise overlay window
  #--------------------------------------------------------------------------
  def raise_overlay_window(symbol, *args)
    deactivate_all_windows(symbol)
    
    if args.size == 1 && args[0].is_a?(Hash)
      $on_exit = true if args[0][:method] == :exit
      @@overlay_windows[symbol].raise_overlay(args[0])
    else
      info      = args[0]
      method    = args[1]
      call_args = args[2]
      forced    = (args[3] || false)
      $on_exit = true if method == :exit
      @@overlay_windows[symbol].raise_overlay(info, method, call_args, forced)
    end
    SceneManager.process_tactic(true) unless SceneManager.tactic_enabled?
  end
  #--------------------------------------------------------------------------
  # * Deactivate All Windows
  #--------------------------------------------------------------------------
  def deactivate_all_windows(symbol)
    
    instance_variables.each do |varname|
      ivar = instance_variable_get(varname)
      if ivar.is_a?(Window_Selectable) && ivar.active?
        begin
          @@overlay_windows[symbol].z = [ivar.z + 1, @@overlay_windows[symbol].z].max
        rescue Exception => e
          puts "#{e}"
        ensure
          @@overlay_windows[symbol].assign_last_window(ivar)
          ivar.deactivate
        end
      end
    end
    
    @@overlay_windows.each do |sym, window|
      @@overlay_windows[symbol].z = [window.z + 1, @@overlay_windows[symbol].z].max rescue nil
    end
  end
  #--------------------------------------------------------------------------
  def find_current_active_window
    instance_variables.each do |varname|
      ivar = instance_variable_get(varname)
      if ivar.is_a?(Window_Selectable) && ivar.active?
        return ivar
      end
    end
    return nil
  end
  #--------------------------------------------------------------------------
  # * Update overlay window
  #--------------------------------------------------------------------------
  def update_overlay
    @@overlayed = false
    @@overlay_windows.each do |sym, window|
      next unless window.visible?
      @@overlayed = true
      window.update
    end
  end
  #--------------------------------------------------------------------------
  # * Start button cooldown
  #--------------------------------------------------------------------------
  def heatup_button(multipler = 1)
    @@button_cooldown = Button_CoolDown * multipler
  end
  #--------------------------------------------------------------------------
  # * Button cooldown finished
  #--------------------------------------------------------------------------
  def button_cooled?
    @@button_cooldown <= 0
  end
  #--------------------------------------------------------------------------
  # * Get Transition Speed
  #--------------------------------------------------------------------------
  def transition_speed
    return 20
  end
  #--------------------------------------------------------------------------
  # * Execute Transition
  #--------------------------------------------------------------------------
  alias perform_transition_load perform_transition
  def perform_transition
    SceneManager.destroy_loading_screen
    perform_transition_load
  end
  #--------------------------------------------------------------------------
  # * Fade Out All Sounds and Graphics
  #--------------------------------------------------------------------------
  def fadeout_all(time = 1000, no_fadeout = false)
    RPG::BGM.fade(time)
    RPG::BGS.fade(time)
    RPG::ME.fade(time)
    Graphics.fadeout(time * Graphics.frame_rate / 1000) unless no_fadeout
    RPG::BGM.stop
    RPG::BGS.stop
    RPG::ME.stop
  end
  #--------------------------------------------------------------------------
  # > Console Debug
  #--------------------------------------------------------------------------
  def update_console
    return unless Input.press?(:kCTRL)
    return unless Input.press?(:kSPACE)
    @window_input = Window_Input.new(Graphics.center_width(480), Graphics.height - 80, 480, autoscroll: true)
    loop do
      update_basic
      @window_input.update
      break if @input_string
    end
    return if @input_string.strip.empty?
    #--
    begin
      eval("GameManager." + @input_string)
    rescue NoMethodError
      eval_standard(@input_string)
    rescue SyntaxError
      eval_standard(@input_string)
    rescue Exception => err
      puts SPLIT_LINE
      debug_print err
      puts err.backtrace
    end
    @input_string = nil
  end
  #--------------------------------------------------------------------------
  def eval_standard(code)
    begin
      eval(code)
    rescue Exception => err
      puts SPLIT_LINE
      debug_print err
      puts err.backtrace
    end
    @input_string = nil
  end
  #--------------------------------------------------------------------------
  def retrieve_input(string)
    @input_string = string
  end
  #----------------------------------------------------------------------------
  def get_input
    re = @input_string
    @input_string = nil
    return re
  end
  #----------------------------------------------------------------------------
  def show_item_help_window(x, y, text = "")
    return hide_item_help_window if text == @cur_item_help_text || text.nil? || text.empty?
    hide_item_help_window
    @cur_item_help_text = text
    rect = Rect.new(2, 2, 120, 42)
    @item_help_window.x, @item_help_window.y = x, y
    @item_help_text.x, @item_help_text.y = x, y
    
    @item_help_text.bitmap.font.size = 20
    
    lines = FileManager.textwrap(text, 120, @item_help_text.bitmap)
    
    lines.each do |line|
      @item_help_text.bitmap.draw_text(rect, line, 1)
      rect.y += 12
    end
    
    @item_help_window.show
    @item_help_text.show
    @help_window_timer = 150
  end
  #-------------------------------------------------------------------------
  def hide_item_help_window
    return unless @item_help_text && @item_help_window
    @cur_item_help_text = ""
    @help_window_timer = 0
    @item_help_text.hide
    @item_help_text.bitmap.clear
    @item_help_window.hide
  end
  #--------------------------------------------------------------------------
  # * Overwrite: aDetermine if Game Is Over
  #   Transition to the game over screen if the entire party is dead.
  #--------------------------------------------------------------------------
  def check_gameover
    return unless $game_party.all_dead?(true)
    return SceneManager.goto(Scene_Gameover) if $game_system.allow_gameover?
    SceneManager.call_all_dead_rescue
  end
  #--------------------------------------------------------------------------
  def show_dim_background
    @dim_background.show if @dim_background && !@dim_background.disposed?
  end
  #--------------------------------------------------------------------------
  def hide_dim_background
    @dim_background.hide if @dim_background && !@dim_background.disposed?
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Scene_Title
#------------------------------------------------------------------------------
#  This class performs the title screen processing.
#==============================================================================
class Scene_Title < Scene_Base
  include PONY::GameMode
  #--------------------------------------------------------------------------
  # * Start Processing
  # Related script => tag: title_start
  #--------------------------------------------------------------------------
  alias start_gamemode start
  def start
    start_gamemode
    create_help_window
    create_mode_window
    create_option_window
    create_language_window
    create_progress_window
    # function calls supposed to add in MOG's animtaed title script
  end
  #-------------------------------------------------------------------------
  alias post_start_msg post_start
  def post_start
    post_start_msg
    display_plugin_message
    display_connection_message
  end
  #-------------------------------------------------------------------------
  def display_plugin_message
    # todo: fix message
    return 
    if !$plugin_loaded
      info = Vocab::Errno::PluginInitErr
    elsif PluginManager.load_error.size > 1
      info = Vocab::Errno::PluginLoadErr
      File.open("PluginErr.txt", "w") do |file|
        info.each do |err|
          file.write(err + SPLIT_LINE + 10.chr)
        end
      end
    else
      info = nil
    end
    return if info.nil?
    
    raise_overlay_window(:popinfo, info)
    loop do
      update_basic
      @@overlay_windows[:popinfo].update
      break unless @@overlay_windows[:popinfo].visible?
    end
  end
  #-------------------------------------------------------------------------
  def display_connection_message
    return if PONY.online?
    info = Vocab::Offline
    raise_overlay_window(:popinfo, info: info, time: sec_to_frame(15))
    loop do
      update_basic
      @@overlay_windows[:popinfo].update
      break unless @@overlay_windows[:popinfo].visible?
    end
  end
  #--------------------------------------------------------------------------
  # * Create Help Window
  #--------------------------------------------------------------------------
  def create_help_window
    @help_window = Window_Help.new
    @help_window.viewport = @viewport
    @help_window.z = PONY::SpriteDepth::Table[:override]
    @help_window.hide
  end
  #-------------------------------------------------------------------------
  def create_mode_window
    @mode_window = Window_GameMode.new(-12, @help_window.height - 2)
    @mode_window.set_z(PONY::SpriteDepth::Table[:override])
    @mode_window.help_window = @help_window
    @mode_window.set_handler(:ok, method(:on_mode_ok))
    @mode_window.set_handler(:cancel, method(:on_mode_cancel))
    @mode_window.hide
    @mode_window.deactivate
  end
  #-------------------------------------------------------------------------
  def create_option_window
    @option_window = Window_SystemOptions.new(@help_window)
    @option_window.set_handler(:cancel, method(:on_option_cancel))
    @option_window.set_handler(:language, method(:command_language))
    @option_window.z = PONY::SpriteDepth::Table[:override]
    @option_window.unselect
    @option_window.hide
    @option_window.deactivate
  end
  #-------------------------------------------------------------------------
  # * Overwrite: Re-arrange command order
  #-------------------------------------------------------------------------
  def create_command_window
    @command_window = Window_TitleCommand.new
    @command_window.set_handler(:continue,   method(:command_continue))
    @command_window.set_handler(:start_game, method(:command_start_game))
    @command_window.set_handler(:option,     method(:command_option))
    @command_window.set_handler(:credits,     method(:command_credits))
    @command_window.set_handler(:shutdown,   method(:command_shutdown))
  end
  #---------------------------------------------------------------------------
  def create_progress_window
    @progress_window = Window_ProgressSelection.new(0, 0)
    @progress_window.set_handler(:new_game, method(:on_start_ok))
    @progress_window.set_handler(:load_game, method(:command_load))
    @progress_window.set_handler(:cancel, method(:on_progress_cancel))
    @progress_window.set_z(PONY::SpriteDepth::Table[:override] + 2)
    @progress_window.unselect
    @progress_window.hide
    @progress_window.deactivate
  end
  #--------------------------------------------------------------------------
  def create_language_window
    ww = 400 # window width
    wh = 320 # height
    cx = Graphics.center_width(ww)
    cy = Graphics.center_height(wh)
    @language_window = Window_LanguageList.new(cx, cy, ww, wh)
    @language_window.set_handler(:ok, method(:on_language_ok))
    @language_window.set_handler(:cancel, method(:on_language_cancel))
    @language_window.z = @option_window.z + 1
    @language_window.refresh
    @language_window.hide
  end
  #--------------------------------------------------------------------------
  def command_language
    @language_window.show
    @language_window.activate
    cur_index = GameManager.get_language_setting
    cur_index = ($supported_languages.keys.find_index(cur_index) || 0)
    @language_window.select(cur_index)
  end
  #--------------------------------------------------------------------------
  def on_language_ok
    symbol = @language_window.item
    raise_overlay_window(:popinfo, Vocab::System::Restart)
    on_language_cancel
    FileManager.write_ini('Option', 'Language', symbol.to_s)
    language_index = -1
    data = @option_window.list
    data.each_index{|i| language_index = i if data[i][:symbol] == :language}
    @option_window.draw_item(language_index) if language_index > 0
  end
  #--------------------------------------------------------------------------
  def on_language_cancel
    @language_window.hide
    @language_window.deactivate
    @option_window.activate
  end
  #--------------------------------------------------------------------------
  def command_continue
    file = DataManager.latest_savefile
    if file.nil?
      return @command_window.activate
    end
    result = DataManager.load_game(file.index, file.mode)
    if result == true
      on_load_success
    else
      @@overlay_windows[:popinfo].assign_last_window(@command_window)
      case result
      when :chainfile_missing
        PONY::ERRNO.raise(:file_missing, nil, nil, "#{DataManager.make_chainfilename(@file_window.index)}")
      when :checksum_missing
        PONY::ERRNO.raise(:file_missing, nil, nil, "#{DataManager.make_hashfilename(@file_window.index)}")
      when :checksum_failed
        PONY::ERRNO.raise(:checksum_failed)
      when :bits_incorrect
        # nothing, already showed the info
      else
        info = " The version of selected file is not compatible with current game version"
        @@overlay_windows[:popinfo].raise_overlay(info)
      end
    end
    close_command_window
  end
  #--------------------------------------------------------------------------
  def on_option_cancel
    @option_window.close
    @option_window.unselect
    @option_window.deactivate
    @help_window.close
    @command_window.activate
  end
  #--------------------------------------------------------------------------
  def command_start_game
    @help_window.back_opacity = 0xff
    @help_window.swap_skin(WindowSkin::Luna)
    @help_window.open
    @command_window.deactivate
    @mode_window.activate
    @mode_window.select(0)
    @mode_window.open
  end
  #--------------------------------------------------------------------------
  def command_option
    @help_window.back_opacity = 0xc0
    @help_window.swap_skin(WindowSkin::Normal)
    @command_window.deactivate
    @help_window.open
    @option_window.open
    @option_window.activate
    @option_window.select(0)
  end
  #--------------------------------------------------------------------------
  def command_credits
    fadeout_all(1000)
    $game_temp.loading_destroy_delay = true
    init_gamemode(:credits)
    close_command_window
    $game_map.autoplay
    SceneManager.goto(Scene_Map)
  end
  #--------------------------------------------------------------------------
  def command_load
    close_command_window
    SceneManager.call(Scene_Load)
  end
  #-------------------------------------------------------------------------
  def on_start_ok
    fadeout_all(1000)
    $game_temp.loading_destroy_delay = true
    init_gamemode(@mode_window.current_data[:symbol])
    close_command_window
    $game_map.autoplay
    SceneManager.goto(Scene_Map)
  end
  #--------------------------------------------------------------------------
  def on_mode_ok
    $game_system.game_mode = @mode_window.current_item[:symbol]
    debug_print("Game mode selected: #{$game_system.game_mode}")
    @mode_window.cursor_sprite.x = 0
    @mode_window.cursor_sprite.y = 0
    @mode_window.cursor_sprite.z = @progress_window.z + 1
    @progress_window.open
    @progress_window.activate
    @progress_window.select(0)
    @help_window.clear
  end
  #--------------------------------------------------------------------------
  def on_progress_cancel
    @progress_window.deactivate
    @progress_window.close
    @progress_window.unselect
    @mode_window.cursor_sprite.z = @mode_window.z + 1
    @mode_window.update_cursor(true)
    @mode_window.activate
    @mode_window.update_help
  end
  #--------------------------------------------------------------------------
  def on_mode_cancel
    @mode_window.deactivate
    @mode_window.unselect
    @mode_window.close
    @help_window.close
    @command_window.activate
  end
  #--------------------------------------------------------------------------
  # new method: on_load_success
  #--------------------------------------------------------------------------
  def on_load_success
    $game_system.on_after_load
    SceneManager.goto(Scene_Map)
  end#--------------------------------------------------------------------------
end

#==============================================================================
# ** Scene_Map
#------------------------------------------------------------------------------
#  This class performs the map screen processing.
#==============================================================================
class Scene_Map < Scene_Base
  
  #--------------------------------------------------------------------------
  # * Public Instance Variables.                                        [NEW]
  #--------------------------------------------------------------------------
  attr_accessor :spriteset
  
  if MakerSystems::Effectus::MAP_SCENE_WINDOW_IMPROVEMENTS
    #--------------------------------------------------------------------------
    # * Update.                                                           [REP]
    #--------------------------------------------------------------------------
    def update
      if @message_window
        unless @message_window.fiber
          @message_window.dispose
          @message_window = nil
        end
      else
        if $game_message.busy? && !$game_message.scroll_mode
          create_message_window
        end
      end
      if @scroll_text_window
        unless @scroll_text_window.text
          @scroll_text_window.dispose
          @scroll_text_window = nil
        end
      else
        if $game_message.scroll_mode && $game_message.has_text?
          create_scroll_text_window
        end
      end
      if @map_name_window && @map_name_window.show_count == 0 && 
         @map_name_window.contents_opacity == 0 
        @map_name_window.dispose
        @map_name_window = nil
      end
      super
      $game_map.update(true)
      $game_player.update
      $game_timer.update
      @spriteset.update
      $game_map.update_events
      $game_map.update_vehicles
      update_scene if scene_change_ok?
    end
    #--------------------------------------------------------------------------
    # * Create All Windows
    #--------------------------------------------------------------------------
    def create_all_windows
      if @message_window
        @message_window.dispose
        @message_window = nil
      end
      if @scroll_text_window
        @scroll_text_window.dispose
        @scroll_text_window = nil
      end
      create_location_window unless $game_map.display_name.empty?
    end
    #--------------------------------------------------------------------------
    # * Preprocessing for Transferring Player
    #--------------------------------------------------------------------------
    def pre_transfer
      @map_name_window.close if @map_name_window
      case $game_temp.fade_type
      when 0
        fadeout(fadeout_speed)
      when 1
        white_fadeout(fadeout_speed)
      end
    end
    #--------------------------------------------------------------------------
    # * Post Processing for Transferring Player
    #--------------------------------------------------------------------------
    def post_transfer
      case $game_temp.fade_type
      when 0
        Graphics.wait(fadein_speed / 2)
        fadein(fadein_speed)
      when 1
        Graphics.wait(fadein_speed / 2)
        white_fadein(fadein_speed)
      end
      create_location_window unless $game_map.display_name.empty?
      @map_name_window.open if @map_name_window
    end
  else
    #--------------------------------------------------------------------------
    # * Update.                                                           [REP]
    #--------------------------------------------------------------------------
    def update
      super
      $game_map.update(true)
      $game_player.update
      $game_timer.update
      @spriteset.update
      $game_map.update_events
      $game_map.update_vehicles
      update_scene if scene_change_ok?
    end
  end
end


#==============================================================================
# ** Scene_Map
#------------------------------------------------------------------------------
#  This class performs the map screen processing.
#==============================================================================
class Scene_Map < Scene_Base
  #--------------------------------------------------------------------------
  attr_accessor :spriteset
  attr_reader :window_log
  #--------------------------------------------------------------------------
  # * Start Processing
  #--------------------------------------------------------------------------
  alias start_opt start
  def start
    @tactic_enabled = false
    start_opt
    create_tactic_cursor
    create_windows
  end
  #--------------------------------------------------------------------------
  # * Post-Start Processing
  #--------------------------------------------------------------------------
  def post_start
    super
    spriteset.restore_projectile
    $game_map.deploy_map_item_drops
    $game_map.restore_battler_fibers
  end
  #--------------------------------------------------------------------------
  def create_windows
    @window_log     = Window_InformationLog.new(SceneManager.resume_map_info)
    @status_window  = Window_TacticStatus.new
    @command_window = Window_TacticCommand.new(0,@status_window.y + @status_window.height)
    @window_help    = Window_Help.new(1)
    @window_help.y  = Graphics.height - @window_help.height
    @window_help.z  = PONY::SpriteDepth::Table[:win_info]
    @window_help.hide
    @command_window_name  = "@command_window".to_sym
    @status_window_name   = "@status_window".to_sym
    set_handlers
  end
  #--------------------------------------------------------------------------
  def set_handlers
    @command_window.set_handler(:move,      method(:command_move))
    @command_window.set_handler(:hold,      method(:command_hold))
    @command_window.set_handler(:reaction,  method(:change_reaction))
    @command_window.set_handler(:cancel,    method(:command_cancel))
  end
  #--------------------------------------------------------------------------
  # * Termination Processing
  #--------------------------------------------------------------------------
  alias terminate_scmap_dnd terminate
  def terminate
    @message_window.dispose_all_windows
    SceneManager.save_map_infos(@window_log.data)
    $game_system.change_cursor_bitmap(nil)
    $game_map.dispose_item_drops
    terminate_scmap_dnd
  end
  #--------------------------------------------------------------------------
  # * Update Frame (for Fade In)
  #--------------------------------------------------------------------------
  def update_for_fade
    update_basic            rescue nil
    $game_map.update(false)
    @spriteset.update       rescue nil
  end
  #--------------------------------------------------------------------------
  # * Update All Windows
  #--------------------------------------------------------------------------
  def update_all_windows
    instance_variables.each do |varname|
      next if varname == @command_window_name || varname == @status_window_name
      ivar = instance_variable_get(varname)
      ivar.update if ivar.is_a?(Window) && !ivar.disposed?
    end
  end
  #--------------------------------------------------------------------------
  # * Create Message Window
  # -------------------------
  #   Overwrite to fix memory leak error
  #--------------------------------------------------------------------------
  def create_message_window
    @message_window = Window_Message.new unless @message_window && !@message_window.disposed?
  end
  #--------------------------------------------------------------------------
  # * Return Spriteset
  #--------------------------------------------------------------------------
  def spriteset
    @spriteset
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Determine if Menu is Called due to Cancel Button
  #--------------------------------------------------------------------------
  def update_call_menu
    if $game_system.menu_disabled || $game_map.interpreter.running?
      @menu_calling = false
    else
      @menu_calling ||= Input.trigger?(:kESC) || Mouse.click?(3)
      @menu_calling = false if $game_system.story_mode?
      call_menu if @menu_calling && !$game_player.moving?
    end
  end
  #--------------------------------------------------------------------------
  # * Alias: Call Menu Screen
  #--------------------------------------------------------------------------
  alias call_imagemenu call_menu
  def call_menu
    Window_MenuImageCommand::init_command_position
    call_imagemenu
  end
  #----------------------------------------------------------------------------
  def create_tactic_cursor
    @tactic_cursor = Game_TacticCursor.new
    @spriteset.create_tactic_cursor(@tactic_cursor)
    $game_system.change_cursor_bitmap(PONY::IconID[:aim]) if $game_player.free_fire
  end
  #----------------------------------------------------------------------------
  # * Display info on window
  #----------------------------------------------------------------------------
  def display_info(text)
    @window_log.add_text(text)
  end
  #----------------------------------------------------------------------------
  # * Clear info
  #----------------------------------------------------------------------------
  def clear_info
    @window_log.clear
  end
  #--------------------------------------------------------------------------
  def register_battle_unit(battler)
    if @spriteset
      @spriteset.register_battle_unit(battler)
    end
  end
  #--------------------------------------------------------------------------
  def resign_battle_unit(battler)
    if @spriteset
      @spriteset.resign_battle_unit(battler)
    end
  end
  #--------------------------------------------------------------------------
  def setup_weapon_use(action)
    if @spriteset
      @spriteset.setup_weapon_use(action)
    end
  end
  #--------------------------------------------------------------------------
  def update_encounter
  end
  #--------------------------------------------------------------------------
  def update_call_debug
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Scene_Map
#------------------------------------------------------------------------------
#  This class performs the map screen processing.
#==============================================================================
# tag: tactic(Scene_Map)
class Scene_Map < Scene_Base
  #--------------------------------------------------------------------------
  attr_reader :battler      # Selected battler
  attr_reader :target       # Target selected in Phase_Selection
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  Phase_Idle            = 0   # Nothing selected
  Phase_Selected        = 1   # A battler is selected
  Phase_MoveSelection   = 2   # Move Selection
  Phase_TargetSelection = 3   # Target Selection
  #--------------------------------------------------------------------------
  # * Start Processing
  #--------------------------------------------------------------------------
  alias start_dndtactic start
  def start
    @phase = Phase_Idle
    start_dndtactic
  end
  #--------------------------------------------------------------------------
  # * alias: Frame Update
  #--------------------------------------------------------------------------
  alias update_scmap_tactic update
  def update
    if @tactic_enabled
      super
      return update_tactic
    elsif SceneManager.time_stopped?
      super
      return update_timestop
    end
    BattleManager.detect_combat
    update_scmap_tactic
  end
  #--------------------------------------------------------------------------
  # * Update for tactic mode
  #--------------------------------------------------------------------------
  def update_tactic
    return if @@overlayed
    update_tactic_cursor
    $game_map.update(false)
    @spriteset.update_timelapse
    @command_window.update if @command_window.visible?
    @status_window.update
  end
  #--------------------------------------------------------------------------
  # * Update for time stop
  #--------------------------------------------------------------------------
  def update_timestop
    return if @@overlayed
    $game_map.update(false)
    @spriteset.update_timelapse
  end
  #--------------------------------------------------------------------------
  def start_tactic
    @tactic_enabled = true
    @spriteset.show_units
  end
  #--------------------------------------------------------------------------
  def end_tactic
    @tactic_enabled = false
    @spriteset.hide_units
    hide_windows
  end
  #--------------------------------------------------------------------------
  def hide_windows
    @status_window.setup_battler(nil)
    @status_window.hide
    @window_help.hide
    @command_window.fallback
    @phase = Phase_Idle
  end
  #--------------------------------------------------------------------------
  def update_tactic_cursor
    return if @command_window.visible?
    @tactic_cursor.update
    @battler = @tactic_cursor.collide_battler?
    @status_window.setup_battler(@battler)
    process_command_handle
  end
  #--------------------------------------------------------------------------
  def process_command_handle
    return unless button_cooled?
    if Input.trigger?(:C)
      if Mouse.click?(1)
        return process_ok if !Mouse.hover_skillbar?
      else
        return process_ok
      end
    end
    return command_fallback if Input.trigger?(:B)
  end
  #--------------------------------------------------------------------------
  def process_ok
    case @phase
    when Phase_Idle
      show_command_window if $game_player.is_friend?(@status_window.battler)
    when Phase_MoveSelection
      target = @battler.nil? ? POS.new(@tactic_cursor.x, @tactic_cursor.y) : @battler
      target.x = (@tactic_cursor.x * 4 + 0.5).to_i / 4
      target.y = (@tactic_cursor.y * 4 + 0.5).to_i / 4
      do_move(target)
      command_fallback
    when Phase_TargetSelection
      @target = @battler.nil? ? POS.new(@tactic_cursor.x, @tactic_cursor.y) : @battler
      command_fallback
    end
    Sound.play_ok
    heatup_button
  end
  #--------------------------------------------------------------------------
  def command_fallback
    case @phase
    when Phase_Selected
      @command_window.fallback
      @phase = Phase_Idle
    when Phase_MoveSelection || Phase_TargetSelection
      @status_window.setup_battler(@command_window.battler)
      @tactic_cursor.relocate(@command_window.battler)
      show_command_window(@command_window.battler)
    end
  end
  #--------------------------------------------------------------------------
  def show_command_window(battler = nil)
    battler = battler.nil? ? @status_window.battler : battler
    @command_window.heatup_button
    @command_window.setup_battler(battler)
    @window_help.hide
    @status_window.refresh
    @phase = Phase_Selected
  end
  #--------------------------------------------------------------------------
  def command_move
    info = Vocab::Tactic::HelpMove
    @window_help.set_text(info)
    @window_help.show
    @command_window.hide
    @phase = Phase_MoveSelection
  end
  #--------------------------------------------------------------------------
  def command_hold
    if @status_window.battler.command_holding?
      @status_window.battler.command_follow
    else
      @status_window.battler.command_hold
    end
    show_command_window
  end
  #--------------------------------------------------------------------------
  def command_selection(info = nil)
    info = info.nil? ? Vocab::Tactic::HelpSel : info
    @window_help.set_text(info)
    @window_help.show
    @command_window.hide
    @phase = Phase_TargetSelection
  end
  #--------------------------------------------------------------------------
  def change_reaction
    char = @status_window.battler
    char.aggressive_level = (char.aggressive_level + 1) % 6
    show_command_window
  end
  #--------------------------------------------------------------------------
  def command_cancel
    Sound.play_cancel
    command_fallback
    heatup_button
  end
  #--------------------------------------------------------------------------
  def get_target
    re = @target.nil? ? nil : @target.dup
    @target = nil
    return re
  end
  #--------------------------------------------------------------------------
  def do_move(target)
    return command_fallback if @command_window.battler.nil?
    if target.is_a?(Game_Event) || target.is_a?(Game_Enemy)
      @command_window.battler.set_target(target)
      @command_window.battler.popup_info("Attack")
    else
      @command_window.battler.move_to_position(target.x, target.y, depth: 300, tool_range: 0)
      @command_window.battler.popup_info("Move")
      @command_window.battler.set_target(nil)
    end
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** Scene_MenuBase
#------------------------------------------------------------------------------
#  This class performs basic processing related to the menu screen.
#==============================================================================
class Scene_MenuBase < Scene_Base
  #------------------------------------------------------------------------------
  def current_actor
    @actor
  end
  
end

#==============================================================================
# ** Scene_Menu
#------------------------------------------------------------------------------
#  This class performs the menu screen processing.
#==============================================================================
class Scene_Menu < Scene_MenuBase
  #--------------------------------------------------------------------------
  # * Start Processing
  #--------------------------------------------------------------------------
  def start
    super
    create_command_window
    create_gold_window
    create_status_window
    create_foreground
    puts "Assign blockchian mining work"
    Thread_Assist.assign_work(:BCmine) # tag: 3
    $game_party.sync_blockchain
    if $USE_SCENE_SKIN == TRUE                                                 
      @command_window.scene_swap($PAUSE_MENU_SKIN)                             
      @gold_window.scene_swap($PAUSE_MENU_SKIN)                                
      @status_window.scene_swap($PAUSE_MENU_SKIN)                              
    end
    $game_map.cache_crash_backup
  end
  #--------------------------------------------------------------------------
  # * Termination Processing
  #--------------------------------------------------------------------------
  def terminate
    super
    dispose_foreground
    puts "Assign blockchian mining work"
    Thread_Assist.assign_work(:BCmine) # tag: 3
    $game_party.sync_blockchain
  end
  #--------------------------------------------------------------------------
  # * Create Status Window
  #--------------------------------------------------------------------------
  def create_status_window
    @status_window = Window_ImageMenuStatus.new(0 ,@command_window.height)
  end
  #--------------------------------------------------------------------------
  # * Create Foreground
  #--------------------------------------------------------------------------
  def create_foreground
    @foreground_sprite = Sprite.new
    @foreground_sprite.bitmap = Cache.UI("Menu_SplitLine")
    @foreground_sprite.y = @command_window.height - 4
    @foreground_sprite.z = PONY::SpriteDepth.layers(1)
  end
  #--------------------------------------------------------------------------
  def dispose_foreground
    return if @foreground_sprite.nil?
    @foreground_sprite.dispose
  end
  #--------------------------------------------------------------------------
  # * Create Gold Window
  #--------------------------------------------------------------------------
  def create_gold_window
    @gold_window = Window_Gold.new(0)
    @gold_window.x = Graphics.width - @gold_window.width
    @gold_window.y = (@command_window.height - @gold_window.height) / 2
  end
  #--------------------------------------------------------------------------
  # * Overwrute: Create Command Window
  #--------------------------------------------------------------------------
  def create_command_window
    @command_window = Window_MenuImageCommand.new
    @command_window.set_handler(:item,      method(:command_item))
    @command_window.set_handler(:skill,     method(:command_personal))
    @command_window.set_handler(:equip,     method(:command_personal))
    @command_window.set_handler(:status,    method(:command_personal))
    @command_window.set_handler(:formation, method(:command_formation))
    @command_window.set_handler(:save,      method(:command_save))
    @command_window.set_handler(:game_end,  method(:command_game_end))
    @command_window.set_handler(:cancel,    method(:return_scene))
    @command_window.set_handler(:quest,    method(:command_quest))
    @command_window.set_handler(:levelup,  method(:command_personal))
  end
  #--------------------------------------------------------------------------
  def command_quest  
    SceneManager.call(Scene_Quest)
  end
  #--------------------------------------------------------------------------
  # * [OK] Personal Command
  #--------------------------------------------------------------------------
  alias ok_personal_ok_dnd on_personal_ok
  def on_personal_ok
    case @command_window.current_symbol
    when :levelup
      SceneManager.call(Scene_LevelUp)
    else
      ok_personal_ok_dnd
    end
  end
  #--------------------------------------------------------------------------
end


#==============================================================================
# ** Scene_Item
#------------------------------------------------------------------------------
#  This class performs the item screen processing.
#==============================================================================
class Scene_Item < Scene_ItemBase
  include WALLPAPER_EX
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  HotkeyPauseTime  = 60
  #--------------------------------------------------------------------------
  # * Alias method: Start Processing
  #--------------------------------------------------------------------------
  alias start_dnd start
  def start
    start_dnd
    init_vars
    create_action_window
    create_skillbar
    create_foreground
  end
  #--------------------------------------------------------------------------
  def init_vars
    @hotkey_ok_pause = false
    @timer           = 0
  end
  #--------------------------------------------------------------------------
  alias update_scitemaction update
  def update
    update_scitemaction
    update_hotkey_selection if @skillbar.visible? && !@hotkey_ok_pause
    update_hotkey_timer if @hotkey_ok_pause
  end
  #--------------------------------------------------------------------------
  def update_hotkey_selection
    @skillbar.update
    assign_hotkey(@skillbar.get_monitor)
    on_hotekey_cancel if Input.trigger?(:B)
  end
  #--------------------------------------------------------------------------
  def create_action_window
    @action_window = Window_ItemAction.new
    @action_window.set_handler(:use_ok,     method(:action_use))
    @action_window.set_handler(:sel_hotkey, method(:action_hotkey))
    @action_window.set_handler(:cancel, method(:on_action_cancel))
    @action_window.z = PONY::SpriteDepth.layers(3)
    @action_window.deactivate
  end
  #--------------------------------------------------------------------------
  def create_skillbar
    @skillbar = $game_party.skillbar
    @skillbar.create_layout(@viewport, 1)
    @skillbar.refresh(@actor)
    @skillbar.hide
  end
  #--------------------------------------------------------------------------
  def create_foreground
    @foreground = Sprite.new(@viewport)
    @foreground.bitmap = Bitmap.new(Graphics.width, Graphics.height)
    wy = @help_window.height
    @foreground.bitmap.fill_rect(0, wy, Graphics.width, Graphics.height - wy, DND::COLOR::Black)
    cx = @skillbar.x + 32 * 4
    cy = @skillbar.y - 2
    crect = Rect.new(cx, cy, 32 * HotKeys::HotKeys.size, 32)
    @foreground.bitmap.clear_rect(crect)
    @foreground.z = PONY::SpriteDepth::Table[:foreground]
    @foreground.opacity = 196
    @foreground.hide
  end
  #--------------------------------------------------------------------------
  def update_hotkey_timer
    @timer += 1
    if @timer >= HotkeyPauseTime
      on_hotkey_end
      @timer = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Item [OK]
  #--------------------------------------------------------------------------
  def on_item_ok
    $game_party.last_item.object = item
    show_action_window
  end
  #--------------------------------------------------------------------------
  # * On action cancel
  #--------------------------------------------------------------------------
  def on_action_cancel
    hide_action_window(true)
  end
  #--------------------------------------------------------------------------
  def on_hotekey_cancel
    @skillbar.hide
    @foreground.hide
    on_action_cancel
    Sound.play_cancel
  end
  #--------------------------------------------------------------------------
  def show_action_window
    @action_window.x = [@item_window.cursor_rect.x + @action_window.width, Graphics.width - @action_window.width].min
    @action_window.y = @item_window.cursor_rect.y + @item_window.y
    @action_window.show.activate(item)
    @action_window.select(0)
  end
  #--------------------------------------------------------------------------
  def hide_action_window(reactive = false)
    @action_window.hide.deactivate
    activate_item_window if reactive
  end
  #--------------------------------------------------------------------------
  def action_use
    hide_action_window
    determine_item
  end
  #--------------------------------------------------------------------------
  def action_hotkey
    hide_action_window
    @help_window.clear
    @help_window.set_text(Vocab::Skillbar::SelHelp)
    @skillbar.show
    @foreground.show
    @skillbar.refresh
  end
  #--------------------------------------------------------------------------
  def assign_hotkey(index)
    return unless index
    @actor.assigned_hotkey[HotKeys.assigned_hotkey_index(index)] = item
    @skillbar.refresh
    on_hotkey_ok(index)
  end
  #--------------------------------------------------------------------------
  def on_hotkey_ok(index)
    Sound.play_ok
    keyname = HotKeys.name(HotKeys::SkillBar[index])
    info = sprintf(Vocab::Skillbar::SelSucc, item.name, keyname)
    @help_window.set_text(info)
    @hotkey_ok_pause = true
  end
  #--------------------------------------------------------------------------
  def on_hotkey_end
    @hotkey_ok_pause = false
    @skillbar.hide
    @foreground.hide
    on_action_cancel
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Create Item Window
  #--------------------------------------------------------------------------
  def create_item_window
    wy = @category_window.y + @category_window.height
    wh = Graphics.height - wy
    @item_window = Window_ItemList.new(0, wy, Graphics.width, wh)
    @item_window.viewport = @viewport
    @item_window.help_window = @help_window
    @item_window.set_handler(:ok,       method(:on_item_ok))
    @item_window.set_handler(:cancel,   method(:on_item_cancel))
    @item_window.set_handler(:next_actor, method(:next_actor))
    @item_window.set_handler(:prev_actor, method(:prev_actor))
    @category_window.item_window = @item_window
  end
  #--------------------------------------------------------------------------
  def next_actor
    return unless @skillbar.visible?
    super
  end
  #--------------------------------------------------------------------------
  def prev_actor
    return unless @skillbar.visible?
    super
  end
  #--------------------------------------------------------------------------
  def on_actor_change
    @item_window.actor = @actor
    @skillbar.refresh(@actor)
  end
  #--------------------------------------------------------------------------
  alias terminate_scitemaction terminate
  def terminate
    @action_window.dispose
    @skillbar.dispose_layout
    @foreground.dispose
    terminate_scitemaction
  end
end

#==============================================================================
# ** Scene_Skill
#------------------------------------------------------------------------------
#  This class performs skill screen processing. Skills are handled as items for
# the sake of process sharing.
#==============================================================================
class Scene_Skill < Scene_ItemBase
  include WALLPAPER_EX
  #--------------------------------------------------------------------------
  # * Constants
  #--------------------------------------------------------------------------
  HotkeyPauseTime  = 60
  #--------------------------------------------------------------------------
  # * Alias method: Start Processing
  #--------------------------------------------------------------------------
  alias start_dnd start
  def start
    start_dnd
    init_vars
    create_action_window
    create_skillbar
    create_foreground
  end
  #--------------------------------------------------------------------------
  def init_vars
    @hotkey_ok_pause = false
    @timer           = 0
  end
  #--------------------------------------------------------------------------
  alias update_scitemaction update
  def update
    update_scitemaction
    update_hotkey_selection if @skillbar.visible? && !@hotkey_ok_pause
    update_hotkey_timer if @hotkey_ok_pause
  end
  #--------------------------------------------------------------------------
  def update_hotkey_selection
    @skillbar.update
    assign_hotkey(@skillbar.get_monitor)
    on_hotekey_cancel if Input.trigger?(:B)
  end
  #--------------------------------------------------------------------------
  def create_action_window
    @action_window = Window_ItemAction.new
    @action_window.set_handler(:use_ok,     method(:action_use))
    @action_window.set_handler(:sel_hotkey, method(:action_hotkey))
    @action_window.set_handler(:cancel, method(:on_action_cancel))
    @action_window.z = PONY::SpriteDepth.layers(2)
    @action_window.deactivate
  end
  #--------------------------------------------------------------------------
  def create_skillbar
    @skillbar = $game_party.skillbar
    @skillbar.create_layout(@viewport, 1)
    @skillbar.refresh(@actor)
    @skillbar.hide
  end
  #--------------------------------------------------------------------------
  def create_foreground
    @foreground = Sprite.new(@viewport)
    @foreground.bitmap = Bitmap.new(Graphics.width, Graphics.height)
    wy = @help_window.height
    @foreground.bitmap.fill_rect(0, wy, Graphics.width, Graphics.height - wy, DND::COLOR::Black)
    cx = @skillbar.x + 32 * 4
    cy = @skillbar.y - 2
    crect = Rect.new(cx, cy, 32 * HotKeys::HotKeys.size, 32)
    @foreground.bitmap.clear_rect(crect)
    @foreground.z = PONY::SpriteDepth::Table[:foreground]
    @foreground.opacity = 196
    @foreground.hide
  end
  #--------------------------------------------------------------------------
  def update_hotkey_timer
    @timer += 1
    if @timer >= HotkeyPauseTime
      on_hotkey_end
      @timer = 0
    end
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Item [OK]
  #--------------------------------------------------------------------------
  def on_item_ok
    $game_party.last_item.object = item
    show_action_window
  end
  #--------------------------------------------------------------------------
  # * On action cancel
  #--------------------------------------------------------------------------
  def on_action_cancel
    hide_action_window(true)
  end
  #--------------------------------------------------------------------------
  def on_hotekey_cancel
    @skillbar.hide
    @foreground.hide
    on_action_cancel
    Sound.play_cancel
  end
  #--------------------------------------------------------------------------
  def show_action_window
    @action_window.x = [@item_window.cursor_rect.x + @action_window.width, Graphics.width - @action_window.width].min
    @action_window.y = @item_window.cursor_rect.y + @item_window.y
    @action_window.show.activate(item)
    @action_window.select(0)
  end
  #--------------------------------------------------------------------------
  def hide_action_window(reactive = false)
    @action_window.hide.deactivate
    activate_item_window if reactive
  end
  #--------------------------------------------------------------------------
  def action_use
    hide_action_window
    determine_item
  end
  #--------------------------------------------------------------------------
  def action_hotkey
    hide_action_window
    @help_window.clear
    @help_window.set_text(Vocab::Skillbar::SelHelp)
    @skillbar.show
    @foreground.show
    @skillbar.refresh
  end
  #--------------------------------------------------------------------------
  def assign_hotkey(index)
    return unless index
    @actor.assigned_hotkey[HotKeys.assigned_hotkey_index(index)] = item
    @skillbar.refresh
    on_hotkey_ok(index)
  end
  #--------------------------------------------------------------------------
  def on_hotkey_ok(index)
    Sound.play_ok
    keyname = HotKeys.name(HotKeys::SkillBar[index])
    info = sprintf(Vocab::Skillbar::SelSucc, item.name, keyname)
    @help_window.set_text(info)
    @hotkey_ok_pause = true
  end
  #--------------------------------------------------------------------------
  def on_hotkey_end
    @hotkey_ok_pause = false
    @skillbar.hide
    @foreground.hide
    on_action_cancel
  end
  #--------------------------------------------------------------------------
  alias terminate_scitemaction terminate
  def terminate
    @action_window.dispose
    @skillbar.dispose_layout
    @foreground.dispose
    terminate_scitemaction
  end
end


#==============================================================================
# ** Scene_Status
#------------------------------------------------------------------------------
#  This class performs the status screen processing.
#==============================================================================
class Scene_Status < Scene_MenuBase
end



#==============================================================================
# ** Scene_Load
#------------------------------------------------------------------------------
#  This class performs load screen processing. 
#==============================================================================
class Scene_Load < Scene_File
  #--------------------------------------------------------------------------
  # * Get File Index to Select First
  #--------------------------------------------------------------------------
  def first_savefile_index
    DataManager.latest_savefile_index($game_system.game_mode)
  end
end


#==============================================================================
# ** Scene_Shop
#------------------------------------------------------------------------------
#  This class performs shop screen processing.
#==============================================================================
class Scene_Shop < Scene_MenuBase
  #--------------------------------------------------------------------------
  # * Instance Vars
  #--------------------------------------------------------------------------
  attr_accessor :shopname
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize
    super
    @shopname = "Shop"
  end
  #--------------------------------------------------------------------------
  # * Execute Purchase
  #  >> source is the bits payer, recipient is who take the bita
  #      thus source will gain the item, recipient will lose item.
  #--------------------------------------------------------------------------
  def do_buy(number)
    bits      = number * buying_price
    source    = Vocab::Player
    recipient = Vocab::Coinbase
    info      = sprintf("%s bought %s(%d) at %s.", $game_party.leader.name, @item.name, number, @shopname)
    BlockChain.new_transaction(bits, @item, number, source, recipient, info)
    $game_party.gain_item_origin(@item, number)
  end
  #--------------------------------------------------------------------------
  # * Execute Sale
  #--------------------------------------------------------------------------
  def do_sell(number)
    bits      = number * selling_price
    source    = Vocab::Coinbase
    recipient = Vocab::Player
    info      = sprintf("%s bought %s(%d) from %s.",$game_party.leader.name, @item.name, number, @shopname)
    BlockChain.new_transaction(bits, @item, number, source, recipient, info)
    $game_party.gain_item_origin(@item, -number)
  end
  #--------------------------------------------------------------------------
  # * Buy [OK]
  #--------------------------------------------------------------------------
  def on_buy_ok
    @item = @buy_window.item
    sync_blockchain
    @buy_window.hide
    @number_window.set(@item, max_buy, buying_price, currency_unit)
    @number_window.show.activate
  end
  #--------------------------------------------------------------------------
  # * Sell [OK]
  #--------------------------------------------------------------------------
  def on_sell_ok
    @item = @sell_window.item
    sync_blockchain
    @status_window.item = @item
    @category_window.hide
    @sell_window.hide
    @number_window.set(@item, max_sell, selling_price, currency_unit)
    @number_window.show.activate
    @status_window.show
  end
  #--------------------------------------------------------------------------
  # * Synchronize BlockChain
  #--------------------------------------------------------------------------
  def sync_blockchain
    BlockChain.recover_nodes
    $game_party.sync_blockchain(@item)
  end
  
end





# tag: test
class Scene_Test < Scene_Base
  def post_start
    super
    create_background
    create_layer
    create_all_window
    @se_timer = 0
  end
  
  
  def start
    super
    $sprite = Sprite.new(@viewport)
    $sprite.z = 1000
    # test_sum
    # test_fi
  end
  
  def test_sum
    puts "===========Test1========="
    len = 10000000
    ar = []
    len.times{|_| ar << (rand() * 100).to_i}
    t1 = Time.now
    p 'start'
    p PONY::API::SumArray.call(len, ar.pack("l*"))
    t2 = Time.now
    puts "DLL: #{(t2-t1).to_s}"
    p ar.inject(0){|r,i| r + i}
    puts "Ruby: #{(Time.now - t2).to_s}"
  end

  def test_fi
    puts "===========Test2========="
    len = 30
    t1 = Time.now
    p 'start'
    p PONY::API::Fiboncci.call(len)
    t2 = Time.now
    puts "DLL: #{(t2 - t1).to_s}"
    p fiboncci_rb(len)
    puts "Ruby: #{(Time.now - t2).to_s}"
  end
  
  def fiboncci_rb(n)
    return 1 if n < 2
    return fiboncci_rb(n-1) + fiboncci_rb(n-2)
  end

  def create_background
    @background = Sprite.new(@viewport)
    @background.bitmap = Bitmap.new(Graphics.width, Graphics.height)
    color = Color.new(255, 255, 255)
    @background.bitmap.fill_rect(0, 0, Graphics.width, Graphics.height, color)
    @background.z = 0
  end
  
  def create_all_window
    @window_input = Window_Input.new(Graphics.center_width(480), Graphics.center_height(28) - 24, 480, autoscroll: true, number: false, dim_background: true, title: "Please enter something~")
    #@window_input = Window_Input.new(Graphics.center_width(480), Graphics.center_height(28) + 24, 480, autoscroll: true)
  end
  
  def update
    super
    if Input.trigger?(:kF5)
      @window_input.dispose   unless @window_input.disposed?
      create_all_window
    end
    process_input
    #Sound.low_hp if @se_timer == 0
    @se_timer += 1
    @se_timer = 0 if @se_timer >= 65
  end
  
  def process_input
    return unless @input_string
    if @input_string.start_with?("eval")
      begin 
        eval(@input_string.split('eval').at(1))
      rescue Exception => e
        p e
      end
    end
    
    @input_string = nil
  end
  
  
  def draw_text(*args)
    @window_debug.draw_text(*args)
  end
  
  def create_layer
    @layer = Sprite.new(@viewport)
    @layer.bitmap = Bitmap.new(Graphics.width, Graphics.height)
    text = "Press F5 to show Input Window"
    cx = (Graphics.width - text.size * 10) /2
    @layer.bitmap.draw_text(cx, 20, 400, 24, text)
  end
  
  def terminate
    super
    @layer.dispose
    @background.dispose
    $sprite.dispose
  end
  
end

#==============================================================================
# ** Scene_Tactic
#------------------------------------------------------------------------------
#  This class to edit AI's combat tactic logic
#==============================================================================
class Scene_Tactic < Scene_MenuBase
  #--------------------------------------------------------------------------
  # * Start Processing
  #--------------------------------------------------------------------------
  def start
    super
    create_all_windows
    @command_list.activate
  end
  #--------------------------------------------------------------------------
  # * Create Background
  #--------------------------------------------------------------------------
  def create_background
    @background_sprite = Sprite.new
    @background_sprite.bitmap = Cache.background("Canterlot_Room")
  end
  #--------------------------------------------------------------------------
  # * Create All Windows
  #--------------------------------------------------------------------------
  def create_all_windows
    create_status_window
    create_list_window
    create_action_window
    create_item_window
    create_hint_window
    create_help_window
    create_info_window
  end
  #--------------------------------------------------------------------------
  def create_status_window
    @status_window = Window_StatusActor.new(0, 0)
    @status_window.actor = @actor
  end
  #--------------------------------------------------------------------------
  # tag: command (Scene_Tactic
  #--------------------------------------------------------------------------
  def create_list_window
    @command_list = Window_TacticList.new(0, @status_window.height)
    @command_list.actor = @actor
    @command_list.set_handler(:ok,      method(:on_command_ok))
    @command_list.set_handler(:cancel,  method(:return_scene))
    @command_list.set_handler(:pagedown, method(:next_actor))
    @command_list.set_handler(:pageup,   method(:prev_actor))
    @command_list.set_handler(:on_dragging_ok, method(:dragging_start))
    @command_list.set_handler(:on_dragging_cancel, method(:dragging_end))
    @command_list.refresh
    @command_list.select(0)
  end
  #--------------------------------------------------------------------------
  def create_action_window
     @action_window = Window_TacticAction.new
     @action_window.set_handler(:call_delete, method(:on_action_delete))
     @action_window.set_handler(:targeting, method(:on_action_ok))
     @action_window.set_handler(:fighting,  method(:on_action_ok))
     @action_window.set_handler(:self,      method(:on_action_ok))
     @action_window.set_handler(:item,      method(:on_action_ok))
     @action_window.set_handler(:skill,     method(:on_action_ok))
     @action_window.set_handler(:general,   method(:on_action_ok))
     @action_window.set_handler(:cancel,    method(:on_action_cancel))
  end
  #--------------------------------------------------------------------------
  def create_item_window
    @item_window = Window_TacticItemList.new(0, 0, 300, 240)
    @item_window.set_handler(:ok, method(:on_item_ok))
    @item_window.set_handler(:cancel, method(:on_item_return))
    @action_window.item_window = @item_window
    @item_window.x = @command_list.width - @item_window.width - 4  
    @item_window.y = @command_list.y
    @item_window.hide
  end
  #--------------------------------------------------------------------------
  def create_help_window
    @help_window = Window_Base.new(0,0, Graphics.width, @status_window.fitting_height(2))
    @help_window.swap_skin(Cache.system(WindowSkin::Applejack))
    @help_window.y = [(@status_window.height - @help_window.height), 0].max / 2
    ry = (@help_window.height - @help_window.line_height*2) / 2
    rect = Rect.new(0, ry, Graphics.width, @help_window.line_height)
    @help_window.draw_text(rect, Vocab::Tactic::SwapHelp, 1)
    @help_window.hide
  end
  #--------------------------------------------------------------------------
  def create_hint_window
    wx, wy = @status_window.width, 0
    ww, wh = Graphics.width - wx, @status_window.height
    @hint_window = Window_Base.new(wx,wy,ww,wh)
    cw = @hint_window.contents_width
    lines = FileManager.textwrap(Vocab::Tactic::Help, cw, @hint_window.contents)
    ty = (wh - @hint_window.line_height * (lines.size + 1)) / 2
    rect  = Rect.new(0, ty,ww, @hint_window.line_height)
    lines.each do |line|
      @hint_window.draw_text(rect, line, 0)
      rect.y += @hint_window.line_height
    end
  end
  #--------------------------------------------------------------------------
  def create_info_window
    @info_window = Window_TacticInfo.new(0, 0)
    @info_window.swap_skin(Cache.system(WindowSkin::Luna))
    @info_window.set_handler(:ok, method(:on_info_return))
    @info_window.set_handler(:cancel, method(:on_info_return))
    @info_window.contents_opacity = 0xff
    @info_window.refresh
  end
  #--------------------------------------------------------------------------
  def on_command_ok
    @action_window.activate(@command_list.item, @actor)
    rect = @command_list.item_rect(@command_list.index)
    @action_window.x = [(rect.x + rect.width) / 2, Graphics.width - @action_window.width].min
    @action_window.y = [[@command_list.y + rect.y - @command_list.oy + 2, 0].max, Graphics.height - @action_window.height - 2].min
    @action_window.show
    @action_window.select(0)
    @item_window.init(@command_list.data)
  end
  #--------------------------------------------------------------------------
  def on_action_delete
    cmd = @action_window.command
    @command_list.data.delete(cmd)
    @command_list.apply_tactic_change
    @action_window.unselect
    @action_window.hide
    @command_list.refresh
    @command_list.activate
  end
  #--------------------------------------------------------------------------
  def on_action_ok
    @action_window.unselect
    @action_window.hide
    @item_window.show
    @item_window.refresh
    @item_window.activate
    @item_window.select(0)
  end
  #--------------------------------------------------------------------------
  def on_action_cancel
    if @action_window.symbol.nil?
      @action_window.unselect
      @action_window.hide
      @command_list.activate
    end
  end
  #--------------------------------------------------------------------------
  def on_item_ok
    @command_list.apply_tactic_change
    on_item_return
  end
  #--------------------------------------------------------------------------
  def on_item_return
    @item_window.unselect
    @item_window.hide
    @command_list.refresh
    @command_list.activate
  end
  #--------------------------------------------------------------------------
  def call_info_window
    @last_active_window = find_current_active_window
    @last_active_window.deactivate
    @info_window.activate
    @info_window.show
  end
  #--------------------------------------------------------------------------
  def on_info_return
    @info_window.deactivate
    @info_window.hide
    @last_active_window.activate
    @last_active_window = nil
  end
  #--------------------------------------------------------------------------
  def dragging_start
    @help_window.show
  end
  #--------------------------------------------------------------------------
  def dragging_end
    @help_window.hide
  end
  #--------------------------------------------------------------------------
  # * Termination Processing
  #--------------------------------------------------------------------------
  def terminate
    super
  end
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  def update
    super
    update_hint_calling
  end
  #--------------------------------------------------------------------------
  def update_hint_calling
    return unless button_cooled?
    if Input.trigger?(:kF4) && !Input.press?(:kALT)
      @info_window.visible? ? on_info_return : call_info_window
      heatup_button
    end
  end
  #--------------------------------------------------------------------------
  # * Change Actors
  #--------------------------------------------------------------------------
  def on_actor_change
    @command_list.actor = @actor
    @status_window.actor = @actor
    @status_window.refresh
    @command_list.refresh
    @command_list.activate
    @command_list.select(0)
  end
end

#==============================================================================
# ** Scene_LevelUp
#------------------------------------------------------------------------------
#  Handles all advancing stuff when leveling
#==============================================================================
class Scene_LevelUp < Scene_MenuBase
  #--------------------------------------------------------------------------
  BackgroundFilename = "Tree_of_Harmony"
  #--------------------------------------------------------------------------
  # * Start Processing
  #--------------------------------------------------------------------------
  def start
    super
    create_help_window
    create_command_window
    create_status_window
    create_index_window
    create_index_help_window
  end
  #--------------------------------------------------------------------------
  # * Create Command Window
  #--------------------------------------------------------------------------
  def create_command_window
    @command_window = Window_LevelUpCommands.new(0, @help_window.height, @actor)
    @command_window.viewport = @viewport
    @command_window.help_window = @help_window
    @command_window.set_handler(:levelup,   method(:command_levelup))
    @command_window.set_handler(:cancel,    method(:return_scene))
    @command_window.set_handler(:pagedown, method(:next_actor))
    @command_window.set_handler(:pageup,   method(:prev_actor))
    set_skilltree_handlers
  end
  #--------------------------------------------------------------------------
  def create_index_help_window
    @index_help = Window_Help.new(11, @index_window.width / 2)
    @index_help.x, @index_help.y = @index_help.width, @index_window.y
    @index_help.swap_skin(WindowSkin::Luna)
    @index_help.hide
    @index_window.help_window = @index_help
    @index_window.refresh
  end
  #--------------------------------------------------------------------------
  def set_skilltree_handlers
    syms = [:unique, :race, :class, :dualclass]
    syms.each do |sym|
      @command_window.set_handler(sym, method(:command_skilltree))
    end
  end
  #--------------------------------------------------------------------------
  # * Create Status Window
  #--------------------------------------------------------------------------
  def create_status_window
    y = @help_window.height
    @status_window = Window_SkillStatus.new(@command_window.width, y)
    @status_window.viewport = @viewport
    @status_window.actor = @actor
  end
  #--------------------------------------------------------------------------
  def create_index_window
    cy = @status_window.y + @status_window.height
    cw = Graphics.width
    ch = Graphics.height - cy
    @index_window = Window_LevelUpIndex.new(0, cy, cw, ch, @actor)
    @index_window.set_handler(:on_levelup_finish, method(:levelup_ok))
    @index_window.set_handler(:cancel, method(:on_index_cancel))
    @index_window.set_handler(:on_feat_ok, method(:on_index_cancel))
  end
  #--------------------------------------------------------------------------
  def command_levelup
    @index_window.set_category(:levelup)
    @index_window.select(0)
    @index_help.show
  end
  #--------------------------------------------------------------------------
  def on_index_cancel
    @index_window.set_category(:main)
    @index_window.deactivate
    @index_window.unselect
    @index_help.hide
    @command_window.activate
  end
  #--------------------------------------------------------------------------
  def command_skilltree
    @command_window.activate  # undefined
  end
  #--------------------------------------------------------------------------
  def levelup_ok
    [@command_window, @status_window].each{|w| w.refresh}
    
    if @actor.queued_levelings.empty?
      on_index_cancel
    else
      @actor.queued_levelings.each do |sid|
        info = Vocab::Leveling::SelectFeat + ' ' + $data_skills[sid].description
        @help_window.set_text(info)
        @index_window.make_feat_commands(sid)
        @index_window.set_category(:select_feat)
      end
      @actor.queued_levelings.clear
    end
  end
  #--------------------------------------------------------------------------
  # * Create Background
  #--------------------------------------------------------------------------
  def create_background
    @background_sprite = Sprite.new
    @background_sprite.bitmap = Cache.background(BackgroundFilename)
  end
  #--------------------------------------------------------------------------
  # * Change Actors
  #--------------------------------------------------------------------------
  def on_actor_change
    @command_window.actor = @actor
    @status_window.actor = @actor
    @index_window.actor = @actor
    @command_window.activate
  end
  #--------------------------------------------------------------------------
end # last work: leveling >> add tags to each skill and score ability improve

#==============================================================================
# ** Scene_Creation
#------------------------------------------------------------------------------
#  Character Creation Scene, cannot be returned
#==============================================================================
# tag: queued
class Scene_Creation < Scene_MenuBase
  #--------------------------------------------------------------------------
  BackgroundFilename = "Tree_of_Harmony"
  #--------------------------------------------------------------------------
  # * Start Processing
  #--------------------------------------------------------------------------
  def start
    super
    create_help_window
    create_command_window
    create_status_window
    create_index_window
  end
  #--------------------------------------------------------------------------
  # * Create Command Window
  #--------------------------------------------------------------------------
  def create_command_window
    @command_window = Window_LevelUpCommands.new(0, @help_window.height, @actor)
    @command_window.viewport = @viewport
    @command_window.help_window = @help_window
    @command_window.set_handler(:levelup,   method(:command_levelup))
    #@command_window.set_handler(:cancel,    method(:return_scene))
    set_skilltree_handlers
  end
  #--------------------------------------------------------------------------
  def set_skilltree_handlers
    syms = [:unique, :race, :class, :dualclass]
    syms.each do |sym|
      @command_window.set_handler(sym, method(:command_skilltree))
    end
  end
  #--------------------------------------------------------------------------
  # * Create Status Window
  #--------------------------------------------------------------------------
  def create_status_window
    y = @help_window.height
    @status_window = Window_SkillStatus.new(@command_window.width, y)
    @status_window.viewport = @viewport
    @status_window.actor = @actor
  end
  #--------------------------------------------------------------------------
  def create_index_window
    cy = @status_window.y + @status_window.height
    cw = Graphics.width
    ch = Graphics.height - cy
    @index_window = Window_LevelUpIndex.new(0, cy, cw, ch, @actor)
  end
  #--------------------------------------------------------------------------
  def command_levelup
    @command_window.activate  # undefined
  end
  #--------------------------------------------------------------------------
  def command_skilltree
    @command_window.activate  # undefined
  end
  #--------------------------------------------------------------------------
  # * Create Background
  #--------------------------------------------------------------------------
  def create_background
    @background_sprite = Sprite.new
    @background_sprite.bitmap = Cache.background(BackgroundFilename)
  end
end

#==============================================================================
# ** Scene_Vancian
#------------------------------------------------------------------------------
#  Scene for prepare vancian spells
#==============================================================================
# last work: spell book
class Scene_Vancian < Scene_MenuBase
  #--------------------------------------------------------------------------
  BackgroundImage       = "StarSwirl_Archive"
  SpellbookImage        = "spellbook"
  SpellLevelTagImage    = "booktag"
  SpellLevelTagOutline  = "booktag_outline"
  #--------------------------------------------------------------------------
  # * start
  #--------------------------------------------------------------------------
  def start
    super
    create_all_windows
  end
  #--------------------------------------------------------------------------
  def create_background
    @background_sprite = Sprite.new
    @background_sprite.bitmap = Cache.background(BackgroundImage)
  end
  #--------------------------------------------------------------------------
  def create_all_windows
    create_help_window
    create_spellbook
  end
  #--------------------------------------------------------------------------
  def create_help_window
    @help_window = Window_Help.new
    @help_window.swap_skin(WindowSkin::Spellbook)
  end
  #--------------------------------------------------------------------------
  def create_spellbook
    @layout    = ::Sprite.new
    @layout.bitmap = Cache.UI(SpellbookImage)
    ww, wh = @layout.bitmap.width, @layout.bitmap.height
    wx, wy = Graphics.center_width(ww), Graphics.height - wh + @help_window.height
    @spellbook = Window_MouseUIBase.new(wx, wy, ww, wh)
    @spellbook.swap_skin(WindowSkin::Empty)
    @spellbook.help_window = @help_window
  end
  #--------------------------------------------------------------------------
end

#============================================================================
# * Game System
#============================================================================
class Game_System
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :console_list            # Inputed console list
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias initialize_console initialize
  def initialize
    @console_list = []
    initialize_console
  end
  #--------------------------------------------------------------------------
  # * Push new console command to record list
  #--------------------------------------------------------------------------
  def push_console(text)
    
    @console_list.unshift(text)
    @console_list.uniq!
    @console_list.pop if @console_list.size >= 10
  end
  #=================================================
  # *) General console setting
  #=================================================
  def console(command = "")
    
    identified = false
    allow_eval_code = false
    if command.include?("RPG::Global")
      command = command.split(">>")
      prefix = "$"
      identified = true
    elsif command.include?("PONY::Eval")
      command = command.split(">>")
      prefix = ""
      identified = true
      allow_eval_code = true
    else
      command = command.split(":")
      prefix = "GameManager."
      identified = true
    end
    
    execute_command = command[1]
    
    if execute_command.nil? || !identified
      info = "No command input!"
    elsif execute_command.include?("$") && !allow_eval_code
      info = "Invailed command!"
    else
      executable = false
      for method in GameManager.singleton_methods
        executable = true if command[1].split('(').at(0) == method.to_s
      end
      
      if executable && !allow_eval_code
        values = command[1].tr('()','')
        executable = values.split(',').size < 3
      end
      
      if executable || allow_eval_code
        execute_command = prefix + execute_command
        info = "success! #{execute_command}"
        begin
          puts "Eval: #{execute_command}"
          eval(execute_command)
        rescue Exception => e
          info = e
          puts e.backtrace
        end
      else
        info = "Invailed command!"
      end
    end
    
    info = info.to_s
    info = info.match("success") ? "Info: " + info : "Error: " + info
    SceneManager.display_info(info)
  end
  
end
#===============================================================================
# * GameMaanger
#===============================================================================
module GameMaanger
  module_function
  #----------------------------------------------------------------------------
  def AddBits(amount, useless = 0)
    bits = $game_party.gold # tag: queued >> security PONY.DecInt($game_party.gold(true))
    amount = [[amount, 1000000 - bits].min, 0].max
    if bits >= 1000000
      SceneManager.display_info("You can only AddBits when you have less than 1M Bits.")
      return
    end
    $game_party.gain_gold(amount)
  end
  #----------------------------------------------------------------------------
  def SetCurrentXP(value = 100, useless = 0)
    $game_party.members.each do |battler|
      battler.change_exp(value,true)
    end
  end
  #----------------------------------------------------------------------------
  def MakeItem(id = 1,amount = 1)
    $game_party.gain_item($data_items[id],amount, false, Vocab::Coinbase, "Console: MakeItem")
  end
  
  alias CreateItem MakeItem;
  alias AddItem    MakeItem;
  #----------------------------------------------------------------------------
  def MakeWeapon(id = 1,amount = 1)
    $game_party.gain_item($data_weapons[id],amount, false, Vocab::Coinbase, "Console: MakeWeapon")
  end
  
  alias CreateWeapon MakeWeapon;
  #----------------------------------------------------------------------------
  def MakeArmor(id = 1,amount = 1)
    $game_party.gain_item($data_armors[id],amount, false, Vocab::Coinbase, "Console: MakeArmor")
  end
  
  alias CreateArmor MakeArmor;
  #----------------------------------------------------------------------------
  def RecoverAll
    $game_party.members.each do |battler|
      battler.recover_all
    end
    #YES.recover_stamina
  end
  #----------------------------------------------------------------------------
  def SaveFile
    SceneManager.call(Scene_Save)
  end
  #----------------------------------------------------------------------------
  def LoadFile
    SceneManager.call(Scene_Load)
  end
  #----------------------------------------------------------------------------
  def Move(dir)
    case dir
    when 2; $game_player.move_poll += [[2,true]]
    when 4; $game_player.move_poll += [[4,true]]
    when 6; $game_player.move_poll += [[6,true]]
    when 8; $game_player.move_poll += [[8,true]]
    else SceneManager.display_info("Invailed Command!")
    end
  end
  #----------------------------------------------------------------------------
  def Teleport(map_id = 27 ,x = 4,y = 3)
    params = [0, map_id, x, y, 2, 2]
    $game_map.interpreter.command_201(params)
    $game_temp.loading_destroy_delay = false
    SceneManager.destroy_loading_screen
  end
  #----------------------------------------------------------------------------
  def ShowBallon(id = 1)
    $game_player.csca_balloon_id = id
  end
  #----------------------------------------------------------------------------
  def EvalFile
    file = File.new("Eval.txt",'r')
    while (line = file.gets)
      eval(line)
    end
    file.close
  end
  #----------------------------------------------------------------------------
  def ShowObjectCollection(cls = nil)
    objects = cls ? ObjectSpace.each_object(cls) : ObjectSpace.each_object
    filename = "objrecord_substring.txt"
    File.open(filename, 'w') do |file|
      objects.each do |obj|
        next if obj.is_a?(String)
        file.write("#{obj.class} #{obj} #{obj.inspect}" + 10.chr) rescue " (UTF-16 text) "
      end
    end
    SceneManager.display_info("Objects have been output to #{filename}")
  end
  #----------------------------------------------------------------------------
  def Performance
    ch_sp  = "Character Sprites: #{SceneManager.spriteset.character_sprites.size}"
    ev_num = "Events Avaliable: #{$game_map.events.size}" 
    infos = [ch_sp, ev_num]
    for info in infos
      SceneManager.display_info(info)
    end
  end
  #----------------------------------------------------------------------------
  def PickupAllDrops
    $game_map.item_drops[$game_map.map_id].each do |loot|
      loot.process_pickup
    end
  end
  #----------------------------------------------------------------------------
  def SuperDuperKillingParty
    $game_map.enemies.each{|e| e.die} until $game_map.enemies.size == 0
  end
  #----------------------------------------------------------------------------
end

=begin
╔════╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═════╗
║ ╔══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╗ ║
╠─╣                        Q:How to use?                                     ╠─╣
╠─╣                                                                          ╠─╣
╠─╣    A:Use script call: (character/event).move_to_position(x,y)            ╠─╣
╠─╣                                                                          ╠─╣
╠─╣    For example, if you want a event chase the plyer, use:                ╠─╣
╠─╣$game_map.events[@event_id].move_to_position($game_player.x,$game_player.y╠─╣
║ ╚══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╦═══╝ ║
╚════╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═══╩═════╝
=end
#==============================================================================
# ** Game_Map
#------------------------------------------------------------------------------
#  This class handles maps. It includes scrolling and passage determination
# functions. The instance of this class is referenced by $game_map.
#==============================================================================
class Game_Map
  #------------------------------------------------------------------------------
  #  * Address over the map's width / height?
  #------------------------------------------------------------------------------
  def over_edge?(x,y)
    return if @map.nil?
    return x < 0 || y < 0 || x >= width || y >= height
  end
  #------------------------------------------------------------------------------
  def scene_map
    return unless SceneManager.scene_is?(Scene_Map)
    return SceneManager.scene
  end
  #------------------------------------------------------------------------------
  def create_debug_layer
    return unless scene_map
    scene_map.create_debug_layer
  end
  #------------------------------------------------------------------------------
  def clear_pathfinding_arrow
    scene_map.clear_pathfinding_arrow
  end
  #------------------------------------------------------------------------------
  def draw_pathfinding_arrow(x, y, dir)
    scene_map.draw_pathfinding_arrow(x, y, dir)
  end
  #------------------------------------------------------------------------------
end
#==============================================================================
# ** Map_Address
#------------------------------------------------------------------------------
# This class is using to save the movement cost and address for the later class
# PathFinding_Queue
#==============================================================================
class Map_Address
  
  attr_accessor :x
  attr_accessor :y
  attr_accessor :cost
  
  def initialize(x = nil, y = nil, cost = 0)
    @x = x
    @y = y
    @cost = cost
  end
  
end
#==============================================================================
# ** PathFinding_Queue
#------------------------------------------------------------------------------
# This class is the main part of path finding, algorithm: A*
#==============================================================================
class PathFinding_Queue
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :visisted
  attr_accessor :nodes
  attr_accessor :move_dir
  attr_accessor :nodes_parent_id
  attr_accessor :distance
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(init_x,init_y)
    @visited          = []           # visited address
    @nodes            = []           # map nodes
    
    @nodes_parent_id  = []           # use for the path lookup after path fonud,
                                     # track up which node leads to the saved
                                     # node.
                                     
    @move_dir         = []           # use for the path lookup after path fonud,
                                     # saves the directions where the character
                                     # should go
                                     
    @distance         = 0x800000     # Distance to goal
    
    start_node = Map_Address.new(init_x,init_y)
    @nodes.push(start_node)
    @nodes_parent_id[ hash_address(init_x,init_y) ] = hash_address(init_x,init_y)
    mark_visited(init_x,init_y)
  end
  #--------------------------------------------------------------------------
  # * Dehash address
  #--------------------------------------------------------------------------
  def dehash_address(value)
    return if value.nil?
    x = (value / 40000.0).round(2)
    y = ((value - (x * 40000)) / 4.0).round(2)
    return [x , y]
  end
  #--------------------------------------------------------------------------
  # * Hash address
  #--------------------------------------------------------------------------
  def hash_address(x,y)
    return (x * 40000 + y * 4).to_i
  end
  #--------------------------------------------------------------------------
  # *  Heuristic algorithm 
  #--------------------------------------------------------------------------
  def predict_movement_cost(source_location,current_location,goal_location)
    
    dx1 = current_location.x - goal_location.x
    dx2 = source_location.x  - goal_location.x
    dy1 = current_location.y - goal_location.y
    dy2 = source_location.y  - goal_location.y
    
    return (dx1.abs + dy1.abs) * 20 + (dx1 * dy2 - dx2 * dy1).abs * 20
  end
  
  #--------------------------------------------------------------------------
  # *  Push new scanned address
  #--------------------------------------------------------------------------
  def push(source_loc, current_loc, next_loc, dir, goal_loc, depth)
    
    extra_cost = depth
    node_cost = predict_movement_cost(source_loc,current_loc,goal_loc) + extra_cost
    node = Map_Address.new(next_loc.x,next_loc.y,node_cost)
    
    @nodes.push(node)
    @nodes.sort!{ |a,b| a.cost <=> b.cost}
    
    # save source direction
    @move_dir[ hash_address(next_loc.x,next_loc.y) ] = dir
    # save source address
    @nodes_parent_id[ hash_address(next_loc.x, next_loc.y) ] = hash_address(current_loc.x,current_loc.y)
  end
  #--------------------------------------------------------------------------
  # *  Address visied?
  #--------------------------------------------------------------------------
  def visited?(x,y)
    return @visited.include?( hash_address(x,y) )
  end
  #--------------------------------------------------------------------------
  # *  Mark address visited
  #--------------------------------------------------------------------------
  def mark_visited(x,y)
    @visited.push( hash_address(x,y) )
  end
  
  #--------------------------------------------------------------------------
  # *  Queue is Empty?
  #--------------------------------------------------------------------------
  def empty?
    return @nodes.size == 0
  end
  #--------------------------------------------------------------------------
  # *  Top of queue, which has the minimum cost
  #--------------------------------------------------------------------------
  def top
    #puts "Node top returned: #{[@nodes[0].x, @nodes[0].y]} cost: #{@nodes[0].cost}"
    return [@nodes[0].x , @nodes[0].y]
  end
  #--------------------------------------------------------------------------
  # *  Remove the top object in the queue
  #--------------------------------------------------------------------------
  def pop
    @nodes.shift
  end
  #--------------------------------------------------------------------------
  # *  Get the route command
  #--------------------------------------------------------------------------
  def get_route_command(path_address,moving_direction)
    cmd_list = []
              
    for i in 0...path_address.size
      curx = path_address[i].x
      cury = path_address[i].y
      
      command_id = 0
      debug_info = ""
      case moving_direction[i]
      when 2
        debug_info = "↓"
        command_id = 2
      when 4
        debug_info = "←"
        command_id = 4
      when 6
        debug_info = "→"
        command_id = 6
      when 8
        debug_info = "↑"
        command_id = 8
      else
        debug_info = "O"
      end #case
      
      puts "#{debug_info} (#{curx},#{cury})" if $pathfinding_debug
      if command_id > 0
        #Pixel_Core::Pixel.times{  }
        cmd_list << [command_id, true]
      end # if command_id > 0
    end # for i in path_address.size
    
    return cmd_list
  end
  #--------------------------------------------------------------------------
  # *  Return the path address and direction
  #--------------------------------------------------------------------------
  def get_walk_path(goalx, goaly)
    current_track_address = hash_address(goalx,goaly)
    path = []
    path_address = []
    go_dir = []
    path.push(current_track_address)
    
    while @nodes_parent_id[current_track_address]
      path.unshift( @nodes_parent_id[current_track_address] )
      go_dir.unshift( @move_dir[current_track_address] )
      
      current_track_address = @nodes_parent_id[current_track_address]
      break if current_track_address == @nodes_parent_id[current_track_address]
    end
    
    path.each do |hash_value|
      _address = dehash_address(hash_value)
      path_address.push( Map_Address.new( _address[0], _address[1]) )
    end
    
    return get_route_command(path_address,go_dir)
  end
  
end
#==============================================================================
# ** Game_Character
#------------------------------------------------------------------------------
#  A character class with mainly movement route and other such processing
# added. It is used as a super class of Game_Player, Game_Follower,
# GameVehicle, and Game_Event.
#==============================================================================
class Game_Character < Game_CharacterBase
  #--------------------------------------------------------------------------
  DefaultPathfindingDepth = 1000
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor   :pathfinding_moves
  attr_accessor   :pathfinding_goal
  attr_accessor   :force_pathfinding
  attr_accessor   :move_poll
  #--------------------------------------------------------------------------
  # * Initialize Public Member Variables
  #--------------------------------------------------------------------------
  alias init_public_members_comp init_public_members
  def init_public_members
    init_public_members_comp
    @pathfinding_moves = []
    @move_poll         = []
    @pathfinding_goal  = nil
    @force_pathfinding = true
    @pathfinding_timer = 0
  end
  #--------------------------------------------------------------------------
  # * adjacent posititon? (for free-movement script)
  #--------------------------------------------------------------------------
  def adjacent?(x2 ,y2 , x1 = @x , y1 = @y)
    return (x1 - x2).abs < 0.6 && (y1 - y2).abs < 0.6
  end
  #--------------------------------------------------------------------------
  # * distance from self to certain pos
  #--------------------------------------------------------------------------
  def distance_to(x, y)
    return Math.hypot(x - @x, y - @y)
  end
  #--------------------------------------------------------------------------
  # * Fix current address (for free-movement script)
  #--------------------------------------------------------------------------
  def fix_address(x = @x, y = @y)
    fixed_x = (x - x.to_i).abs < 0.500 ? x.to_i : x.to_i + 1
    fixed_y = (y - y.to_i).abs < 0.500 ? y.to_i : y.to_i + 1
    
    return [fixed_x,fixed_y]
  end
  #--------------------------------------------------------------------------
  def clear_pathfinding_moves
    @pathfinding_moves.clear
    @move_poll.clear
    @pathfinding_goal = nil
  end
  #--------------------------------------------------------------------------
  # * next step is blocked by events?
  #--------------------------------------------------------------------------
  def path_blocked_by_event?(next_x,next_y)
    px, py = next_x * 4, next_y * 4
    return collision?(px, py)
  end # def path_blocked
  
  #--------------------------------------------------------------------------
  # * next step is blocked by events?
  #--------------------------------------------------------------------------
  def path_blocked_by_player?(next_x,next_y)
    return collision_character?($game_player)
  end # def path_blocked_by_player
  #--------------------------------------------------------------------------
  # * core function, move to assigned position
  # ququed: modify pathfinding method
  #--------------------------------------------------------------------------
  def move_to_position(goalx, goaly, args = {})
    return true unless @pathfinding_timer == 0 || args[:forced]
    @pathfinding_timer = 60
    clear_pathfinding_moves
    ti = Time.now
    
    depth             = args[:depth].nil? ? DefaultPathfindingDepth : args[:depth]
    tool_range        = args[:tool_range].nil?     ? 0     : args[:tool_range]
    draw_arrow        = args[:draw_arrow].nil?     ? false : true
    debug             = args[:debug].nil?          ? false : true
    through_chars     = args[:through_chars].nil?  ? []    : args[:through_chars]
    @pathfinding_goal = args[:goal].nil?           ? nil   : args[:goal]
    
    through_chars << @pathfinding_goal if @pathfinding_goal
    
    puts SPLIT_LINE if debug
    puts "Current Address: #{@x} #{@y}" if debug
    puts "Goal: #{goalx} #{goaly}"      if debug
    $game_map.clear_pathfinding_arrow if draw_arrow
    $pathfinding_debug = debug
    @on_path_finding = true
    
    tox   = [0,-Pixel_Core::Tile,Pixel_Core::Tile,0]
    toy   = [Pixel_Core::Tile,0,0,-Pixel_Core::Tile]
    dir   = [2,4,6,8]
    cnt   = 0
    path_queue = PathFinding_Queue.new([@x,0].max,[@y,0].max)
    path_found = false
    best_path  = path_queue.dup
    bestx, besty = @x, @y
    goalx += 0.25; goaly += 0.25;
    
    puts "Current pos: #{x} #{y}" if debug
    puts "Goal pos: #{goalx} #{goaly}"  if debug
    
    while !path_found && !path_queue.empty? && cnt <= depth
      
      cnt += 1
      curx = path_queue.top[0]
      cury = path_queue.top[1]
      
      path_queue.distance = [path_queue.distance, Math.hypot(goalx - curx, goaly - cury)].min
      if (curx - goalx).abs < 0.25 && (cury - goaly).abs < 0.25
        path_found = true
        puts "Path found: #{curx} #{cury}" if debug
        break
      elsif path_queue.distance < best_path.distance
        best_path = path_queue.dup
        bestx     = curx
        besty     = cury
      end
      
      path_queue.pop
      
      for i in 0...4
        break if path_found
        next_x = curx + tox[i]
        next_y = cury + toy[i]
        next if path_queue.visited?(next_x,next_y)
        next if $game_map.over_edge?(next_x, next_y)
        
        if path_passable?(next_x, next_y, dir[i], through_chars) || adjacent?(next_x, next_y, goalx, goaly)
          if adjacent?(next_x, next_y, goalx, goaly) && path_clear?(curx, cury, goalx, goaly)
            path_found = true
            goalx, goaly = next_x, next_y
            puts "Path found by adjacent: #{next_x} #{next_y}" if debug
          elsif ((next_x - goalx).abs + (next_y - goaly).abs ) <= tool_range && path_clear?(curx, cury, goalx, goaly)
            goalx = next_x
            goaly = next_y
            path_found = true
            puts "Path found by range: #{next_x} #{next_y}" if debug
          end
          
          source_loc  = Map_Address.new(@x,@y)
          current_loc = Map_Address.new(curx,cury)
          next_loc    = Map_Address.new(next_x,next_y)
          goal_loc    = Map_Address.new(goalx,goaly)
          
          path_queue.push(source_loc,current_loc,next_loc,dir[i],goal_loc, cnt)
          if draw_arrow
            $game_map.draw_pathfinding_arrow(next_x+0.5, next_y+0.5, dir[i])
            $game_map.interpreter.wait(1) rescue nil
          end
        end # if passable?        
        path_queue.mark_visited(next_x,next_y)
      end # for i in 0...4
    end # while !path_found
    
    if path_found
      best_path = path_queue
    else 
      goalx, goaly = bestx, besty
      debug_print "Destination x,y: #{goalx}, #{goaly}" if debug
    end # if !path found
    
    debug_print "Pathfinding time takes: #{Time.now.to_f - ti.to_f}" if debug
    @pathfinding_moves = best_path.get_walk_path(goalx, goaly)
    #finalize_offset(fx, fy)
    #push_movement_offset(ori_goalx, ori_goaly, goalx, goaly)
    debug_print "Pathfinding moves: #{@pathfinding_moves.size}" if debug
    interpret_debug_moves if debug
    return path_found
  end # def move_to_position
  #--------------------------------------------------------------------------
  def finalize_offset(fx,fy)
    return if fx == @x && fy == @y
    return if @pathfinding_moves.size < 4
    next_step   = @pathfinding_moves.shift(4).at(0)
    corrections = []
    next_dir = next_step[0]
    next_pos = POS.new(fx, fy)
    case next_dir
    when 2; next_pos.y += 1;
    when 4; next_pos.x -= 1;
    when 6; next_pos.x += 1;
    when 8; next_pos.y -= 1;
    end
    delta_x = next_pos.x - @x; delta_y = next_pos.y - @y
    puts "Next pos: #{next_pos.x} #{next_pos.y}" if $pathfinding_debug
    puts "Offset delta: #{delta_x} #{delta_y}"   if $pathfinding_debug
    (delta_x * Pixel_Core::Pixel).abs.to_i.times do 
      corrections << [delta_x > 0 ? 6 : 4 , next_step[1]]
    end
    (delta_y * Pixel_Core::Pixel).abs.to_i.times do 
      corrections << [delta_y > 0 ? 2 : 8 , next_step[1]]
    end
    corrections.reverse.each{|step| @pathfinding_moves.unshift(step)}
  end
  #--------------------------------------------------------------------------
  def push_movement_offset(fx, fy, tx, ty)
    offset_x, offset_y = fx - tx, fy - ty
    if offset_x != 0
      t = (offset_x * 4).abs.to_i
      dir = offset_x < 0 ? 4 : 6
      puts "Offset dir X: #{dir}, times: #{t}" if $pathfinding_debug
      t.times { @pathfinding_moves << [dir ,true] }
    end
    if offset_y != 0
      t = (offset_y * 4).abs.to_i
      dir = offset_y < 0 ? 8 : 2
      puts "Offset dir Y: #{dir}, times: #{t}" if $pathfinding_debug
      t.times { @pathfinding_moves << [dir ,true] }
    end
  end
  #--------------------------------------------------------------------------
  # * Overwrite Method: Process Move Route End
  #--------------------------------------------------------------------------
  def process_route_end
    if @move_route.repeat
      @move_route_index = -1
    elsif @move_route_forcing
      @on_path_finding    = false
      @move_route_forcing = false
      restore_move_route
    end
    @move_type = @previous_move_type
  end
  #--------------------------------------------------------------------------
  def trigger_movement_key?
    return false unless self.is_a?(Game_Player)
    return Input.press?(:DOWN) || Input.press?(:kS) || Input.press?(:LEFT)  || Input.press?(:kA) ||
           Input.press?(:UP)   || Input.press?(:kW) || Input.press?(:RIGHT) || Input.press?(:kD)
  end
  #--------------------------------------------------------------------------
  # * Process pathfinding movement
  #--------------------------------------------------------------------------
  # tag: movement
  def process_pathfinding_movement
    return clear_pathfinding_moves if trigger_movement_key?
    return clear_pathfinding_moves if @pathfinding_goal && adjacent?(@pathfinding_goal.x, @pathfinding_goal.y)
    return if moving?
    return unless @pathfinding_moves.size > 0 && @move_poll.empty?
    @move_poll << @pathfinding_moves.shift
    @followers.move if self.is_a?(Game_Player)
    interpret_move
  end
  #-------------------------------------------------------------------------
  # * Execute queued movement
  #-------------------------------------------------------------------------
  def interpret_move
    return if @move_poll.empty?
    route = @move_poll.shift
    move_pixel(route[0], route[1])
  end
  #-------------------------------------------------------------------------
  def interpret_debug_moves
    pos = POS.new(@x, @y)
    @pathfinding_moves.each do |step|
      dir = step[0]
      case dir
      when 2
        debug_info = "↓"
        pos.y += 1.0 / Pixel_Core::Pixel
      when 4
        debug_info = "←"
        pos.x -= 1.0 / Pixel_Core::Pixel
      when 6
        debug_info = "→"
        pos.x += 1.0 / Pixel_Core::Pixel
      when 8
        debug_info = "↑"
        pos.y -= 1.0 / Pixel_Core::Pixel
      else
        debug_info = "O"
      end #case
      debug_info += " (#{pos.x},#{pos.y})"
      puts debug_info
    end
  end
  
end # class Game_Character
#==============================================================================
# ** Game_Event
#------------------------------------------------------------------------------
#  This class handles events. Functions include event page switching via
# condition determinants and running parallel process events. Used within the
# Game_Map class.
#==============================================================================
class Game_Event < Game_Character
  
end
#==============================================================================
# ** Scene_Map
#------------------------------------------------------------------------------
#  This class performs the map screen processing.
#==============================================================================
class Scene_Map < Scene_Base
  #-------------------------------------------------------------------------
  # *) draw pathfinding arrow
  #-------------------------------------------------------------------------
  def draw_pathfinding_arrow(x, y, dir)
    case dir
    when 2; name = "arow_D";
    when 4; name = "arow_L";
    when 6; name = "arow_R";
    when 8; name = "arow_U";
    end
    @spriteset.draw_tile_picture(x, y, name) rescue nil
  end
  #-------------------------------------------------------------------------
  def clear_pathfinding_arrow
    @spriteset.clear_tile_picture
  end
  #-------------------------------------------------------------------------
end
#==============================================================================#
#                                                                              #
#                      ▼   End of File   ▼                                     #
#                                                                              # 
#==============================================================================#

#==============================================================================
# ** PONY::ERRNO
#------------------------------------------------------------------------------
#  Friendship is magic. Error is tragic.
#==============================================================================
module PONY::ERRNO
  #--------------------------------------------------------------------------
  # * ERRNO COLLECTION
  #--------------------------------------------------------------------------
  ERR_INFO = Vocab::Errno::RESymbol_Table
  SequenceArgTable = {
    :pose           => 4,
    :move           => 5,
    :slide          => 5,
    :move_to_target => 5,
    :target_damage  => 2,
    :show_anim      => 2,
    :cast           => 2,
    :flip           => 2,
    :action         => 2,
    :icon           => 2,
    :sound          => 2,
    :if             => 3,
    :add_state      => 2,
    :rem_state      => 2,
    :change_target  => 2,
    :target_move    => 5,
    :target_slide   => 5,
    :target_reset   => 3,
    :target_lock_z  => 2,
    :target_flip    => 2,
    :ballon         => 2,
    :log            => 2,
    :loop           => 3,
    :while          => 3,
    :slow_motion    => 3,
    :timestop       => 2,
    :com_event      => 2,
    :rotate         => 4,
    :autopose       => 4,
    
    nil             => 1,
  }
  #--------------------------------------------------------------------------
  @raised = false
  #--------------------------------------------------------------------------
  # * Raise Error Overlay
  #--------------------------------------------------------------------------
  def self.raise(symbol, cmd = nil, args = nil, extra_info = "")
    @sym        = symbol
    @cmd        = cmd
    @args       = args
    @extra_info = extra_info
    @errno      = true
  end
  #--------------------------------------------------------------------------
  def self.raise_errno
    return if @raised
    
    @raised = true
    Audio.se_play("Audio/SE/Pinkie_Pie_Sad_Trombone",100,100)
    sym    = ERR_INFO[@sym] ? ERR_INFO[@sym] : "" 
    info   = sprintf(Vocab::Errno::RunTimeErr, sym, @extra_info)
    puts SPLIT_LINE
    puts "An Error occurred!: #{@sym}"
    puts "#{@extra_info}"
    puts SPLIT_LINE
    SceneManager.scene.raise_overlay_window(:popinfo , info, @cmd, @args, true)
  end
  #--------------------------------------------------------------------------
  def self.close_errno_window
    @raised     = false
    @sym        = nil
    @cmd        = nil
    @args       = nil
    @extra_info = nil
    @errno      = nil
  end
  #--------------------------------------------------------------------------
  def self.mutex_error(e)
    @error = e
  end
  #--------------------------------------------------------------------------
  def self.error_occurred?
    @error
  end
  #--------------------------------------------------------------------------
  def self.errno_occurred?
    @errno
  end
  #--------------------------------------------------------------------------
  def self.check_sequence(seq)
    exp_num = (SequenceArgTable[seq.first] || 0)
    if seq.size < exp_num
      self.sequence_error(:args, seq.first, exp_num, seq.size - 1)
      return false
    else
      return true
    end
  end
  #--------------------------------------------------------------------------
  def self.sequence_error(type, *args)
    case type
    when :args
      info = Vocab::Errno::SequenceArgError
      raise ArgumentError, sprintf(info, args[0], args[1], args[2])
    when :eval
      raise args[0]
    end
  end
end

#==============================================================================
# ** PONY::Rescue
#------------------------------------------------------------------------------
#  Thou shall not die!
#==============================================================================
module PONY::Rescue
  module_function
  
  def CallPrincessLuna
    return if $LunaCalled
    $LunaCalled = true
    $game_player.start_animation(159)
    info = Vocab::Rescue::Luna
    $game_message.add(info)
    ex, ey = $game_player.x, $game_player.y
    rpeve = RPG::Event.new(ex,ey)
    rpeve.name = "Princess Luna"
    rpeve.id = 2000
    eve = Game_Event.new($game_map.map_id, rpeve)
    eve.move_speed = 4
    eve.through_character = true
    eve.set_graphic("Princess_Luna%(6)", 0)
    eve.spawn_npc_battler(9)
    $game_map.register_event(eve)
    item = $data_skills[15]
    target = BattleManager.autotarget(eve, item)
    eve.priority_type = 1
    eve.step_anime = true
    eve.action = Game_Action.new(eve, target, item)
  end
  
end

# =============================================================================
# TheoAllen - Basic Modules
# Version : 1.5d
# Contact : www.rpgmakerid.com (or) http://theolized.blogspot.com
# By : TheoAllen (Original Scripter)
# =============================================================================
$imported = {} if $imported.nil?
# =============================================================================
# This basic modules means to be my personal module to develop script or system.
# It's to facilitate me on everything I do. Whether is just a little experiment
# or make a big system. 
#
# However, not all of my scripts needs this basic modules. Mostly not, but some 
# other requires.
# -----------------------------------------------------------------------------
# This module contains :
# =============================================================================
$imported[:Theo_BasicFuntions] = true  # Basic Funtions
$imported[:Theo_BitmapAddons]  = true  # Bitmap Extra Addons
$imported[:Theo_CoreDamage]    = true  # Core Damage Processing
$imported[:Theo_CoreResult]    = true  # Core Damage Result
$imported[:Theo_Movement]      = true  # Object Core Movement
$imported[:Theo_CoreFade]      = true  # Object Core Fade
$imported[:Theo_Circular]      = true  # Object Circular Movement
$imported[:Theo_CloneImage]    = true  # Clone Image. For Afterimage Base
$imported[:Theo_RotateImage]   = true  # To rotate sprite
$imported[:Theo_SmoothMove]    = true  # Object Smooth Movement
# =============================================================================
# Note to users:
# -----------------------------------------------------------------------------
# Categorize this script as core script. It means that you have to put this
# script above all custom scripts.
#
# I know sometimes basic modules provides incompatibility among others. In fact,
# not all of these functions are being used in my scripts. I always mentioned
# in any script that requires this basic modules which methods I use. So, to
# provide more compatibility, you may disable unused functions by set it to
# false.
#
# =============================================================================
# Note to scripters :
# -----------------------------------------------------------------------------
# The documentation of each division is written below.
#
# You may edit this basic modules if you think you could make it better. And
# please tell me what have you edited. I glad if there is any scripter who
# willing to contribute to this basic modules to make it better.
#
# You may put your name to credit list if you have contributed to this basic 
# module. But please keep in mind. This basic module shouldn't affect default 
# script so much. It's only provides basic functions which will be used in 
# other script.
# =============================================================================
# Known incompatibility :
# >> Modern Algebra - Bitmap Addons (Disable the Bitmap Addon)
# >> Tsukihime - Core Damage (Disable the Core Damage processing)
# >> YEA - Lunatic Damage (Disable the Core Damage processing)
# >> Enu - Tankentai (I just heard. Haven't tried it yet)
# =============================================================================
# ChangeLogs :
# =============================================================================
# Version 1.0   : - Initial Release
# Version 1.2   : - Add Bitmap Entire Fill
#                 - Add Bitmap Border Fill
#                 - Add To Center window position
#                 - Add more description
# Version 1.3   : - Added Clone Sprite function and afterimagebase
# Version 1.3b  : - Added TSBS basic function
#                 - Greatly reduced lag for afterimage effect
# Version 1.4   : - Added rotate image basic module
#                 - Fixed bug at Object Core Fade
# Version 1.5   : - Added Smooth movement
#                 - Fixed bug on circle movement
#                 - Fixed bug on movement module where float may causes endless
#                   moving
#                 - Fixed wrong parameter in drawing eclipse / circle
#                 - Fixed color parameter on drawing arrow
#                 - Added Plane_Mask on basic functions
#                 - Added step parameter on draw circle
#                 - Fixed wrong target opacity in object core fade for Window
#                 - Dispose afterimages from Sprite_Base
# Version 1.5b    - Afterimage now followed by flashing sprite
# Version 1.5c    - Fixed bug on object core fade.
#                 - Remove core fade from window since it's absurb :v
#                 - Compatibility with nickle's core
# Version 1.5d    - Allow you to jump in same place
# =============================================================================
# RGSS3 ~ Bug Fixes (Taken from RMWeb.com)
# forums.rpgmakerweb.com/index.php?/topic/1131-rgss3-unofficial-bugfix-snippets
# =============================================================================
# =============================================================================
# Screen shake bugfix
# -----------------------------------------------------------------------------
class Game_Interpreter
  
  def command_225
    screen.start_shake(@params[0], @params[1], @params[2])
    wait(@params[2]) if @params[3]
  end
  
end
# -----------------------------------------------------------------------------
# Enemy targeting bugfix
# -----------------------------------------------------------------------------
class Game_Action
  def targets_for_friends
    if item.for_user?
      [subject]
    elsif item.for_dead_friend?
      if item.for_one?
        [friends_unit.smooth_dead_target(@target_index)]
      else
        friends_unit.dead_members
      end
    elsif item.for_friend?
      if item.for_one?
        if @target_index < 0
          [friends_unit.random_target]
        else
          [friends_unit.smooth_target(@target_index)]
        end
      else
        friends_unit.alive_members
      end
    end
  end
end
# -----------------------------------------------------------------------------
# process normal char bugfix
# -----------------------------------------------------------------------------
class Window_Base < Window
  alias :process_normal_character_theolized :process_normal_character
  def process_normal_character(c, pos)
    return unless c >= ' '
    process_normal_character_theolized(c, pos)
  end
end
# -----------------------------------------------------------------------------
# Disable Japanese input name
# -----------------------------------------------------------------------------
class Game_System
  def japanese?
    false
  end
end
#==============================================================================
# ** Basic Functions ~
#------------------------------------------------------------------------------
#  These are just basic functions. It will not do anything in script mechanics.
# I only provide these functions to be used later in upcoming script or just
# simply for experimental.
#------------------------------------------------------------------------------
if $imported[:Theo_BasicFuntions] # Activation flag
#==============================================================================
module Math
  
  # Convert degree to radian
  def self.radian(degree)
    return (degree.to_f/180) * Math::PI
  end
  
  # Convert radian to degree
  def self.degree(radian)
    return (radian.to_f/Math::PI) * 180
  end
  
end
class Object
  
  # Generate number with range from minimum to maximum
  unless method_defined?(:rand_range)
    def rand_range(min,max,float = false)
      range = max - min
      return float ? (min + (rand*range)) : min + rand(range)
    end 
  end
  # ---------------------------------------------------------------------------
  # Iterate instance variables one by one. 
  # 
  # Example usage :
  # each_var do |ivar|
  #   ivar.update if ivar.is_a?(Sprite)
  # end
  # ---------------------------------------------------------------------------
  def each_var
    instance_variables.each do |varsymb|
      yield instance_variable_get(varsymb)
    end
  end
  
end
#==============================================================================
# ** Sprite_Screen
#------------------------------------------------------------------------------
#  Sprite that same size as the screen. It can be used to draw anything on
# screen. I believe sometime you need it
#
# Example usage :
# - http://goo.gl/E88ufV  ( Event Pointer )
#==============================================================================
class Sprite_Screen < Sprite
  
  def initialize(viewport = nil)
    super(viewport)
    self.bitmap = Bitmap.new(Graphics.width,Graphics.height)
  end
  
  def dispose
    self.bitmap.dispose
    super
  end
  
end
#==============================================================================
# ** Plane_Mask
#------------------------------------------------------------------------------
#  Sprite that same size as the map size. It's also scrolled alongside the map
# if it's updated. It can be used to draw anything on map. Can be used as base
# class of parallax lock actually
#==============================================================================
class Plane_Mask < Plane
  
  def initialize(vport)
    super(vport)
    @width = 1
    @height = 1
  end
  
  def update
    if $game_map
      if @width != $game_map.width || @height != $game_map.height
        @width = $game_map.width
        @height = $game_map.height
        update_bitmap
      end
      self.ox = $game_map.display_x * 32
      self.oy = $game_map.display_y * 32
    end
  end
  
  def update_bitmap
    bmp = Bitmap.new(@width * 32, @height * 32)
    self.bitmap = bmp
  end
  
end
#==============================================================================
# ** Window_Confirmation
#------------------------------------------------------------------------------
#  Window command class that holds yes and no command. Used to make 
# confirmation function. If you want some alteration of this class, just make
# inheritance.
#
#  This is for my personal development. I mean, if there is a simple script 
# that display window yes/no confirmation, it will not require this basic 
# module. I prefer to duplicate this class to my script instead. You know,
# most people hates Core Script / Basic Modules
#==============================================================================
class Window_Confirmation < Window_Command
  def window_width
    return 100
  end
  
  def make_command_list
    add_command(ok_vocab, :ok, ok_condition)
    add_command(cancel_vocab, :cancel, cancel_condition)
  end
  
  # Vocab yes
  def ok_vocab
    return "Yes"
  end
  
  # Vocab cancel
  def cancel_vocab
    return "No"
  end
  
  # Overwrite this method in child class
  def ok_condition
    return true
  end
  
  # Overwrite this method in child class
  def cancel_condition
    return true
  end
  
  def alignment
    return 1
  end
  
end
#==============================================================================
# ** Coordinate
#------------------------------------------------------------------------------
#  Coordinate class that holds x dan y point. Can be used to calculate point
# operation such as vector
#
# Example usage :
# - http://goo.gl/E88ufV  ( Event Pointer )
#==============================================================================
class Coordinate
  attr_accessor :x,:y
  
  def initialize(x,y)
    @x = x
    @y = y
  end
  
  def + (other)
    other = other.to_c unless other.is_a?(Coordinate)
    Coordinate.new(self.x + other.x, self.y + other.y)
  end
  
  def - (other)
    other = other.to_c unless other.is_a?(Coordinate)
    Coordinate.new(self.x - other.x, self.y - other.y)
  end
  
  def == (other)
    other = other.to_c unless other.is_a?(Coordinate)
    return self.x == other.x && self.y == other.y
  end
  
  # To String function
  def to_s
    return "(#{self.x},#{self.y})"
  end
  
end
#==============================================================================
# ** Vector
#------------------------------------------------------------------------------
#  Vector class that handles all vector functions. Note that some of these
# methods and variable terms are named in Indonesian terms. Because I don't
# really know what is in English terms
#
# Example usage :
# - http://goo.gl/E88ufV  ( Event Pointer )
#==============================================================================
class Vector
  attr_accessor :pangkal  # Starting point
  attr_accessor :ujung    # End point
  
  def initialize(pangkal,ujung,radius = 0)
    @pangkal = pangkal.is_a?(Coordinate) ? pangkal : pangkal.to_c
    if ujung.is_a?(Numeric)
      x_pos = @pangkal.x + (Math.cos(Math.radian(ujung)) * radius)
      y_pos = @pangkal.y + (Math.sin(Math.radian(ujung)) * radius)
      @ujung = Coordinate.new(x_pos,y_pos)
      return
    end
    @ujung = ujung.is_a?(Coordinate) ? ujung : ujung.to_c
  end
  
  # Get scalar value
  def skalar
    Math.sqrt(jarak_x**2 + jarak_y**2)
  end
  
  def + (other)
    if other.is_a?(Coordinate)
      return Vector.new(pangkal + other, ujung + other)
    end
    Vector.new(pangkal, ujung + other.satuan)
  end
  
  def - (other)
    if other.is_a?(Coordinate)
      return Vector.new(pangkal - other, ujung - other)
    end
    Vector.new(pangkal, ujung - other.satuan)
  end
  
  # Get degree upon two different point
  def degree
    Math.degree(Math.atan2(jarak_y,jarak_x)) rescue 0
  end
  
  # Get distance X
  def jarak_y
    ujung.y - pangkal.y
  end
  
  # Get distance Y
  def jarak_x
    ujung.x - pangkal.x
  end
  
  # Convert vector to coordinate
  def satuan
    Coordinate.new(jarak_x, jarak_y)
  end
  
  # To string format
  def to_s
    return @pangkal.to_s + " ---> " + @ujung.to_s
  end
  
end
#==============================================================================
# ** VectorObject
#------------------------------------------------------------------------------
# This class handles two objects that their vector is later will be used.
#
# Example usage :
# - http://goo.gl/E88ufV  ( Event Pointer )
#==============================================================================
class VectorObject
  attr_accessor :pangkal  # Starting object
  attr_accessor :ujung    # End object
  attr_accessor :color    # Color value (to draw lines)
  attr_accessor :offset_x # Offset value X
  attr_accessor :offset_y # Offset value Y
  
  # Basically, offset value is a increment value upon a new vector that created
  # using to_v vector. I don't really know if 'offset' is the right word. I'm 
  # suck at english afterall
  
  def initialize(pangkal,ujung,color = Color.new(255,255,255))
    @pangkal = pangkal
    @ujung = ujung
    @color = color
    @offset_x = 0
    @offset_y = 0
  end
  
  # Two object converted into vector
  def to_v
    a = @pangkal.to_c
    b = @ujung.to_c
    a.x += @offset_x
    b.x += @offset_x
    a.y += @offset_y
    b.y += @offset_y
    Vector.new(a,b)
  end
  
end
#==============================================================================
# ** Bitmap
#------------------------------------------------------------------------------
# Built in class that handles bitmap
#==============================================================================
class Bitmap
  
  # Fill entire bitmap with color
  def entire_fill(color = Color.new(0,0,0,150))
    fill_rect(self.rect,color)
  end
  
  # Fill bitmap edge only
  def border_fill(color = Color.new(255,255,255))
    fill_rect(0,0,width,1,color)
    fill_rect(0,0,1,height,color)
    fill_rect(width-1,0,1,height,color)
    fill_rect(0,height-1,width,1,color)
  end
  
end
#==============================================================================
# ** Window_Base
#------------------------------------------------------------------------------
# This is a super class of all windows within the game.
#==============================================================================
class Window_Base < Window
  
  # Same as bitmap entire fill
  def entire_fill(color = Color.new(0,0,0,150))
    contents.entire_fill(color)
  end
  
  # Set window to center position of the screen
  def to_center
    self.x = Graphics.width/2 - self.width/2
    self.y = Graphics.height/2 - self.height/2
  end
  
end
#==============================================================================
# ** Color
#------------------------------------------------------------------------------
# Built in class that handles color
#==============================================================================
class Color
  
  # Is color same as other?
  def same?(*args)
    args = args.select {|color| color.is_a?(Color)}
    return false if args.empty?
    return args.any?{|color| self.red == color.red && 
      self.green == color.green && self.blue == color.blue && 
      self.alpha == color.alpha}
  end
  
  # Is color empty?
  def empty?
    return self.alpha <= 0
  end
  
end
# -----------------------------------------------------------------------------
# New Method : To Coordinate Conversion
# -----------------------------------------------------------------------------
class Object
  
  def to_c
    return Coordinate.new(0,0)
  end
end
class Numeric
  
  def to_c
    return Coordinate.new(self,self)
  end
  
end
class Sprite
  
  def to_c
    return Coordinate.new(self.x,self,y)
  end
  
end
class Window
  
  def to_c
    return Coordinate.new(self.x,self,y)
  end
  
end
class Game_Enemy < Game_Battler
  
  def to_c
    return Coordinate.new(self.screen_x,self,screen_y)
  end
  
end
class Game_CharacterBase
  
  def to_c(map = false)
    if map
      return Coordinate.new(self.real_x,self.real_y)
    end
    return Coordinate.new(self.screen_x,self.screen_y)
  end
  
end
# -----------------------------------------------------------------------------
# Added TSBS basic function. To calculate sprite anim cell
# -----------------------------------------------------------------------------
module TSBS
  def self.cell(row, col)
    result = (MaxCol * (row - 1)) + (col - 1)
    return result
  end
end
end
#==============================================================================
# ** Bitmap Extra addons v2.1
#------------------------------------------------------------------------------
#  This bitmap extra addons provide basic function of drawing shapes. It could
# be drawing polygon, line, arrow, elipse or such. 
#
# The code may look messy. Even myself forget how it works. To be note that
# even this current version is 2.1, the draw filled polygon is imperfect. Do
# not use at this moment.
#
# Some functions may need my Basic Functions to be activated. So I suggest you
# to also activate it
#
# Example usage :
# - http://goo.gl/E88ufV ( Event Pointer )
# - http://goo.gl/DlrPuR ( Simple Polygon Status )
#------------------------------------------------------------------------------
if $imported[:Theo_BitmapAddons]  # Activation flag
# =============================================================================
class Bitmap
  attr_accessor :start_degree
  
  # ------------------------------------------------------------------------
  # Static Members
  # ------------------------------------------------------------------------
  @@default_color = Color.new(255,255,255)
  @@arrow_degree = 30
  
  def self.default_color=(color)
    @@default_color = color
  end
  
  def self.arrow_degree=(degree)
    @@arrow_degree = degree
  end
  
  def self.default_color
    @@default_color
  end
  
  def self.arrow_degree
    @@arrow_degree
  end
  
  alias theo_bitmap_init initialize
  def initialize(*args)
    theo_bitmap_init(*args)
    @start_degree = 270
  end
  # ------------------------------------------------------------------------
  # Bitmap draw line. The avalaible arguments to put are
  # - draw_line(x1,x2,y1,y2,[color])
  # - draw_line(coordinate1, coordinate2, [color])
  # - draw_line(vector, [color])
  #
  # coordinate must be Coordinate object from this basic module.
  # So do the vector
  # ------------------------------------------------------------------------
  def draw_line(x1, y1=0, x2=0, y2=0, color=@@default_color.dup,
      color_set_skip = false)
    # ----------------------------------------------------------------------
    # If the argument is a vector
    # ----------------------------------------------------------------------
    if x1.is_a?(Vector)
      new_color = (y1.is_a?(Color) ? y1 : color)
      draw_line(x1.pangkal,x1.ujung,new_color) # Recursive
      return # Exit
    # ----------------------------------------------------------------------
    # If two arguments are coordinates
    # ----------------------------------------------------------------------
    elsif x1.is_a?(Coordinate) && y1.is_a?(Coordinate)
      pangkal = x1
      ujung = y1
      new_color = (x2.is_a?(Color) ? x2 : color)
      draw_line(pangkal.x,pangkal.y,ujung.x,ujung.y,new_color) # Recursive
      return # Exit
    end
    # ----------------------------------------------------------------------
    # If two coordinate is same
    # ----------------------------------------------------------------------
    if x1 == x2 && y1 == y2 
      set_pixel(x1,y1,color)
      yield [x1,x2] if block_given?
      return # Exit
    end
    # ----------------------------------------------------------------------
    # Calculate distance X dan Y
    # ----------------------------------------------------------------------
    jarak_x = (x2-x1)
    jarak_y = (y2-y1)
    # ----------------------------------------------------------------------
    # If line is horz line or vert line
    # ----------------------------------------------------------------------
    if jarak_y == 0 || jarak_x == 0
      
      # Horizontal
      if jarak_y == 0
        draw_horz(x1,y1,jarak_x,color)
        for j in 0..jarak_x
          yield [x1,y1]
          x1 += 1
        end if block_given?
        
      # Vertikal
      elsif jarak_x == 0
        draw_vert(x1,y1,jarak_y,color)
        for k in 0..jarak_y
          yield [x1,y1]
          y1 += 1
        end if block_given?
      end
      return # Exit
      
    end
    # ----------------------------------------------------------------------
    # If line is diagonal
    # ----------------------------------------------------------------------
    maximum = [jarak_x.abs,jarak_y.abs].max
    rasio_x = jarak_x / maximum.to_f 
    rasio_y = jarak_y / maximum.to_f
    real_x = x1.to_f
    real_y = y1.to_f
    for i in 0..maximum
      set_pixel(x1,y1,color) unless get_pixel(x1,y1).same?(color) || 
        color_set_skip ? !get_pixel(x1,y1).empty? : false
      real_x += rasio_x
      real_y += rasio_y
      yield [x1,y1] if block_given?
      x1 = real_x.round
      y1 = real_y.round
    end
  end
  # ------------------------------------------------------------------------
  # Gradient line
  # ------------------------------------------------------------------------
  def gradient_line(x1,y1=0,x2=0,y2=0,color1=@@default_color.dup,
      color2 = color1)
    if x1.is_a?(Vector)
      warna_pangkal = (y1.is_a?(Color) ? y1 : color1)
      warna_ujung = (x2.is_a?(Color) ? x2 : color2)
      gradient_line(x1.pangkal, x1.ujung, warna_pangkal, warna_ujung)
      return
    elsif x1.is_a?(Coordinate) && y1.is_a?(Coordinate)
      pangkal = x1
      ujung = y1
      warna_pangkal = (x2.is_a?(Color) ? x2 : color1)
      warna_ujung = (y2.is_a?(Color) ? y2 : color2)
      gradient_line(pangkal.x,pangkal.y,ujung.x,ujung.y,warna_pangkal,
        warna_ujung)
      return
    end
    jarak_x = (x2-x1)
    jarak_y = (y2-y1)
    radius = Math.sqrt((jarak_x**2) + (jarak_y**2))
    red_diff = (color2.red - color1.red) / radius
    green_diff = (color2.green - color1.green) / radius
    blue_diff = (color2.blue - color1.blue) / radius
    alpha_diff = (color2.alpha - color1.alpha) / radius
    red = color1.red
    green = color1.green
    blue = color1.blue
    alpha = color1.alpha
    if jarak_y.abs == 0 || jarak_x.abs == 0
      gradient_fill_rect(x1,y1,1,jarak_y,color1,color2,true) if jarak_y.abs == 0
      gradient_fill_rect(x1,y1,jarak_x,1,color1,color2) if jarak_x.abs == 0
      return
    end
    maximum = [jarak_x.abs,jarak_y.abs].max
    rasio_x = jarak_x / maximum.to_f
    rasio_y = jarak_y / maximum.to_f
    real_x = x1.to_f
    real_y = y1.to_f
    for i in 0..maximum
      new_color = Color.new(red,green,blue,alpha)
      set_pixel(x1,y1,new_color) unless get_pixel(x1,y1).same?(new_color)
      real_x += rasio_x
      real_y += rasio_y
      x1 = real_x.round
      y1 = real_y.round
      red += red_diff
      blue += blue_diff
      green += green_diff
      alpha += alpha_diff
    end
  end
  
  # Draw horizontal line
  def draw_horz(x,y,width,color = Color.new(255,255,255))
    if width < 0
      fill_rect(x+width+1,y,width.abs,1,color)
      return
    end
    fill_rect(x,y,width,1,color)
  end
  
  # Draw vertical line 
  def draw_vert(x,y,height,color = Color.new(255,255,255))
    if height < 0
      fill_rect(x,y+height+1,1,height.abs,color)
      return
    end
    fill_rect(x,y,1,height,color)
  end
  
  # --------------------------------------------------------------------------
  # Drawing ellipse.
  # 
  # The parameters are :
  # - x     >> Center coordinate X
  # - y     >> Center coordinate Y
  # - horz  >> Horizontal Radius value
  # - vert  >> Vertical Radius value
  # - color >> Line color
  # - thick >> Thickness of line
  # - step  >> Dot step. Greater number may causes ellipse being drawn
  #            imperfect. But may perform better
  # --------------------------------------------------------------------------
  def draw_ellipse(x,y=0,horz=1,vert=1,color=Color.new(255,255,255),thick=1,
      step=0.1)
    return if thick < 1
    ori_x = x
    ori_y = y
    x += horz
    degree = 0.0
    while degree <= 360
      yield [x,y] if block_given?
      set_pixel(x,y,color) unless get_pixel(x,y).same?(color)
      x = Math.cos(Math.radian(degree)) * horz + ori_x
      y = Math.sin(Math.radian(degree)) * vert + ori_y
      degree = [degree+step,361].min
    end
    if thick > 1
      draw_ellipse(ori_x+1,ori_y+1,horz,vert,color,thick-1,step)
      draw_ellipse(ori_x-1,ori_y-1,horz,vert,color,thick-1,step)
      draw_ellipse(ori_x+1,ori_y-1,horz,vert,color,thick-1,step)
      draw_ellipse(ori_x-1,ori_y+1,horz,vert,color,thick-1,step)
    end
  end
  # --------------------------------------------------------------------------
  # Draw circle. Similar of drawing ellipse. But only have one radius parameter
  # --------------------------------------------------------------------------
  def draw_circle(x,y,radius,color=Color.new(255,255,255),step=0.1,thick=1)
    draw_ellipse(x,y,radius,radius,color,thick,step) {|coordinate|
      yield coordinate if block_given?
    }
  end
  
  # Do not use ~ !
  def fill_circle(x,y,radius,color1,color2=color1,step=0.1)
    fill_ellipse(x,y,radius,radius,color1,color2,step)
  end
  
  # Do not use ~ !
  def fill_ellipse(x,y,horz,vert,color1,color2=color1,step=0.1)
    draw_ellipse(x,y,horz,vert,1,color1,0.5) {|cor|
      draw_line(x,y,cor[0],cor[1],color2,true)
    }
    for i in 0..1
      for baris in 0..horz*2
        for kolom in 0..vert*2
          pos_x = baris-horz+x
          pos_y = kolom-vert+y
          syarat = (get_pixel(pos_x+1,pos_y).same?(color1,color2) &&
          get_pixel(pos_x-1,pos_y).same?(color1,color2)) ||
          (get_pixel(pos_x,pos_y-1).same?(color1,color2) &&
          get_pixel(pos_x,pos_y+1).same?(color1,color2)) ||
          (get_pixel(pos_x+1,pos_y+1).same?(color1,color2) &&
          get_pixel(pos_x-1,pos_y-1).same?(color1,color2)) ||
          (get_pixel(pos_x-1,pos_y+1).same?(color1,color2) &&
          get_pixel(pos_x+1,pos_y-1).same?(color1,color2))
          if syarat && !get_pixel(pos_x,pos_y).same?(color1,color2)
            set_pixel(pos_x,pos_y,color2)
          end
        end
      end
    end
  end
  # ---------------------------------------------------------------------------
  # Drawing polygon
  #
  # The parameters are :
  # - x       >> Center coordinate X
  # - y       >> Center coordinate Y
  # - corner  >> Number of corner. The mininmal value is 3 (Triangle)
  # - length  >> Radius range from center
  # - color1  >> Edge line color
  # - bone    >> Drawing bone? (true/false)
  # - color2  >> Bone Color
  # ---------------------------------------------------------------------------
  def draw_polygon(x,y,corner,length,color1,bone=true,color2=color1)
    return unless corner.is_a?(Numeric)
    draw_shape(x,y,Array.new(corner){1},length,color1,bone,false,color2)
  end
  
  # Do not use ~ !
  def fill_polygon(x,y,corner,length,color1,color2=color1)
    return unless corner.is_a?(Numeric)
    draw_shape(x,y,Array.new(corner),length,color1,false,true,color2)
  end
  
  # Draw polygon parameter
  def draw_shape_params(x,y,params,length,color1,bone=true,color2=color1)
    draw_shape(x,y,params,length,color1,bone,false,color2)
  end
  
  # Do not use ~ !
  def fill_shape_params(x,y,params,length,color1,color2=color1)
    draw_shape(x,y,params,length,color1,false,true,color2)
  end
  
  # Core function of drawing shape
  def draw_shape(x,y,params,length,color1 = Color.new(255,255,255), 
      include_bone = true ,fill=false,color2 = color1)
    return unless params.is_a?(Array) # Corner lenght should be array
    return unless params.size >= 3    # At the size should have min 3
    degree_plus = 360 / params.size
    degree = @start_degree
    coordinate = []
    edge = []
    params.each do |i|
      x_des = x + Math.cos(Math.radian(degree)) * (length*(i.to_f/params.max))
      y_des = y + Math.sin(Math.radian(degree)) * (length*(i.to_f/params.max))
      draw_line(x,y,x_des,y_des,color2) if include_bone
      degree += degree_plus
      coordinate.push(Coordinate.new(x_des,y_des))
    end
    for i in -1..coordinate.size-2
      c = coordinate
      draw_line(c[i].x,c[i].y,c[i+1].x,c[i+1].y,color1) {|cor| edge.push(cor)}
    end
    return unless fill
    # -------------------------------------------------------------------------
    # Yes, it should return. Because the code below this point is sooo much
    # messy. 
    # -------------------------------------------------------------------------
    edge.each do |line|
      draw_line(x,y,line[0],line[1],color2,true)
    end
    for i in 0..1
      for baris in 0..length*2
        for kolom in 0..length*2
          pos_x = baris-length+x
          pos_y = kolom-length+y
          syarat = (get_pixel(pos_x+1,pos_y).same?(color1,color2) &&
          get_pixel(pos_x-1,pos_y).same?(color1,color2)) ||
          (get_pixel(pos_x,pos_y-1).same?(color1,color2) &&
          get_pixel(pos_x,pos_y+1).same?(color1,color2)) ||
          (get_pixel(pos_x+1,pos_y+1).same?(color1,color2) &&
          get_pixel(pos_x-1,pos_y-1).same?(color1,color2)) ||
          (get_pixel(pos_x-1,pos_y+1).same?(color1,color2) &&
          get_pixel(pos_x+1,pos_y-1).same?(color1,color2))
          if syarat && !get_pixel(pos_x,pos_y).same?(color1,color2)
            set_pixel(pos_x,pos_y,color2)
          end
        end
      end
    end
  end
  
  # ---------------------------------------------------------------------------
  # Bitmap drawing arrows. It's similar as draw line actually
  # - draw_arrow(x1,x2,y1,y2,[color])
  # - draw_arrow(coordinate1, coordinate2, [color])
  # - draw_arrow(vector, [color])
  #
  # coordinate must be Coordinate object from this basic module.
  # So do the vector
  # ---------------------------------------------------------------------------
  def draw_arrow(x1,y1=0,x2=0,y2=0,color=@@default_color.dup)
    if x1.is_a?(Vector)
      new_color = (y1.is_a?(Color) ? y1 : color)
      
      # Recursive call. Split a vector to two coordinate.
      draw_arrow(x1.pangkal,x1.ujung,new_color)
      # Return
      return
    elsif x1.is_a?(Coordinate) && y1.is_a?(Coordinate)
      pangkal = x1
      ujung = y1
      new_color = (x2.is_a?(Color) ? x2 : color)
      
      # Recursive call. Split each coordinate into two primitive x,y value
      draw_arrow(pangkal.x,pangkal.y,ujung.x,ujung.y,new_color)
      # Return
      return
    end
    # Draw basic line
    draw_line(x1,y1,x2,y2,color)
    # Get reversed degree
    degree = Vector.new(Coordinate.new(x1,y1),Coordinate.new(x2,y2)).degree-180
    # Draw arrow 
    draw_line(Vector.new(Coordinate.new(x2,y2),degree + @@arrow_degree,10),
      color)
    draw_line(Vector.new(Coordinate.new(x2,y2),degree - @@arrow_degree,10),
      color)
  end
  
end
# -----------------------------------------------------------------------------
# Draw Polygon status
# -----------------------------------------------------------------------------
class Game_Battler < Game_BattlerBase
  
  def params_array
    return [self.atk,self.def,self.mat,self.mdf,self.agi,self.luk]
  end
  
end
class Window_Base < Window
  
  def draw_polygon_params(x,y,actor,inner,outer,color1,color2)
    contents.draw_shape_params(x,y,actor.params_array,inner,color1)
    contents.draw_polygon(x,y,actor.params_array.size,outer,color2)
  end
  
end
end
#==============================================================================
# ** Object Core Movement
#------------------------------------------------------------------------------
#  This basic module allow you to move objects like Window or Sprite to a
# certain position in a given time duration. The object must be updated in each
# frame. It could also applied to any classes that contains x,y and allow it to
# be modified
#
# Avalaible methods :
# - goto(x, y, duration, [jump])
#   Tells the object to move to specified x,y coordinate in a given time
#   duration in frame. By default, the jump value is zero.
#   
# - slide(x, y, duration, jump)
#   Tells the object to slide in x,y coordinate from original position in a 
#   given time duration in frame. By default, the jump value is zero.
#
# I use this module within my sideview battle system movement sequences
#------------------------------------------------------------------------------
if $imported[:Theo_Movement]  # Activation flag
#==============================================================================
module THEO
  module Movement
    # =========================================================================
    # Exclusive class move object. To prevent adding to many instance variable
    # in object that implements this module
    # -------------------------------------------------------------------------
    class Move_Object
      attr_reader :obj # Reference object
      # -----------------------------------------------------------------------
      # *) Initialize
      # -----------------------------------------------------------------------
      def initialize(obj)
        @obj = obj
        clear_move_info
      end
      # -----------------------------------------------------------------------
      # *) Clear move info
      # -----------------------------------------------------------------------
      def clear_move_info
        @to_x = -1
        @to_y = -1
        @real_x = 0.0
        @real_y = 0.0
        @x_speed = 0.0
        @y_speed = 0.0
        @jump = 0.0
        @jump_interval = 0.0
        @offset = 0
        @duration = 0
      end
      # -----------------------------------------------------------------------
      # *) Tells the object to move
      # -----------------------------------------------------------------------
      def move_to(x,y=0,jump=0,duration=0)
        # You can also put the coordinate
        if x.is_a?(Coordinate)
          target = x
          move_to(target.x, target.y, y, jump)
          return
        end
        @to_x = x
        @to_y = y
        puts "To: #{[@to_x, @to_y]}"
        @real_x = @obj.x.to_f
        @real_y = @obj.y.to_f
        determine_speed(duration,jump)
      end
      # -----------------------------------------------------------------------
      # *) Determine traveling speed
      # -----------------------------------------------------------------------
      def determine_speed(duration,jump)
        @x_speed = (@to_x - @obj.x) / duration.to_f
        @y_speed = (@to_y - @obj.y) / duration.to_f
        @jump = jump.to_f
        @jump_interval = @jump/(duration/2.0)
        @duration = duration
      end
      # -----------------------------------------------------------------------
      # *) Is object currently moving?
      # -----------------------------------------------------------------------
      def moving?
        return false if @to_x == -1 && @to_y == -1
        result = @obj.x != @to_x || @obj.y != @to_y
        return result || @duration > 0
      end
      # -----------------------------------------------------------------------
      # *) Update movement
      # -----------------------------------------------------------------------
      def update_move # last work: fix sequence movement bugs
        @duration -= 1
        @real_x += @x_speed
        @real_y += @y_speed
        
        @obj.set_pos(@real_x, @real_y)
        if obj.is_a?(Game_Character)
          puts "OBJ POS:#{[@obj.x, @obj.y]} #{[@obj.real_x, @obj.real_y]}"
        end
        @jump -= @jump_interval
        @offset -= @jump
        clear_move_info unless moving?
      end
    end # Move_Object
    #==========================================================================
    # -------------------------------------------------------------------------
    # *) Set the movement object
    # -------------------------------------------------------------------------
    def set_obj(obj)
      # I just added only one instance variable
      @move_obj = Move_Object.new(obj) 
    end
    #-------------------------------------------------------------------------
    # *) Tells the object to move
    #-------------------------------------------------------------------------
    def goto(x,y,duration = Graphics.frame_rate,jump = 0.0)
      @move_obj.move_to(x,y,jump,duration)
    end
    # -------------------------------------------------------------------------
    # *) Tells the object to slide
    # -------------------------------------------------------------------------
    def slide(x,y,duration = Graphics.frame_rate,jump = 0.0)
      slide_x = 0
      slide_y = 0
      if x.is_a?(Coordinate)
        target  = x
        slide_x = @move_obj.obj.x + target.x
        slide_y = @move_obj.obj.y + target.y
      else
        slide_x = @move_obj.obj.x + x
        slide_y = @move_obj.obj.y + y
      end
      goto(slide_x,slide_y,duration,jump) unless moving?
    end
    # -------------------------------------------------------------------------
    # *) Update movement
    # -------------------------------------------------------------------------
    def update_move
      @move_obj.update_move if moving?
    end
    # -------------------------------------------------------------------------
    # *) Is object moving?
    # -------------------------------------------------------------------------
    def moving?
      @move_obj.moving?
    end
    # -------------------------------------------------------------------------
    # *) Slide up
    # -------------------------------------------------------------------------
    def up(range,duration = Graphics.frame_rate,jump = 0.0)
      slide(0,-range,duration,jump)
    end
    # -------------------------------------------------------------------------
    # *) Slide down
    # -------------------------------------------------------------------------
    def down(range,duration = Graphics.frame_rate,jump = 0.0)
      slide(0,range,duration,jump)
    end
    # -------------------------------------------------------------------------
    # *) Slide to right
    # -------------------------------------------------------------------------
    def right(range,duration = Graphics.frame_rate,jump = 0.0)
      slide(range,0,duration,jump)
    end
    # -------------------------------------------------------------------------
    # *) Slide to left
    # -------------------------------------------------------------------------
    def left(range,duration = Graphics.frame_rate,jump = 0.0)
      slide(-range,0,duration,jump)
    end
    # -------------------------------------------------------------------------
    # *) Slide to upright
    # -------------------------------------------------------------------------
    def upright(range,duration = Graphics.frame_rate,jump = 0.0)
      slide(range,-range,duration,jump)
    end
    # -------------------------------------------------------------------------
    # *) Slide to upleft
    # -------------------------------------------------------------------------
    def upleft(range,duration = Graphics.frame_rate,jump = 0.0)
      slide(-range,-range,duration,jump)
    end
    # -------------------------------------------------------------------------
    # *) Slide to downright
    # -------------------------------------------------------------------------
    def downright(range,duration = Graphics.frame_rate,jump = 0.0)
      slide(range,-range,duration,jump)
    end
    # -------------------------------------------------------------------------
    # *) Slide to downleft
    # -------------------------------------------------------------------------
    def downleft(range,duration = Graphics.frame_rate,jump = 0.0)
      slide(-range,range,duration,jump)
    end    
  end
end
# -----------------------------------------------------------------------------
# Implemented to Sprite
# -----------------------------------------------------------------------------
class Sprite
  include THEO::Movement
  
  alias theolized_sprite_init initialize
  def initialize(*args)
    theolized_sprite_init(*args)
    set_obj(self)
  end
  
  alias theolized_move_update update
  def update
    return if disposed?
    theolized_move_update
    update_move
  end
end
# -----------------------------------------------------------------------------
# Implemented to Window
# -----------------------------------------------------------------------------
class Window
  include THEO::Movement 
  
  alias theolized_move_window_init initialize
  def initialize(x, y, width, height)
    theolized_move_window_init(x, y, width, height)
    set_obj(self) 
  end
  
  alias theolized_move_update update
  def update
    theolized_move_update
    update_move
  end
  
end
end
#==============================================================================
# ** Object Core Fade
#------------------------------------------------------------------------------
#  Same as core movement. But this one is dealing with opacity. It can be
# implemented to any object that has opacity value. Such as Window or Sprite
#
# Avalaible methods :
# - fade(target_opacity, duration)
# - fadeout(duration)
# - fadein(duration)
#
# I use this module within my sideview battle system
#------------------------------------------------------------------------------
if $imported[:Theo_CoreFade]  # Activation flag
#==============================================================================
module THEO
  module FADE
    # Default duration of fading
    DEFAULT_DURATION = 60
    # -------------------------------------------------------------------------
    # *) Init core fade instance variables
    # -------------------------------------------------------------------------
    def init_fade_members
      @obj = nil
      @target_opacity = -1
      @fade_speed = 0.0
      @pseudo_opacity = 0
    end
    # -------------------------------------------------------------------------
    # *) Set object
    # -------------------------------------------------------------------------
    def setfade_obj(obj)
      @obj = obj
      @pseudo_opacity = @obj.opacity
    end
    # -------------------------------------------------------------------------
    # *) Fade function
    # -------------------------------------------------------------------------
    def fade(opacity, duration = DEFAULT_DURATION)
      @target_opacity = opacity
      make_fade_speed(duration)
    end
    # -------------------------------------------------------------------------
    # *) Determine fade speed
    # -------------------------------------------------------------------------
    def make_fade_speed(duration)
      @fade_speed = (@target_opacity - @obj.opacity)/duration.to_f
      @pseudo_opacity = @obj.opacity.to_f
    end
    # -------------------------------------------------------------------------
    # *) Fadeout function
    # -------------------------------------------------------------------------
    def fadeout(duration = DEFAULT_DURATION)
      fade(0, duration)
    end
    # -------------------------------------------------------------------------
    # *) Fadein function
    # -------------------------------------------------------------------------
    def fadein(duration = DEFAULT_DURATION)
      fade(255, duration)
    end
    # -------------------------------------------------------------------------
    # *) Update fade
    # -------------------------------------------------------------------------
    def update_fade
      if fade?
        @pseudo_opacity += @fade_speed
        @obj.opacity = @pseudo_opacity
      else
        @target_opacity = -1
      end
    end
    # -------------------------------------------------------------------------
    # *) Is performing fade?
    # -------------------------------------------------------------------------
    def fade?
      return false if @target_opacity == -1
      @target_opacity != @pseudo_opacity.round
    end
    
  end
end
# -----------------------------------------------------------------------------
# Implements to Sprite
# -----------------------------------------------------------------------------
class Sprite
  
  include THEO::FADE
  
  alias pre_fade_init initialize
  def initialize(*args)
    pre_fade_init(*args)
    init_fade_members
    setfade_obj(self)
  end
  
  alias pre_fade_update update
  def update
    pre_fade_update
    update_fade
  end
  
end
end
#==============================================================================
# ** Object Circular Movement
#------------------------------------------------------------------------------
#   This is the most troublesome basic module I have ever made. I wrote this 
# documentation after I made this modules months ago. So I little bit forgot
# how it works, why I did this, why I did that.
#
#   Well, this basic module is deal with circular movement of object. Like our
# Moon and Earth. You can set which coordinate/object that will be the center
# rotation. Then tells the object to surround. I'm aware this module is far
# from perfect. I'm open mind if anyone want to edit to make it better
#
# Avalaible Methods :
# - circle_move(degree, duration)
# - center_coordinate(x,y)
# - center_object(obj)
# - endless_circle(speed)
#------------------------------------------------------------------------------
if $imported[:Theo_Circular]  # Activation flag
#==============================================================================
module THEO
  module Circular
    class Circular_Obj
      attr_reader :ox           # Center coordinate X
      attr_reader :oy           # Center coordinate Y
      attr_reader :center_obj   # Center object
      attr_reader :obj          # Object
      # -----------------------------------------------------------------------
      # *) Initialize
      # -----------------------------------------------------------------------
      def initialize(obj,ox,oy,center_obj)
        @obj = obj
        @center_obj = center_obj if can_move?(center_obj)
        @ox = ox
        @oy = oy
        @speed = 0
        @endless = false
        @freeze = false
        refresh_info
      end
      # -----------------------------------------------------------------------
      # *) Refresh information
      # -----------------------------------------------------------------------
      def refresh_info
        @radius = radius
        @degree_dest = @current_degree = get_degree
      end
      # -----------------------------------------------------------------------
      # *) Set center object
      # -----------------------------------------------------------------------
      def center_obj=(center)
        return unless can_move?(center)
        @center_obj = center
        refresh_info
      end
      # -----------------------------------------------------------------------
      # *) Set center coordinate X
      # -----------------------------------------------------------------------
      def ox=(ox)
        @ox = ox
        refresh_info
      end
      # -----------------------------------------------------------------------
      # *) Set center coordinate Y
      # -----------------------------------------------------------------------
      def oy=(oy)
        @oy = oy
        refresh_info
      end
      # -----------------------------------------------------------------------
      # *) Is object can move?
      # -----------------------------------------------------------------------
      def can_move?(obj)
        obj.respond_to?("x") && obj.respond_to?("y")
      end
      # -----------------------------------------------------------------------
      # *) Circle move
      # -----------------------------------------------------------------------
      def circle_move(degree,duration)
        return if endless?
        @degree_dest = (@current_degree + degree)
        @speed = (@degree_dest - @current_degree) / duration.to_f
      end
      # -----------------------------------------------------------------------
      # *) Go to specified degree
      # -----------------------------------------------------------------------
      def circle_goto(degree,duration)
        return if endless?
        @degree_dest = degree
        @speed = (@degree_dest - @current_degree) / duration.to_f
      end
      # -----------------------------------------------------------------------
      # *) Endless circle movement
      # -----------------------------------------------------------------------
      def endless_circle(speed)
        @speed = speed
        @endless = true
      end
      # -----------------------------------------------------------------------
      # *) Get current degree from center point
      # -----------------------------------------------------------------------
      def get_degree
        Math.degree(Math.atan2(range_y,range_x)) rescue 0
      end
      # -----------------------------------------------------------------------
      # *) Get distance X from center point
      # -----------------------------------------------------------------------
      def range_x
        @obj.x - center_x
      end
      # -----------------------------------------------------------------------
      # *) Get distance Y from center point
      # -----------------------------------------------------------------------
      def range_y
        @obj.y - center_y
      end
      # -----------------------------------------------------------------------
      # *) Get coordinate X from center point
      # -----------------------------------------------------------------------
      def center_x
        @center_obj.nil? ? @ox : @center_obj.x
      end
      # -----------------------------------------------------------------------
      # *) Get coordinate Y from center point
      # -----------------------------------------------------------------------
      def center_y
        @center_obj.nil? ? @oy : @center_obj.y
      end
      # -----------------------------------------------------------------------
      # *) Get radius value from center point
      # -----------------------------------------------------------------------
      def radius
        Math.sqrt((range_x**2) + (range_y**2))
      end
      # -----------------------------------------------------------------------
      # *) Update circle movement
      # -----------------------------------------------------------------------
      def update_circle
        return if circle_frozen?
        return unless rotate? || @endless
        @current_degree += @speed
        update_x
        update_y
        @degree_dest = @current_degree if @endless
      end
      # -----------------------------------------------------------------------
      # *) Object is moving?
      # -----------------------------------------------------------------------
      def rotate?
        return @current_degree.round != @degree_dest.round
      end
      # -----------------------------------------------------------------------
      # *) Update X position
      # -----------------------------------------------------------------------
      def update_x
        @obj.x = center_x + (@radius * 
          Math.cos(Math.radian(@current_degree))).round
      end
      # -----------------------------------------------------------------------
      # *) Update Y position
      # -----------------------------------------------------------------------
      def update_y
        @obj.y = center_y + (@radius * 
          Math.sin(Math.radian(@current_degree))).round
      end
      # -----------------------------------------------------------------------
      # *) Freeze circle
      # -----------------------------------------------------------------------
      def circle_freeze
        @freeze = true
      end
      # -----------------------------------------------------------------------
      # *) Unfreeze circle
      # -----------------------------------------------------------------------
      def circle_unfreeze
        @freeze = false
      end
      # -----------------------------------------------------------------------
      # *) Is frozen?
      # -----------------------------------------------------------------------
      def circle_frozen?
        @freeze
      end
      # -----------------------------------------------------------------------
      # *) Stop circling
      # -----------------------------------------------------------------------
      def stop
        @endless = false
      end
      # -----------------------------------------------------------------------
      # *) Continue circling
      # -----------------------------------------------------------------------
      def continue
        @endless = true
      end
      # -----------------------------------------------------------------------
      # *) Endless circle?
      # -----------------------------------------------------------------------
      def endless?
        @endless
      end
    end
    # =========================================================================
    # These methods below aren't necessary to comment
    # -------------------------------------------------------------------------
    def set_circle(obj,ox = 0,oy = 0,center_obj = nil)
      @circle = Circular_Obj.new(obj,ox,oy,center_obj)
    end
    
    def stop
      @circle.stop
    end
    
    def continue
      @circle.continue
    end
    
    def endless?
      @circle.endless?
    end
    
    def circle_move(degree, dur = Graphics.frame_rate)
      @circle.circle_move(degree,dur)
    end
    
    def endless_circle(speed)
      @circle.endless_circle(speed)
    end
    
    def circle_freeze
      @circle.circle_freeze
    end
    
    def circle_unfreeze
      @circle.circle_unfreeze
    end
    
    def circle_frozed?
      @circle.circle_frozen?
    end
    
    def update_circle
      @circle.update_circle
    end
    
    def rotating?
      @circle.rotate?
    end
    
    def center_coordinate(ox,oy)
      @circle.ox = ox
      @circle.oy = oy
    end
    
    def center_distance(ox,oy)
      @circle.ox = @circle.obj.x + ox
      @circle.oy = @circle.obj.y + oy
    end
    
    def center_obj(obj)
      @circle.center_obj = obj
    end
    
    def refresh_info
      @circle.refresh_info
    end
    
  end
end
# -----------------------------------------------------------------------------
# Implements to window
# -----------------------------------------------------------------------------
class Window
  
  include THEO::Circular
  
  alias theolized_circle_window_init initialize
  def initialize(*args)
    theolized_circle_window_init(*args)
    set_circle(self,x,y)
  end
  
  alias window_circle_update update
  def update
    window_circle_update
    update_circle
  end
  
end
# -----------------------------------------------------------------------------
# Implements to sprite
# -----------------------------------------------------------------------------
class Sprite
  
  include THEO::Circular
  
  alias theolized_circle_init initialize
  def initialize(*args)
    theolized_circle_init(*args)
    set_circle(self,x,y)
  end
  
  alias sprite_circle_update update
  def update
    sprite_circle_update
    update_circle
  end
  
end
end
#==============================================================================
# ** Clone Image / Afterimage Base
#------------------------------------------------------------------------------
#  This basic modules is purposely to make sprite can be cloned / duplicated.
# In more complex concept, it could be used as base of afterimage. It's used
# within my sideview battle system
#------------------------------------------------------------------------------
if $imported[:Theo_CloneImage]  # Activation flag
#==============================================================================
class Sprite
  attr_reader :clone_bitmap
  # ---------------------------------------------------------------------------
  # *) Aliased Initialize
  # ---------------------------------------------------------------------------
  alias theo_clonesprites_init initialize
  def initialize(*args)
    @cloned_sprites = []
    @color_flash = Color.new(0,0,0,0)
    @alpha_val = 0.0
    @alpha_ease = 0.0
    @dur_flash = 0
    theo_clonesprites_init(*args)
  end
  # ---------------------------------------------------------------------------
  # *) Base function to clone sprite
  # ---------------------------------------------------------------------------
  def clone(z_pos = 0, clone_bitmap = false)
    @cloned_sprites.delete_if {|spr| spr.disposed? }
    cloned = clone_class.new(viewport)
    cloned.x = x
    cloned.y = y
    cloned.bitmap = bitmap
    cloned.bitmap = bitmap.clone if clone_bitmap
    if z_pos != 0
      cloned.z = z + z_pos
    else
      @cloned_sprites.each do |spr|
        spr.z -= 1
      end
      cloned.z = z - 1
    end
    cloned.src_rect.set(src_rect)
    cloned.zoom_x = zoom_x
    cloned.zoom_y = zoom_y
    cloned.angle = angle
    cloned.mirror = mirror
    cloned.opacity = opacity
    cloned.blend_type = blend_type
    cloned.color.set(color)
    cloned.tone.set(tone)
    cloned.visible = visible
    cloned.bush_depth = bush_depth
    cloned.bush_opacity = bush_opacity
    cloned.ox = ox
    cloned.oy = oy
    on_after_cloning(cloned)
    @cloned_sprites.push(cloned)
    cloned
  end
    
  def on_after_cloning(cloned)
    cloned.theo_clonesprites_flash(@color_flash, @dur_flash)
    # Abstract method. Overwrite it as you want
  end
  
  # Sprite class for cloned sprite
  def clone_class
    Sprite
  end
  
  alias theo_clonesprites_flash flash
  def flash(color, duration)
    theo_clonesprites_flash(color, duration)
    @dur_flash = duration
    @color_flash = color.clone
    @alpha_val = color.alpha.to_f
    @alpha_ease = @alpha_val / duration
  end
  
  alias theo_clonesprites_update update
  def update
    theo_clonesprites_update
    @dur_flash = [@dur_flash - 1,0].max
    @alpha_val = [@alpha_val - @alpha_ease,0.0].max
    @color_flash.alpha = @alpha_val
  end
  
end
# =============================================================================
# Afterimages basic module for all sprite base instance object. Any classes
# that inherited from Sprite_Base will highly possible to make afterimage
# effect.
#
# How to setup :
# - Make sure "def afterimage" should return to true
# - Set rate and opacity easing
# - Higher rate means the higher delay between displayed afterimage
# - Higher opac means the faster afterimage will fadeout
# =============================================================================
class Sprite_Base < Sprite
  attr_accessor :afterimage       # Afterimage flag
  attr_accessor :afterimage_opac  # Afterimage opacity easing
  attr_accessor :afterimage_rate  # Afterimage thick rate
  # ---------------------------------------------------------------------------
  # *) Aliased initialize
  # ---------------------------------------------------------------------------
  alias theo_afterimagebase_init initialize
  def initialize(*args)
    init_afterimage_base
    theo_afterimagebase_init(*args)
  end
  # ---------------------------------------------------------------------------
  # *) Initialize afterimage variables
  # ---------------------------------------------------------------------------
  def init_afterimage_base
    @afterimage = false
    @afterimage_count = 0
    @afterimage_rate = 3
    @afterimage_opac = 5
    @afterimages = []
  end
  # ---------------------------------------------------------------------------
  # *) Aliased update method
  # ---------------------------------------------------------------------------
  alias theo_afterimagebase_update update
  def update
    theo_afterimagebase_update
    update_afterimage_effect
  end
  # ---------------------------------------------------------------------------
  # *) Update afterimage
  # ---------------------------------------------------------------------------
  def update_afterimage_effect
    # Update and delete afterimage once its opacity has reached zero
    @afterimages.delete_if do |image|
      image.opacity -= afterimage_opac
      image.update if updating_afterimages? 
      if image.opacity == 0
        image.dispose
      end
      image.disposed?
    end
    return unless afterimage
    @afterimage_count += 1
    if @afterimage_count % afterimage_rate == 0
      @afterimages.push(clone)
    end
  end
  # ---------------------------------------------------------------------------
  # *) Is afterimages are need to be updated?
  # ---------------------------------------------------------------------------
  def updating_afterimages?
    return false
  end
  # ---------------------------------------------------------------------------
  # *) Disposes sprite alongside the afterimage to prevent RGSS3 crash
  # ---------------------------------------------------------------------------
  alias theo_afterimagebase_dispose dispose
  def dispose
    theo_afterimagebase_dispose
    @afterimages.each do |afimg|
      afimg.dispose
    end
  end
  
end
end
#==============================================================================
# ** Sprite Rotate Basic module
#------------------------------------------------------------------------------
#  This basic module only dealing with sprite angle. It's used within my
# sideview battle system to rotate weapon icon.
#------------------------------------------------------------------------------
if $imported[:Theo_RotateImage]
#==============================================================================
module Theo
  module Rotation
    # -------------------------------------------------------------------------
    # *) Init rotate function
    # -------------------------------------------------------------------------
    def init_rotate
      @degree = self.angle.to_f
      @target_degree = 0
      @rotating = false
      @rotate_speed = 0.0
    end
    # -------------------------------------------------------------------------
    # *) Change to specific angle
    # -------------------------------------------------------------------------
    def change_angle(target_degree, duration)
      @degree = self.angle.to_f
      @target_degree = target_degree.to_f
      if duration == 0
        @rotate_speed = target_degree
      else
        @rotate_speed = (target_degree - @degree) / duration
      end
      @rotating = true
    end
    # -------------------------------------------------------------------------
    # *) Update rotation
    # -------------------------------------------------------------------------
    def update_rotation
      return unless @rotating
      @degree += @rotate_speed
      new_angle = @degree.round
      self.angle = new_angle
      if new_angle == @target_degree
        init_rotate
      end
    end
    # -------------------------------------------------------------------------
    # *) Start rotate to additional degree
    # -------------------------------------------------------------------------
    def start_rotate(degree_plus, duration)
      change_angle(@degree + degree_plus, duration)
    end
    
  end
end
# -----------------------------------------------------------------------------
# Implements on sprite
# -----------------------------------------------------------------------------
class Sprite
  include Theo::Rotation
  
  alias theo_spr_rotate_init initialize
  def initialize(viewport = nil)
    theo_spr_rotate_init(viewport)
    init_rotate
  end
  
  alias theo_spr_rotate_update update
  def update
    theo_spr_rotate_update
    update_rotation
  end
  
end
end
#==============================================================================
# ** Smooth_Slide
#------------------------------------------------------------------------------
#  This module provides basic module for smooth sliding. It can be implemented
# to any classes as long as they have x and y.
#
# Avalaible methods :
# - smooth_move(x,y,dur,[reverse])
#   Tells the object to move to specific x,y coordinate in given time duration
#   in frame. If reverse set to true, object will start with maximum speed
#
# - smooth_slide(x,y,dur,[reverse])
#   Tells the object to slide to specific x,y coordinate from original position
#   in given time duration in frame. If reverse set to true, object will start 
#   with maximum speed
#------------------------------------------------------------------------------
if $imported[:Theo_SmoothMove]  # Activation Flag
#==============================================================================
module Smooth_Slide 
  # ---------------------------------------------------------------------------
  # Initialize smooth movement data
  # ---------------------------------------------------------------------------
  def init_smove
    @smooth_dur = 0     # Travel duration
    @accel_x = 0.0      # Acceleration X
    @accel_y = 0.0      # Acceleration Y
    @vel_x = 0.0        # Velocity X
    @vel_y = 0.0        # Velocity Y
    @sreal_x = self.x   # Real position X 
    @sreal_y = self.y   # Real Position Y
    @starget_x = 0.0    # Target X
    @starget_y = 0.0    # Target Y
    @srev = false       # Reverse Flag
    @smove = false      # Moving Flag
    
    # The reason why I give 's' in front of most instance variables is for
    # uniqueness. Well, if there is any basic module / script out there that
    # also use same instance name, it may causes incompatibility
    
  end
  # ---------------------------------------------------------------------------
  # Do smooth movement
  # ---------------------------------------------------------------------------
  def smooth_move(x,y,dur,reverse = false)
    init_smove
    @srev = reverse
    @smove = true
    @smooth_dur = dur
    @sreal_x = self.x.to_f
    @sreal_y = self.y.to_f
    @starget_x = x.to_i
    @starget_y = y.to_i
    calc_accel
  end
  # ---------------------------------------------------------------------------
  # Do smooth slide
  # ---------------------------------------------------------------------------
  def smooth_slide(x,y,dur,reverse = false)
    tx = x + self.x
    ty = y + self.y
    smooth_move(tx,ty,dur,reverse)
  end
  # ---------------------------------------------------------------------------
  # Calculate acceleration
  # ---------------------------------------------------------------------------
  def calc_accel
    # Get travel distance
    dist_x = @starget_x - @sreal_x
    dist_y = @starget_y - @sreal_y
    
    # Calculate acceleration
    @accel_x = (dist_x/((@smooth_dur**2)/2.0))
    @accel_y = (dist_y/((@smooth_dur**2)/2.0))
    
    # If reverse, velocity started on max speed
    if @srev
      @vel_x = (@accel_x * (@smooth_dur.to_f - 0.5))
      @vel_y = (@accel_y * (@smooth_dur.to_f - 0.5))
    end
  end
  # ---------------------------------------------------------------------------
  # Execute end smooth
  # ---------------------------------------------------------------------------
  def end_smooth_slide
    init_smove
  end
  # ---------------------------------------------------------------------------
  # Update Smooth movement
  # ---------------------------------------------------------------------------
  def update_smove
    if @smove
      # If not reversed. Increase velocity on the first time executed
      if !@srev
        @vel_x += @accel_x
        @vel_y += @accel_y
      end
      
      # Give increment / decrement upon real position
      @sreal_x = (@starget_x > @sreal_x ? 
        [@sreal_x + @vel_x, @starget_x].min : 
        [@sreal_x + @vel_x, @starget_x].max)
      @sreal_y = (@starget_y > @sreal_y ? 
        [@sreal_y + @vel_y, @starget_y].min : 
        [@sreal_y + @vel_y, @starget_y].max)
      
      # Rounded real position 
      self.x = @sreal_x.round
      self.y = @sreal_y.round
      
      # If reversed, decrease velocity after make a change to real position
      if @srev
        @vel_x -= @accel_x
        @vel_y -= @accel_y
      end
      
      # If target has reach it's destination, call end execution
      if (self.x == @starget_x && self.y == @starget_y)
        end_smooth_slide
      end
    end
  end
  # ---------------------------------------------------------------------------
  # Get smooth moving flag
  # ---------------------------------------------------------------------------
  def smoving?
    @smove
  end
  
end
# -----------------------------------------------------------------------------
# Implemented on sprite
# -----------------------------------------------------------------------------
class Sprite
  include Smooth_Slide
  
  alias smooth_init initialize
  def initialize(v=nil)
    smooth_init(v)
    init_smove
  end
  
  alias smooth_update update
  def update
    smooth_update
    update_smove
  end
  
end
# -----------------------------------------------------------------------------
# Implemented on window
# -----------------------------------------------------------------------------
class Window
  include Smooth_Slide
  
  alias smooth_init initialize
  def initialize(*args)
    smooth_init(*args)
    init_smove
  end
  
  alias smooth_update update
  def update
    smooth_update
    update_smove
  end
  
end
end
# =============================================================================
# Below this line are just miscellaneous functions
# -----------------------------------------------------------------------------
# Debug print line
# -----------------------------------------------------------------------------
def debug
  puts "This line is executed"
end
# -----------------------------------------------------------------------------
# Debug print frame
# -----------------------------------------------------------------------------
def debugc
  puts Graphics.frame_count
end
# -----------------------------------------------------------------------------
# Copy object. Because calling clone/dup sometimes is not enough
# -----------------------------------------------------------------------------
def copy(object)
  Marshal.load(Marshal.dump(object))
end
module TSBS
  # ---------------------------------------------------------------------------
  SEQUENCE_POSE             = :pose           # set pose
  SEQUENCE_MOVE             = :move           # trigger move     
  SEQUENCE_SLIDE            = :slide          # trigger slide
  SEQUENCE_RESET            = :goto_oripost   # trigger back to original post
  SEQUENCE_MOVE_TO_TARGET   = :move_to_target # trigger move to target
  SEQUENCE_SCRIPT           = :script         # call script function
  SEQUENCE_WAIT             = :wait           # wait for x frames
  SEQUENCE_DAMAGE           = :target_damage  # Apply skill/item to target
  SEQUENCE_SHOW_ANIMATION   = :show_anim      # Show animation on target
  SEQUENCE_CAST             = :cast           # Show animation on self
  SEQUENCE_VISIBLE          = :visible        # Toggle visibility
  SEQUENCE_AFTERIMAGE       = :afterimage     # Toggle afterimage effect
  SEQUENCE_FLIP             = :flip           # Toggle flip / mirror sprite
  SEQUENCE_ACTION           = :action         # Call predefined action
  SEQUENCE_PROJECTILE       = :projectile     # Show projectile
  SEQUENCE_PROJECTILE_SETUP = :proj_setup     # Setup projectile
  SEQUENCE_LOCK_Z           = :lock_z         # Lock shadow (and Z)
  SEQUENCE_ICON             = :icon           # Show icon
  SEQUENCE_SOUND            = :sound          # Play SE
  SEQUENCE_IF               = :if             # Set Branched condition
  SEQUENCE_TIMED_HIT        = :timed_hit      # Trigger timed hit function
  SEQUENCE_SCREEN           = :screen         # Setup screen
  SEQUENCE_ADD_STATE        = :add_state      # Add state
  SEQUENCE_REM_STATE        = :rem_state      # Remove state
  SEQUENCE_CHANGE_TARGET    = :change_target  # Change current target
  SEQUENCE_TARGET_MOVE      = :target_move    # Force move target
  SEQUENCE_TARGET_SLIDE     = :target_slide   # Force slide target
  SEQUENCE_TARGET_RESET     = :target_reset   # Force target to return
  SEQUENCE_BLEND            = :blend          # Setup battler blending
  SEQUENCE_FOCUS            = :focus          # Setup focus effect
  SEQUENCE_UNFOCUS          = :unfocus        # Remove focus effect
  SEQUENCE_TARGET_LOCK_Z    = :target_lock_z  # Lock target shadow (and Z)
  # ---------------------------------------------------------------------------
  SEQUENCE_ANIMTOP          = :anim_top     # Flag animation in always on top  
  SEQUENCE_FREEZE           = :freeze       # Freeze the screen (not tested) 
  SEQUENCE_CSTART           = :cutin_start  # Start cutin graphic)
  SEQUENCE_CFADE            = :cutin_fade   # Fade cutin graphic
  SEQUENCE_CMOVE            = :cutin_slide  # Slide cutin graphic
  SEQUENCE_TARGET_FLIP      = :target_flip  # Flip target
  SEQUENCE_PLANE_ADD        = :plane_add    # Show looping image
  SEQUENCE_PLANE_DEL        = :plane_del    # Delete looping image
  SEQUENCE_BOOMERANG        = :boomerang    # Flag projectile as boomerang
  SEQUENCE_PROJ_AFTERIMAGE  = :proj_afimage # Set afterimage for projectile
  SEQUENCE_BALLOON          = :balloon      # Show balloon icon
  # ---------------------------------------------------------------------------
  SEQUENCE_LOGWINDOW        = :log        # Display battle log
  SEQUENCE_LOGCLEAR         = :log_clear  # Clear battle log
  SEQUENCE_AFTINFO          = :aft_info   # Change afterimage
  SEQUENCE_SMMOVE           = :sm_move    # Smooth move
  SEQUENCE_SMSLIDE          = :sm_slide   # Smooth slide
  SEQUENCE_SMTARGET         = :sm_target  # Smooth move to target
  SEQUENCE_SMRETURN         = :sm_return  # Smooth return
  # ---------------------------------------------------------------------------
  SEQUENCE_LOOP             = :loop         # Loop in n times
  SEQUENCE_WHILE            = :while        # While loop
  SEQUENCE_COLLAPSE         = :collapse     # Perform collapse effect  
  SEQUENCE_FORCED           = :forced       # Force change action key to target
  SEQUENCE_ANIMBOTTOM       = :anim_bottom    # Play anim behind battler
  SEQUENCE_CASE             = :case           # Case switch
  SEQUENCE_INSTANT_RESET    = :instant_reset  # Instant reset
  SEQUENCE_ANIMFOLLOW       = :anim_follow    # Animation follow the battler
  SEQUENCE_CHANGE_SKILL     = :change_skill   # Change carried skill
  #---------------------------------------------------------------------------
  SEQUENCE_CHECKCOLLAPSE    = :check_collapse # Check collapse for target
  SEQUENCE_RESETCOUNTER     = :reset_counter  # Reset damage counter
  SEQUENCE_FORCEHIT         = :force_hit      # Toggle force to always hit
  SEQUENCE_SLOWMOTION       = :slow_motion    # Slow Motion effect
  SEQUENCE_TIMESTOP         = :timestop       # Timestop effect
  #---------------------------------------------------------------------------
  SEQUENCE_ONEANIM          = :one_anim       # One Anim Flag
  SEQUENCE_PROJ_SCALE       = :proj_scale     # Scale damage for projectile
  SEQUENCE_COMMON_EVENT     = :com_event      # Call common event
  SEQUENCE_GRAPHICS_FREEZE  = :scr_freeze     # Freeze the graphic
  SEQUENCE_GRAPHICS_TRANS   = :scr_trans      # Transition
  #---------------------------------------------------------------------------
  SEQUENCE_FORCEDODGE       = :force_evade    # Force target to evade
  SEQUENCE_FORCEREFLECT     = :force_reflect  # Force target to reflect magic
  SEQUENCE_FORCECOUNTER     = :force_counter  # Force target to counter
  SEQUENCE_FORCECRITICAL    = :force_critical # Force criticaly hit to target
  SEQUENCE_FORCEMISS        = :force_miss     # Force miss target
  SEQUENCE_BACKDROP         = :backdrop       # Change Battleback
  SEQUENCE_BACKTRANS        = :back_trans     # Backdrop Change transition
  SEQUENCE_REVERT_BACKDROP  = :reset_backdrop # Reset battleback
  SEQUENCE_TARGET_FOCUS     = :target_focus   # Custom target focus
  SEQUENCE_SCREEN_FADEOUT   = :scr_fadeout    # Fadeout screen
  SEQUENCE_SCREEN_FADEIN    = :scr_fadein     # Fadein screen
  SEQUENCE_CHECK_COVER      = :check_cover    # Check battler cover
  SEQUENCE_STOP_MOVEMENT    = :stop_move      # Stop all movement
  SEQUENCE_ROTATION         = :rotate         # Rotate battler
  SEQUENCE_FADEIN           = :fadein         # Self fadein
  SEQUENCE_FADEOUT          = :fadeout        # Self fadeout
  SEQUENCE_IMMORTALING      = :immortal       # Immortal flag
  SEQUENCE_END_ACTION       = :end_action     # Force end action
  SEQUENCE_SHADOW_VISIBLE   = :shadow         # Shadow visibility
  SEQUENCE_AUTOPOSE         = :autopose       # Automatic pose
  SEQUENCE_ICONFILE         = :icon_file      # Set icon file
  SEQUENCE_IGNOREFLIP       = :ignore_flip    # Ignore flip reverse point
  #=====================================================================
  # Screen sub-modes
  Screen_Tone       = :tone       # Set screen tone
  Screen_Shake      = :shake      # Set screen shake
  Screen_Flash      = :flash      # Set screen flash
  Screen_Normalize  = :normalize  # Normalize screen
  
  # Projectile setup
  PROJ_START          = :start      # Initial starting (head, mid, feet)
  PROJ_END            = :end        # Initial end position (head, mid, feet)
  PROJ_STARTPOS       = :start_pos  # Relative starting coordinate 
  PROJ_ENDPOS         = :end_pos    # Relative end position
  PROJ_REVERSE        = :reverse    # Reverse flag
  PROJ_POSITION_HEAD  = :head       # Position : head
  PROJ_POSITION_MID   = :middle     # Position : middle
  PROJ_POSITION_FEET  = :feet       # Position : feet
  PROJ_POSITION_NONE  = :none       # Position : none
  PROJ_POSITION_SELF  = :self       # Position : self (put only in PROJ_END)
  PROJ_POSITION_LAST_TARGET = :last_target
  PROJ_DAMAGE_EXE     = :damage     # Damage execution after hit
  PROJ_ANIMSTART      = :anim_start # Custom animation on start
  PROJ_ANIMEND        = :anim_end   # Custom animation on start
  PROJ_ANIMPOS        = :anim_pos   # Animation position
  PROJ_ANIMDEFAULT    = :default    # Default animation
  PROJ_ANIMHIT        = :anim_hit   # Play animation only if hit
  PROJ_SCALE          = :scale      # Damage Scale
  PROJ_PIERCE         = :pierce     # Piercing flag
  PROJ_BOOMERANG      = :boomerang  # Boomerang flag
  PROJ_AFTERIMAGE     = :aftimg     # Afterimage flag
  PROJ_AFTOPAC        = :aft_opac   # Afterimage opacity easing
  PROJ_AFTRATE        = :aft_rate   # Afterimage clone rate
  PROJ_ANGLE          = :angle      # Starting angle
  PROJ_WAITCOUNT      = :wait       # Wait frame before throws
  PROJ_CHANGE         = :change     # Change flag
  PROJ_FLASH_REF      = :flash      # Animation flash references
  PROJ_RESET          = :reset      # Reset command
  # Default projectile setup (version 1.4)
  PROJECTILE_DEFAULT = {
    PROJ_START      => PROJ_POSITION_MID, # Done ~ !
    PROJ_END        => PROJ_POSITION_MID, # Done ~ !
    PROJ_STARTPOS   => [0,0,0], # Done ~ !
    PROJ_ENDPOS     => [0,0,0], # Done ~ !
    PROJ_REVERSE    => false, # Not tested!
    PROJ_SCALE      => 1.0,   # Done ~ !
    PROJ_DAMAGE_EXE => 1,     # Not tested!
    PROJ_PIERCE     => false, # Done ~ !
    PROJ_BOOMERANG  => false, # Done ~ !
    PROJ_AFTERIMAGE => false, # Done ~ !
    PROJ_AFTOPAC    => 17,    # Done ~ !
    PROJ_AFTRATE    => 1,     # Done ~ !
    PROJ_ANIMSTART  => nil,   # Done ~ !
    PROJ_ANIMEND    => nil,   # Done ~ !
    PROJ_ANIMPOS    => 0,     # Done ~ !
    PROJ_ANIMHIT    => false, # Done ~ !
    PROJ_ANGLE      => 0.0,   # Done ~ !
    PROJ_WAITCOUNT  => 0,     # Done ~ !
    PROJ_FLASH_REF  => [false, false], # Done ~ !
  }
  # Default afterimage setting
  AFTIMG_OPACITY_EASE = 20  # opacity easing
  AFTIMG_IMAGE_RATE   = 2   # image cloning rate
  
  # Default setting for balloon
  BALLOON_SPEED = 8 # Balloon change speed.
  BALLOON_WAIT  = 12 # Wait count in last frame
  
  # Backdrop constant
  BACKDROP_SWITCH   = :switch
  BACKDROP_DURATION = :duration
  BACKDROP_NAME     = :name
  BACKDROP_VAGUE    = :vague
  
  # Backdrop transition default setting
  BACKDROP_TRANS_DEFAULT = {
    BACKDROP_SWITCH   => true,
    BACKDROP_DURATION => 45,
    BACKDROP_NAME     => "",
    BACKDROP_VAGUE    => 120,
  }
  
  TSBS_END_SEQUENCE_WAIT = 30 
  # Frame wait after perform sequence
  CONVERT_DRAIN = true 
  # When magic reflected, drain damage type will be converted to normal damage
  
  #TIMED_HIT_BUTTON_SYMBOL = :button
  #TIMED_HIT_TIMING_SYMBOL = :timing
  #TIMED_HIT_ANIME_SYMBOL  = :anim
  #TIMED_HIT_ANIME_FOLLOW  = :follow
  #TIMED_HIT_DEFAULT_BUTTON = :C
  
  #TIMED_HIT_SETUP = {
    #TIMED_HIT_BUTTON_SYMBOL => [TIMED_HIT_DEFAULT_BUTTON],
    #TIMED_HIT_TIMING_SYMBOL => 0,
    #TIMED_HIT_ANIME_SYMBOL => TimedHit_Anim,
    #TIMED_HIT_ANIME_FOLLOW => true,
  #}
  
  # Not yet implemented
  FOCUS_TYPE_FADES    = :fade
  FOCUS_TYPE_BLACKOUT = :blackout
  FOCUS_BLACKOUT_DEFAULT_COLOR = Color.new(0,0,0,150)
  
  # -------------------------------------------------------------------------
  # Regular Expression (REGEXP) Constants. Want to simplify notetags? edit 
  # this section. If only you understand the ruby regular expression
  # -------------------------------------------------------------------------
  AnimGuard = /<anim[_\s]+guard\s*:\s*(\d+)>/i
  # Notetag for animation guard
  SkillGuard = /<skill[_\s]+guard\s*:\s*(\d+)>/i
  # Notetag for skill guard
  
  SGRange = /<sg[\s_]+range\s*:\s*(\d+)>/i
  # Skill Guard range
  
  IgnoreSkillGuard = /<ignore[-\s]skill[-\s]guard>/i
  # Notetag for skill that ignore state skill guard
  
  IgnoreAnimGuard = /<ignore[-\s]anim[-\s]guard>/i
  # Notetag for skill that ignore state skill guard
  
  ParallelTAG = /<parallel[\s_]+anim>/i
  # Pararrel tag to plays animation and anim guard simultaneously
  
  StateOpacity = /<opacity\s*:\s*(\d+)>/i
  # Notetag for state Opacity
  
  SequenceREGX = /\\sequence\s*:\s*(.+)/i
  # Action sequence notetag in skill
  
  PrepareREGX = /\\preparation\s*:\s*(.+)/i
  # Preparation move for skill
  
  ReturnREGX = /\\return\s*:\s*(.+)/i
  # Return sequence movement for each skill
  
  ReflectAnim = /<reflect[_\s]+anim\s*:\s*(\d+)>/i
  # Reflect animation for skill
  
  AreaTAG = /<area>/i
  # Tag for area skill
  
  NoReturnTAG = /<no[\s_]+return>/i
  # Tag for no return sequence for skill
  
  NoShadowTAG = /<no[\s_]+shadow>/i
  # Tag for no shadow for actor/enemy
  
  AbsoluteTarget = /<abs[-_\s]+target>/i
  # Tag for absolute targeting
  
  StateAnim = /<animation\s*:\s*(\d+)/i
  # State Animation ID notetag
  
  AlwaysHit = /<always[_\s]+hit>/i
  # Always hit tag
  
  AntiCounter = /<anti[_\s]+counter>/i
  # Anti counter attack
  
  AntiReflect = /<anti[_\s]+reflect>/i
  # Anti magic reflect
  
  CounterSkillID = /<counter[_\s]+skill\s*:\s*(\d+)>/i
  # Counter Skill ID
  
  RandomReflect = /<random[_\s]+reflect>/i
  # Random magic reflection
  
  Transform = /<transform\s*:\s*(.+)>/i
  # Transform State
  
  DefaultFlip = /<flip>/i
  # Default flip for enemies
  
  DefaultATK = /<attack[\s_]*:\s*(\d+)>/i
  DefaultDEF = /<guard[\s_]*:\s*(\d+)>/i
  # Default basic actions
  
  AnimBehind = /<anim[\s_]+behind>/i
  # State Animation behind flag
  
  CollapSound = /<collapsound\s*:\s*(.+)\s*,\s*(\d+)\s*,\s*(\d+)\s*>/i
  # Collapse sound effect 
  
  OneAnimation = /<one[\s_]+animation>/i
  # One Animation tag
  
  FolderRef = /<folder\s*:\s*(.+)>/i
  # Battler folder reference
  
  CustomShadow = /<shadow\s*:\s*(.+)>/i
  # Custom battler shadow
  
  ShadowYPOS = /<shadow\s+pos\s*:\s*(-|\+*)(.+)>/i
  # Shadow Y Position
  
  CustomFlip = /<custom[\s_]+flip>/i
  # Custom Flip flag
  
  ClassChangeName = /<classname\s*:\s*(.+)>/i
  # Class change battler graphics
  
  IconFile = /<iconfile\s*:\s*(.+)>/i
  # Icon file graphics for weapons
  
  ToneREGX = 
  /<tone:\s*(-|\+*)(\d+),\s*(-|\+*)(\d+),\s*(-|\+*)(\d+),\s*(-|\+*)(\d+)>/i
  # Regular expression for state tone tag
  
  ColorREGX =
  /<color:\s*(-|\+*)(\d+),\s*(-|\+*)(\d+),\s*(-|\+*)(\d+),\s*(-|\+*)(\d+)>/i
  # Regular expression for state color blend
  
  SBS_Start   = /<sideview>/i             # Starting Sideview Tag
  SBS_Start_S = /<sideview\s*:\s*(.+)>/i  # Starting with string
  SBS_End     = /<\/sideview>/i           # End of sideview tag
  # ---------------------------------------------
  # Sideview tags
  # ---------------------------------------------
  SBS_Idle      = /\s*idle\s*:\s*(.+)/i
  SBS_Critical  = /\s*critical\s*:\s*(.+)/i
  SBS_Evade     = /\s*evade\s*:\s*(.+)/i
  SBS_Hurt      = /\s*hurt\s*:\s*(.+)/i
  SBS_Return    = /\s*return\s*:\s*(.+)/i
  SBS_Dead      = /\s*dead\s*:\s*(.+)/i
  SBS_Escape    = /\s*escape\s*:\s*(.+)/i
  SBS_Win       = /\s*victory\s*:\s*(.+)/i
  SBS_Intro     = /\s*intro\s*:\s*(.+)/i
  SBS_Counter   = /\s*counter\s*:\s*(.+)/i
  SBS_Collapse  = /\s*collapse\s*:\s*(.+)/i
  # -------------------------------------------------------------------------
  # Error Handler. Because I don't want to be the one who blamed ~
  # -------------------------------------------------------------------------
  ErrorSound = RPG::SE.new("Buzzer1",100,100)
  def self.error(symbol, params, seq)
    ErrorSound.play
    text = "Sequence : #{seq}\n" +
    "#{symbol} mode needs at least #{params} parameters"
    msgbox text
    exit
  end
  #============================================================================
  # * Screen_Point class used to screen reposition (Battle Camera)
  # ---------------------------------------------------------------------------
  class Screen_Point
    attr_accessor :x
    attr_accessor :y
    #--------------------------
    include THEO::Movement
    include Smooth_Slide
    #--------------------------
    def initialize(x = 0, y = 0)
      set(x,y)
      set_obj(self)
      init_smove
    end
    #--------------------------
    # Set at once
    #--------------------------
    def set(x,y)
      @x = x
      @y = y
    end
    alias :set_pos :set
    #--------------------------
    # Update move
    #--------------------------
    def update_move
      super
      update_smove
    end
    #--------------------------
    def clear_move_info
      @move_obj.clear_move_info
    end
    #--------------------------
    alias screen_x x
    alias screen_y y
  end
  #============================================================================
  # * Afterimage sprite
  # ---------------------------------------------------------------------------
  class Afterimage < Sprite
    def initialize(vport = nil)
      super
      @screen_point = Screen_Point.new
    end
    # -------------------------------------------------------------------------
    # * Refresh point value
    # -------------------------------------------------------------------------
    def refresh_point(x, y)
      @screen_point.x = x
      @screen_point.y = y
      update_point_placement
    end
    # -------------------------------------------------------------------------
    # * Update
    # -------------------------------------------------------------------------
    def update   
      super
      update_point_placement
      self.zoom_x = self.zoom_y = $tsbs_camera.zoom
    end
    # -------------------------------------------------------------------------
    # * Update point placement
    # -------------------------------------------------------------------------
    def update_point_placement
      self.x = @screen_point.screen_x
      self.y = @screen_point.screen_y
    end
  end
end

module WindowSkin
  
  # Main settings
  Skins = [
  "Window",                  #  0
  "Window _MenuCommand",     #  1
  "Window_spellbook",        #  2
  "Window_infos",            #  3 
  "Window_itemmoreinfo",     #  4
  "Rainbow dash5",           #  5
  "Luna",                    #  6
  "Pinkie pie4",             #  7
  "Celestia",                #  8
  "Fluttershy7",             #  9 
  "Applejack2",              # 10
  "ModeWindow",              # 11
  "BoarderlessBlack",        # 12
  "Empty",                   # 13
  ]
  
  Default = "Window"
  Enable  = true
  
  # Variables that may be interfered with by other scripts that define 
  # windowskins.
  Normal      = Skins[0]
  Title       = Skins[0]
  Message     = Skins[0]
  Menu        = Skins[0]
  SkillList   = Skins[0]
  EquipList   = Skins[0]
  StatusList  = Skins[0]
  DataList    = Skins[0]
  ShopMenu    = Skins[0]
  DebugWindow = Skins[0]
  SpellBook   = Skins[2]
  MapInfo     = Skins[3]
  InputBox    = Skins[3]
  ItemInfo    = Skins[4]
  Pinkie      = Skins[7]
  RainbowDash = Skins[5]
  Luna        = Skins[6]
  Celestia    = Skins[8]
  Fluttershy  = Skins[9]
  ItemAction  = Skins[6]
  Applejack   = Skins[10]
  ModeWindow  = Skins[11]
  BBoarder    = Skins[12]
  Empty       = Skins[13]
end

#==============================================================================
# ** BlockChain::Block
#------------------------------------------------------------------------------
#  The Block
#==============================================================================
$imported = {} if $imported.nil?
module BlockChain
  #==============================================================================
  # * Block Header
  #==============================================================================
  class Block_Header
  	#--------------------------------------------------------------------------
    # * Instance Vars
    #--------------------------------------------------------------------------
    attr_reader :previous_blockhash
    attr_reader :timestamp
    attr_reader :difficulty
    attr_reader :nonce
    attr_reader :merkle_roothash
    attr_reader :genesis
    attr_reader :hashid
  	#--------------------------------------------------------------------------
    # * Block Initialization
    #--------------------------------------------------------------------------
    def initialize(parent_hash, height, target, _genesis)
      @previous_blockhash = parent_hash
      @nonce = (rand() * 1000000000).to_i + height
      @difficulty = target
      @timestamp = Time.now
      @genesis = _genesis
      @merkle_roothash = PONY.MD5("friendship is magic").to_i(16)
      update_hash
    end
    #--------------------------------------------------------------------------
    # * Update invailed nonce
    #--------------------------------------------------------------------------
    def update_nonce
      @nonce = (rand() * 1000000000).to_i
      update_hash
    end
    #--------------------------------------------------------------------------
    # * Push Transaction
    #--------------------------------------------------------------------------
    def push_info(info)
      @merkle_roothash = PONY.MD5(@merkle_roothash.to_s + info).to_i(16)
      update_hash
    end
    #--------------------------------------------------------------------------
    # * Update hashid after nonce changed
    #--------------------------------------------------------------------------
    def update_hash
      base = @previous_blockhash ? 0 : @previous_blockhash
      base = @merkle_roothash + @nonce + @difficulty
      @hashid = PONY.Sha256(base.to_s).to_i(16)
    end
    def sign; push_info(PONY.Verify(@nonce, @difficulty)); end
  end
  #==============================================================================
  # * Block Index
  #==============================================================================
  class Block
  	#--------------------------------------------------------------------------
    # * Instance Vars
    #--------------------------------------------------------------------------
    attr_reader :hashid
    attr_reader :header
    attr_reader :height
    attr_reader :record
    attr_reader :difficulty
    attr_reader :parent_hash
    attr_reader :prev_transsum
    attr_reader :magic_num
    attr_reader :value
  	#--------------------------------------------------------------------------
    # * Block Initialization
    #--------------------------------------------------------------------------
    def initialize(parent, _height, difficulty, genesis = false)
      @magic_num = rand() * (10 ** 9)
      @parent_hash = parent
      @height = _height
      @record = []
      @difficulty = difficulty
      @header = Block_Header.new(parent, @height, difficulty, genesis)
      @prev_transsum = 0
      @value = 0
      update_hash
      verify_genesis
    end
    #--------------------------------------------------------------------------
    def verify_genesis
      if genesis? && @parent_hash
        info = "Child genesis block"
        PONY::ERRNO.raise(:chain_broken, :exit, nil, info)
      elsif !genesis? && !@parent_hash
        info = "Chain broken"
        PONY::ERRNO.raise(:chain_broken, :exit, nil, info)
      end
    end
    #--------------------------------------------------------------------------
    # * Block Mining
    #--------------------------------------------------------------------------
    def mining
      return :no_record unless @record.size > 0
      @header.update_nonce
      update_hash(true)
      succ = PONY.Mining(nonce, @difficulty).to_bool
      @header.sign if succ
      update_hash  if succ
      return succ
    end
    #--------------------------------------------------------------------------
    # * Update hashid after nonce changed
    #-------------------------------------------------------------------------- 
    def update_hash(header_only = false)
      sum = @header.hashid
      sum += header_only ? @prev_transsum : 0
      if !header_only
        record.each {|trans| sum += trans.hashid}
        @prev_transsum = sum
      end
      @hashid = PONY.Sha256(sum).to_i(16)
    end
    #--------------------------------------------------------------------------
    # * Push Extra Transaction
    #--------------------------------------------------------------------------
    def push_transaction(trans)
      @record.push(trans)
      @header.push_info(trans.info)
      @value += trans.value
      BlockChain.record_transaction(trans)
      update_hash
    end
    #--------------------------------------------------------------------------
    # * Query account balance
    #--------------------------------------------------------------------------
    def account_balance(accid, currency_id, async)
      sum = 0
      record.each do |trans|
        next unless trans.type == currency_id
        if async
          t = Thread_Assist.pause? ? 1 : Thread_Assist::Uwait
          sleep(t)
        end
        sum += trans.value if trans.recipient == accid
        sum -= trans.value if trans.source    == accid
      end
      return sum
    end
    #--------------------------------------------------------------------------
    # * Query item amount in player's saddlebag
    #--------------------------------------------------------------------------
    def item_amount(accid, item_hashid, async)
      sum = 0
      record.each do |trans|
        next unless trans.goods && trans.goods.hashid == item_hashid
        if async
          t = Thread_Assist.pause? ? 1 : Thread_Assist::Uwait
          sleep(t)
        end
        # recipient is the one who receive the money, sell the good, so good
        # amount is decreased, and vice versa
        sum -= trans.good_amount if trans.recipient == accid
        sum += trans.good_amount if trans.source    == accid
      end
      return sum
    end
    #--------------------------------------------------------------------------
    def all_items(items, accid, async)
      record.each do |trans|
        next unless trans.goods
        if async
          t = Thread_Assist.pause? ? 1 : Thread_Assist::Uwait
          sleep(t)
        end
        item     = trans.goods
        itemname = trans.goods.name rescue nil
        type = :item   if item.is_a?(RPG::Item)
        type = :weapon if item.is_a?(RPG::Weapon)
        type = :armor  if item.is_a?(RPG::Armor)
        if !type
          info = "Invalid item transaction: #{itemname} for #{item.class}"
          PONY::ERRNO.raise(:datatype_error, :exit, nil, info)
        end
        items[type][item.hashid] = 0 if !items[type][item.hashid]
        items[type][item.hashid] -= trans.good_amount if trans.recipient == accid
        items[type][item.hashid] += trans.good_amount if trans.source    == accid
      end
      return items
    end
    #--------------------------------------------------------------------------
    def all_data(data, accid, async)
      record.each do |trans|
        if async
          t = Thread_Assist.pause? ? 1 : Thread_Assist::Uwait
          sleep(t)
        end
        data[:gold] = 0 if !data[:gold]
        data[:gold] += trans.value if trans.recipient == accid
        data[:gold] -= trans.value if trans.source    == accid
        
        item     = trans.goods
        itemname = trans.goods.name rescue nil
        next if item.nil?
        type = :item   if item.is_a?(RPG::Item)
        type = :weapon if item.is_a?(RPG::Weapon)
        type = :armor  if item.is_a?(RPG::Armor)
        if !type
          info = "Invalid item transaction: #{itemname} for #{item.class}"
          PONY::ERRNO.raise(:datatype_error, :exit, nil, info)
        end
        data[type][item.hashid] = 0 if !data[type][item.hashid]
        data[type][item.hashid] -= trans.good_amount if trans.recipient == accid
        data[type][item.hashid] += trans.good_amount if trans.source    == accid
      end
      return data
    end
    #--------------------------------------------------------------------------
    # * Merge transaction
    #--------------------------------------------------------------------------
    def merge_transaction(trans)
      succ = false
      @record.each do |oldtrans|
        succ = !oldtrans.merge(trans).nil?
        break if succ
      end
      PONY::ERRNO.raise(:checksum_failed, :exit) if succ == :checksum_failed
      return succ
    end
    #--------------------------------------------------------------------------
    # * Sync data
    #--------------------------------------------------------------------------
    def sync_data(block)
      @difficulty    = block.difficulty
      @parent_hash   = block.parent_hash
      @prev_transsum = block.prev_transsum
      @height        = block.height
      @magic_num     = block.magic_num
      @header        = block.header.dup
      @value         = block.value
      sync_record(block.record)
      update_hash
    end
    
    def sync_record(record)
      @record.clear
      n = record.size
      for i in 0...n do 
        record[i].dup_currency
        @record.push(record[i].dup) 
      end
    end
    #--------------------------------------------------------------------------
    # * Block build time
    def date; @header.timestamp.to_i; end
    #--------------------------------------------------------------------------
    def genesis?; @header.genesis; end
    #--------------------------------------------------------------------------
    # * Nonce
    def nonce; @header.nonce; end
    def have_record?; !@record.empty?; end
  end
  #==============================================================================
  # * Block Chain Accounts
  #==============================================================================
  class PonyAccount
  	#--------------------------------------------------------------------------
    # * Instance Vars
    #--------------------------------------------------------------------------
    attr_reader :name
    attr_reader :id
    attr_reader :balance
    attr_reader :item_amount
  	#--------------------------------------------------------------------------
    # * Object Initialization
    #--------------------------------------------------------------------------
    def initialize(name, balance = 0)
      @name = name
      @id = PONY.MD5(name).to_i(16)
      @balance = balance
      @item_amount = {}
    end
    #--------------------------------------------------------------------------
    # * Redefine equal
    #--------------------------------------------------------------------------
    def ==(obj)
      return obj == @name if obj.is_a?(String)
      return obj == @id   unless obj.is_a?(String)
    end
    #--------------------------------------------------------------------------
    # * Merge outdated block to saved data
    #--------------------------------------------------------------------------
    def merge_block(block)
      block.record.each do |trans|
        @balance -= trans.value if trans.source.id    == @id
        @balance += trans.value if trans.recipient.id == @id
        next unless trans.goods
        good_hash = trans.goods.hashid
        @item_amount[good_hash] = 0 if @item_amount[good_hash].nil?
        @item_amount[good_hash] += trans.good_amount if trans.source.id    == @id
        @item_amount[good_hash] -= trans.good_amount if trans.recipient.id == @id
      end
    end
    
    def account_balance; return @balance; end
    def item_amount(hashid); return @item_amount[hashid] || 0; end
  end # Class:PonyAccount
  #==============================================================================
  # * Block Chain Nodes
  #==============================================================================
  class PonyNode
    #--------------------------------------------------------------------------
    # * Instance Vars
    #--------------------------------------------------------------------------
    attr_reader :name
    attr_reader :id
    attr_reader :blocks
    attr_reader :price_index
    attr_reader :last_block
    attr_reader :enabled
    attr_reader :corrupted
    attr_reader :capacity
  	#--------------------------------------------------------------------------
    # * Object Initialization
    #--------------------------------------------------------------------------
    def initialize(name, enable = false)
      @name = name
      @id   = PONY.MD5(name).to_i(16)
      @price_index = 1
      @enabled = enable
      @last_block = nil
      @corrupted = false
      @capacity = 0
      @blocks  = {}
    end
    #--------------------------------------------------------------------------
    # * Update Block
    #--------------------------------------------------------------------------
    def update_block(block)
      @blocks[block.hashid] = block
    end
    #--------------------------------------------------------------------------
    # * Push New Block
    #--------------------------------------------------------------------------
    def new_workblock
      new_block = Block.new(@last_block.hashid, BlockChain.height, BlockChain.difficulty)
      @blocks[@last_block.hashid].freeze
      @last_block = new_block
      update_block(@last_block)
    end
    #--------------------------------------------------------------------------
    # * Prepare commit new work
    #--------------------------------------------------------------------------
    def commit_transaction(trans, difficulty, genesis = false)
      @last_block = Block.new(nil, 0, difficulty, genesis) if genesis && !@last_block
      self.push_block(@last_block)                         if genesis && !@last_block
      # Delete last block because the hashid will change later
      @blocks.delete(@last_block.hashid) 
      @last_block.push_transaction(trans)
      update_block(@last_block)
      @capacity += 1
    end
    #--------------------------------------------------------------------------
    # * Block Mining
    #--------------------------------------------------------------------------
    def mining
      return unless @enabled
      return :nil_blcok unless @last_block
      @blocks.delete(@last_block.hashid)
      re = @last_block.mining
      update_block(@last_block.clone)
      return re
    end
    #--------------------------------------------------------------------------
    # * Mining Reward
    #--------------------------------------------------------------------------
    def reward
      value = (@last_block.value * PONY::CHAIN::Transaction_Fee)
      value = (@last_block.record.size * PONY::CHAIN::Transaction_Fee) if value == 0
      value
    end
    #--------------------------------------------------------------------------
    # * Sync to succed mined block
    #--------------------------------------------------------------------------
    def sync(node)
      return if node.id == self.id
      @last_block.sync_data(node.last_block.dup)
      @capacity = node.capacity
      @blocks.clear
      node.blocks.each do |hashid, block|
        bc = Block.new(@last_block.hashid, BlockChain.height, BlockChain.difficulty)
        bc.sync_data(block.dup)
        begin
          @blocks[bc.hashid] = bc.clone
        rescue Exception => e
          msgbox "Node RunTime error! #{@name}"
          raise e
        end
      end
      
      @corrupted  = false
    end
    #--------------------------------------------------------------------------
    # * Verify nonce
    #--------------------------------------------------------------------------
    def verify_nonce(nonce)
      return (PONY.Mining(nonce, @last_block.difficulty).to_bool & trans_legal?)
    end
    #--------------------------------------------------------------------------
    # * Query item amount in player's saddlebag
    #--------------------------------------------------------------------------
    def item_amount(accid, item_hashid, async)
      sum = 0
      cur_key = @last_block.hashid
      while @blocks[cur_key]
        @blocks[cur_key].verify_genesis
        if async
          t = Thread_Assist.pause? ? 1 : Thread_Assist::Uwait
          sleep(t)
        end
        sum    += @blocks[cur_key].item_amount(accid, item_hashid, async)
        cur_key = @blocks[cur_key].parent_hash
      end
      return sum
    end
    #--------------------------------------------------------------------------
    def all_items(accid, async)
      items = {}
      items[:item]   = {}
      items[:weapon] = {}
      items[:armor]  = {}
      cur_key = @last_block.hashid
      while @blocks[cur_key]
        @blocks[cur_key].verify_genesis
        if async
          t = Thread_Assist.pause? ? 1 : Thread_Assist::Uwait
          sleep(t)
        end
        items = @blocks[cur_key].all_items(items, accid, async)
        cur_key = @blocks[cur_key].parent_hash
      end
      return items
    end
    #--------------------------------------------------------------------------
    def all_data(accid, async)
      data = {}
      data[:gold]   = 0
      data[:item]   = {}
      data[:weapon] = {}
      data[:armor]  = {}
      cur_key = @last_block.hashid
      while @blocks[cur_key]
        @blocks[cur_key].verify_genesis
        if async
          t = Thread_Assist.pause? ? 1 : Thread_Assist::Uwait
          sleep(t)
        end
        data = @blocks[cur_key].all_data(data, accid, async)
        cur_key = @blocks[cur_key].parent_hash
      end
      return data
    end
    #--------------------------------------------------------------------------
    # * Query account or total balance
    #--------------------------------------------------------------------------
    def account_balance(accid, currency_id, async)
      sum = 0
      cur_key = @last_block.hashid
      while @blocks[cur_key]
        @blocks[cur_key].verify_genesis
        if async
          t = Thread_Assist.pause? ? 1 : Thread_Assist::Uwait
          sleep(t)
        end
        sum    += @blocks[cur_key].account_balance(accid, currency_id, async)
        cur_key = @blocks[cur_key].parent_hash
      end
      return sum
    end
    #--------------------------------------------------------------------------
    # * Push New Block
    #--------------------------------------------------------------------------
    def archive_lastblock
      return unless @last_block.have_record?
      new_workblock
    end
    #--------------------------------------------------------------------------
    # * Show History
    #--------------------------------------------------------------------------
    def show_history
      cur_key = @last_block.hashid
      while @blocks[cur_key] && cur_key
        puts "key: #{cur_key}"
        records = @blocks[cur_key].record
        cur_key = @blocks[cur_key].parent_hash
        records.reverse.each do |trans|
          puts SPLIT_LINE
          puts "Info: #{trans.info} | payment is from: #{trans.source.name} | to: #{trans.recipient.name}"
          puts "Bits Amount: #{trans.value}"
          puts "Item: #{trans.goods.name} x#{trans.good_amount}" if trans.goods
        end
      end
      puts SPLIT_LINE
    end
    #--------------------------------------------------------------------------
    # * Maintain Query Speed is under control
    #--------------------------------------------------------------------------
    def maintain
      return unless overload?
      outdated = @last_block
      @blocks.each do |hashid, block|
        outdated = block.clone if !block.genesis && block.date < outdated.date
      end
      @blocks.delete(outdated)
      @capacity -= outdated.record.size
      return outdated
    end
    #--------------------------------------------------------------------------
    # * Verify if all transactions is still legal
    #--------------------------------------------------------------------------
    def trans_legal?
      cur_key = @last_block.hashid
      while @blocks[cur_key] && cur_key
        records = @blocks[cur_key].record
        cur_key = @blocks[cur_key].parent_hash
        return false if records.any? {|trans| !trans.trans_legal?}
      end
      return true
    end
    #--------------------------------------------------------------------------
    # * Recover nodes to previous state
    #--------------------------------------------------------------------------
    def recover
      cur_key = @last_block.hashid
      while @blocks[cur_key] && cur_key
        records = @blocks[cur_key].record
        cur_key = @blocks[cur_key].parent_hash
        records.each {|i| i.recover}
      end
    end
    #--------------------------------------------------------------------------
    # * Return transaction data related to given account, all if nil given
    #--------------------------------------------------------------------------
    def transaction_data(accid)
      cur_key = @last_block.hashid
      data = []
      while @blocks[cur_key] && cur_key
        records = @blocks[cur_key].record
        cur_key = @blocks[cur_key].parent_hash
        records.each do |trans|
          next unless trans.source.id == accid || trans.recipient.id == accid
          data << trans
          puts SPLIT_LINE
          puts "Info: #{trans.info} | payment is from: #{trans.source.name} | to: #{trans.recipient.name}"
          puts "Bits Amount: #{trans.value}"
          puts "Item: #{trans.goods.name} x#{trans.good_amount}" if trans.goods
        end
      end
      puts SPLIT_LINE
      return data
    end
    #--------------------------------------------------------------------------
    def overload?; @capacity > 3000; end
    def drop_block; @corrupted = true; end
    def length; @corrupted ? -1 : (@blocks.size + @last_block.record.size); end
    #--------------------------------------------------------------------------
  end # PonyNode
end # Module:BlockChain

#==============================================================================
# ** BlockChain
#------------------------------------------------------------------------------
#  Block Chain module for process transactions, ultra secure!
#==============================================================================
$imported = {} if $imported.nil?
$imported["COM_BlockChain"] = true
module BlockChain
  #--------------------------------------------------------------------------
  # * Instance vars
  #--------------------------------------------------------------------------
  @nodes    = []
  @accounts = {}
  @trans_megadata  = []
  @height   = 0
  @capacity = 0
  @checksum = 0x0
  @locked   = false
  #--------------------------------------------------------------------------
  # * Block Chain Initialize
  #--------------------------------------------------------------------------
  def self.init_chain
  	self.init_nodes if node_empty?
    self.depoly_first_contract
  end
  #--------------------------------------------------------------------------
  def self.clear
    @nodes    = []
    @accounts = {}
    @trans_megadata  = []
    @height   = 0
    @capacity = 0
    @checksum = 0x0
  end
  #--------------------------------------------------------------------------
  # * Block Chain Nodes Initialization
  #--------------------------------------------------------------------------
  def self.init_nodes
    areas = PONY::CHAIN::Nodes
    areas.size.times do |i|
      @nodes.push( PonyNode.new(areas[i], true) )
    end
  end
  #--------------------------------------------------------------------------
  # * Depoly first dispute
  #--------------------------------------------------------------------------
  def self.depoly_first_contract
    acc = PonyAccount.new("Hasbro", PONY::CHAIN::TotalBalance)
    @accounts["Hasbro"] = acc
    @nodes.each do |node|
      amount = PONY::CHAIN::Dispute_Weight[node.id] * PONY::CHAIN::TotalBalance
      trans = Game_Transaction.new(0, amount.to_i, "Hasbro", node.name, nil, nil, "Initial Dispute")
      self.push_transaction(trans, true)
    end
  end
  # Block Height & difficulty target
  def self.height; return @height; end
  def self.target; return (PONY::CHAIN::Difficulty + (self.height / 42)); end
  def self.difficulty; return self.target; end
  #--------------------------------------------------------------------------
  # * Load BC information
  #--------------------------------------------------------------------------
  def self.load_chain_data(contents)
    @nodes    = contents[:nodes]
    @accounts = contents[:accounts]
    @trans_megadata  = contents[:megadata]
    @height   = contents[:height]
    @capacity = contents[:capacity]
    @checksum = contents[:checksum]
    self.recover_nodes
    return true
  end
  #--------------------------------------------------------------------------
  # * Save Chain
  #--------------------------------------------------------------------------
  def self.item_for_save(filename)
    contents = {}
    contents[:nodes]    = @nodes
    contents[:accounts] = @accounts
    contents[:megadata]  = @trans_megadata
    contents[:height]   = @height
    contents[:capacity] = @capacity
    contents[:player_balance] = self.account_balance(Vocab::Player)
    return contents
  end
  #--------------------------------------------------------------------------
  # * Load Header
  #--------------------------------------------------------------------------
  def self.load_file_header(filename)
    File.open(filename, 'rb') do |file|
      return Marshal.load(file)
    end
  end
  #--------------------------------------------------------------------------
  # * Push new transaction
  #--------------------------------------------------------------------------
  def self.push_transaction(trans, gensis = false)
    @capacity += 1
    @nodes.each do |node|
      node.commit_transaction(trans, self.difficulty, gensis)
    end
    self.mining if @capacity >= 100
  end
  #--------------------------------------------------------------------------
  # * Start process mining
  #--------------------------------------------------------------------------
  def self.mining(async = false)
    puts "[BlockChain]: Start Mining, lock: #{@locked}, caller: #{[caller[0], caller[1]]}"
    return if node_empty? || @locked
    begin
      @locked = true unless async
      winner  = nil
      Thread_Assist.yield if !async && Thread_Assist.work?(:BCmine)
      while !winner
        no_record_cnt = 0
        @nodes.each do |node|
          if async
            t = Thread_Assist.pause? ? 1 : Thread_Assist::Uwait
            sleep(t)
          end
          SceneManager.update_loading
          result = node.mining
          no_record_cnt += 1                   if result == :no_record
          PONY::ERRNO.raise(:nil_block, :exit) if result == :nil_block
          winner = node.clone                  if result == true
        end
        
        if no_record_cnt > @nodes.size / 2
          puts "[BlockChain]: No transaction to mine" 
        elsif winner
          puts "[BlockChain]: #{winner.name} has mined the block"
        end
        
        return if no_record_cnt > @nodes.size / 2
      end
      puts "[BlockChain]: Block Mined"
      self.settlement(winner) if self.nonce_legal?(winner)
    ensure
      @locked = false
    end
  end
  #--------------------------------------------------------------------------
  # * Archive all current working block and start a new one
  #--------------------------------------------------------------------------
  def self.settlement(winner)
    puts '[BlockChain]: Settle currnet blocks'
    self.dispute_player_reward(winner) if winner.name == Vocab::Player
    self.sync_node(winner)
    @height += 1
    @nodes.each do |node|
      node.archive_lastblock
    end
    self.maintain
    @capacity = 0
  end
  #--------------------------------------------------------------------------
  def self.dispute_player_reward(winner)
    amount = winner.reward
    return if amount > 0x8000
    $game_party.mining_reward(amount)
    info = sprintf(Vocab::Party::BCGain, amount)
    SceneManager.display_info(info)
    puts "Player has mined reward: #{amount}"
  end
  #--------------------------------------------------------------------------
  # * Account
  #--------------------------------------------------------------------------
  def self.accounts(accname, reg = false)
    @accounts.each do |name, acc|
      return acc if accname == name || accname == acc.id
    end
    return unless accname.is_a?(String)
    acc = PonyAccount.new(accname)
    @accounts[acc.id] = acc
    return reg ? acc : nil 
  end
  #--------------------------------------------------------------------------
  # * Query account or total balance
  #--------------------------------------------------------------------------
  def self.account_balance(accid = nil, currency_type = 0, async = false)
    accid = PONY.MD5(accid).to_i(16) if accid && accid.is_a?(String)
    result_pool = {}
    candidates = [accid]
    if accid.nil? # Return total balance if nil id given
      @accounts.each do |accname, acc|
        candidates.push(acc.id)
      end
    end
    $mutex.synchronize{
    @nodes.compact.each do |node|
      result = 0
      candidates.compact.each do |accid|
        result += node.account_balance(accid, currency_type, async)
        result += self.accounts(accid).balance
      end
      if result < 0
        info = "Negative account balance for #{accounts(accid).name}"
        PONY::ERRNO.raise(:illegel_value, :exit, nil, info)
      end
      result_pool[result] = Array.new() unless result_pool[result].is_a?(Array)
      result_pool[result].push(node.clone)
    end
    } # mutex
    self.determine_result(result_pool)
  end
  #--------------------------------------------------------------------------
  # * Query specified item amount
  #--------------------------------------------------------------------------
  def self.item_amount(accid, item, async = false)
    accid = PONY.MD5(accid).to_i(16) if accid.is_a?(String)
    result_pool = {}
    $mutex.synchronize{
    @nodes.each do |node|
      result = node.item_amount(accid, item.hashid, async) + self.accounts(accid).item_amount(item.hashid)
      if result < 0
        info = "Negative item amount for #{item.name}(#{accounts(accid).name})"
        PONY::ERRNO.raise(:illegel_value, :exit, nil, info)
      end
      result_pool[result] = Array.new() unless result_pool[result].is_a?(Array)
      result_pool[result].push(node.clone)
    end
    } # $mutex
    return determine_result(result_pool) || 0
  end
  #--------------------------------------------------------------------------
  # * Query all item amount
  #--------------------------------------------------------------------------
  def self.all_items(accid, async = false)
    self.recover_nodes
    accid = PONY.MD5(accid).to_i(16) if accid.is_a?(String)
    items = nil
    $mutex.synchronize{
    items = @nodes[0].all_items(accid, async)
    [:item, :weapon, :armor].each do |type|
      items[type].each {|id, amount|
        items[type][id] += self.accounts(accid).item_amount(id)
      }
    end
    } # mutex
    return items
  end
  #--------------------------------------------------------------------------
  # * Query all data
  #--------------------------------------------------------------------------
  def self.all_data(accid, async = false)
    return if node_empty?
    self.recover_nodes
    accid = PONY.MD5(accid).to_i(16) if accid.is_a?(String)
    data  = nil
    data  = @nodes[0].all_data(accid, async)
    data[:gold] += self.accounts(accid).balance
    [:item, :weapon, :armor].each do |type|
      data[type].each {|id, amount|
        data[type][id] += self.accounts(accid).item_amount(id)
        item = PONY.hashid_table[id]
        if data[type][id] < 0
          info = "Negative item amount for #{item.name}(#{accounts(accid).name})"
          PONY::ERRNO.raise(:illegel_value, :exit, nil, info)
        end
      }
    end
    return data
  end
  #--------------------------------------------------------------------------
  # * Determind return value & sync
  #--------------------------------------------------------------------------
  def self.determine_result(pool)
    pool[0]  = Array.new() unless pool[0].is_a?(Array)
    superior = 0
    pool.each do |amount, node|
      superior = amount if pool[amount].size > pool[superior].size
    end
    winner = pool[superior].at(0)
    pool[superior].each do |node|
      winner = node if node.length > winner.length
    end
    self.sync_node(winner)
    return superior
  end
  #--------------------------------------------------------------------------
  # * Verify nonce correct b4 sync
  #--------------------------------------------------------------------------
  def self.nonce_legal?(master_node)
    err = 0
    nonce = master_node.last_block.nonce
    @nodes.each do |node|
      err += 1 unless node.verify_nonce(nonce)
    end
    re = err < (@nodes.size / 2)
    master_node.drop_block unless re
    self.recover_nodes     unless re
    puts "[BlockChain]: Nonce Legal: #{re}"
    return re
  end
  #--------------------------------------------------------------------------
  # * Recover nodes
  #--------------------------------------------------------------------------
  def self.recover_nodes
    pool = {}
    @nodes.each do |node|
      node.recover if !node.trans_legal?
      pool[node.length] = Array.new() unless pool[node.length].is_a?(Array)
      pool[node.length].push(node)
    end
    winner = []
    pool.each do |key, ar|
      winner = pool[key] if pool[key].size > winner.size
    end
    self.sync_node(winner.at(0))
  end
  #--------------------------------------------------------------------------
  # * All nodes sync to mater node
  #--------------------------------------------------------------------------
  def self.sync_node(master_node)
    @nodes.each {|node| node.sync(master_node)}
  end
  #--------------------------------------------------------------------------
  # * Show History
  def self.show_history
    self.recover_nodes
    @nodes[0].show_history
  end
  #--------------------------------------------------------------------------
  # * Maintain blocks size is in limit
  #--------------------------------------------------------------------------
  def self.maintain
    self.recover_nodes
    outdated = @nodes[0].maintain
    return if outdated.nil?
    puts "[BlockChain]: Merge outdated block: #{outdated.hashid}"
    self.merge_block(outdated)
    self.sync_node(@nodes[0])
  end
  #--------------------------------------------------------------------------
  # * Merge block info to account, ensure calc speed is acceptable
  #--------------------------------------------------------------------------
  def self.merge_block(block)
    @accounts.each{|accid, acc| acc.merge_block(block)}
  end
  #--------------------------------------------------------------------------
  # * Node loaded?
  def self.node_empty?; return @nodes.empty?; end
  #--------------------------------------------------------------------------
  # * Make A Bits only transaction
  #--------------------------------------------------------------------------
  def self.bits_transaction(amount, source, receiver, info = '')
    trans = Game_Transaction.new(0, amount.to_i, source, receiver, nil, nil, info)
    self.push_transaction(trans)
  end
  #--------------------------------------------------------------------------
  # * Make A Item only transaction
  #--------------------------------------------------------------------------
  def self.item_transaction(item,amount, source, receiver, info = '')
    trans = Game_Transaction.new(0, 0, source, receiver, item, amount, info)
    self.push_transaction(trans)
  end
  #--------------------------------------------------------------------------
  # * Make Standard Trade
  #--------------------------------------------------------------------------
  def self.new_transaction(amount, item, item_amount, source, receiver, info = '')
    trans = Game_Transaction.new(0, amount.to_i, source, receiver, item, item_amount, info)
    self.push_transaction(trans)
  end
  #--------------------------------------------------------------------------
  # * Record transaction detail
  #--------------------------------------------------------------------------
  def self.record_transaction(trans)
    @trans_megadata.push(trans)
  end
  #--------------------------------------------------------------------------
  # * Return transaction data related to given account, all if nil given
  #--------------------------------------------------------------------------
  def self.transaction_data(accid = nil)
    accid = PONY.MD5(accid).to_i(16) if accid.is_a?(String)
    return @nodes[0].transaction_data(accid)
  end
  # Nodes in Chain
  def self.chain_nodes; return @nodes; end
  def self.locked?; return @locked; end
end

#==============================================================================
# ■ Scene_Map
#==============================================================================
# tag: hotkey
# tag: button
# tag: tactic (inputs)
class Scene_Map < Scene_Base
  #--------------------------------------------------------------------------
  # * Frame update
  #--------------------------------------------------------------------------
  alias update_scmap_inputs update
  def update
    update_input_buttons unless $game_system.story_mode?
    update_scmap_inputs
  end
  #--------------------------------------------------------------------------
  # * Button utility process
  #--------------------------------------------------------------------------
  def update_input_buttons
    return unless button_cooled?
    return heatup_button if Input.press?(:kTAB)  && process_switch_button
    return heatup_button if Input.press?(:kCTRL) && process_control_button
    return heatup_button if process_normal_button
  end
  #--------------------------------------------------------------------------
  #  *) Actions when tab key is pressed
  #--------------------------------------------------------------------------
  def process_switch_button
    return if SceneManager.time_stopped?
  	#--------------------------------------------------------------------------
    # > Swap current control actor
    #--------------------------------------------------------------------------
    if Input.press?(:kF3)
      return if ($game_party.battle_members_array[1] || 0) < 1
      return if $game_actors[$game_party.battle_members_array[1]].dead?
      $game_party.swap_order(0,1)
      return true
    #--------------------------------------------------------------------------
    # > Swap current control actor
    #--------------------------------------------------------------------------
    elsif Input.press?(:kF4)
      #return if $game_party.members[2].nil?
      #return if $game_party.members[2].dead?
      return if ($game_party.battle_members_array[2] || 0) < 1
      return if $game_party.battle_members_array[2].dead?
      $game_party.swap_order(0,2)
      return true
    #--------------------------------------------------------------------------
    # > Swap current control actor
    #--------------------------------------------------------------------------
    elsif Input.press?(:kF5)
      return if ($game_party.battle_members_array[3] || 0) < 1
      return if $game_actors[$game_party.battle_members_array[3]].dead?
      $game_party.swap_order(0,3)
      return true
    end
    #--------------------------------------------------------------------------
  end
  #--------------------------------------------------------------------------
  #  *) Actions when Ctrl key is pressed
  #--------------------------------------------------------------------------
  def process_control_button
    return unless button_cooled?
    #--------------------------------------------------------------------------
    # > Follower follow command
    #--------------------------------------------------------------------------
    if Input.press?(:kF)
      $game_player.followers.each do |follower|
        follower.command_follow
      end
      $game_player.followers.movement_command = 1
      $game_map.interpreter.gab("Follow up!",0,0)
      return true
    #--------------------------------------------------------------------------
    # > Follower gather command
    #--------------------------------------------------------------------------
    elsif Input.trigger?(:kG)
      $game_player.followers.each do |follower|
        follower.set_target(nil)
        follower.move_to_position($game_player.x, $game_player.y, tool_range: 0)
      end
      $game_map.interpreter.gab("Gather around!",0,0)
      return true
    #--------------------------------------------------------------------------
    # > Follower hold command
    #--------------------------------------------------------------------------
    elsif Input.trigger?(:kH)
      $game_player.followers.each do |follower|
        follower.command_hold
      end
      $game_player.followers.movement_command = 3
      $game_map.interpreter.gab("Hold in position!",0,0)
      return true
    #--------------------------------------------------------------------------
    # > Party concentrate fire on player's target
    #--------------------------------------------------------------------------
    elsif Input.trigger?(:kV) && $game_player.current_target
      $game_player.followers.each do |follower|
        follower.set_target($game_player.current_target)
      end
      $game_map.interpreter.gab("Concentrate fire!",0,0)
      return true
    #--------------------------------------------------------------------------
    # > Ranged tool free-fire mode
    #--------------------------------------------------------------------------
    elsif Input.trigger?(:kR)
      $game_player.free_fire ^= 1
      if $game_player.free_fire
        $game_system.change_cursor_bitmap(PONY::IconID[:aim])
      else
        $game_system.change_cursor_bitmap(nil)
      end
      return true
    #-----------------------------------------------------
    end
    return false
  end
  #--------------------------------------------------------------------------
  #  *) Actions when single key triggered
  #--------------------------------------------------------------------------
  def process_normal_button
  	#--------------------------------------------------------------------------
    # > Tactic Mode
    # tag: tactic (trigger button)
    #--------------------------------------------------------------------------
    if Input.trigger?(:kSPACE) && !Input.press?(:kALT) && !Input.press?(:kCTRL)
      SceneManager.process_tactic
      return true
    #--------------------------------------------------------------------------
    # > Dubug: show player coordinate
    #--------------------------------------------------------------------------
    elsif Input.trigger?(:kP)
      SceneManager.display_info "Player address: (#{$game_player.x},#{$game_player.y})"
      SceneManager.display_info "Mouse  address: (#{Mouse.true_grid[0]},#{Mouse.true_grid[1]})"
      SceneManager.display_info "Mouse pixel address: #{Mouse.pos}"
      return true
    end
    #-----------------------------------------------------------------------
  end
  #--------------------------------------------------------------------------
end # Scene_Map

#==============================================================================
# ** Game_Follower
#------------------------------------------------------------------------------
#  This class handles followers. A follower is an allied character, other than
# the front character, displayed in the party. It is referenced within the
# Game_Followers class.
#==============================================================================
class Game_Character
  #--------------------------------------------------------------------------
  MovementCommandFollow = 1
  MovementCommandGather = 2
  MovementCommandHold   = 3
  HoldPositionStateID   = PONY::StateID[:hold_position]
  #--------------------------------------------------------------------------
  attr_accessor :movement_command
  #--------------------------------------------------------------------------
  # * Initialize Public Member Variables
  #--------------------------------------------------------------------------
  alias init_public_members_dnd init_public_members
  def init_public_members
    init_public_members_dnd
    @movement_command = MovementCommandFollow
  end
  #----------------------------------------------------------------------------
  def command_follow
    @movement_command = MovementCommandFollow
    return if battler.nil? || battler == self
    popup_info('Move')
    battler.remove_state(HoldPositionStateID)
    battler.result.removed_states.delete(HoldPositionStateID)
    $game_player.followers.move if self.is_a?(Game_Follower)
  end
  #----------------------------------------------------------------------------
  def command_gather
    return ; # tag: queued
    @movement_command = MovementCommandGather
    self.move_to_position($game_player.x, $game_player.y, goal:$game_player)
    $game_player.followers.move if self.is_a?(Game_Follower)
  end
  #----------------------------------------------------------------------------  
  def command_hold
    return if battler.nil? || battler == self
    @movement_command = MovementCommandHold
    clear_pathfinding_moves
    popup_info('Hold in Position')
    battler.add_state(HoldPositionStateID, self)
    $game_player.followers.move if self.is_a?(Game_Follower)
  end
  #----------------------------------------------------------------------------
  def command_following?;   return  @movement_command == MovementCommandFollow; end
  def command_gathering?;   return  @movement_command == MovementCommandGather; end
  def command_holding?  ;   return  @movement_command == MovementCommandHold;   end
  #----------------------------------------------------------------------------
  # *) update follower movement
  #----------------------------------------------------------------------------
  def update_follower_movement
    process_pathfinding_movement
    return if command_holding? || command_gathering?
    # tag: unfinished
  end
  #----------------------------------------------------------------------------
end
#==============================================================================
# ** Game_Followers
#------------------------------------------------------------------------------
#  This is a wrapper for a follower array. This class is used internally for
# the Game_Player class. 
#==============================================================================
class Game_Followers
  #--------------------------------------------------------------------------
  MovementCommandFollow = 1
  MovementCommandGather = 2
  MovementCommandHold   = 3
  HoldPositionStateID   = PONY::StateID[:hold_position]
  #--------------------------------------------------------------------------
  attr_accessor :movement_command
  #----------------------------------------------------------------------------
  alias initialize_addon initialize
  def initialize(leader)
    initialize_addon(leader)
    @movement_command = MovementCommandFollow
  end
  #----------------------------------------------------------------------------
  def enable_followers
    $game_temp.reserve_common_event(27)
    @data.each do |follower|
      follower.moveto($game_player.x,$game_player.y)
    end
    
  end
  #----------------------------------------------------------------------------
  def disable_followers
    visible = false
  end
  #----------------------------------------------------------------------------
end
#jump to => tag: follower

#==============================================================================
# ** Game_Player
#------------------------------------------------------------------------------
#  This class handles the player. It includes event starting determinants and
# map scrolling functions. The instance of this class is referenced by
# $game_player.
#==============================================================================
class Game_Player < Game_Character
  #--------------------------------------------------------------------------
  # * Processing of Movement via Input from Directional Buttons
  #--------------------------------------------------------------------------
  alias move_by_input_dnd move_by_input
  def move_by_input
    return if $tactic_enabled || $game_party.leader.state?(2)
    return if $game_system.story_mode?
    return unless controlable?
    move_by_input_dnd
  end
  #--------------------------------------------------------------------------
  # Alias: update
  #--------------------------------------------------------------------------
  alias update_dndAI update
  def update
    update_dndAI
    process_party_movement
    return unless $game_party.leader.state?(2)
    update_followers_attack
    update_follower_movement
  end
  #-------------------------------------------------------------------------
  def update_cancel_action
    @action_cancel_timer += 1
    return unless @action_cancel_timer > 3
    @action_cancel_timer = 0
    cancel_action_without_penalty
  end
  #-------------------------------------------------------------------------
  def process_party_movement
    process_pathfinding_movement
    trigger_target_event if @target_event
    
  end
  #-------------------------------------------------------------------------
  def trigger_target_event
    if distance_to(@target_event.x, @target_event.y) <= 1
      @target_event.start
      @target_event = nil
    end
  end
  #-------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Actor
#------------------------------------------------------------------------------
#  This class handles actors. It is used within the Game_Actors class
# ($game_actors) and is also referenced from the Game_Party class ($game_party).
#==============================================================================
class Game_Actor < Game_Battler
  #--------------------------------------------------------------------------
  # * Get the right class id of class parent
  #--------------------------------------------------------------------------
  def get_class(symbol)
    classid = 0
    compare_template = []
    case symbol
    when :barbarian
      compare_template = DND::ClassID::Barbarian
    when :bard
      compare_template = DND::ClassID::Bard
    when :cleric
      compare_template = DND::ClassID::Cleric
    when :druid
      compare_template = DND::ClassID::Druid
    when :fighter
      compare_template = DND::ClassID::Fighter
    when :monk
      compare_template = DND::ClassID::Monk
    when :paladin
      compare_template = DND::ClassID::Paladin
    when :ranger
      compare_template = DND::ClassID::Ranger
    when :rogue
      compare_template = DND::ClassID::Rogue
    when :Sorcerer
      compare_template = DND::ClassID::Sorcerer
    when :warlock
      compare_template = DND::ClassID::Warlock
    when :wizard
      compate_template = DND::ClassID::Wizard
    end
    classid = self.class     if compare_template.include?(@class_id)
    classid = self.dualclass if compare_template.include?(@dualclass_id)
    return classid
  end
  #--------------------------------------------------------------------------
end

#tag: param
module DND
  
  SKILL_STYPE_ID      =   1
  SPELL_STYPE_ID      =   2
  VANCIAN_STYPE_ID    =   3
  PASSIVE_STYPE_ID    =   4
  
  CLASS_ACTIONDC = {
  # id    skill, spell/vancian/save
    1  => [:str, :con],    # Barbarian
    2  => [:dex, :cha],    # Bard
    3  => [:wis, :cha],    # Cleric
    4  => [:int, :wis],    # Druid
    5  => [:str, :con],    # Fighter
    6  => [:str, :dex],    # Monk
    7  => [:str, :wis],    # Paladin
    8  => [:str, :dex],    # Ranger
    9  => [:dex, :int],    # Rogue
    10 => [:con, :cha],    # Sorcerer
    11 => [:wis, :cha],    # Warlock
    12 => [:wis, :int],    # Wizard
    13 => [:cha, :int],    # Arch-Mage
    
  }
  
      # cnt       0,   1,   2,   3,   4,   5,   6,   7
      # id      dhp, dmp, str, con, int, wis, dex, cha
  Base_Param  = [   8,  5,  10,  10,  10,  10,  10,  10]
  
  Base_Attack = 0
  Base_AC     = 10
  
  EXP_FOR_LEVEL = {
  # lv    require xp(/1000)
    0  =>  0,
    1  =>  0,
    2  =>  0.3,
    3  =>  0.9,
    4  =>  2.7,
    5  =>  6.5,
    6  =>  14,
    7  =>  23,
    8  =>  34,
    9  =>  48,
    10 =>  64,
    11 =>  85,
    12 =>  100,
    13 =>  120,
    14 =>  140,
    15 =>  165,
    16 =>  195,
    17 =>  225,
    18 =>  265,
    19 =>  305,
    20 =>  355,
    21 =>  410,
    22 =>  472,
    23 =>  558,
    24 =>  650,
    25 =>  750,
    26 =>  862,
    27 =>  986,
    28 => 1120,
    29 => 1260,
    30 => 1414,
    31 => 1732,
    32 => 1905,
    33 => 2088,
    34 => 2278,
    35 => 2473,
    36 => 2675,
    37 => 2880,
    38 => 3088,
    39 => 3308,
    40 => 3530,
    41 => 3758,
    42 => 3990,
    43 => 4225,
    44 => 4665,
    45 => 4720,
    46 => 5252,
    47 => 5534,
    48 => 5828,
    49 => 6140,
    50 => 6535,
  }
  
end
#==============================================================================
# ** Game_Battler
#------------------------------------------------------------------------------
#  A battler class with methods for sprites and actions added. This class 
# is used as a super class of the Game_Actor class and Game_Enemy class.
#==============================================================================
class Game_Battler < Game_BattlerBase
  #--------------------------------------------------------------------------
  # * Attack Bonus
  #--------------------------------------------------------------------------
  def attack_bonus
    attack_bonus_base + attack_bonus_plus
  end
  #--------------------------------------------------------------------------
  # * Armor Class
  #--------------------------------------------------------------------------
  def armor_class
    param_modifier( get_param_id(:dex) ) + armor_class_base + armor_class_plus
  end
  #--------------------------------------------------------------------------
  def attack_bonus_base
    return DND::Base_Attack
  end
  #--------------------------------------------------------------------------
  def attack_bonus_plus
    return feature_objects.inject(0){|r,obj| r += (obj.attack_bonus | 0)}
  end
  #--------------------------------------------------------------------------
  def armor_class_base
    return DND::Base_AC
  end
  #--------------------------------------------------------------------------
  def armor_class_plus
    return feature_objects.inject(0){|r,obj| r += (obj.attack_bonus | 0)}
  end
  #------------
end
  
#==============================================================================
# ** Game_Enemy
#------------------------------------------------------------------------------
#  This class handles enemies. It used within the Game_Troop class 
# ($game_troop).
#==============================================================================
class Game_Enemy < Game_Battler
  #--------------------------------------------------------------------------
  # * Attack Bonus
  #--------------------------------------------------------------------------
  def attack_bonus
    self.enemy.attack_bonus
  end
  #--------------------------------------------------------------------------
  # * Armor Class
  #--------------------------------------------------------------------------
  def armor_class
    self.enemy.armor_class
  end
  #------------
end
#==============================================================================
# ** Game_Player
#------------------------------------------------------------------------------
#  This class handles the player. It includes event starting determinants and
# map scrolling functions. The instance of this class is referenced by
# $game_player.
#==============================================================================
class Game_Player < Game_Character
  #--------------------------------------------------------------------------
  # * Attack Bonus
  #--------------------------------------------------------------------------
  def attack_bonus
    self.actor.attack_bonus
  end
  #--------------------------------------------------------------------------
  # * Armor Class
  #--------------------------------------------------------------------------
  def armor_class
    self.actor.armor_class
  end
  #------------
end
#==============================================================================
# ** Game_Follower
#------------------------------------------------------------------------------
#  This class handles followers. A follower is an allied character, other than
# the front character, displayed in the party. It is referenced within the
# Game_Followers class.
#==============================================================================
class Game_Follower < Game_Character
  #--------------------------------------------------------------------------
  # * Attack Bonus
  #--------------------------------------------------------------------------
  def attack_bonus
    self.actor.attack_bonus
  end
  #--------------------------------------------------------------------------
  # * Armor Class
  #--------------------------------------------------------------------------
  def armor_class
    self.actor.armor_class
  end
  #------------
end

#==============================================================================
# ** Game_CharacterBase
#------------------------------------------------------------------------------
#  This base class handles characters. It retains basic information, such as 
# coordinates and graphics, shared by all characters.
#==============================================================================
class Game_BattlerBase
  include DND::Utility
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader   :wprof
  attr_reader   :aprof
  attr_reader   :lskills
  attr_reader   :lskill_bonus
  attr_accessor :result_critical
  attr_accessor :result_miss
  
  #--------------------------------------------------------------------------
  # * Access Method by Parameter Abbreviations
  #--------------------------------------------------------------------------
  def attack_bonus;  xparam(0);   end               # Attack Bonus
  def armor_class;   xparam(1);   end               # Armor Class
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias initialize_battler_dnd initialize
  def initialize
    @lskills      = Table.new(18)
    @lskill_bonus = Table.new(18)
    @wprof = Table.new(Vocab::DND::WEAPON_TYPE_NAME.size)
    @aprof = Table.new(Vocab::DND::ARMOR_TYPE_NAME.size)
    @result_critical = false
    @result_miss = false
    
    initialize_battler_dnd
  end
  #--------------------------------------------------------------------------
  # * new method: proficiency
  #--------------------------------------------------------------------------
  def proficiency
    return ((level+1)/4 + 0.5).to_i + 1
  end
  #--------------------------------------------------------------------------
  # * new method: proficiency
  #--------------------------------------------------------------------------
  def param_modifier(param_id)
    return 0 if param_id.nil? || param_id < 3
    return (( param(param_id) - 10) / 2 ).to_i
  end
  #--------------------------------------------------------------------------
  # * new method: rolld20
  #--------------------------------------------------------------------------
  def roll(time, face)
    roll = 0
    (0...time).each do |i|
      roll += 1 + rand(face)
    end
    return roll
  end
  #--------------------------------------------------------------------------
  # * new method: lskill_save
  #--------------------------------------------------------------------------
  def lskill_save(type,bonus,dc,user = nil,item = nil)
    type = get_param_id(type) if type.is_a?(String)
    
    dc = actionDC(user,item)
    base_roll = roll(1,20)
    return true  if base_roll == 20
    return false if base_roll == 1
    
    
    return result
  end
  #-----------------------------------------------------
end

#==============================================================================
# ** Game_CharacterBase
#------------------------------------------------------------------------------
#  This base class handles characters. It retains basic information, such as 
# coordinates and graphics, shared by all characters.
#==============================================================================
class Game_CharacterBase
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :dash_speed_bonus
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias initialize_add_onsII initialize
  def initialize
    initialize_add_onsII
    @dash_speed_bonus = 0
  end
  #--------------------------------------------------------------------------
  # * Increase Steps
  #--------------------------------------------------------------------------
  def increase_steps
    set_direction(8) if ladder? && !self.is_a?(Game_Projectile)
    @stop_count = 0
    update_bush_depth
  end
  #--------------------------------------------------------------------------
  # * calc_move_speed_bonus
  #--------------------------------------------------------------------------
  def calc_move_speed_bonus
    
    @dash_speed_bonus = 0
    #-------------------------------------------
    # Haste
    #-------------------------------------------
    @dash_speed_bonus += 0.3 if $game_party.leader.state?(283)
    #-------------------------------------------
    # Boots of Speed
    #-------------------------------------------
    for battler in $game_party.members
      for equip in battler.equips
        if equip.is_a?(RPG::Armor)
          
          if equip.name == "Boots of Speed"
            @dash_speed_bonus = [0.5,@dash_speed_bonus].max
          end # equip.name == "Boots of Speed"
          
        end # is_a?(Armor)
      end # for equip
    end # for battler
    
    #----------------------------------------------
  end  
  
  #--------------------------------------------------------------------------
  # * distance_to
  #--------------------------------------------------------------------------
  def distance_to(x1, y1, x2 = @x, y2 = @y)
    return Math.hypot(x1 - x2, y1 - y2)
  end
  
  #--------------------------------------------------------------------------
  # * Check if face toward character
  #--------------------------------------------------------------------------
  def face_toward_character?(character, range = nil)
    cx = @x - character.x
    cy = @y - character.y
    
    if range
      range += 0.3
      return false if Math.hypot(cx,cy) >= range
    end
    
    if cx.abs < cy.abs
      return cx > 0 ? @direction == 4 : @direction == 6
    else
      return cy > 0 ? @direction == 2 : @direction == 8
    end
    
  end
  
  #-----------
end
#==============================================================================
# ** Game_Actor
#------------------------------------------------------------------------------
#  This class handles actors. It is used within the Game_Actors class
# ($game_actors) and is also referenced from the Game_Party class ($game_party).
#==============================================================================
class Game_Actor < Game_Battler
  #--------------------------------------------------------------------------
  # *) Recover All
  #--------------------------------------------------------------------------
  alias recover_revive recover_all
  def recover_all(gather_follower = true)
    recover_revive
    @deadposing = nil
    return unless $game_map.map_id > 0
    return unless gather_follower
    $game_player.followers.each do |follower|
      follower.moveto($game_player.x, $game_player.y)
    end
  end
  #--------------------------------------------------------------------------
  # * Show Level Up Message
  #     new_skills : Array of newly learned skills, useless here
  #--------------------------------------------------------------------------
  def display_level_up(new_skills)
    text  = sprintf("%s - Level Up", @name)
    self.recover_all(false)
    SceneManager.display_info(text)
  end
  
  #--------------------------------------------------------------------------
end
#==============================================================================
# ** Game_Party
#------------------------------------------------------------------------------
#  This class handles parties. Information such as gold and items is included.
# Instances of this class are referenced by $game_party.
#==============================================================================
class Game_Party < Game_Unit
  #--------------------------------------------------------------------------
  # * Get Maximum Number of Items Possessed
  #--------------------------------------------------------------------------
  def max_item_number(item)
    return item.item_own_max
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Extra Param Formulas v1.00
# -- Last Updated: 2012.01.10
# -- Level: Hard
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-ExtraParamFormulas"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.10 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# RPG Maker VX Ace certainly gives a lot of control to developers over many
# aspects of designing their RPG including custom formulas for individual items
# and skills. However, the program does not offer custom formulas for some of
# the more unique parameters such as hit rates, evasion rates, critical rates,
# etc. This script provides the ability to alter those extra parameters with
# primary stats altering them such as LUK affecting critical, DEF affecting PDR
# and whatnot.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# Modify the formulas in the script module to your liking.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
module YEA
  module XPARAM
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Formula Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This hash allows you to adjust all of extra parameters to gain extra
    # bonuses based on primary stats (such as ATK, DEF, MAT, MDF, AGI, LUK).
    # You can define what stats affect these extra parameters and the formulas
    # that affect them, as well.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    FORMULA ={
    # This adjusts the formula for HIT. HIT is the physical accuracy rate.
    # This provided formula uses the average of the user's ATK and AGI as a
    # bonus contributing factor to increasing the user's HIT. If you do not
    # wish to use this formula, change it to "base_hit" to have it use
    # whatever the original HIT rate is.
      :hit_n_value => "atk",
      :hit_formula => "(n / (100.0 + n)) * 0.250 + 0.050 + base_hit * 2/3",
    
    # This adjusts the formula for EVA. EVA is the physical evasion rate.
    # This provided formula uses the average of the user's AGI and LUK as a
    # bonus contributing factor to increasing the user's EVA. If you do not
    # wish to use this formula, change it to "base_eva" to have it use
    # whatever the original EVA rate is.
      :eva_n_value => "agi",
      :eva_formula => "(n / (256.0 + n)) * 0.250 + 0.000 + base_eva",
      
    # This adjusts the formula for CRI. CRI is the critical hit rate.
    # This provided formula uses the user's flat total amount of LUK as a
    # bonus contributing factor to increasing the user's CRI. If you do not
    # wish to use this formula, change it to "base_cri" to have it use
    # whatever the original CRI rate is.
      :cri_n_value => "luk",
      :cri_formula => "(n / (100.0 + n)) * 0.333 + 0.000 + base_cri",
      
    # This adjusts the formula for CEV. CEV is the critical evasion rate.
    # This provided formula uses a shifted percentage of LUK and AGI as a
    # bonus contributing factor to increasing the user's CRI. If you do not
    # wish to use this formula, change it to "base_cev" to have it use
    # whatever the original CRI rate is.
      :cev_n_value => "agi * 0.75 + luk * 0.25",
      :cev_formula => "(n / (512.0 + n)) * 0.167 + 0.000 + base_cev",
      
    # This adjusts the formula for MEV. MEV is the magical evasion rate.
    # This provided formula uses the average of the user's MDF and LUK as a
    # bonus contributing factor to increasing the user's MEV. If you do not
    # wish to use this formula, change it to "base_mev" to have it use
    # whatever the original MEV rate is.
      :mev_n_value => "0",
      :mev_formula => "(n / (256.0 + n)) * 0.250 + 0.000 + base_mev",
      
    # This adjusts the formula for MRF. MRF is the magical reflect rate.
    # This script does not provide any default stat bonuses that alter MRF.
      :mrf_n_value => "0",
      :mrf_formula => "base_mrf",
      
    # This adjusts the formula for CNT. CNT is the counter attack rate.
    # This script does not provide any default stat bonuses that alter CNT.
      :cnt_n_value => "0",
      :cnt_formula => "base_cnt",
      
    # This adjusts the formula for HRG. HRG is the HP Regeneration Rate.
    # This script does not provide any default stat bonuses that alter HRG.
      :hrg_n_value => "0",
      :hrg_formula => "base_hrg",
      
    # This adjusts the formula for MRG. MRG is the MP Regeneration Rate.
    # This script does not provide any default stat bonuses that alter MRG.
      :mrg_n_value => "0",
      :mrg_formula => "base_mrg",
      
    # This adjusts the formula for TRG. TRG is the TP Regeneration Rate.
    # This script does not provide any default stat bonuses that alter TRG.
      :trg_n_value => "0",
      :trg_formula => "base_trg",
      
    # This adjusts the formula for TGR. TGR is the Target Likelihood Rate.
    # This script does not provide any default stat bonuses that alter TGR.
      :tgr_n_value => "0",
      :tgr_formula => "base_tgr",
      
    # This adjusts the formula for GRD. GRD is the guard reduce defense rate.
    # This provided formula uses the average of the user's DEF and MDF as a
    # bonus contributing factor to increasing the user's GRD. If you do not
    # wish to use this formula, change it to "base_grd" to have it use
    # whatever the original GRD rate is.
      :grd_n_value => "self.def",
      :grd_formula => "(n / (256.0 + n)) * 0.333 + 0.000 + base_grd",
      
    # This adjusts the formula for REC. REC is the Recovery Effect Rate.
    # This script does not provide any default stat bonuses that alter REC.
      :rec_n_value => "0",
      :rec_formula => "base_rec",
      
    # This adjusts the formula for PHA. PHA is the Pharmacology Effect Rate.
    # This script does not provide any default stat bonuses that alter PHA.
      :pha_n_value => "0",
      :pha_formula => "base_pha",
      
    # This adjusts the formula for MCR. MCR is the MP Cost Rate Rate.
    # This script does not provide any default stat bonuses that alter MCR.
      :mcr_n_value => "0",
      :mcr_formula => "base_mcr",
      
    # This adjusts the formula for TCR. TCR is the TP Charge Rate Rate.
    # This script does not provide any default stat bonuses that alter TCR.
      :tcr_n_value => "0",
      :tcr_formula => "base_tcr",
      
    # This adjusts the formula for PDR. PDR is the Physical Damage Reduce Rate.
    # This provided formula uses the user's flat total amount of DEF as a
    # bonus contributing factor to increasing the user's PDR. If you do not
    # wish to use this formula, change it to "base_pdr" to have it use
    # whatever the original PDR rate is.
      :pdr_n_value => "self.def",
      :pdr_formula => "base_pdr - (n / (256.0 + n)) * 0.500 - 0.000",
      
    # This adjusts the formula for MDR. MDR is the Magical Damage Reduce Rate.
    # This provided formula uses the user's flat total amount of MDF as a
    # bonus contributing factor to increasing the user's MDR. If you do not
    # wish to use this formula, change it to "base_pdr" to have it use
    # whatever the original PDR rate is.
      :mdr_n_value => "mdf",
      :mdr_formula => "base_mdr - (n / (256.0 + n)) * 0.500 - 0.000",
      
    # This adjusts the formula for FDR. FDR is the Floor Damage Rate.
    # This script does not provide any default stat bonuses that alter FDR.
      :fdr_n_value => "0",
      :fdr_formula => "base_fdr",
      
    # This adjusts the formula for EXR. EXR is the Experience Gain Rate.
    # This script does not provide any default stat bonuses that alter EXR.
      :exr_n_value => "0",
      :exr_formula => "base_exr",
    
    } # Do not remove this.
    
  end # XPARAM
end # YEA
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
#==============================================================================
# ■ Game_BattlerBase
#==============================================================================
class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # mass alias methods
  #--------------------------------------------------------------------------
  alias_xparam = ["hit", "eva", "cri", "cev", "mev", "mrf", "cnt", "hrg", "mrg",
    "trg", "tgr", "grd", "rec", "pha", "mcr", "tcr", "pdr", "mdr", "fdr", "exr"]
  alias_xparam.each { |xparam|
  aStr = %Q(
  alias game_battlerbase_#{xparam}_epf #{xparam}
  def #{xparam}
    base_#{xparam} = game_battlerbase_#{xparam}_epf
    n = eval(YEA::XPARAM::FORMULA[:#{xparam}_n_value])
    return eval(YEA::XPARAM::FORMULA[:#{xparam}_formula])
  end
  )
  module_eval(aStr)
  } # Do not remove this.
  
end # Game_BattlerBase
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
# ** Dungeons and Dragons
#------------------------------------------------------------------------------
#  Skill: skill stuff, such as level charges
#==============================================================================
#tag: vancian
#tag: skill
#tag: state
#==============================================================================
# ** DND::SkillCharges
#------------------------------------------------------------------------------
#  This module calculate the charge times for each skill of level
#==============================================================================
module DND::SkillCharges
  #-----------------------------------------------------------------------------
  # * Barbarian's rage
  #-----------------------------------------------------------------------------
  def self.Rage(level)
    return 2 if level < 3
    return 3 if level < 9
    return 4 if level < 13
    return 5 if level < 17
    return 6 if level < 20
    return 99
  end
  
end
#==============================================================================
# ** DND::SkillModify
#------------------------------------------------------------------------------
#  This module calculate various effects of skill or state
#==============================================================================
module DND::SkillModify
  #-----------------------------------------------------------------------------
  # * Attack bonus plus of Barbarian's rage
  #-----------------------------------------------------------------------------
  def self.RageTHAC0(level)
    return 2 if level < 9
    return 3 if level < 16
    return 4 if level < 22
    return 5 if level < 30
    return 6 if level < 37
    return 7 if level < 46
    return 8
  end
  
end

#==============================================================================
# ** Game_CharacterBase
#------------------------------------------------------------------------------
#  This base class handles characters. It retains basic information, such as 
# coordinates and graphics, shared by all characters.
#==============================================================================
# tag: battler
class Game_CharacterBase
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :weight, :velocity, :opacity, :x, :y, :move_speed
  attr_accessor :movment_formula  # delta y = f(x)
  attr_accessor :action, :casting_flag
  attr_accessor :next_action
  attr_accessor :current_target
  attr_accessor :last_hit_target
  #----------------------------------------------------------------------------
  # *) Initialize Object
  #----------------------------------------------------------------------------
  alias initialize_charbaseopt initialize
  def initialize
    initialize_charbaseopt
    @weight   = 10
    @velocity = @move_speed
    @opacity  = 0xff
    @movment_formula    = nil
    @next_action        = nil
    @action             = nil
    @current_target     = nil
    @last_hit_target    = nil
    @hint_cooldown      = 0
    @popup_timer        = 0
    @combo_timer        = 0
    @weapon_combo_stack = []
    @queued_popups      = []
  end
  #----------------------------------------------------------------------------
  # * Update
  #----------------------------------------------------------------------------
  alias update_charbase_opt update
  def update
    update_realtime_action if valid_battler?
    update_popups
    update_charbase_opt
  end
  #----------------------------------------------------------------------------
  # * Update RTA
  #----------------------------------------------------------------------------
  def update_realtime_action
    @last_hit_target = nil if !@last_hit_target.nil? && (!BattleManager.valid_battler?(@last_hit_target) || @last_hit_target.dead?)
    update_cooldown
    update_combo    if @combo_timer > 0
    update_action   if @action || @next_action
  end
  #----------------------------------------------------------------------------
  # * Cool down reduce
  #----------------------------------------------------------------------------
  def update_cooldown
    battler.stiff -= 1 if battler.stiff > 0
    battler.skill_cooldown.each do |id, cdt|
      battler.skill_cooldown[id] -= 1 if cdt > 0
    end
    battler.item_cooldown.each do |id, cdt|
      battler.item_cooldown[id] -= 1 if cdt > 0
    end
    battler.weapon_cooldown.each do |id, cdt|
      battler.weapon_cooldown[id] -= 1 if cdt > 0
    end
    battler.armor_cooldown.each do |id, cdt|
      battler.armor_cooldown[id] -= 1 if cdt > 0
    end
  end
  #----------------------------------------------------------------------------
  def update_combo
    @combo_timer -= 1 if @combo_timer > 0
    clear_combo       if @combo_timer == 0
  end
  #----------------------------------------------------------------------------
  # * Can perform action?
  #----------------------------------------------------------------------------
  def actable?
    return false if $game_message.busy?
    return false if !movable?
    return true
  end
  #----------------------------------------------------------------------------
  def determine_targets(item)
    if $game_player.free_fire && self.is_a?(Game_Player) && item.ranged?
      pos = Mouse.true_grid_by_pos(false)
      pos = POS.new(pos[0], pos[1])
      pos.x -= 0.125; pos.y -= 0.125;
      return pos
    end
    
    #return battler if item.is_weapon? rescue false
    #return battler if item.is_item? && item.for_friend? rescue false
    
    if item.for_all? && (!$game_system.autotarget_aoe || Input.press?(:kALT))
      return BattleManager.target_selection(self, item)
    elsif item.scope == BattleManager::Scope_OneEnemy && (!$game_system.autotarget  || Input.press?(:kALT))
      return BattleManager.target_selection(self, item)
    end
    
    return BattleManager.autotarget(battler, item)
  end
  #----------------------------------------------------------------------------
  # * Item usage process
  #----------------------------------------------------------------------------
  def process_tool_action(item)    
    return if item.nil?
    return unless actable?
    if !usable_test_passed?(item)
      Audio.se_play("Audio/SE/Cursor1", 80, 100) if self.is_a?(Game_Player)
      return false
    end
    targets = determine_targets(item)
    use_tool(item, targets)
  end
  #----------------------------------------------------------------------------
  # * Return an item can be used effectivly
  #----------------------------------------------------------------------------
  def usable_test_passed?(item)
    @hint_cooldown -= 1 if @hint_cooldown > 0
    msg = battler.usable?(item)
    if msg == true
      return true
    elsif @hint_cooldown == 0 && msg == :outofammo
      text = sprintf("%s - run out of ammo", battler.name)
      SceneManager.display_info(text)
      @hint_cooldown = 10
    end
    return false
  end
  #----------------------------------------------------------------------------
  # * Use item
  #----------------------------------------------------------------------------
  def use_tool(item, target = nil)
    #puts "[Debug]: Use item: #{item}, target: #{target} #{target.x} #{target.y}"
    target = BattleManager.autotarget(self, item) if target.nil?
    name = target.name rescue nil
    turn_toward_character(target) if target
    #puts "[Debug]: Item final target: #{target}(#{name}) at #{[target.x,target.y]}"
    @next_action = Game_Action.new(battler, target, item)
  end
  #----------------------------------------------------------------------------
  # * Update current action
  #----------------------------------------------------------------------------
  def update_action
    return if $game_system.story_mode?
    if !@action && @next_action && battler.stiff == 0
      @ori_step_anime = @step_anime
      @action         = @next_action.dup
      @next_action    = nil
      @step_anime     = true unless static_object?
      if @action.item.is_a?(RPG::BaseItem) && @action.item.tool_castime > 10
        @casting_flag = true
        @chase_timer  = 30
        @combat_timer = 30
        clear_pathfinding_moves
      end
      tx, ty = @action.target.x, @action.target.y
      move_to_position(tx, ty, tool_range: @action.item.tool_distance) unless @action.action_impleable?
    end
    @action.update if @action
    return interrupt_casting  if casting? && casting_interrupted?
    return unless @action
    chase_target(@action) if @action.need_chase?
    execute_action     if @action.cast_done? && !@action.casted?
    cancel_action_without_penalty(true) if @action.done?
  end
  #----------------------------------------------------------------------------
  # * Execute action
  #----------------------------------------------------------------------------
  def execute_action
    return if $game_system.story_mode?
    return @action.execute  unless @action.item_valid?
    
    if @action.item.tool_castime > 5
      info = sprintf("%s: %s", @action.user.name, @action.item.name)
      SceneManager.display_info(info)
    end
    @action.execute
    turn_toward_character(@action.target)
    #debug_print("#{self.name} execute action: #{@action.item.name}")
    
    process_skill_action  if @action.item.is_a?(RPG::Skill)
    process_item_action   if @action.item.is_a?(RPG::Item)
    process_weapon_action if @action.item.is_a?(RPG::Weapon)
    process_armor_action  if @action.item.is_a?(RPG::Armor)
    
    clear_combo           if !@weapon_combo_stack.empty? && !combo_continue?(@action.item)
    apply_action_stiff
  end
  #----------------------------------------------------------------------------
  def cancel_action_without_penalty(forced = false)
    return if !forced && @action && @action.started
    @action       = nil
    @casting_flag = false
    @aggressive_level = @ori_agresilv
    @aggressive_level = 4 if @aggressive_level.nil?
    @step_anime = @ori_step_anime; @ori_step_anime = nil;
  end
  #----------------------------------------------------------------------------
  def apply_action_stiff
    battler.stiff = action_stiff
  end
  #----------------------------------------------------------------------------
  def process_skill_action(action = @action)
    play_item_soundeffect(action.item)
    
    if action.item.tool_animmoment == 1 # Projectile
      use_item(action.item)
    else
      use_item(action.item)
      BattleManager.execute_action(@action)
    end
    
    if action.item.tool_graphic
      proj = $game_map.get_idle_proj.send(:initialize, action)
      SceneManager.setup_projectile(proj)
    end
    apply_cooldown(:skill, action.item.id, action.item.tool_cooldown)
  end
  #----------------------------------------------------------------------------
  def process_item_action
    BattleManager.execute_action(@action)
    apply_cooldown(:item, @action.item.id, @action.item.tool_cooldown)
  end
  #----------------------------------------------------------------------------
  def process_weapon_action
    cdt = @action.item.tool_cooldown
    if !@weapon_combo_stack.empty? && @action.item.id == @weapon_combo_stack.first
      prev_item = $data_weapons[@weapon_combo_stack.last]
      @action.reassign_item_without_delay($data_weapons[prev_item.tool_combo])
    end
    
    if @action.item.tool_combo > 1
      @weapon_combo_stack << @action.item.id
      cdt = 15
      @combo_timer = 40
    end
    
    play_item_soundeffect(@action.item)
    SceneManager.setup_weapon_use(@action)
    apply_cooldown(:weapon, @action.item.id, cdt)
  end
  #----------------------------------------------------------------------------
  def play_item_soundeffect(item)
    tool_se = item.tool_soundeffect
    volume  = tool_se.last * $game_system.volume(:sfx) * 0.01
    Audio.se_play('Audio/SE/' + tool_se.first, volume, 100) if tool_se && tool_se.first
  end
  #----------------------------------------------------------------------------
  def process_armor_action
    apply_cooldown(:armor, @action.item.id, @action.item.tool_cooldown)
  end
  #----------------------------------------------------------------------------
  def apply_cooldown(type, id, time)
    id ||= 0; time ||= 0;
    time = (time * self.ctr).to_i unless type == :skill && id == 18
    case type
    when :item;   battler.item_cooldown[id] = time;
    when :weapon; battler.weapon_cooldown[id] = time;
    when :armor;  battler.armor_cooldown[id] = time;
    when :skill;  battler.skill_cooldown[id] = time;
    end
  end
  #----------------------------------------------------------------------------
  def combo_continue?(item)
    return false unless item.is_a?(RPG::Weapon)
    return false unless @weapon_combo_stack.include?(item.id)
    return false unless item.tool_combo > 1
    return true
  end
  #----------------------------------------------------------------------------
  def clear_combo
    @weapon_combo_stack.clear
  end
  #----------------------------------------------------------------------------
  # * Pop-up text
  #----------------------------------------------------------------------------
  def popup_info(text, color = DND::COLOR::White, icon_id = 0)
    color = DND::COLOR::White if color.nil?
    @queued_popups << [text, color, icon_id]
  end
  #----------------------------------------------------------------------------
  def update_popups
    @popup_timer -= 1 if @popup_timer > 0
    execute_popup if !@queued_popups.empty? && @popup_timer == 0
  end
  #----------------------------------------------------------------------------
  def execute_popup
    @popup_timer = 15
    info = @queued_popups.shift
    text = info[0]; color = info[1]; icon_id = info[2];
    SceneManager.setup_popinfo(text, POS.new(screen_x, screen_y), color, icon_id)
  end
  #----------------------------------------------------------------------------
  # * A short time that cannot do next action continually
  #----------------------------------------------------------------------------
  def action_stiff
    return 20
  end
  #----------------------------------------------------------------------------
  # * Determine cast time needed for item
  # tag: casting
  #----------------------------------------------------------------------------
  def item_casting_time(item)
    return 0 unless item.is_a?(RPG::BaseItem)
    return 0 unless BattleManager.valid_battler?(self)
    timer = [item.tool_castime - ctr, 0].max
    return timer
  end
  #----------------------------------------------------------------------------
  def valid_battler?
    return false
  end
  #----------------------------------------------------------------------------
  # * Hash position address to single integer
  #----------------------------------------------------------------------------
  def hash_pos
    return (@x * 1000 + @y)
  end
  #----------------------------------------------------------------------------
  def action; @action end
  def current_action; @action end
  #----------------------------------------------------------------------------
  def casting_interrupted?
    return false if @action.initial_casting?
    return true if moving? && saving_throw(:wis) <= 15
  end
  #----------------------------------------------------------------------------
  def interrupt_casting
    @aggressive_level = @ori_agresilv
    @aggressive_level = 4 if @aggressive_level.nil?
    @casting_flag = false
    @step_anime = @ori_step_anime; @ori_step_anime = nil;
    id = @action.item.id; time = (@action.item.tool_cooldown / 5).to_i;
    type = :item    if @action.item.is_a?(RPG::Item)
    type = :weapon  if @action.item.is_a?(RPG::Weapon)
    type = :armor   if @action.item.is_a?(RPG::Armor)
    type = :skill   if @action.item.is_a?(RPG::Skill)
    apply_cooldown(type, id, time)
    @action.interrupt
    @action = nil
    if name
      info = sprintf("%s - casting interrupted", name)
      SceneManager.display_info(info)
    end
  end
  #----------------------------------------------------------------------------
  def controlable?
    return true if @action.nil?
    return !@action.acting?
  end
  #----------------------------------------------------------------------------
  def finalize_acting
    @action.sequence_finished = true if @action
  end
  #----------------------------------------------------------------------------
end

#==============================================================================
# ** Game_Character
#------------------------------------------------------------------------------
#  A character class with mainly movement route and other such processing
# added. It is used as a super class of Game_Player, Game_Follower,
# GameVehicle, and Game_Event.
#==============================================================================
# tag: AI
class Game_Character < Game_CharacterBase
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_accessor :combat_timer       # lazy update timer
  attr_reader   :translucent
  #--------------------------------------------------------------------------
  # * Initialize Public Member Variables
  #--------------------------------------------------------------------------
  alias init_public_combatdnd init_public_members
  def init_public_members
    @combat_timer    = rand(20)
    @tactic_commands = []
    @translucent     = false
    @chase_timer     = 0
    @chase_pathfinding_timer = 0
    init_public_combatdnd
  end
  #----------------------------------------------------------------------------
  def target_rate(target, modifier = 0)
    sum  = 100
    sum  = apply_tactic_target(sum, target)
    sum *= tgr
    return sum.to_i + modifier
  end
  #----------------------------------------------------------------------------
  def set_target(target)
    @current_target = target
    signal = target.nil? ? false : true
    BattleManager.send_flag(in_battle: signal)
  end
  #----------------------------------------------------------------------------
  def update_combat
    return set_target(nil) if aggressive_level == 0
    start_timer(:combat)
    process_tactic_commands
  end
  #----------------------------------------------------------------------------
  def chase_target(action = nil, impleable = nil)
    target = action ? action.target : @current_target
    return if target.nil?
    return if halt?
    return process_target_dead if target.dead?
    return if @chase_timer > 0 && @chase_timer < 20
    return if aggressive_level < 3 || command_holding?
    
    if !action
      if primary_weapon
        action = Game_Action.new(battler, target, primary_weapon)
      else
        return escape_from_threat(target)
      end
    end
    
    do_ok = impleable.nil? ? action.action_impleable?(false) : impleable
    if do_ok
      # Impleaable, wondering around
      movable_dir = [2,4,6,8]
      movable_dir.delete(turn_toward_character(target))
      move_straight(movable_dir[rand(3)], false)
      start_timer(:chase) if @chase_pathfinding_timer == 0
    else
      # If unimpleable, chase target
      if @chase_pathfinding_timer == 0
        tpos = target.pos
        tx, ty = tpos.x, tpos.y
        move_to_position(tx, ty, goal: target, 
                           tool_range: action.item.tool_distance)
        start_timer(:chase_pathfinding)
        start_timer(:chase, 104)
      elsif @pathfinding_moves.empty?
        move_toward_character(target)
        start_timer(:chase)
      end
    end # do_ok
  end
  #----------------------------------------------------------------------------
  def determine_attack
    return if !primary_weapon
    return unless battler.cooldown_ready?(primary_weapon)
    return if halt?
    BattleManager.opponent_battler(self, true).each do |enemy|
      next if distance_to_character(enemy) > primary_weapon.tool_distance
      attack(enemy)
    end
  end
  #----------------------------------------------------------------------------
  def determine_skill_usage
  end
  #----------------------------------------------------------------------------
  def determine_item_usage
  end
  #----------------------------------------------------------------------------
  def battler_debug_print(*args)
    return unless self == $game_map.events[8]
    puts *args
  end
  #----------------------------------------------------------------------------
  def process_tactic_commands(spec_category = nil)
    usable_actions = []
    checked        = 0  # Bitset
    commands = tactic_commands
    n = commands.size; i = 0;
    forced   = false
    while i < n
      #battler_debug_print("Check status of #{i}: #{(checked & PONY::Bitset[i]).to_bool}")
      if (checked & PONY::Bitset[i]).to_bool
        i += 1; next;
      end
      command = commands[i]
      checked |= PONY::Bitset[i]
      #battler_debug_print("cmd index: #{command.condition_symbol} #{command.action.item}")
      if spec_category && command.category != spec_category
        i += 1; next;
      end
      
      #battler_debug_print(command.check_condition(forced))
      unless command.check_condition(forced)
        i += 1; next;
      end
      forced = false
      
      if command.action.item == :jump_to
        i = command.jump_command.index_id
        forced = true
        next
      end
      i += 1
      _action = command.action.dup; _action.target = command.get_target;
      _action.reassign_item(_action.get_symbol_item)
      if _action.item.is_a?(Symbol)
        execute_symbol_action(_action)
      else
        usable_actions.unshift(_action)
      end
    end
    return if usable_actions.empty?
    _action = usable_actions.select{|a| a.action_impleable?}.first
    _action = usable_actions.first if _action.nil?
    interpret_tactic_action(_action)
  end
  #----------------------------------------------------------------------------
  def interpret_tactic_action(action)
    return if action == @next_action
    use_tool(action.item, action.target)
  end
  #----------------------------------------------------------------------------
  def execute_symbol_action(action)
    item, target = action.item, action.target
    case item
    when :target_none
      set_target(nil)
    end
    return unless target || target.hashid != self.hashid
    return if target.is_a?(Array) && target.empty?
    case item
    when :set_target
      set_target(target) unless target.is_friend?(self) || !change_target?(target)
    when :move_away
      escape_from_threat(target)
    when :move_close
      move_toward_character(target) unless distance_to_character(target) < 2
    end
  end
  #----------------------------------------------------------------------------
  def attack(target = @current_target)
    #move_toward_character(target) if aggressive_level > 2
    turn_toward_character(target)
  end
  #----------------------------------------------------------------------------
  def tactic_retreat
  end
  #----------------------------------------------------------------------------
  def visible?
    return false if battler == self
    return !battler.state?(PONY::StateID[:invisible])
  end
  alias :visible :visible?
  #----------------------------------------------------------------------------
  def change_visibility(status = !@visible)
    @visible     =  status
    @translucent = !status if BattleManager.is_friend?(self, $game_player)
    if !@visible && @translucent
      @opacity = translucent_alpha
    else
      @opacity = 0xff
    end
  end
  #--------------------------------------------------------------------------
  def true_sight
    return battler.state?(PONY::StateID[:true_sight])
  end
  #--------------------------------------------------------------------------
  # * Get Alpha Value of Translucent Drawing
  #--------------------------------------------------------------------------
  def translucent_alpha
    return 160
  end
  #----------------------------------------------------------------------------
  # * Increase the target rate if target is meet to current tactic target
  #----------------------------------------------------------------------------
  def apply_tactic_target(value, target)
    return value
  end
  #----------------------------------------------------------------------------
  # * Change target to attacker when being attcked
  #----------------------------------------------------------------------------
  def apply_damaged_target_change(attacker, value)
    return unless BattleManager.valid_battler?(self)
    return if aggressive_level == 0
    return unless is_opponent?(attacker)
    set_target(attacker) if change_target?(attacker)
  end
  #----------------------------------------------------------------------------
  # * Determine whether change current target
  #----------------------------------------------------------------------------
  def change_target?(target)
    debug = self.is_a?(Game_Follower)
    return false if halt?    
    return false if target == @current_target
    return true  if @current_target.nil? || @current_target.dead?
    return true  if target && distance_to_character(target) < distance_to_character(@current_target)
    return false
  end
  #----------------------------------------------------------------------------
  # *) Determind sight angle
  #----------------------------------------------------------------------------
  def determind_sight_angles(angle)
    case direction
    when 2; value = [270 + angle, 270 - angle]
    when 4; value = [180 + angle, 180 - angle]
    when 6; value = [  0 + angle,   0 - angle]
    when 8; value = [ 90 + angle,  90 - angle]
    end
    value[0] = (value[0] + 360) % 360
    value[1] = (value[1] + 360) % 360
    return value
  end
  #----------------------------------------------------------------------------
  def battler_in_sight?(battler)
    dis = distance_to_character(battler)
    brange = (blind_sight rescue 0)
    vrange = visible_sight;
    return false if dis > vrange
    return true  if dis <= brange
    return in_sight?(battler, vrange)
  end
  #----------------------------------------------------------------------------
  # *) sight
  #----------------------------------------------------------------------------
  def in_sight?(target, dis)
    return false if !target.visible? && !true_sight
    offset  = target.body_size / 2
    tx, ty  = target.x + offset, target.y + offset
    angle   = determind_sight_angles(75)
    result  = Math.in_arc?(tx, ty, @x, @y, angle[0], angle[1], dis - 1 + offset*3, @direction)
    result &= can_see?(@x, @y, target.x, target.y)
    return result
  end
  #----------------------------------------------------------------------------
  def update_battler
    battler.update
  end
  #----------------------------------------------------------------------------
  def process_target_dead
    set_target(nil)
  end
  #----------------------------------------------------------------------------
  def find_nearest_enemy
  end
  #---------------------------------------------------------------------------
  def update_sight
  end
  #----------------------------------------------------------------------------
  def tactic_commands
    return battler.tactic_commands if battler != self
    return []
  end
  #----------------------------------------------------------------------------
  def start_timer(sym, plus = 0)
    case sym
    when :combat
      return @combat_timer = 20 + plus;
    when :chase_pathfinding
      return @chase_pathfinding_timer = 120 + plus;
    when :chase
      return @chase_timer = 12 + plus;
    end
  end
  
end

#==============================================================================
# ** Game_Event
#------------------------------------------------------------------------------
#  This class handles events. Functions include event page switching via
# condition determinants and running parallel process events. Used within the
# Game_Map class.
#==============================================================================
# tag: AI
class Game_Event < Game_Character
  #--------------------------------------------------------------------------
  Sight_Angle = 75
  #--------------------------------------------------------------------------
  # * Frame Update
  #--------------------------------------------------------------------------
  alias update_gaevdndai update
  def update
    if @enemy
      update_timer
      update_sight if effectus_near_the_screen?
    end
    update_gaevdndai
  end
  #----------------------------------------------------------------------------
  # * update enemies in sight
  #----------------------------------------------------------------------------
  def update_sight
    return unless aggressive_level > 1 && !static_object? && !halt?
    @sight_timer -= 1 if @sight_timer > 0
    return if @sight_timer > 0
    @sight_timer = 15 + rand(15)
    process_tactic_commands(:targeting)
    update_sighted if @current_target
  end
  #----------------------------------------------------------------------------
  def update_timer
    @chase_timer  -= 1 if @chase_timer > 0
    @chase_pathfinding_timer -= 1 if @chase_pathfinding_timer > 0
  end
  #----------------------------------------------------------------------------
  # *) Determind sight angle
  #----------------------------------------------------------------------------
  def determind_sight_angles(angle)
    case direction
    when 2; value = [270 + angle, 270 - angle]
    when 4; value = [180 + angle, 180 - angle]
    when 6; value = [  0 + angle,   0 - angle]
    when 8; value = [ 90 + angle,  90 - angle]
    end
    value[0] = (value[0] + 360) % 360
    value[1] = (value[1] + 360) % 360
    return value
  end
  #----------------------------------------------------------------------------
  # *) sight
  #----------------------------------------------------------------------------
  def in_sight?(target, dis)
    return false if !target.visible? && !true_sight
    offset = target.body_size / 2
    tx, ty = target.x + offset, target.y + offset
    angle  = determind_sight_angles(Sight_Angle)
    result = Math.in_arc?(tx, ty, @x, @y, angle[0], angle[1], dis - 1 + offset*3, @direction)
    return false unless result
    result = can_see?(@x, @y, target.x, target.y)
    return result
  end
  #----------------------------------------------------------------------------
  def update_battler
    return if dead? || $game_system.story_mode?
    super
    @combat_timer -= 1 if @combat_timer > 0
    update_combat if @combat_timer == 0 && !halt?
  end
  #----------------------------------------------------------------------------
  def update_sighted
    if battler_in_sight?(@current_target)
      @sight_lost_timer = 150
      @target_last_pos = @current_target.pos
    else
      @sight_lost_timer -= 15 if @sight_lost_timer > 0
      process_target_missing  if @sight_lost_timer == 0
    end
  end
  #----------------------------------------------------------------------------
  def process_target_missing
    return if !@target_last_pos
    cancel_action_without_penalty
    @next_action = nil if @next_action && @next_action.target == @current_target
    puts "#{name}: Target Missing, Last pos: #{[@target_last_pos.x, @target_last_pos.y]}"
    move_to_position(@target_last_pos.x, @target_last_pos.y, tool_range: 0) if aggressive_level > 3
    @target_last_pos = nil
    set_target(nil)
  end
  #----------------------------------------------------------------------------
  def attack(target = @current_target)
    return if halt?
    super
    @enemy.process_tool_action(primary_weapon)
  end
  #----------------------------------------------------------------------------
  def find_nearest_enemy
    brange = blind_sight
    vrange = visible_sight
    candidates = BattleManager.opponent_battler(self)
    best_target = [nil,0xffff]
    
    candidates.each do |char|
      next if char.static_object?
      dis = distance_to_character(char)
      next if dis > vrange && dis > brange
      if dis <= brange || in_sight?(char, vrange)
        rate = target_rate(char, dis)
        best_target = [char, rate] if rate < best_target[1]
      end
    end
    
    return best_target.first
  end
  #----------------------------------------------------------------------------
  def determine_skill_usage
    skill = @enemy.determine_skill_usage
    unless skill.nil?
      if (skill.tool_castime || 0) > 10
        @casting_flag = true
        @ori_agresilv = @aggressive_level
        @aggressive_level = 0
        @chase_timer = 30
      end
      target = BattleManager.autotarget(self, skill)
      @next_action = Game_Action.new(self, target, skill) 
      clear_pathfinding_moves
    end
  end
  
  def valid_battler?
    return true if @enemy
    return super
  end
  #----------------------------------------------------------------------------
  def set_target(target)
    super
    if target.nil?
      $game_map.remove_active_enemy(self)
    else
      $game_map.add_active_enemy(self)
    end
  end
end

#==============================================================================
# ** Game_Follower
#------------------------------------------------------------------------------
#  This class handles followers. A follower is an allied character, other than
# the front character, displayed in the party. It is referenced within the
# Game_Followers class.
#==============================================================================
# tag: AI
class Game_Follower < Game_Character
  #----------------------------------------------------------------------------
  def attack(target = @current_target)
    return if halt?
    super
    actor.process_tool_action(primary_weapon)
  end
  #----------------------------------------------------------------------------
  def set_target(target)
    return if gather? && target
    super
  end
  #--------------------------------------------------------------------------
  # * Alias: Frame Update
  #--------------------------------------------------------------------------
  alias update_dnd_combat update
  def update
    update_dnd_combat
    update_timer
    update_battler
  end
  #----------------------------------------------------------------------------
  def update_timer
    @chase_timer  -= 1 if @chase_timer > 0
    @chase_pathfinding_timer -= 1 if @chase_pathfinding_timer > 0
  end
  #----------------------------------------------------------------------------
  def update_battler
    return if dead? || $game_system.story_mode?
    super
    @combat_timer -= 1 if @combat_timer > 0
    update_combat if @combat_timer == 0 && !halt?
  end
  #----------------------------------------------------------------------------
  def update_combat
    return set_target(nil) if aggressive_level == 0
    start_timer(:combat)
    #puts "AI: #{$game_player.followers.tactic_enabled?}"
    process_tactic_commands if $game_player.followers.tactic_enabled?
  end
  #----------------------------------------------------------------------------
  # *) Determind sight angle
  #----------------------------------------------------------------------------
  def determind_sight_angles(angle)
    case direction
    when 2; value = [270 + angle, 270 - angle]
    when 4; value = [180 + angle, 180 - angle]
    when 6; value = [  0 + angle,   0 - angle]
    when 8; value = [ 90 + angle,  90 - angle]
    end
    value[0] = (value[0] + 360) % 360
    value[1] = (value[1] + 360) % 360
    return value
  end
  #----------------------------------------------------------------------------
  # *) sight
  #----------------------------------------------------------------------------
  def in_sight?(target, dis)
    return false if !target.visible? && !true_sight
    return can_see?(@x, @y, target.x, target.y)
  end
  #----------------------------------------------------------------------------
  def find_nearest_enemy
    enemies = BattleManager.opponent_battler(self)
    best = [nil, 0xffff]
    enemies.each do |enemy|
      next if enemy.static_object?
      dis = distance_to_character(enemy)
      next if distance_to_character(enemy) > 8
      next if !path_clear?(@x, @y, enemy.x, enemy.y)
      best = [enemy, dis] if dis < best.last
    end
    return best.first
  end
  #----------------------------------------------------------------------------
  def start_timer(sym, plus = 0)
    case sym
    when :combat
      return @combat_timer = 20 + plus;
    when :chase_pathfinding
      return @chase_pathfinding_timer = 60 + plus;
    when :chase
      return @chase_timer = 8 + plus;
    end
  end
  #----------------------------------------------------------------------------
  def valid_battler?
    return true if actor
    return super
  end
  #----------------------------------------------------------------------------
end

#==============================================================================
# ** Module: Tactic Condition
#------------------------------------------------------------------------------
#  Define the conditions of tactic command
#==============================================================================
# tag: AI
module Tactic_Config
  #--------------------------------------------------------------------------
  General_Actions = {
    :attack_mainhoof        => :attack_mainhoof,
    :attack_offhoof         => :attack_offhoof,
    :target_none            => :target_none,
    :set_target             => :set_target,
    :hp_most_power          => :hp_most_power,
    :hp_least_power         => :hp_least_power,
    :ep_most_power          => :ep_most_power,
    :ep_least_power         => :ep_least_power,
    :jump_to                => :nil,
    :move_away              => :move_away,
    :move_close             => :move_close,
  }
  #--------------------------------------------------------------------------
  # * This module contains the conditions when targeting a opponent
  #--------------------------------------------------------------------------
  module Enemy
    #--------------------------------------------------------------------------
    # * Corresponding mehtod name to each symbol
    #--------------------------------------------------------------------------
    Condition_Table = {
      # symbol,              mehtod name
      :lowest_hp            => :pick_hp_lowest,
      :highest_hp           => :pick_hp_highest,
      :has_state            => :pick_state_included,
      :nearest_visible      => :pick_nearest_visible,
      #:nearest_visible_type => :pick_nearest_type,
      :attacking_ally       => :pick_attacking_ally,
      :target_of_ally       => :pick_target_of_ally,
      :rank                 => :pick_rank,
    }
    #--------------------------------------------------------------------------
    module_function
    #--------------------------------------------------------------------------
    def start_check(user, symbol, args)
      if !Condition_Table.keys.include?(symbol)
        PONY::ERRNO.raise(:tactic_sym_missing, nil, nil, symbol)
        return
      end
      func = Condition_Table[symbol]
      @args = args
      @user = user
      @candidates = BattleManager.opponent_battler(@user)
      @range = @user.visible_sight
      @candidates = @candidates.select{|ch| @user.distance_to_character(ch) <= @range}
      @candidates.select!{|ch| @user.battler_in_sight?(ch) }
      @candidates.sort!{|a,b| @user.distance_to_character(a) <=> @user.distance_to_character(b)}
      return method(func).call
    end
    #--------------------------------------------------------------------------
    def pick_hp_lowest
      re = @candidates.min_by{|ch| ch.hp.to_f / ch.mhp}
      return re.empty? ? nil : re
    end
    #--------------------------------------------------------------------------
    def pick_hp_highest
      re = @candidates.max_by{|ch| ch.hp.to_f / ch.mhp}
      return re.empty? ? nil : re
    end
    #--------------------------------------------------------------------------
    def pick_state_included
      return unless (@args[0] || 0) > 0
      @candidates.each do |ch|
        return ch if ch.state?(@args[0])
      end
      return nil
    end
    #--------------------------------------------------------------------------
    def pick_nearest_visible
      @candidates.each do |ch|
        next if ch.dead?
        return ch
      end
      return nil
    end
    #--------------------------------------------------------------------------
    def pick_attacking_ally
      ally = @args[0]
      return nil unless ally
      ally = ally == :player ? $game_player : ally.battler
      
      @candidates.each do |ch|
        next if ch.dead?
        next if ch.current_target.nil?
        return ch if ch.current_target.hashid == ally.hashid
      end
      return nil
    end
    #--------------------------------------------------------------------------
    def pick_target_of_ally
      ally = @args[0]
      if ally == :player
        target = $game_player.current_target 
        return nil unless target
        return target if $game_player.can_see?(target)
        return nil
      end
      return ally.map_char.current_target if ally
      $game_party.members.each do |ch|
        next if ch.dead?
        next if ch.nil? || !ch.map_char
        return ch.map_char.current_target if ch.map_char.current_target
      end
      return nil
    end
    #--------------------------------------------------------------------------
    def pick_rank
      return if @args[0].nil?
      @candidates.each do |ch|
        next if ch.dead?
        return ch if ch.rank == ch.rank
      end
      return nil
    end
    #--------------------------------------------------------------------------
  end
  #--------------------------------------------------------------------------
  # * Handling the conditions when fighting enemy
  #--------------------------------------------------------------------------
  module Target
    #--------------------------------------------------------------------------
    Condition_Table = {
      :any              => :return_any,
      :has_state        => :state_included?,
      :clustered        => :determine_cluster_number,
      :hp_lower         => :hp_lower,
      :hp_higher        => :hp_higher,
      :target_range     => :determine_target_range_scale,
      :target_atk_type  => :determine_target_attack_type,
    }
    #--------------------------------------------------------------------------
    module_function
    #--------------------------------------------------------------------------
    def start_check(user, symbol, args)
      @user = user
      @target = user.current_target
      @args = args
      return method(Condition_Table[symbol]).call if @target
    end
    #--------------------------------------------------------------------------
    def return_any
      return true
    end
    #--------------------------------------------------------------------------
    def state_included?
      return @target.state?(@args[0])
    end
    #--------------------------------------------------------------------------
    def determine_cluster_number
      enemies = BattleManager.opponent_battler(@user)
      enemies.each do |enemy|
        cnt += 1 if enemy.distance_to_character(@target) < 3
      end
      return cnt >= @args[0] # number greater gate
    end
    #--------------------------------------------------------------------------
    def hp_lower
      percent = @args[0] / 100.0 # percent
      return (@target.hp.to_f / @target.mhp) <= percent
    end
    #--------------------------------------------------------------------------
    def hp_higher
      percent = @args[0] / 100.0 # percent
      return (@target.hp.to_f / @target.mhp) >= percent
    end
    #--------------------------------------------------------------------------
    def determine_target_range_scale
      dis = @user.distance_to_character(@target)
      return dis <= 2 if @args[0] == :short
      return dis <= 6 if @args[0] == :medium
      return dis > 6 if @args[0]  == :long
    end
    #--------------------------------------------------------------------------
    def determine_target_attack_type
      return false if @target.primary_weapon.nil?
      return @target.primary_weapon.melee?  if @args[0] == :melee
      return @target.primary_weapon.ranged? if @args[0] == :ranged
      return @target.casting?               if @args[0] == :magic
    end
    
  end # queued: tactic AI
  #--------------------------------------------------------------------------
  # * Handling the conditions about player itself
  #--------------------------------------------------------------------------
  module Players
     #--------------------------------------------------------------------------
    Condition_Table = {
      :any                    => :return_any,
      :has_state              => :state_included?,
      :hp_lower               => :hp_lower,
      :ep_lower               => :ep_lower,
      :being_attacked_by_type => :last_attacked_type,
      :enemies_alive          => :alive_enemy_number,
      :allies_alive           => :alive_ally_number,
      :allies_dead            => :dead_ally_number,
      :using_attack_type      => :current_attack_type,
      :surrounded_by_enemies  => :nearby_enemy_number
    }
    #--------------------------------------------------------------------------
    module_function
    #--------------------------------------------------------------------------
    def start_check(user, symbol, args)
      @user = user
      @args = args
      @range = 8
      return method(Condition_Table[symbol]).call
    end
    #--------------------------------------------------------------------------
    def return_any
      return true
    end
    #--------------------------------------------------------------------------
    def check_in_battle?
      return BattleManager.in_battle?
    end
    #--------------------------------------------------------------------------
    def state_included?
      return @user.state?(@args[0])
    end
    #--------------------------------------------------------------------------
    def hp_lower
      percent = @args[0] / 100.0
      return (@user.hp.to_f / @user.mhp) <= percent
    end
    #--------------------------------------------------------------------------
    def ep_lower
      percent = @args[0] / 100.0
      return (@user.mp.to_f / @user.mmp) <= percent
    end
    #--------------------------------------------------------------------------
    def last_attacked_type
      return @user.battler.last_attacked_action.collect{|a| a.item}.any?{|i| i.attack_type == @args[0]}
    end
    #--------------------------------------------------------------------------
    def alive_enemy_number
      enemies = BattleManager.opponent_battler(@user)
      enemies.select!{|ch| @user.distance_to_character(ch) <= @range}
      enemies.select!{|ch| @user.path_clear?(@user.x, @user.y, ch.x, ch.y) }
      number = enemies.size
      return number >= @args[0]
    end
    #--------------------------------------------------------------------------
    def alive_ally_number
      number = $game_party.battle_members.select{|ch| !ch.dead?}
      return number >= @args[0]
    end
    #--------------------------------------------------------------------------
    def dead_ally_number
      number = $game_party.battle_members.select{|ch| ch.dead?}
      return number >= @args[0]
    end
    #--------------------------------------------------------------------------
    def current_attack_type
      return @user.primary_weapon.attack_type == @args[0]
    end
    #--------------------------------------------------------------------------
    def nearby_enemy_number
      number = BattleManager.opponent_battler(@user).select{|ch| ch.distance_to_character(@user) < 3}
      return number >= @args[0]
    end
  end
  #--------------------------------------------------------------------------
  # * Handling the conditions about other party member
  #--------------------------------------------------------------------------
  module Party
     #--------------------------------------------------------------------------
    Condition_Table = {
      :has_state              => :state_included?,
      :hp_lower               => :hp_lower,
      :ep_lower               => :ep_lower,
      :being_attacked_by_type => :last_attacked_type,
      :using_attack_type      => :current_attack_type,
      :surrounded_by_enemies  => :nearby_enemy_number
    }
    #--------------------------------------------------------------------------
    module_function
    #--------------------------------------------------------------------------
    def start_check(user, symbol, args)
      @user = @user
      @args = args
      @candidates = $game_party.members.select{|member| member.map_char}
      return method(Condition_Table[symbol]).call
    end
    #--------------------------------------------------------------------------
    def state_included?
      @candidates.each do |member|
        return member if member.state?(@args[0])
      end
      return false
    end
    #--------------------------------------------------------------------------
    def hp_lower
      @candidates.each do |member|
        percent = @args[0] / 100.0
        return member if (member.hp.to_f / member.mhp) <= percent
      end
      return false
    end
    #--------------------------------------------------------------------------
    def ep_lower
      @candidates.each do |member|
        percent = @args[0] / 100.0
        return member if (member.mp.to_f / member.mmp) <= percent
      end
      return false
    end
    #--------------------------------------------------------------------------
    def last_attacked_type
      @candidates.each do |member|
        if member.last_attacked_action.collect{|a| a.item}.any?{|i| i.attack_type == @args[0]}
          return member
        end
      end
      return false
    end
    #--------------------------------------------------------------------------
    def current_attack_type
      @candidates.each do |member|
        return member if member.primary_weapon.attack_type == @args[0]
      end
      return false
    end
    #--------------------------------------------------------------------------
    def nearby_enemy_number
      @candidates.each do |member|
        number = BattleManager.opponent_battler(@user).select{|ch| ch.distance_to_character(member) < 3}
        return member if number >= @args[0]
      end
      return false
    end
    #--------------------------------------------------------------------------
  end
  #--------------------------------------------------------------------------
end
#==============================================================================
# ** Module: Tactic Condition
#------------------------------------------------------------------------------
#  Define the conditions of tactic command
#==============================================================================
module Tactic_Config
  Condition_Symbol = {
    :has_state              => :collect_valid_states,
    :attacking_ally         => :player_party_members, 
    :target_of_ally         => :player_party_members,
    :rank                   => DND::Rank,
    :target_atk_type        => DND::AttackType,
    :being_attacked_by_type => DND::AttackType,
    :using_attack_type      => DND::AttackType,
    :target_range           => [:short, :medium, :long],
    :jump_to                => :empty_function,
  }
  #--------------------------------------------------------------------------
  module_function
  #--------------------------------------------------------------------------
  def empty_function
  end
  #--------------------------------------------------------------------------
  def call_function(symbol)
    return method(symbol).call
  end
  #--------------------------------------------------------------------------
  def player_party_members
    return $game_party.members
  end
  #--------------------------------------------------------------------------
  def collect_valid_states
    return $data_states.select{|state| state_valied?(state)}
  end
  #--------------------------------------------------------------------------
  def state_valied?(state)
    return false if state.nil?
    return false if state.id < 1
    return false if (state.icon_index || 0) < 1
    return false if state.name.nil? || state.name.empty?
    return false if state.features.empty? && state.note.empty?
    return true
  end
  #--------------------------------------------------------------------------
  
end

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Passive States v1.02
# -- Last Updated: 2012.01.23
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-PassiveStates"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.23 - Compatibility Update: Doppelganger
# 2012.01.08 - Added passive state checks for adding/removing states.
# 2011.12.14 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script allows for actors, classes, weapons, armours, and enemies to have
# passives that are based off of states. Passive states will be active at all
# times and are immune to restrictions and will only disappear if the battler
# dies. Once the battler revives, the passives will return.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Actor Notetags - These notetags go in the actors notebox in the database.
# -----------------------------------------------------------------------------
# <passive state: x>
# <passive state: x, x>
# This will cause state x to be always on (unless the battler is dead). To have
# multiple passives, insert multiples of this notetag.
# 
# -----------------------------------------------------------------------------
# Class Notetags - These notetags go in the class notebox in the database.
# -----------------------------------------------------------------------------
# <passive state: x>
# <passive state: x, x>
# This will cause state x to be always on (unless the battler is dead). To have
# multiple passives, insert multiples of this notetag.
# 
# -----------------------------------------------------------------------------
# Weapon Notetags - These notetags go in the weapons notebox in the database.
# -----------------------------------------------------------------------------
# <passive state: x>
# <passive state: x, x>
# This will cause state x to be always on (unless the battler is dead). To have
# multiple passives, insert multiples of this notetag.
# 
# -----------------------------------------------------------------------------
# Armour Notetags - These notetags go in the armours notebox in the database.
# -----------------------------------------------------------------------------
# <passive state: x>
# <passive state: x, x>
# This will cause state x to be always on (unless the battler is dead). To have
# multiple passives, insert multiples of this notetag.
# 
# -----------------------------------------------------------------------------
# Enemy Notetags - These notetags go in the enemies notebox in the database.
# -----------------------------------------------------------------------------
# <passive state: x>
# <passive state: x, x>
# This will cause state x to be always on (unless the battler is dead). To have
# multiple passives, insert multiples of this notetag.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
module YEA
  module REGEXP
  module BASEITEM
    
    PASSIVE_STATE = 
      /<(?:PASSIVE_STATE|passive state):[ ]*(\d+(?:\s*,\s*\d+)*)>/i
    
  end # BASEITEM
  end # REGEXP
end # YEA
#==============================================================================
# ■ DataManager
#==============================================================================
module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_pst load_database; end
  def self.load_database
    load_database_pst
    load_notetags_pst
  end
  
  #--------------------------------------------------------------------------
  # new method: load_notetags_pst
  #--------------------------------------------------------------------------
  def self.load_notetags_pst
    groups = [$data_actors, $data_classes, $data_weapons, $data_armors,
      $data_enemies]
    for group in groups
      for obj in group
        next if obj.nil?
        obj.load_notetags_pst
      end
    end
  end
  
end # DataManager
#==============================================================================
# ■ RPG::BaseItem
#==============================================================================
class RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :passive_states
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_pst
  #--------------------------------------------------------------------------
  def load_notetags_pst
    @passive_states = []
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::BASEITEM::PASSIVE_STATE
        $1.scan(/\d+/).each { |num| 
        @passive_states.push(num.to_i) if num.to_i > 0 }
      #---
      end
    } # self.note.split
    #---
  end
  
end # RPG::BaseItem
#==============================================================================
# ■ Game_BattlerBase
#==============================================================================
class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # alias method: state?
  #--------------------------------------------------------------------------
  alias game_battlerbase_state_check_pst state?
  def state?(state_id)
    return true if passive_state?(state_id)
    return game_battlerbase_state_check_pst(state_id)
  end
  
  #--------------------------------------------------------------------------
  # alias method: states
  #--------------------------------------------------------------------------
  alias game_battlerbase_states_pst states
  def states
    array = game_battlerbase_states_pst
    array |= passive_states
    return array
  end
  
  #--------------------------------------------------------------------------
  # new method: passive_state?
  #--------------------------------------------------------------------------
  def passive_state?(state_id)
    @passive_states = [] if @passive_states.nil?
    return @passive_states.include?(state_id)
  end
  
  #--------------------------------------------------------------------------
  # new method: passive_states
  #--------------------------------------------------------------------------
  def passive_states
    array = []
    if actor?
      for state_id in self.actor.passive_states
        array.push($data_states[state_id]) if passive_state_addable?(state_id)
      end
      for state_id in self.class.passive_states
        array.push($data_states[state_id]) if passive_state_addable?(state_id)
      end
      for equip in equips
        next if equip.nil?
        for state_id in equip.passive_states
          array.push($data_states[state_id]) if passive_state_addable?(state_id)
        end
      end
    else # enemy
      for state_id in self.enemy.passive_states
        array.push($data_states[state_id]) if passive_state_addable?(state_id)
      end
      if $imported["YEA-Doppelganger"] && !self.class.nil?
        for state_id in self.class.passive_states
          array.push($data_states[state_id]) if passive_state_addable?(state_id)
        end
      end
    end
    create_passive_state_array(array)
    sort_passive_states(array)
    set_passive_state_turns(array)
    return array
  end
  
  #--------------------------------------------------------------------------
  # new method: create_passive_state_array
  #--------------------------------------------------------------------------
  def create_passive_state_array(array)
    @passive_states = []
    for state in array
      @passive_states.push(state.id)
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: passive_state_addable?
  #--------------------------------------------------------------------------
  def passive_state_addable?(state_id)
    return false if $data_states[state_id].nil?
    return alive?
  end
  
  #--------------------------------------------------------------------------
  # new method: set_passive_state_turns
  #--------------------------------------------------------------------------
  def sort_passive_states(array)
    array.sort! do |state_a, state_b|
      if state_a.priority != state_b.priority
        state_b.priority <=> state_a.priority
      else
        state_a.id <=> state_b.id
      end
    end
    return array
  end
  
  #--------------------------------------------------------------------------
  # new method: set_passive_state_turns
  #--------------------------------------------------------------------------
  def set_passive_state_turns(array)
    for state in array
      @state_turns[state.id] = 0 unless @states.include?(state.id)
      @state_steps[state.id] = 0 unless @states.include?(state.id)
    end
  end
  
end # Game_BattlerBase
#==============================================================================
# ■ Game_Battler
#==============================================================================
class Game_Battler < Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # alias method: state_addable?
  #--------------------------------------------------------------------------
  alias game_battler_state_addable_ps state_addable?
  def state_addable?(state_id)
    return false if passive_state?(state_id)
    return game_battler_state_addable_ps(state_id)
  end
  
  #--------------------------------------------------------------------------
  # alias method: remove_state
  #--------------------------------------------------------------------------
  alias game_battler_remove_state_ps remove_state
  def remove_state(state_id)
    return if passive_state?(state_id)
    game_battler_remove_state_ps(state_id)
  end
  
end # Game_Battler
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Lunatic States v1.02
# -- Last Updated: 2012.01.30
# -- Level: Lunatic
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-LunaticStates"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.30 - Compatibility Update: Ace Battle Engine
# 2011.12.19 - Fixed Death State stacking error.
# 2011.12.15 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# Lunatic mode effects have always been a core part of Yanfly Engine scripts.
# They exist to provide more effects for those who want more power and control
# for their items, skills, status effects, etc., but the users must be able to
# add them in themselves.
# 
# This script provides the base setup for state lunatic effects. These effects
# will occur under certain conditions, which can include when a state is
# applied, erased, leaves naturally, before taking damage, after taking damage,
# at the start of a turn, while an action finishes, and at the end of a turn.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # ● Welcome to Lunatic Mode
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # Lunatic States allow allow states to trigger various scripted functions
  # throughout certain set periods of times or when certain conditions
  # trigger. These effects can occur when a state is applied, when a state is
  # erased, when a state leaves naturally, before damage is taken, after
  # damage is taken, at the beginning of a turn, while the turn is occuring,
  # and at the closing of a turn. These effects are separated by these eight
  # different notetags.
  # 
  #     <apply effect: string>     - Occurs when state is applied.
  #     <erase effect: string>     - Occurs when state is removed.
  #     <leave effect: string>     - Occurs when state timer hits 0.
  #     <react effect: string>     - Occurs before taking damage.
  #     <shock effect: string>     - Occurs after taking damage.
  #     <begin effect: string>     - Occurs at the start of each turn.
  #     <while effect: string>     - Occurs after performing an action.
  #     <close effect: string>     - Occurs at the end of a turn.
  # 
  # If multiple tags of the same type are used in the same skill/item's
  # notebox, then the effects will occur in that order. Replace "string" in
  # the tags with the appropriate flag for the method below to search for.
  # Note that unlike the previous versions, these are all upcase.
  # 
  # Should you choose to use multiple lunatic effects for a single state, you
  # may use these notetags in place of the ones shown above.
  # 
  #     <apply effect>      <erase effect>      <leave effect>
  #      string              string              string
  #      string              string              string
  #     </apply effect>     </erase effect>     </leave effect>
  # 
  #                <react effect>      <shock effect>
  #                 string              string
  #                 string              string
  #                </react effect>     </shock effect>
  # 
  #     <begin effect>      <while effect>      <close effect>
  #      string              string              string
  #      string              string              string
  #     </begin effect>     </while effect>     </close effect>
  # 
  # All of the string information in between those two notetags will be
  # stored the same way as the notetags shown before those. There is no
  # difference between using either.
  #--------------------------------------------------------------------------
  def lunatic_state_effect(type, state, user , attacker = nil)
    return unless SceneManager.scene_is?(Scene_Battle)
    return if state.nil?
    case type
    when :apply; effects = state.apply_effects;
    when :erase; effects = state.erase_effects;
    when :leave; effects = state.leave_effects;
    when :react; effects = state.react_effects;
    when :shock; effects = state.shock_effects;
    when :begin; effects = state.begin_effects;
    when :while; effects = state.while_effects;
    when :close; effects = state.close_effects;
    else; return ;
    end
    log_window = SceneManager.scene.log_window
    state_origin = state_origin?(state.id)
    
    
    for effect in effects
      case effect.upcase
      #----------------------------------------------------------------------
      # Common Effect: Apply
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      # This is a common effect that runs whenever a state is refreshly added
      # to the battler's state pool. There is no need to modify this unless
      # you see fit.
      #----------------------------------------------------------------------
      when /COMMON APPLY/i
        # No common apply effects added.
        
      #----------------------------------------------------------------------
      # Common Effect: Erase
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      # This is a common effect that runs whenever a state is removed from
      # the battler's state pool. There is no need to modify this unless you
      # see fit.
      #----------------------------------------------------------------------
      when /COMMON ERASE/i
        # No common erase effects added.
        
      #----------------------------------------------------------------------
      # Common Effect: Leave
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      # This is a common effect that runs whenever a state's turns reach 0
      # and leaves the battler's state pool. There is no need to modify this
      # unless you see fit.
      #----------------------------------------------------------------------
      when /COMMON LEAVE/i
        # No common leave effects added.
        
      #----------------------------------------------------------------------
      # Common Effect: React
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      # This is a common effect that runs right before the battler is about
      # to take damage. There is no need to modify this unless you see fit.
      #----------------------------------------------------------------------
      when /COMMON REACT/i
        # No common react effects added.
        
      #----------------------------------------------------------------------
      # Common Effect: Shock
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      # This is a common effect that runs right after the battler has taken
      # damage. There is no need to modify this unless you see fit.
      #----------------------------------------------------------------------
      when /COMMON SHOCK/i
        # No common shock effects added.
        
      #----------------------------------------------------------------------
      # Common Effect: Begin
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      # This is a common effect that runs at the start of the party's turn. 
      # There is no need to modify this unless you see fit.
      #----------------------------------------------------------------------
      when /COMMON BEGIN/i
        # No common begin effects added.
        
      #----------------------------------------------------------------------
      # Common Effect: While
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      # This is a common effect that runs at the end of the battler's turn. 
      # There is no need to modify this unless you see fit.
      #----------------------------------------------------------------------
      when /COMMON WHILE/i
        # No common while effects added.
        
      #----------------------------------------------------------------------
      # Common Effect: Close
      # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      # This is a common effect that runs at the end of the party's turn. 
      # There is no need to modify this unless you see fit.
      #----------------------------------------------------------------------
      when /COMMON CLOSE/i
        # No common close effects added.
      #----------------------------------------------------------------------
      # Stop editting past this point.
      #----------------------------------------------------------------------
      else
        lunatic_state_extension(effect, state, user, state_origin, log_window , attacker)
      end
    end # for effect in effects
    
  end # lunatic_object_effect
  
end # Game_BattlerBase
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
module YEA
  module REGEXP
  module STATE
    
    APPLY_EFFECT_STR = /<(?:APPLY_EFFECT|apply effect):[ ](.*)>/i
    APPLY_EFFECT_ON  = /<(?:APPLY_EFFECT|apply effect)>/i
    APPLY_EFFECT_OFF = /<\/(?:APPLY_EFFECT|apply effect)>/i
    
    ERASE_EFFECT_STR = /<(?:ERASE_EFFECT|erase effect):[ ](.*)>/i
    ERASE_EFFECT_ON  = /<(?:ERASE_EFFECT|erase effect)>/i
    ERASE_EFFECT_OFF = /<\/(?:ERASE_EFFECT|erase effect)>/i
    
    LEAVE_EFFECT_STR = /<(?:LEAVE_EFFECT|leave effect):[ ](.*)>/i
    LEAVE_EFFECT_ON  = /<(?:LEAVE_EFFECT|leave effect)>/i
    LEAVE_EFFECT_OFF = /<\/(?:LEAVE_EFFECT|leave effect)>/i
    
    REACT_EFFECT_STR = /<(?:REACT_EFFECT|react effect):[ ](.*)>/i
    REACT_EFFECT_ON  = /<(?:REACT_EFFECT|react effect)>/i
    REACT_EFFECT_OFF = /<\/(?:REACT_EFFECT|react effect)>/i
    
    SHOCK_EFFECT_STR = /<(?:SHOCK_EFFECT|shock effect):[ ](.*)>/i
    SHOCK_EFFECT_ON  = /<(?:SHOCK_EFFECT|shock effect)>/i
    SHOCK_EFFECT_OFF = /<\/(?:SHOCK_EFFECT|shock effect)>/i
    
    BEGIN_EFFECT_STR = /<(?:BEGIN_EFFECT|begin effect):[ ](.*)>/i
    BEGIN_EFFECT_ON  = /<(?:BEGIN_EFFECT|begin effect)>/i
    BEGIN_EFFECT_OFF = /<\/(?:BEGIN_EFFECT|begin effect)>/i
    
    WHILE_EFFECT_STR = /<(?:WHILE_EFFECT|while effect):[ ](.*)>/i
    WHILE_EFFECT_ON  = /<(?:WHILE_EFFECT|while effect)>/i
    WHILE_EFFECT_OFF = /<\/(?:WHILE_EFFECT|while effect)>/i
    
    CLOSE_EFFECT_STR = /<(?:CLOSE_EFFECT|close effect):[ ](.*)>/i
    CLOSE_EFFECT_ON  = /<(?:CLOSE_EFFECT|close effect)>/i
    CLOSE_EFFECT_OFF = /<\/(?:CLOSE_EFFECT|close effect)>/i
    
  end # STATE
  end # REGEXP
end # YEA
#==============================================================================
# ■ DataManager
#==============================================================================
module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_lsta load_database; end
  def self.load_database
    load_database_lsta
    load_notetags_lsta
  end
  
  #--------------------------------------------------------------------------
  # new method: load_notetags_lsta
  #--------------------------------------------------------------------------
  def self.load_notetags_lsta
    for state in $data_states
      next if state.nil?
      state.load_notetags_lsta
    end
  end
  
end # DataManager
#==============================================================================
# ■ RPG::State
#==============================================================================
class RPG::State < RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :apply_effects
  attr_accessor :erase_effects
  attr_accessor :leave_effects
  attr_accessor :react_effects
  attr_accessor :shock_effects
  attr_accessor :begin_effects
  attr_accessor :while_effects
  attr_accessor :close_effects
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_lsta
  #--------------------------------------------------------------------------
  def load_notetags_lsta
    @apply_effects = ["COMMON APPLY"]
    @erase_effects = ["COMMON ERASE"]
    @leave_effects = ["COMMON LEAVE"]
    @react_effects = ["COMMON REACT"]
    @shock_effects = ["COMMON SHOCK"]
    @begin_effects = ["COMMON BEGIN"]
    @while_effects = ["COMMON WHILE"]
    @close_effects = ["COMMON CLOSE"]
    @apply_effects_on = false
    @erase_effects_on = false
    @leave_effects_on = false
    @react_effects_on = false
    @shock_effects_on = false
    @begin_effects_on = false
    @while_effects_on = false
    @close_effects_on = false
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::STATE::APPLY_EFFECT_STR
        @apply_effects.push($1.to_s)
      when YEA::REGEXP::STATE::ERASE_EFFECT_STR
        @erase_effects.push($1.to_s)
        puts "#{self.name} has erase effect"
      when YEA::REGEXP::STATE::LEAVE_EFFECT_STR
        @leave_effects.push($1.to_s)
      when YEA::REGEXP::STATE::REACT_EFFECT_STR
        @react_effects.push($1.to_s)
      when YEA::REGEXP::STATE::SHOCK_EFFECT_STR
        @shock_effects.push($1.to_s)
      when YEA::REGEXP::STATE::BEGIN_EFFECT_STR
        @begin_effects.push($1.to_s)
      when YEA::REGEXP::STATE::WHILE_EFFECT_STR
        @while_effects.push($1.to_s)
      when YEA::REGEXP::STATE::CLOSE_EFFECT_STR
        @close_effects.push($1.to_s)
      #---
      when YEA::REGEXP::STATE::APPLY_EFFECT_ON
        @apply_effects_on = true
        #p sprintf("[YEA|Lunatic State]:Detected apply effect: %s",self.name)
      when YEA::REGEXP::STATE::ERASE_EFFECT_ON
        @erase_effects_on = true
      when YEA::REGEXP::STATE::LEAVE_EFFECT_ON
        @leave_effects_on = true
      when YEA::REGEXP::STATE::REACT_EFFECT_ON
        @react_effects_on = true
      when YEA::REGEXP::STATE::SHOCK_EFFECT_ON
        @shock_effects_on = true
      when YEA::REGEXP::STATE::BEGIN_EFFECT_ON
        @begin_effects_on = true
      when YEA::REGEXP::STATE::WHILE_EFFECT_ON
        @while_effects_on = true
      when YEA::REGEXP::STATE::CLOSE_EFFECT_ON
        @close_effects_on = true
      #---
      when YEA::REGEXP::STATE::APPLY_EFFECT_OFF
        @apply_effects_on = false
      when YEA::REGEXP::STATE::ERASE_EFFECT_OFF
        @erase_effects_on = false
      when YEA::REGEXP::STATE::LEAVE_EFFECT_OFF
        @leave_effects_on = false
      when YEA::REGEXP::STATE::REACT_EFFECT_OFF
        @react_effects_on = false
      when YEA::REGEXP::STATE::SHOCK_EFFECT_OFF
        @shock_effects_on = false
      when YEA::REGEXP::STATE::BEGIN_EFFECT_OFF
        @begin_effects_on = false
      when YEA::REGEXP::STATE::WHILE_EFFECT_OFF
        @while_effects_on = false
      when YEA::REGEXP::STATE::CLOSE_EFFECT_OFF
        @close_effects_on = false
      #---
      else
        @apply_effects.push(line.to_s) if @apply_effects_on
        @erase_effects.push(line.to_s) if @erase_effects_on
        @leave_effects.push(line.to_s) if @leave_effects_on
        @react_effects.push(line.to_s) if @react_effects_on
        @shock_effects.push(line.to_s) if @shock_effects_on
        @begin_effects.push(line.to_s) if @begin_effects_on
        @while_effects.push(line.to_s) if @while_effects_on
        @close_effects.push(line.to_s) if @close_effects_on
      end
    } # self.note.split
    #---    
  end
  
end # RPG::State
#==============================================================================
# ■ Game_BattlerBase
#==============================================================================
class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # alias method: clear_states
  #--------------------------------------------------------------------------
  alias game_battlerbase_clear_states_lsta clear_states
  def clear_states
    game_battlerbase_clear_states_lsta
    clear_state_origins
  end
  
  #--------------------------------------------------------------------------
  # alias method: erase_state
  #--------------------------------------------------------------------------
  alias game_battlerbase_erase_state_lsta erase_state
  def erase_state(state_id)
    lunatic_state_effect(:erase, $data_states[state_id], self)
    change_state_origin(:erase)
    game_battlerbase_erase_state_lsta(state_id)
  end
  
  #--------------------------------------------------------------------------
  # new method: clear_state_origins
  #--------------------------------------------------------------------------
  def clear_state_origins
    @state_origins = {}
  end
  
  #--------------------------------------------------------------------------
  # new method: change_state_origin
  #--------------------------------------------------------------------------
  def change_state_origin(state_id, type = :apply)
    return unless $game_party.in_battle
    return if state_id == death_state_id
    if :apply && SceneManager.scene_is?(Scene_Battle)
      subject = SceneManager.scene.subject
      clear_state_origins if @state_origins.nil?
      if subject.nil?
        @state_origins[state_id] = [:actor, self.id] if self.actor?
        @state_origins[state_id] = [:enemy, self.index] unless self.actor?
      elsif subject.actor?
        @state_origins[state_id] = [:actor, subject.id]
      else
        @state_origins[state_id] = [:enemy, subject.index]
      end
    else # :erase
      @state_origins[state_id] = nil
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: state_origin?
  #--------------------------------------------------------------------------
  def state_origin?(state_id)
    return self unless $game_party.in_battle
    return self if @state_origins[state_id].nil?
    team = @state_origins[state_id][0]
    subject = @state_origins[state_id][1]
    if team == :actor
      return $game_actors[subject]
    else # :enemy
      return $game_troop.members[subject]
    end
  end
  
end # Game_BattlerBase
#==============================================================================
# ■ Game_Battler
#==============================================================================
class Game_Battler < Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # alias method: on_battle_start
  #--------------------------------------------------------------------------
  alias game_battler_on_battle_start_lsta on_battle_start
  def on_battle_start
    game_battler_on_battle_start_lsta
    clear_state_origins
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_battle_end
  #--------------------------------------------------------------------------
  alias game_battler_on_battle_end_lsta on_battle_end
  def on_battle_end
    game_battler_on_battle_end_lsta
    clear_state_origins
  end
  
  #--------------------------------------------------------------------------
  # alias method: add_new_state
  #--------------------------------------------------------------------------
  alias game_battler_add_new_state_lsta add_new_state
  def add_new_state(state_id)
    game_battler_add_new_state_lsta(state_id)
    change_state_origin(state_id, :apply)
    lunatic_state_effect(:apply, $data_states[state_id], self)
  end
  
  #--------------------------------------------------------------------------
  # alias method: remove_states_auto
  #--------------------------------------------------------------------------
  alias game_battler_remove_states_auto_lsta remove_states_auto
  def remove_states_auto(timing)
    states.each do |state|
      next if state.note =~ /<eternal>/
      if @state_turns[state.id] == 0 && state.auto_removal_timing == timing
        lunatic_state_effect(:leave, state, self)
      end
    end
    game_battler_remove_states_auto_lsta(timing)
  end
  #--------------------------------------------------------------------------
  # alias method: execute_damage
  # tag: modified
  #--------------------------------------------------------------------------
  alias game_battler_execute_damage_lsta execute_damage
  def execute_damage(user)
    for state in states; run_lunatic_states(:react,user); end
    return if user.state?(PONY::COMBAT_STOP_FLAG)
    
    game_battler_execute_damage_lsta(user)
    @result.restore_damage if $imported["YEA-BattleEngine"]
    for state in states; run_lunatic_states(:shock); end
    return unless $imported["YEA-BattleEngine"]
    @result.store_damage
    @result.clear_damage_values
  end
  
  #--------------------------------------------------------------------------
  # new method: run_lunatic_states
  #--------------------------------------------------------------------------
  def run_lunatic_states(type , attacker = nil)
    for state in states; lunatic_state_effect(type, state, self , attacker); end
  end
  
end # Game_Battler
#==============================================================================
# ■ Scene_Battle
#==============================================================================
class Scene_Battle < Scene_Base
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :log_window
  attr_accessor :subject
  
  #--------------------------------------------------------------------------
  # alias method: turn_start
  #--------------------------------------------------------------------------
  alias scene_battle_turn_start_lsta turn_start
  def turn_start
    scene_battle_turn_start_lsta
    for member in all_battle_members; member.run_lunatic_states(:begin); end
  end
  
  #--------------------------------------------------------------------------
  # alias method: turn_end
  #--------------------------------------------------------------------------
  alias scene_battle_turn_end_lsta turn_end
  def turn_end
    for member in all_battle_members; member.run_lunatic_states(:close); end
    scene_battle_turn_end_lsta
  end
  
  #--------------------------------------------------------------------------
  # alias method: execute_action
  #--------------------------------------------------------------------------
  alias scene_battle_execute_action_lsta execute_action
  def execute_action
    scene_battle_execute_action_lsta
    @subject.run_lunatic_states(:while)
  end
  
end # Scene_Battle
#==============================================================================
# ■ Game_BattlerBase
#==============================================================================
class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # new method: lunatic_state_extension
  #--------------------------------------------------------------------------
  def lunatic_state_extension(effect, state, user, state_origin, log_window, attacker = nil)
    # Reserved for future Add-ons.
    p sprintf("--------State Script--------")
    puts "#{effect}"
    p sprintf("----------------------------")
    eval(effect)
  end
  
end # Game_BattlerBase
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Lunatic States Package - Punishment v1.01
# -- Last Updated: 2011.12.15
# -- Level: Lunatic
# -- Requires: YEA - Lunatic States v1.00+
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-LSP-Punishment"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2011.12.31 - Bug Fixed: Error with battle popups not showing.
# 2011.12.15 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This is a script for Lunatic States Package Effects with punishment themed
# effects. Included in it are effects that make battlers undead (take damage
# whenever they are healed), make battlers whenever they execute physical or
# magical attacks, make battlers take damage based on the original caster of
# the state's stats, and an effect that heals the original caster of the state
# whenever the battler takes HP or MP damage.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# Install this script under YEA - Lunatic States. Then, proceed to use the
# proper effects notetags to apply the proper LSP Punishment item desired.
# Look within the script for more instructions on how to use each effect.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
# This script requires YEA - Lunatic States v1.00+ to work. It must be placed
# under YEA - Lunatic States v1.00+ in the script listing.
# 
#==============================================================================
if $imported["YEA-LunaticStates"]
class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # ● Lunatic States Package Effects - Punishment
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # These effects are centered around the theme of punishment. These effects
  # punish users for doing various aspects that may benefit them by harming
  # them in different ways.
  #--------------------------------------------------------------------------
  alias lunatic_state_extension_lsp1 lunatic_state_extension
  def lunatic_state_extension(effect, state, user, state_origin, log_window, attacker = nil)
    return if $current_user.nil?
    
    case effect.upcase
    #----------------------------------------------------------------------
    # Punish Effect No.1: Undead HP
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with react effect. This causes any HP healing done to become
    # reversed and deal HP damage to the healed target.
    # 
    # Recommended notetag:
    #   <react effect: undead hp>
    #----------------------------------------------------------------------
    when /UNDEAD HP/i
      return unless @result.hp_damage < 0
      @result.hp_damage *= -1
      @result.hp_drain *= -1
      
    #----------------------------------------------------------------------
    # Punish Effect No.2: Undead MP
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with react effect. This causes any MP healing done to become
    # reversed and deal MP damage to the healed target.
    # 
    # Recommended notetag:
    #   <react effect: undead mp>
    #----------------------------------------------------------------------
    when /UNDEAD MP/i
      return unless @result.mp_damage < 0
      @result.mp_damage *= -1
      @result.mp_drain *= -1
      
    #----------------------------------------------------------------------
    # Punish Effect No.3: Physical Backfire
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with while effect. Whenever the affected battler uses a
    # physical attack, that battler will take HP damage equal to its own
    # stats after finishing the current action. Battler cannot die from
    # this effect.
    # 
    # Recommended notetag:
    #   <while effect: physical backfire stat x%>
    # 
    # Replace "stat" with MAXHP, MAXMP, ATK, DEF, MAT, MDF, AGI, or LUK.
    # Replace x with the stat multiplier to affect damage dealt.
    #----------------------------------------------------------------------
    when /PHYSICAL BACKFIRE[ ](.*)[ ](\d+)([%％])/i
      return if user.current_action.nil?
      return unless user.current_action.item.physical?
      case $1.upcase
      when "MAXHP"; dmg = user.mhp
      when "MAXMP"; dmg = user.mmp
      when "ATK";   dmg = user.atk
      when "DEF";   dmg = user.def
      when "MAT";   dmg = user.mat
      when "MDF";   dmg = user.mdf
      when "AGI";   dmg = user.agi
      when "LUK";   dmg = user.luk
      else; return
      end
      dmg = (dmg * $2.to_i * 0.01).to_i
      if $imported["YEA-BattleEngine"] && dmg > 0
        text = sprintf(YEA::BATTLE::POPUP_SETTINGS[:hp_dmg], dmg.group)
        user.create_popup(text, "HP_DMG")
      end
      user.perform_damage_effect
      user.hp = [user.hp - dmg, 1].max
      
    #----------------------------------------------------------------------
    # Punish Effect No.4: Magical Backfire
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with while effect. Whenever the affected battler uses a
    # magical attack, that battler will take HP damage equal to its own
    # stats after finishing the current action. Battler cannot die from
    # this effect.
    # 
    # Recommended notetag:
    #   <while effect: magical backfire stat x%>
    # 
    # Replace "stat" with MAXHP, MAXMP, ATK, DEF, MAT, MDF, AGI, or LUK.
    # Replace x with the stat multiplier to affect damage dealt.
    #----------------------------------------------------------------------
    when /MAGICAL BACKFIRE[ ](.*)[ ](\d+)([%％])/i
      return if user.current_action.nil?
      return unless user.current_action.item.magical?
      case $1.upcase
      when "MAXHP"; dmg = user.mhp
      when "MAXMP"; dmg = user.mmp
      when "ATK";   dmg = user.atk
      when "DEF";   dmg = user.def
      when "MAT";   dmg = user.mat
      when "MDF";   dmg = user.mdf
      when "AGI";   dmg = user.agi
      when "LUK";   dmg = user.luk
      else; return
      end
      dmg = (dmg * $2.to_i * 0.01).to_i
      if $imported["YEA-BattleEngine"] && dmg > 0
        text = sprintf(YEA::BATTLE::POPUP_SETTINGS[:hp_dmg], dmg.group)
        user.create_popup(text, "HP_DMG")
      end
      user.perform_damage_effect
      user.hp = [user.hp - dmg, 1].max
      
    #----------------------------------------------------------------------
    # Punish Effect No.5: Stat Slip Damage
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with close effect. At the end of the turn, the affected
    # battler will take HP slip damage based on the stat of the of one who
    # casted the status effect onto the battler. Battler cannot die from
    # this effect.
    # 
    # Recommended notetag:
    #   <close effect: stat slip damage x%>
    # 
    # Replace "stat" with MAXHP, MAXMP, ATK, DEF, MAT, MDF, AGI, or LUK.
    # Replace x with the stat multiplier to affect damage dealt.
    #----------------------------------------------------------------------
    when /(.*)[ ]SLIP DAMAGE[ ](\d+)([%％])/i
      case $1.upcase
      when "MAXHP"; dmg = state_origin.mhp
      when "MAXMP"; dmg = state_origin.mmp
      when "ATK";   dmg = state_origin.atk
      when "DEF";   dmg = state_origin.def
      when "MAT";   dmg = state_origin.mat
      when "MDF";   dmg = state_origin.mdf
      when "AGI";   dmg = state_origin.agi
      when "LUK";   dmg = state_origin.luk
      else; return
      end
      dmg = (dmg * $2.to_i * 0.01).to_i
      if $imported["YEA-BattleEngine"] && dmg > 0
        text = sprintf(YEA::BATTLE::POPUP_SETTINGS[:hp_dmg], dmg.group)
        user.create_popup(text, "HP_DMG")
      end
      user.perform_damage_effect
      user.hp = [user.hp - dmg, 1].max
      
    #----------------------------------------------------------------------
    # Punish Effect No.6: Stat Slip Heal
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with close effect. At the end of the turn, the affected
    # battler will heal HP  based on the stat of the of one who casted the
    # status effect onto the battler.
    # 
    # Recommended notetag:
    #   <close effect: stat slip heal x%>
    # 
    # Replace "stat" with MAXHP, MAXMP, ATK, DEF, MAT, MDF, AGI, or LUK.
    # Replace x with the stat multiplier to affect damage dealt.
    #----------------------------------------------------------------------
    when /(.*)[ ]SLIP HEAL[ ](\d+)([%％])/i
      case $1.upcase
      when "MAXHP"; dmg = state_origin.mhp
      when "MAXMP"; dmg = state_origin.mmp
      when "ATK";   dmg = state_origin.atk
      when "DEF";   dmg = state_origin.def
      when "MAT";   dmg = state_origin.mat
      when "MDF";   dmg = state_origin.mdf
      when "AGI";   dmg = state_origin.agi
      when "LUK";   dmg = state_origin.luk
      else; return
      end
      dmg = (dmg * $2.to_i * 0.01).to_i
      if $imported["YEA-BattleEngine"] && dmg > 0
        text = sprintf(YEA::BATTLE::POPUP_SETTINGS[:hp_heal], dmg.group)
        user.create_popup(text, "HP_HEAL")
      end
      user.perform_damage_effect
      user.hp += dmg
      
    #----------------------------------------------------------------------
    # Punish Effect No.7: Drain HP
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with shock effect. Whenever user takes HP damage, the
    # original caster of the state will heal HP based on HP damage dealt.
    # 
    # Recommended notetag:
    #   <shock effect: drain hp x%>
    #----------------------------------------------------------------------
    when /DRAIN HP[ ](\d+)([%％])/i
      return unless @result.hp_damage > 0
      dmg = (@result.hp_damage * $1.to_i * 0.01).to_i
      if $imported["YEA-BattleEngine"] && dmg > 0
        Sound.play_recovery
        text = sprintf(YEA::BATTLE::POPUP_SETTINGS[:hp_heal], dmg.group)
        user.create_popup(text, "HP_HEAL")
      end
      state_origin.hp += dmg
      
    #----------------------------------------------------------------------
    # Punish Effect No.8: Drain MP
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with shock effect. Whenever user takes MP damage, the
    # original caster of the state will heal MP based on MP damage dealt.
    # 
    # Recommended notetag:
    #   <shock effect: drain mp x%>
    #----------------------------------------------------------------------
    when /DRAIN MP[ ](\d+)([%％])/i
      return unless @result.mp_damage > 0
      dmg = (@result.mp_damage * $1.to_i * 0.01).to_i
      if $imported["YEA-BattleEngine"] && dmg > 0
        Sound.play_recovery
        text = sprintf(YEA::BATTLE::POPUP_SETTINGS[:mp_heal], dmg.group)
        user.create_popup(text, "MP_HEAL")
      end
      state_origin.mp += dmg
    #----------------------------------------------------------------------
    #tag: state
    #======================================================================
    # ● Bleed
    #======================================================================
    when /BLEED/i
        
    #----------------------------------------------------------------------
    # Stop editting past this point.
    #----------------------------------------------------------------------
    else
      so = state_origin
      lw = log_window
      lunatic_state_extension_lsp1(effect, state, user, so, lw,attacker)
    end
  end
  
end # Game_BattlerBase
end # $imported["YEA-LunaticStates"]
#==============================================================================
# 
# ▼ End of LSP
# 
#==============================================================================

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Lunatic States Package - Protection v1.00
# -- Last Updated: 2011.12.17
# -- Level: Lunatic
# -- Requires: YEA - Lunatic States v1.00+
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-LSP-Protection"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2011.12.17 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This is a script for Lunatic States Package Effects with protection themed
# effects. These effects reduce damage based on various situations and
# conditions, but they overall protect the user.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# Install this script under YEA - Lunatic States. Then, proceed to use the
# proper effects notetags to apply the proper LSP Protection item desired.
# Look within the script for more instructions on how to use each effect.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
# This script requires YEA - Lunatic States v1.00+ to work. It must be placed
# under YEA - Lunatic States v1.00+ in the script listing.
# 
#==============================================================================
if $imported["YEA-LunaticStates"]
class Game_BattlerBase
  #--------------------------------------------------------------------------
  # ● Lunatic States Package Effects - Protection
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  # These effects are centered around the theme of protection through mostly
  # damage reduction effects.
  #--------------------------------------------------------------------------
  alias lunatic_state_extension_lsp2 lunatic_state_extension
  def lunatic_state_extension(effect, state, user, state_origin, log_window, attacker = nil)
    case effect.upcase
    #----------------------------------------------------------------------
    # Protection Effect No.1: Damage Cut
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with react effect. This causes any HP damage under the
    # marked MaxHP percentage to be nullified.
    # 
    # Recommended notetag:
    #   <react effect: damage cut x%>
    #----------------------------------------------------------------------
    when /DAMAGE CUT[ ](\d+)([%％])/i
      return unless @result.hp_damage > 0
      return unless self.mhp * $1.to_i * 0.01 >= @result.hp_damage
      @result.hp_damage = 0
      return unless $imported["YEA-BattleEngine"]
      create_popup(state.name, "IMMU_ELE")
      
    #----------------------------------------------------------------------
    # Protection Effect No.2: Damage Barrier
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with react effect. This causes any HP damage over the
    # marked MaxHP percentage to be nullified.
    # 
    # Recommended notetag:
    #   <react effect: damage barrier x%>
    #----------------------------------------------------------------------
    when /DAMAGE BARRIER[ ](\d+)([%％])/i
      return unless @result.hp_damage > 0
      return unless self.mhp * $1.to_i * 0.01 <= @result.hp_damage
      @result.hp_damage = 0
      return unless $imported["YEA-BattleEngine"]
      create_popup(state.name, "IMMU_ELE")
      
    #----------------------------------------------------------------------
    # Protection Effect No.3: Damage Shelter
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with react effect. This causes any HP damage over the
    # marked MaxHP percentage to be capped at the marked MaxHP percentage.
    # 
    # Recommended notetag:
    #   <react effect: damage shelter x%>
    #----------------------------------------------------------------------
    when /DAMAGE SHELTER[ ](\d+)([%％])/i
      return unless @result.hp_damage > 0
      return unless self.mhp * $1.to_i * 0.01 <= @result.hp_damage
      @result.hp_damage = (self.mhp * $1.to_i * 0.01).to_i
      return unless $imported["YEA-BattleEngine"]
      create_popup(state.name, "REST_ELE")
      
    #----------------------------------------------------------------------
    # Protection Effect No.4: Damage Block
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with react effect. This causes any HP damage to decrease
    # (or increase if you use the + tag) by a set amount. Decreased damage
    # will not go under zero.
    # 
    # Recommended notetag:
    #   <react effect: damage block -x>
    #   <react effect: damage block +x>
    #----------------------------------------------------------------------
    when /DAMAGE BLOCK[ ]([\+\-]\d+)/i
      return unless @result.hp_damage > 0
      @result.hp_damage = [@result.hp_damage + $1.to_i, 0].max
      
    #----------------------------------------------------------------------
    # Protection Effect No.5: Heal Boost
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with react effect. This causes any HP healing done to be
    # increased (or decreased) by a multiplier.
    # 
    # Recommended notetag:
    #   <react effect: heal boost x%>
    #----------------------------------------------------------------------
    when /HEAL BOOST[ ](\d+)([%％])/i
      return unless @result.hp_damage < 0
      @result.hp_damage = (@result.hp_damage * $1.to_i * 0.01).to_i
      
    #----------------------------------------------------------------------
    # Protection Effect No.6: Heal Bonus
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with react effect. This causes any HP healing done to be
    # increased (or decreased) by a set amount. Healing done cannot be
    # changed to damage.
    # 
    # Recommended notetag:
    #   <react effect: heal bonus +x>
    #   <react effect: heal bonus -x>
    #----------------------------------------------------------------------
    when /HEAL BONUS[ ]([\+\-]\d+)/i
      return unless @result.hp_damage < 0
      @result.hp_damage = [@result.hp_damage - $1.to_i, 0].min
      
    #----------------------------------------------------------------------
    # Protection Effect No.7: Persist
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # Best used with remove effect. If the user receives damage that would
    # be lethal, there is a chance that the user will persist and live at
    # 1 HP left. 
    # 
    # Recommended notetag:
    #   <react effect: persist x%>
    #----------------------------------------------------------------------
    when /PERSIST[ ](\d+)([%％])/i
      return unless @result.hp_damage >= self.hp
      return if rand > $1.to_i * 0.01
      @result.hp_damage = self.hp - 1
      return unless $imported["YEA-BattleEngine"]
      create_popup(state.name, "WEAK_ELE")
    #----------------------------------------------------------------------
    # tag: state
    #======================================================================
    # ● Rage
    #======================================================================
    when /RageApply/i
      cclass = get_class(:babarian)
      level  = cclass ? cclass.level : @level
      value  = DND::SkillModify.RageTHAC0(level)
      @attack_bonus_pool << [state.id, value]
    when /RageRemove/i
      @attack_bonus_pool.delete(state.id)
    #----------------------------------------------------------------------
    # Stop editting past this point.
    #----------------------------------------------------------------------
    else
      so = state_origin
      lw = log_window
      lunatic_state_extension_lsp2(effect, state, user, so, lw,attacker)
    end
  end
  
end # Game_BattlerBase
end # $imported["YEA-LunaticStates"]
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

# =============================================================================
# Seperated from:
# Theolized Sideview Battle System (TSBS)
# Version : 1.4ob1 (Open Beta)
# Language : English
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Contact :
#------------------------------------------------------------------------------
# *> http://www.rpgmakerid.com
# *> http://www.rpgmakervxace.net
# *> http://theolized.blogspot.com
# =============================================================================
# Last updated : 2014.10.28
# -----------------------------------------------------------------------------
# Requires : Theo - Basic Modules v1.5b
# >> Basic Functions 
# >> Movement
# >> Core Result
# >> Core Fade
# >> Clone Image
# >> Rotate Image
# >> Smooth Movement
# -----------------------------------------------------------------------------
# This section is mainly aimed for scripters. There's nothing to do unless
# you know what you're doing. I told ya. It's for your own good 
# =============================================================================
#==============================================================================
# ** Game_Battler
#------------------------------------------------------------------------------
#  A battler class with methods for sprites and actions added. This class 
# is used as a super class of the Game_Actor class and Game_Enemy class.
#==============================================================================
class Game_Battler < Game_BattlerBase
  # --------------------------------------------------------------------------
  # Basic modules
  # --------------------------------------------------------------------------
  include THEO::Movement  # Import basic module for battler movements
  include TSBS            # Import constantas
  include Smooth_Slide    # Import smooth sliding module
  include Theo::Rotation  # Import rotation function
  # --------------------------------------------------------------------------
  # New public attributes
  # --------------------------------------------------------------------------
  attr_accessor :animation_array    # Store animation sequence
  attr_accessor :battler_index      # Store battler filename index
  attr_accessor :anim_index         # Pointer for animation array
  attr_accessor :anim_cell          # Battler image index
  attr_accessor :item_in_use        # Currently used item
  attr_accessor :visible            # Visible flag
  attr_accessor :flip               # Mirror flag
  attr_accessor :area_flag          # Area damage flag
  attr_accessor :afterimage         # Afterimage flag
  attr_accessor :refresh_opacity    # Refresh opacity flag
  attr_accessor :icon_key           # Store icon key
  attr_accessor :lock_z             # Lock Z flag
  attr_accessor :balloon_id         # Balloon ID for battler
  attr_accessor :anim_guard         # Anim Guard ID
  attr_accessor :anim_guard_mirror  # Mirror Flag
  attr_accessor :afopac             # Afterimage opacity fade speed
  attr_accessor :afrate             # Afterimage show rate
  attr_accessor :forced_act         # Force action
  attr_accessor :force_hit          # Force always hit flag
  # --------- Update V1.4 --------- #
  attr_accessor :force_evade        # Force evade flag
  attr_accessor :force_reflect      # Force reflect
  attr_accessor :force_counter      # Force counter
  attr_accessor :force_critical     # Force critical hit
  attr_accessor :force_miss         # Force miss
  attr_accessor :balloon_speed      # Balloon speed
  attr_accessor :balloon_wait       # Balloon wait
  attr_accessor :cover_battler      # Substitue / cover battler
  attr_accessor :covering           # Covering flag
  attr_accessor :angle              # Angle rotation
  attr_accessor :immortal           # Immortal flag
  attr_accessor :break_action       # Break action
  #=====================================================================
  #
  # tag: customed
  # New public attributes (access only)
  #
  #=====================================================================
  attr_reader :target         # Current target
  attr_accessor :last_target
  attr_reader :target_array   # Overall target
  attr_reader :battle_phase   # Battle Phase
  attr_reader :blend          # Blend
  attr_reader :shadow_point   # Shadow Point
  attr_reader :acts           # Used action
  attr_reader :user           # self
  #--------------------------------------------------------------------------
  attr_reader :sequence_index
  attr_reader :action_sequence
  attr_reader :move_obj, :fiber
  # --------------------------------------------------------------------------
  # Alias method : initialize
  # --------------------------------------------------------------------------
  alias theo_tsbs_batt_init initialize
  def initialize(*args)
    @sequence_index = 0
    @fiber = nil
    @user = self
    @shadow_point = Screen_Point.new
    theo_tsbs_batt_init(*args)
    set_obj(self)
    clear_tsbs
  end
  # --------------------------------------------------------------------------
  # New method : Icon File
  # --------------------------------------------------------------------------
  def icon_file(index = 0)
    return @icon_file unless @icon_file.empty?
    return weapons[index].icon_file if weapons[index]
    return ''
  end
  # --------------------------------------------------------------------------
  # New method : Default Flip
  # --------------------------------------------------------------------------
  def default_flip
    return false
  end
  # --------------------------------------------------------------------------
  # New method : Custom Flip
  # --------------------------------------------------------------------------
  def custom_flip?
    return data_battler.custom_flip?
  end
  # --------------------------------------------------------------------------
  # New method : Final Flip result
  # --------------------------------------------------------------------------
  def battler_flip
    (custom_flip? ? false : @flip)
  end
  # --------------------------------------------------------------------------
  # New method : finish
  # --------------------------------------------------------------------------
  def finish
    @finish || @break_sequence
  end
  # --------------------------------------------------------------------------
  # New method : sprite
  # --------------------------------------------------------------------------
  unless method_defined?(:sprite)
  def sprite
    SceneManager.spriteset.battler_sprite_table[hashid]
  end
  end
  # --------------------------------------------------------------------------
  # New method : Reset to original position
  # --------------------------------------------------------------------------
  def reset_pos(dur = 30, jump = 0)
    goto(@ori_x, @ori_y, dur, jump)
  end
  # --------------------------------------------------------------------------
  # New method : Relative X position from center (used for camera)
  # --------------------------------------------------------------------------
  def rel_x
    return x - Graphics.width/2
  end
  # --------------------------------------------------------------------------
  # New method: Relative Y position from center (used for camera)
  # --------------------------------------------------------------------------
  def rel_y
    return y - Graphics.height/2
  end
  # --------------------------------------------------------------------------
  # New method: Distance between the shadow and the battler
  # --------------------------------------------------------------------------
  def height
    return @shadow_point.y - self.y
  end
  # --------------------------------------------------------------------------
  # New method : Clear TSBS infos
  # --------------------------------------------------------------------------
  def clear_tsbs
    @animation_array = []
    @finish = false
    @anim_index = 0
    @anim_cell = 0
    @battler_index = 1
    @battle_phase = nil
    @target = nil
    @ori_target = nil # Store original target. Do not change!
    @target_array = []
    @ori_targets = [] # Store original target array. Do not change!
    @item_in_use = nil  
    @visible = true
    @flip = default_flip
    @area_flag = false
    @afterimage = false
    @proj_icon = 0
    @refresh_opacity = false
    @lock_z = false
    @icon_key = ""
    @acts = []
    @blend = 0
    @used_sequence = "" # Record the used  for error handling
    @sequence_stack = []  # Used sequence stack trace for error handling
    @balloon_id = 0
    @balloon_speed = BALLOON_SPEED
    @balloon_wait = BALLOON_WAIT
    @anim_guard = 0
    @anim_guard_mirror =  false
    @forced_act = ""
    @proj_setup = copy(PROJECTILE_DEFAULT)
    @focus_target = 0
    @covering = false
    @shadow_point.x = @shadow_point.y = 0
    @angle = 0.0
    @immortal = false
    @break_sequence = false
    @autopose = []
    @icon_file = ''
    reset_force_result
    reset_aftinfo
  end
  # --------------------------------------------------------------------------
  # Overwrite method : Goto (basic module)
  # --------------------------------------------------------------------------
  def goto(x, y, dur, jump, height = 0)
    super(x, y, dur, jump)
    height = [height, 0].max
    y = @shadow_point.y if @lock_z
    @shadow_point.goto(x, y + height, dur, 0)
  end
  # --------------------------------------------------------------------------
  # Overwrite method : Slide (basic module)
  # --------------------------------------------------------------------------
  def slide(x, y, dur, jump, height = 0)
    slide_x = self.x + x
    slide_y = self.y + y
    goto(slide_x, slide_y, dur, jump, height) unless moving?
  end
  #---------------------------------------------------------------------------
  # Overwrite method : Smooth move (basic module)
  #---------------------------------------------------------------------------
  def smooth_move(x, y, dur, reverse = false)
    super(x,y,dur,reverse)
    @shadow_point.smooth_move(x,y,dur,reverse)
  end
  # --------------------------------------------------------------------------
  # New method : Battler update
  # --------------------------------------------------------------------------
  def update
    update_move           # Update movements (Basic Modules)
    update_smove          # Update smooth movement (Basic Modules)
    update_rotation       # Update rotation
    @shadow_point.update_move
    update_sequence
  end
  #--------------------------------------------------------------------------
  def update_shadow_point
    return unless @shadow_point
    @shadow_point.x = x
    @shadow_point.y = y
  end
  #--------------------------------------------------------------------------
  def update_sequence
    @fiber.resume if @fiber
  end
  #--------------------------------------------------------------------------
  def clear_sequence
    @fiber = nil
    @sequence_index = 0
    @proj_setup = []
    @action_sequence = nil
    @break_sequence = true
    @map_char.finalize_acting if @map_char
  end
  #--------------------------------------------------------------------------
  def setup_action_sequence(sequence)
    @action_sequence = sequence
    @sequence_index = 0
    @break_sequence = false
    @fiber = Fiber.new{execute_sequence}
  end
  #--------------------------------------------------------------------------
  def current_act
    @acts
  end
  #--------------------------------------------------------------------------
  def execute_sequence
    # defined in later script
  end
  #--------------------------------------------------------------------------
  def save_fiber
    @fiber_saved = !@fiber.nil?
    @fiber = nil
  end
  #--------------------------------------------------------------------------
  def restore_fiber
    return unless @fiber_saved
    @fiber = Fiber.new{execute_sequence}
    @fiber_saved = false
  end
  # --------------------------------------------------------------------------
  # New method : Refers to battler database
  # --------------------------------------------------------------------------
  def data_battler
    return nil
  end
  # --------------------------------------------------------------------------
  # New method : Determine if battler is in critical condition
  # --------------------------------------------------------------------------
  def critical?
    hp_rate <= Critical_Rate
  end
  # --------------------------------------------------------------------------
  # New method : Idle sequence key
  # --------------------------------------------------------------------------
  # Idle key sequence contains several sequence keys. Include dead sequence,
  # state sequence, critical sequence,and normal sequence. Dead key sequence
  # has the top priority over others. Just look at the below
  # --------------------------------------------------------------------------
  def idle_key
    return data_battler.dead_key if !@immortal && dead? && actor?    
    return state_sequence if state_sequence
    return data_battler.critical_key if critical? && 
      !data_battler.critical_key.empty?
    return data_battler.idle_key
  end
  # --------------------------------------------------------------------------
  # New method : Skill sequence key
  # Must be called when item_in_use isn't nil
  # --------------------------------------------------------------------------
  def skill_key
    return item_in_use.seq_key[rand(item_in_use.seq_key.size)]
  end
  # --------------------------------------------------------------------------
  # New method : Return sequence key
  # Must be called when item_in_use isn't nil
  # --------------------------------------------------------------------------
  def return_key
    return "Knock_Back" if item_in_use.nil?
    return item_in_use.return_key if !item_in_use.return_key.empty?
    return data_battler.return_key
  end
  # --------------------------------------------------------------------------
  # New method : Preparation key
  # Must be called when item_in_use isn't nil
  # --------------------------------------------------------------------------
  def prepare_key
    return item_in_use.prepare_key
  end
  # --------------------------------------------------------------------------
  # Miscellaneous keys
  # --------------------------------------------------------------------------
  def escape_key;   data_battler.escape_key;    end
  def victory_key;  data_battler.victory_key;   end
  def hurt_key;     data_battler.hurt_key;      end
  def evade_key;    data_battler.evade_key;     end
  def intro_key;    data_battler.intro_key;     end
  def counter_key;  data_battler.counter_key;   end
  def collapse_key; data_battler.collapse_key;  end
  def covered_key;  evade_key;                  end
  def aim_target_key;  aim_target_key;          end
  # --------------------------------------------------------------------------
  # New method : Start
  # --------------------------------------------------------------------------
  def tsbs_battler_start
    reset_force_result
    reset_aftinfo
    @proj_setup = copy(PROJECTILE_DEFAULT)
    @focus_target = 0
    @autopose = []
    @icon_file = ''
    @ignore_flip_point = false
  end
  # --------------------------------------------------------------------------
  # New method : Reset force result
  # --------------------------------------------------------------------------
  def reset_force_result
    @force_hit = false
    @force_evade = false
    @force_reflect = false
    @force_counter = false
    @force_critical = false
    @force_miss = false
  end
  # --------------------------------------------------------------------------
  # New method : Reset afterimage info
  # --------------------------------------------------------------------------
  def reset_aftinfo
    @afopac = AFTIMG_OPACITY_EASE
    @afrate = AFTIMG_IMAGE_RATE
  end  
  #--------------------------------------------------------------------------
end
#==============================================================================
# ** Game_Map
#------------------------------------------------------------------------------
#  This class handles maps. It includes scrolling and passage determination
# functions. The instance of this class is referenced by $game_map.
#==============================================================================
class Game_Map
  #--------------------------------------------------------------------------
  def save_battler_fibers
    all_battlers.each do |battler|
      battler.save_fiber
    end
    debug_print("Fiber saved")
  end
  #--------------------------------------------------------------------------
  def restore_battler_fibers
    all_battlers.each do |battler|
      battler.restore_fiber
    end
    debug_print("Fiber restored")
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# ** DND::SkillSequence
#------------------------------------------------------------------------------
#  Sequence of action defined of the skill when performed
#==============================================================================
#tag: skill
#tag: sequence
module DND::SkillSequence
  
  ACTS = {
    
    0 => [
            # do nothing
         ],
  
    1 => [
            [:move,  1,  0, 4, 0], [:wait, 4],
            [:move, -1,  1, 4, 0], [:wait, 4],
            [:move, -1, -1, 4, 0], [:wait, 4],
            [:move,  1, -1, 4, 0], [:wait, 4],
            [:move,  0,  1, 4, 0], [:wait, 4],
         ],
         
  }
end

#==============================================================================
# ** State & Skill Effects
#------------------------------------------------------------------------------
#  Code eval for skill and states
#==============================================================================
# Special Thanks: TheoAllen
# Basic template of this script is form his TSBS scripts, aka
# Theolized Sideview Battle System
#==============================================================================
# ** Game_Battler
#------------------------------------------------------------------------------
#  A battler class with methods for sprites and actions added. This class 
# is used as a super class of the Game_Actor class and Game_Enemy class.
#==============================================================================
#tag: state
class Game_Battler < Game_BattlerBase
  #--------------------------------------------------------------------------
  # * Public Instance Variables
  #--------------------------------------------------------------------------
  attr_reader :eval_effects
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  alias init_battler_stat initialize
  def initialize
    @eval_effects          = {}
    @eval_effects[:erase]  = []
    @eval_effects[:timeup] = []
    @eval_effects[:react]  = []
    @eval_effects[:shock]  = []
    @eval_effects[:begin]  = []
    @eval_effects[:while]  = []
    init_battler_stat
  end
  #--------------------------------------------------------------------------
  # * Alias: Processing at End of Turn
  #--------------------------------------------------------------------------
  alias on_turn_end_gb on_turn_end
  def on_turn_end
     @states.each do |id|
       on_state_begin(id)
     end
    on_turn_end_gb
  end
  #--------------------------------------------------------------------------
  # * Occur when state applied, including stacked
  #--------------------------------------------------------------------------
  def on_state_apply(state_id)
    reset_effect_param_cache
  end
  #--------------------------------------------------------------------------
  # * Occur when state removed
  #--------------------------------------------------------------------------
  def on_state_erase(state_id)
    reset_effect_param_cache
  end
  #--------------------------------------------------------------------------
  # * Occur when state timer hits 0
  #--------------------------------------------------------------------------
  def on_state_timeup(state_id)
  end
  #--------------------------------------------------------------------------
  # * Occur before taking damage
  #--------------------------------------------------------------------------
  def on_state_react(state_id, attacker = nil, item = nil, value = 0)
  end
  #--------------------------------------------------------------------------
  # * Occur after taking damage
  #--------------------------------------------------------------------------
  def on_state_shock(state_id, attacker = nil, item = nil, value = 0)
  end
  #--------------------------------------------------------------------------
  # * Occur at begin/end of each turn/second
  #--------------------------------------------------------------------------
  def on_state_begin(state_id)
  end
  #--------------------------------------------------------------------------
  # * Occur when performing action
  #--------------------------------------------------------------------------
  def on_state_while(state_id, item = nil)
  end
  #--------------------------------------------------------------------------
  # * 
  #--------------------------------------------------------------------------
  def reset_effect_param_cache
  end
  
end
#==============================================================================
# ** Game_Battler
#------------------------------------------------------------------------------
#  A battler class with methods for sprites and actions added. This class 
# is used as a super class of the Game_Actor class and Game_Enemy class.
#==============================================================================
class Game_Battler < Game_BattlerBase
  # tag: last work: skill sequence
  #--------------------------------------------------------------------------
  def current_action_targets
    return unless @map_char
    return @map_char.current_action.subject
  end
  #--------------------------------------------------------------------------
  def execute_sequence
    puts "#{name}: execute sequence"
    while @sequence_index < @action_sequence.size
      puts "Update sequence: #{@sequence_index}"
      @acts = @action_sequence[@sequence_index]
      execute_act
      @sequence_index += 1
      #Fiber.yield # consider uncomment this line
    end
    clear_sequence
  end
  #--------------------------------------------------------------------------
  def execute_act
    case @acts[0]
    when SEQUENCE_POSE;               setup_pose
    when SEQUENCE_MOVE;               setup_move
    when SEQUENCE_SLIDE;              setup_slide
    when SEQUENCE_RESET;              setup_reset
    when SEQUENCE_MOVE_TO_TARGET;     setup_move_to_target
    when SEQUENCE_SCRIPT;             setup_eval_script
    when SEQUENCE_WAIT;               @acts[1].times { method_wait }
    when SEQUENCE_DAMAGE;             setup_damage
    when SEQUENCE_CAST;               setup_cast
    when SEQUENCE_VISIBLE;            @visible = @acts[1]
    when SEQUENCE_SHOW_ANIMATION;     setup_anim
    when SEQUENCE_AFTERIMAGE;         @afterimage = @acts[1]
    when SEQUENCE_FLIP;               setup_flip
    when SEQUENCE_ACTION;             setup_action
    when SEQUENCE_PROJECTILE_SETUP;   setup_projectile
    when SEQUENCE_PROJECTILE;         show_projectile
    when SEQUENCE_LOCK_Z;             @lock_z = @acts[1]
    when SEQUENCE_ICON;               setup_icon
    when SEQUENCE_SOUND;              setup_sound
    when SEQUENCE_IF;                 setup_branch
    when SEQUENCE_TIMED_HIT;          setup_timed_hit
    when SEQUENCE_SCREEN;             setup_screen
    when SEQUENCE_ADD_STATE;          setup_add_state
    when SEQUENCE_REM_STATE;          setup_rem_state  
    when SEQUENCE_CHANGE_TARGET;      setup_change_target
    when SEQUENCE_TARGET_MOVE;        setup_target_move
    when SEQUENCE_TARGET_SLIDE;       setup_target_slide
    when SEQUENCE_TARGET_RESET;       setup_target_reset
    when SEQUENCE_BLEND;              @blend = @acts[1]
    when SEQUENCE_FOCUS;              setup_focus
    when SEQUENCE_UNFOCUS;            setup_unfocus
    when SEQUENCE_TARGET_LOCK_Z;      setup_target_z
    #-----
    when SEQUENCE_ANIMTOP;            setup_anim_top
    when SEQUENCE_FREEZE;             #$game_temp.global_freeze = @acts[1]
    when SEQUENCE_CSTART;             setup_cutin
    when SEQUENCE_CFADE;              setup_cutin_fade
    when SEQUENCE_CMOVE;              setup_cutin_slide
    when SEQUENCE_TARGET_FLIP;        setup_targets_flip
    when SEQUENCE_PLANE_ADD;          setup_add_plane
    when SEQUENCE_PLANE_DEL;          setup_del_plane
    when SEQUENCE_BOOMERANG;          @proj_setup[PROJ_BOOMERANG] = true
    when SEQUENCE_PROJ_AFTERIMAGE;    @proj_setup[PROJ_AFTERIMAGE] = true
    when SEQUENCE_BALLOON;            setup_balloon_icon
    #-----
    when SEQUENCE_LOGWINDOW;          setup_log_message
    when SEQUENCE_LOGCLEAR;           get_scene.log_window.clear
    when SEQUENCE_AFTINFO;            setup_aftinfo
    when SEQUENCE_SMMOVE;             setup_smooth_move
    when SEQUENCE_SMSLIDE;            setup_smooth_slide
    when SEQUENCE_SMTARGET;           setup_smooth_move_target
    when SEQUENCE_SMRETURN;           setup_smooth_return
    #-----
    when SEQUENCE_LOOP;               setup_loop
    when SEQUENCE_WHILE;              setup_while
    when SEQUENCE_COLLAPSE;           tsbs_perform_collapse_effect
    when SEQUENCE_FORCED;             setup_force_act
    when SEQUENCE_ANIMBOTTOM;         setup_anim_bottom
    when SEQUENCE_CASE;               setup_switch_case
    when SEQUENCE_INSTANT_RESET;      setup_instant_reset
    when SEQUENCE_ANIMFOLLOW;         setup_anim_follow
    when SEQUENCE_CHANGE_SKILL;       setup_change_skill
    when SEQUENCE_CHECKCOLLAPSE;      setup_check_collapse
    when SEQUENCE_RESETCOUNTER;       get_scene.damage.reset_value
    when SEQUENCE_FORCEHIT;           @force_hit = default_true
    when SEQUENCE_SLOWMOTION;         setup_slow_motion
    when SEQUENCE_TIMESTOP;           setup_timestop
    when SEQUENCE_ONEANIM;            $game_temp.one_animation_flag = true
    when SEQUENCE_PROJ_SCALE;         setup_proj_scale
    when SEQUENCE_COMMON_EVENT;       setup_common_event
    when SEQUENCE_GRAPHICS_FREEZE;    Graphics.freeze
    when SEQUENCE_GRAPHICS_TRANS;     setup_transition
    #-----
    when SEQUENCE_FORCEDODGE;         @force_evade = default_true
    when SEQUENCE_FORCEREFLECT;       @force_reflect = default_true
    when SEQUENCE_FORCECOUNTER;       @force_counter = default_true
    when SEQUENCE_FORCECRITICAL;      @force_critical = default_true
    when SEQUENCE_FORCEMISS;          @force_miss = default_true
    when SEQUENCE_BACKDROP;           setup_backdrop
    when SEQUENCE_BACKTRANS;          setup_backdrop_transition
    when SEQUENCE_REVERT_BACKDROP;    $game_temp.backdrop.revert;Fiber.yield
    when SEQUENCE_TARGET_FOCUS;       @focus_target = @acts[1]
    when SEQUENCE_SCREEN_FADEOUT;     setup_screen_fadeout
    when SEQUENCE_SCREEN_FADEIN;      setup_screen_fadein
    when SEQUENCE_CHECK_COVER;        setup_check_cover
    when SEQUENCE_STOP_MOVEMENT;      stop_all_movements
    when SEQUENCE_ROTATION;           setup_rotation
    when SEQUENCE_FADEIN;             setup_fadein
    when SEQUENCE_FADEOUT;            setup_fadeout
    when SEQUENCE_IMMORTALING;        setup_immortaling
    when SEQUENCE_END_ACTION;         setup_end_action
    when SEQUENCE_SHADOW_VISIBLE;     $game_temp.shadow_visible = default_true
    when SEQUENCE_AUTOPOSE;           setup_autopose
    when SEQUENCE_ICONFILE;           @icon_file = @acts[1] || ''
    when SEQUENCE_IGNOREFLIP;         @ignore_flip_point = default_true
    when SEQUENCE_SAVE_POSITION;      setup_save_position
    when SEQUENCE_RESTORE_POSITION;   setup_restore_position
    else
      # reserved
    end
  end
  #---------------------------------------------------------------------------
  def default_true
    return (@acts[1] || true)
  end
  #---------------------------------------------------------------------------
  def target_valid?(ta = current_target)
    return ta && ta.valid_battler? && ta.alive?
  end
  #---------------------------------------------------------------------------
  # * New method : Method for wait [:wait,]
  #---------------------------------------------------------------------------
  def method_wait
    puts "method wait"
    Fiber.yield
    @anim_cell = @autopose.shift unless @autopose.empty?
  end
  #---------------------------------------------------------------------------
  # New method : Setup pose [:pose,]
  #---------------------------------------------------------------------------
  def setup_pose
    return unless PONY::ERRNO.check_sequence(current_act)
    @battler_index = @acts[1]
    @anim_cell     = @acts[2]
    if @anim_cell.is_a?(Array)
      row = (@anim_cell[0] - 1) * MaxRow
      col = @anim_cell[1] - 1
      @anim_cell = row + col
    end
    @icon_key = @acts[4] if @acts[4]  # Icon call
    @icon_key = @acts[5] if @acts[5] && flip  # Icon call
  end
  #---------------------------------------------------------------------------
  # New method : Save current position [:save_pos, speed]
  # speed: the move speed in restoring
  #---------------------------------------------------------------------------
  def setup_save_position(_speed = 0)
    @saved_position = [@map_char.real_x, @map_char.real_y, _speed]
  end
  #---------------------------------------------------------------------------
  # New method : Setup movement [:restore_pos, :method]
  # method: movement method
  #---------------------------------------------------------------------------
  def setup_restore_position
    if !@saved_position
      debug_print("Warning: #{self} has no saved position but restore called")
      return
    end
    nx, ny = @saved_position[0], @saved_position[1]
    @acts.shift
    @acts[1] = :move if @acts[1].nil?
    @acts[2] = @saved_position[0]
    @acts[3] = @saved_position[1]
    @acts[4] = @saved_position[2]
    execute_act
    @saved_position = nil
  end
  #---------------------------------------------------------------------------
  # New method : Setup movement [:move,]
  #---------------------------------------------------------------------------
  def setup_move
    return unless PONY::ERRNO.check_sequence(current_act)
    stop_all_movements
    mx = @map_char.real_x + @acts[1]
    my = @map_char.real_y + @acts[2]
    goto(mx, my, @acts[3], @acts[4], @acts[5] || 0)
  end
  #--------------------------------------------------------------------------
  # New method : Setup slide [:slide,]
  #--------------------------------------------------------------------------
  def setup_slide
    return unless PONY::ERRNO.check_sequence(current_act)
    stop_all_movements
    xpos = (flip && !@ignore_flip_point ? -@acts[1] : @acts[1])
    ypos = @acts[2]
    slide(xpos, ypos, @acts[3], @acts[4], @acts[5] || 0)
    @acts[4].times do
      method_wait
    end
  end
  #--------------------------------------------------------------------------
  # New method : Setup reset [:goto_oripost,]
  #--------------------------------------------------------------------------
  def setup_reset
    stop_all_movements
    goto(@ori_x, @ori_y, @acts[1], @acts[2])
  end
  #--------------------------------------------------------------------------
  # New method : Setup move to target [:move_to_target,]
  #--------------------------------------------------------------------------
  def setup_move_to_target
    return unless PONY::ERRNO.check_sequence(current_act)
    stop_all_movements
    xpos = target.x + (flip ? -@acts[1] : @acts[1])
    ypos = target.y + @acts[2]
    goto(xpos, ypos, @acts[3], @acts[4], @acts[5] || 0)
  end
  #--------------------------------------------------------------------------
  # New method : Setup eval script [:script,]
  #--------------------------------------------------------------------------
  def setup_eval_script
    begin
      eval(@acts[1])
    rescue StandardError => err
      PONY::ERRNO.sequence_error(:eval, err)
    end
  end
  #--------------------------------------------------------------------------
  # New method : Setup damage [:target_damage,]
  #--------------------------------------------------------------------------
  def setup_damage
    return unless PONY::ERRNO::check_sequence(current_act)
    target = current_action_targets
    item = @acts[1].is_a?(Numeric) ? $data_skills[@acts[1]] : @acts[1]
    temp_action = Game_Action.new(self, target, item)
    temp_aciton.reassign_item(temp_action.get_symbol_item)
    return if item.nil? || item.is_a?(Symbol)
    BattleManager.invoke_action(temp_action)
  end
  #--------------------------------------------------------------------------
  # New method : Setup cast [:cast,]
  #--------------------------------------------------------------------------
  def setup_cast
    return unless PONY::ERRNO::check_sequence(current_act)
    @map_char.start_animation(@acts[1])
  end
  # --------------------------------------------------------------------------
  # New method : Setup animation [:show_anim,]
  # --------------------------------------------------------------------------
  def setup_anim
    return unless PONY::ERRNO::check_sequence(current_act)
    anid = @acts[1]
    
    if @acts[2]
      if target_valid?
        current_target.map_char.start_animation(anid)
      else
        @map_char.start_animation(anid)
      end
    else
      current_action_targets.each do |target|
        next unless target_valid?(target)
        target.map_char.start_animation(anid)
      end
    end
  end
  #--------------------------------------------------------------------------
  # New method : Setup battler flip [:flip,]
  # -------------------------------------------------------------------------
  def setup_flip
    return unless PONY::ERRNO::check_sequence(current_act)
    if @acts[1] == :toggle
      @flip = !@flip 
    elsif @acts[1] == :ori
      @flip = default_flip
    else
      @flip = @acts[1]
    end
  end
  #--------------------------------------------------------------------------
  # New method : Setup actions [:action,]
  # -------------------------------------------------------------------------
  def setup_action
    return unless PONY::ERRNO::check_sequence(current_act)
    new_sequence = @action_sequence[@sequence_index+1...@action_sequence.size]
    @sequence_index = 0
    new_sequence = DND::SkillSequence::ACTS[@acts[1]] + new_sequence
    execute_sequence
  end
  # --------------------------------------------------------------------------
  # New method : Setup projectile [:proj_setup,]
  # --------------------------------------------------------------------------
  def setup_projectile
    return unless PONY::ERRNO::check_sequence(current_act)
    skill_id = @acts[1]
    source   = @acts[2]
    target   = @acts[3]
    Game_Action.new(source, target, $data_skills[skill_id])
  end
  #--------------------------------------------------------------------------
  # New method : Setup weapon icon [:icon,]
  # -------------------------------------------------------------------------
  def setup_icon
    return unless PONY::ERRNO::check_sequence(current_act)
    @icon_key = @acts[1]
    @icon_key = @acts[2] if @acts[2] && flip
  end
  #--------------------------------------------------------------------------
  # New method : Setup sound [:sound,]
  #--------------------------------------------------------------------------
  def setup_sound
    return unless PONY::ERRNO::check_sequence(current_act)
    name  = @acts[1]
    vol   = @acts[2] || 100
    pitch = @acts[3] || 100
    RPG::SE.new(name,vol,pitch).play
  end
  #--------------------------------------------------------------------------
  # New method : Setup conditional branch [:if,]
  # -------------------------------------------------------------------------
  def setup_branch
    return unless PONY::ERRNO::check_sequence(current_act)
    act_true = @acts[2]
    act_false = @acts[3]
    bool = false
    
    begin # Test the script call condition
      bool = eval(@acts[1])
    rescue StandardError => err
      PONY::ERRNO.sequence_error(:eval, err)
    end
    act_result = (bool ? act_true : (!act_false.nil? ? act_false: nil))
    if act_result
      is_array = act_result.is_a?(Array)
      if is_array && act_result[0].is_a?(Array)
        act_result.each do |action|
          next unless action.is_a?(Array)
          @acts = action
          execute_act
        end
      elsif is_array
        @acts = act_result
        execute_act
      else
        @acts = [:action, act_result]
        execute_act
      end
    end
    
  end
  #--------------------------------------------------------------------------
  # New method [:timed_hit,]
  #--------------------------------------------------------------------------
  def setup_timed_hit
    return unless PONY::ERRNO::check_sequence(current_act)
    # perhaps not needed
  end
  #--------------------------------------------------------------------------
  # New method [:setup_screen,]
  #--------------------------------------------------------------------------
  def setup_screen
    return unless PONY::ERRNO::check_sequence(current_act)
    screen = $game_map.screen
    argse = @acts.size - 1
    case @acts[1]
    when Screen_Tone
      return PONY::ERRNO.sequence_error(:args, "Screen_Tone", 3, argse) if @acts.size < 4
      tone = @acts[2]
      duration = @acts[3]
      screen.start_tone_change(tone, duration)
    when Screen_Shake
      return PONY::ERRNO.sequence_error(:args, "Screen_Shake", 4, argse) if @acts.size < 5
      power = @acts[2]
      speed = @acts[3]
      duration = @acts[4]
      screen.start_shake(power, speed, duration)
    when Screen_Flash
      return PONY::ERRNO.sequence_error(:args, "Screen_Flash", 3, argse) if @acts.size < 4
      color = @acts[2]
      duration = @acts[3]
      screen.start_flash(color, duration)
    when Screen_Normalize
      return PONY::ERRNO.sequence_error(:args, "Screen_Normalize", 2, argse) if @acts.size < 3
      tone = Tone.new
      duration = @acts[2]
      screen.start_tone_change(tone, duration)
    end
  end
  #--------------------------------------------------------------------------
  # New method Setup add state [:add_state,]
  #--------------------------------------------------------------------------
  def setup_add_state
    return unless PONY::ERRNO::check_sequence(current_act)
    
    current_action_targets.each do |target|
      state_id = @acts[1]
      chance   = @acts[2] || 100
      chance   = chance / 100.0 if c.integer?
      chance  *= target.state_rate(state_id) unless @acts[3]
      target.add_state(state_id, self) if rand < chance
    end
  end
  #--------------------------------------------------------------------------
  # New method Setup remove state [:rem_state,]
  #--------------------------------------------------------------------------
  def setup_rem_state
    return unless PONY::ERRNO::check_sequence(current_act)
    current_action_targets.each do |target|
      state_id = @acts[1]
      chance   = @acts[2] || 100
      chance   = chance / 100.0 if c.integer?
      target.remove_state(state_id)   if rand < chance
    end
  end
  #--------------------------------------------------------------------------
  # New method : Setup change target [:change_target,]
  #--------------------------------------------------------------------------
  def setup_change_target
    return unless PONY::ERRNO::check_sequence(current_act)
    setup_target(@acts[1])
  end
  #--------------------------------------------------------------------------
  # New method : Setup target movement [:target_move,]
  #--------------------------------------------------------------------------
  def setup_target_move
    return unless PONY::ERRNO::check_sequence(current_act)
    args = [@acts[1], @acts[2], @acts[3], @acts[4], @acts[5] || 0]
    current_action_targets.each do |target|
      target.goto(*args)
    end
  end
  #--------------------------------------------------------------------------
  # New method : Setup target slide [:target_slide,]
  #--------------------------------------------------------------------------
  def setup_target_slide
    return unless PONY::ERRNO::check_sequence(current_act)
    args = [@acts[1], @acts[2], @acts[3], @acts[4], @acts[5] || 0]
    current_action_targets.each do |target|
      target.slide(*args)
    end
  end
  #--------------------------------------------------------------------------
  # New method : Setup target reset [:target_reset]
  #--------------------------------------------------------------------------
  def setup_target_reset
    return unless PONY::ERRNO::check_sequence(current_act)
    current_action_targets.each do |target|
      target.reset_pos(@acts[1], @acts[2])
    end
  end
  #--------------------------------------------------------------------------
  # New method : Setup target lock Z [:target_lock_z,]
  #--------------------------------------------------------------------------
  def setup_target_z
    return unless PONY::ERRNO::check_sequence(current_act)
    current_action_targets.each do |target|
      target.lock_z = @acts[1]
    end
  end
  #--------------------------------------------------------------------------
  # New method : Setup anim top [:anim_top]
  #--------------------------------------------------------------------------
  def setup_anim_top
    # not sure if needed
    $game_temp.anim_top = (@acts[1] == true || @acts[1].nil? ? 1 : 0)
  end
  #--------------------------------------------------------------------------
  # New method : Setup anim bottom [:anim_bottom]
  #--------------------------------------------------------------------------
  def setup_anim_bottom
    # not sure if needed
    $game_temp.anim_top = (@acts[1] == true || @acts[1].nil? ? -1 : 0)
  end
  #--------------------------------------------------------------------------
  # New method : Setup anim follow [:anim_follow]
  #--------------------------------------------------------------------------
  def setup_anim_follow
    # not sure if needed
    $game_temp.anim_follow = default_true
  end
  #--------------------------------------------------------------------------
  # New method : Cutin Start [:cutin_start,]
  #--------------------------------------------------------------------------
  def setup_cutin
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_cutin_fade
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_cutin_slide
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  # New method : Setup Targets flip [:target_flip,]
  #--------------------------------------------------------------------------
  def setup_targets_flip
    return unless PONY::ERRNO::check_sequence(current_act)
    current_actions_targets.each do |target|
      target.flip = @acts[1]
    end
  end
  #--------------------------------------------------------------------------
  def setup_add_plane
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_del_plane
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_balloon_icon
    return unless PONY::ERRNO::check_sequence(current_act)
    @balloon_id    = @acts[1]
    @balloon_speed = @acts[2] || BALLOON_SPEED
    @balloon_wait  = @acts[3] || BALLOON_WAIT
  end
  #--------------------------------------------------------------------------
  def setup_log_message
    return unless PONY::ERRNO::check_sequence(current_act)
    SceneManager.display_info(@acts[1])
  end
  #--------------------------------------------------------------------------
  # New method : Setup Afterimage Information [:aft_info,]
  #--------------------------------------------------------------------------
  def setup_aftinfo
    @afrate = @acts[1] || 3
    @afopac = @acts[2] || 20
  end
  #--------------------------------------------------------------------------
  # New method : Smooth Moving [:sm_move,]
  #--------------------------------------------------------------------------
  def setup_smooth_move
    tx = @acts[1] || x
    ty = @acts[2] || y
    dur = @acts[3] || 25
    rev = @acts[4]
    rev = true if rev.nil?
    smooth_move(tx,ty,dur,rev)
  end
  #--------------------------------------------------------------------------
  # New method : Smooth Sliding [:sm_slide,]
  #--------------------------------------------------------------------------
  def setup_smooth_slide
    tx = @acts[1] + x || 0
    ty = @acts[2] + y || 0
    dur = @acts[3] || 25
    rev = @acts[4]
    rev = true if rev.nil?
    smooth_move(tx,ty,dur,rev)
  end
  #--------------------------------------------------------------------------
  # New method : Smooth Move to target [:sm_target,]
  #--------------------------------------------------------------------------
  def setup_smooth_move_target
    targets = current_action_targets
    size = targets.size
    xpos = targets.inject(0){|r, battler| r + battler.map_char.x} / size
    ypos = targets.inject(0){|r, battler| r + battler.map_char.y} / size
    xpos += @acts[1]
    xpos *= -1 if flip && !@ignore_flip_point
    rev = @acts[3].nil? ? true : (@acts[3] || false)
    smooth_move(xpos, ypos + @acts[2], @acts[3])
  end
  #--------------------------------------------------------------------------
  # New method : Smooth return [:sm_return,]
  #--------------------------------------------------------------------------
  def setup_smooth_return
    tx = @ori_x
    ty = @ori_y
    dur = @act[1] || 25
    rev = @acts[2]
    rev = true if rev.nil?
    smooth_move(tx,ty,dur,rev)
  end
  #--------------------------------------------------------------------------
  # New method : Setup loop [:loop,]
  #--------------------------------------------------------------------------
  def setup_loop
    return unless PONY::ERRNO::check_sequence(current_act)
    count      = @acts[1]
    action_key = @acts[2]
    is_string  = action_key.is_a?(String)
    count.times do
      if is_string
        @acts = [:action, action_key]
        execute_sequence
        break if @break_sequence
      else
        begin
          action_key.each do |action|
            @acts = action
            execute_sequence
            break if @break_sequence
          end
        rescue
          ErrorSound.play
          text = "Wrong [:loop] parameter!"
          msgbox text
          exit
        end
      end # if is_string
      break if @break_sequence
    end # count.times
  end
  #--------------------------------------------------------------------------
  # New method : Setup 'while' mode loop [:while]
  #--------------------------------------------------------------------------
  def setup_while
    return unless PONY::ERRNO::check_sequence(current_act)
    cond = @acts[1]
    action_key = @acts[2]
    actions = (action_key.class == String ? TSBS::AnimLoop[action_key] : action_key)
    if actions.nil?
      show_action_error(action_key)
    end
    begin
      while eval(cond)
        exe_act = actions.clone
        until exe_act.empty? || @break_sequence
          @acts = exe_act.shift
          execute_sequence
        end
      end
    rescue StandardError => err
      display_error("[#{SEQUENCE_WHILE},]",err)
    end
  end
  #--------------------------------------------------------------------------
  def setup_force_act
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_switch_case
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  # New method : Setup Instant Reset [:instant_reset,]
  #--------------------------------------------------------------------------
  def setup_instant_reset
    reset_pos(1)  # Reset position
    update_move   # Update move as well
  end
  #--------------------------------------------------------------------------
  def setup_change_skill
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_check_collapse
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  # New method : Setup check collapse [:slow_motion,]
  #-------------------------------------------------------------------------- 
  def setup_slow_motion
    return unless PONY::ERRNO::check_sequence(current_act)
    $game_temp.slowmotion_frame = @acts[1]
    $game_temp.slowmotion_rate  = @acts[2]
  end
  #--------------------------------------------------------------------------
  # New method : Setup timestop [:timestop,]
  #--------------------------------------------------------------------------
  def setup_timestop
    return unless PONY::ERRNO::check_sequence(current_act)
    @acts[1].times { SceneManager.update_basic }
  end
  #--------------------------------------------------------------------------
  def setup_proj_scale
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_common_event
    return unless PONY::ERRNO::check_sequence(current_act)
    unless @acts[1].is_a?(Numeric)
      return raise(TypeError, "Expect Fixnum, Received #{@acts[1].ruby_class}")
    end
    $game_temp.reserve_common_event(@acts[1])
  end
  #--------------------------------------------------------------------------
  def setup_transition
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_backdrop
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_backdrop_transition
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_screen_fadeout
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_screen_fadein
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_check_cover
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_rotation
    return unless PONY::ERRNO::check_sequence(current_act)
    @angle = @acts[1]
    change_angle(@acts[2], @acts[3])
  end
  #--------------------------------------------------------------------------
  def setup_fadein
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_fadeout
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_immortaling
    return unless PONY::ERRNO::check_sequence(current_act)
    #reserved
  end
  #--------------------------------------------------------------------------
  def setup_end_action
    clear_sequence
  end
  #--------------------------------------------------------------------------
  def setup_autopose
    return unless PONY::ERRNO::check_sequence(current_act)
    @battler_index = @acts[1]
    initial_cell = (@acts[2] - 1) * MaxRow
    @autopose.clear
    MaxCol.times do |i|
      @autopose += Array.new(@acts[3]) { initial_cell + i}
    end
  end
  #---------------------------------------------------------------------------
  def stop_all_movements
    @move_obj.clear_move_info
    @shadow_point.clear_move_info
    end_smooth_slide
    @shadow_point.end_smooth_slide
  end
end


module TacticCommandModule
  
  @template = {}
  
  Index = {
    :basic => [
      # category    #condition        # args    # action          # args
      [:targeting, :nearest_visible,  [true],      :set_target,      [nil] ],
      [:fighting,  :any,              [true],      :attack_mainhoof, [nil] ],
    ]
  }
  
  def self.load_template(symbol, battler)
    commands = @template[symbol].collect{|command| command.dup}
    commands.each do |command|
      command.battler     = battler
      command.action.user = battler
    end
    return commands
  end
  
  def self.compile_modules
    Index.each do |key, commands|
      result = []
      commands.each do |command|
        cmd = Game_TacticCommand.new(nil, command[2])
        cmd.category         = command[0]
        cmd.condition_symbol = command[1]
        cmd.action = Game_Action.new(nil, nil, command[3])
        result.push(cmd)
      end
      @template[key] = result
    end
  end
  
  compile_modules
end

#-------------------------------------------------------------------------------
# * [ACE] Sapphire Action System IV
#-------------------------------------------------------------------------------
# * By Khas Arcthunder - arcthunder.site40.net
# * Version: 4.4 EN
# * Released on: 11/07/2012
#
#-------------------------------------------------------------------------------
# * Terms of Use
#-------------------------------------------------------------------------------
# Terms of Use – June 22, 2012
# 1. You must give credit to Khas;
# 2. All Khas scripts are licensed under a Creative Commons license
# 3. All Khas scripts are free for non-commercial projects. If you need some 
#    script for your commercial project, check bellow these terms which 
#    scripts are free and which scripts are paid for commercial use;
# 4. All Khas scripts are for personal use, you can use or edit for your own 
#    project, but you are not allowed to post any modified version;
# 5. You can’t give credit to yourself for posting any Khas script;
# 6. If you want to share a Khas script, don’t post the script or the direct 
#    download link, please redirect the user to http://arcthunder.site40.net/
# 7. You are not allowed to convert any of Khas scripts to another engine, 
#    such converting a RGSS3 script to RGSS2 or something of that nature.
# 8. Its your obligation (user) to check these terms on the date you release 
#    your game. Your project must follow them correctly.
#
# Free commercial use scripts:
# - Sapphire Action System IV (RPG Maker VX Ace)
# - Awesome Light Effects (RPG Maker VX Ace)
# - Pixel movement (RPG Maker VX e RPG Maker VX Ace)
# - Sprite & Window Smooth Sliding (RPG Maker VX e RPG Maker VX Ace)
# - Pathfinder (RPG Maker VX Ace)
#
# Check all the terms at http://arcthunder.site40.net/terms/
#
#-------------------------------------------------------------------------------
# * Features
#-------------------------------------------------------------------------------
# The Sapphire Action System IV includes the following features:
# - Pixel Movement
# - Realistic collisions
# - Easy to use
# - Skill support
#
#-------------------------------------------------------------------------------
# * Instructions
#-------------------------------------------------------------------------------
# All the instructions are on SAS IV guide. Please read them carefully.
#
#-------------------------------------------------------------------------------
# * How to use
#-------------------------------------------------------------------------------
# 1. Physics System
# In order to run this script with the best performance, there's a system 
# called "Physics". This system will load each map between the transitions,
# so you may experience little loadings. The Khas Pixel Movement is not 
# recommended for huge maps.
#
# 2. Event Commands (place a comment)
# There are two special commands for events, you may add a comment with
# the following sintax:
#
# a. [collision_x A]
# This command sets the x collision to A (A must be an integer)
#
# b. [collision_y B]
# This command sets the y collision to B (B must be an integer)
#
# Please check the demo to understand how the collision system works!
#
# 3. Event Commands (call script)
# You can call the following commands for the player or the events
#
# character.px
# This command returns the pixel coordinate X (4 px = 1 tile)
#
# character.py
# This command returns the pixel coordinate Y (4 py = 1 tile)
#
# character.pixel_passable?(px,py,d)
# This command checks the pixel passability from (px, py) to the direction d.
# 
# 4. Map Commands
# You can call a special command to update the passability of the current
# map. You MUST run this command if the option "Auto_Refresh_Tile_Events"
# is set to false.
#
# "But when do I need to use this command?"
# Well, if you change a event graphic to a tileset graphic, or if you remove
# this event graphic, then your map need to be updated!
#
# $game_map.refresh_table(start_x,start_y,end_x,end_y)
#
# Where:
# start_x => Initial X
# start_y => Initial Y
# end_x => End X
# end_y => End Y
#
#-------------------------------------------------------------------------------
# * Warning!
#-------------------------------------------------------------------------------
# Check your tileset directions. If any direction is set as unpassable, the
# system will set the whole tile as unpassable. Setup your tilesets before
# using them!
#
#-------------------------------------------------------------------------------
# * Setup Part (Sapphire Engine)
#-------------------------------------------------------------------------------
# tag: movement
#-------------------------------------------------------------------------------
# * Game CharacterBase
#-------------------------------------------------------------------------------
class Game_CharacterBase
  include Pixel_Core
  #-------------------------------------------------------------------------------
  # * Instance variables
  #-------------------------------------------------------------------------------
  attr_accessor :px
  attr_accessor :py
  attr_accessor :cx
  attr_accessor :cy
  #-------------------------------------------------------------------------------
  # * Alias mehtods
  #-------------------------------------------------------------------------------
  alias kp_moveto moveto
  alias kp_move_straight move_straight
  alias kp_move_diagonal move_diagonal
  alias kp_bush? bush?
  alias kp_ladder? ladder?
  alias kp_terrain_tag terrain_tag
  alias kp_region_id region_id
  alias sas_update update
  alias sas_public_members init_public_members
  alias sas_straighten straighten
  #-------------------------------------------------------------------------------
  # * New: Range in pixel
  #-------------------------------------------------------------------------------
  def pixel_range?(px,py)
    #puts "#{@cx} #{@cy}"
    #puts "#{@x},#{@y};#{px},#{py}; #{(@px - px).abs <= @cx && (@py - py).abs <= @cy}"
    #puts "#{@x},#{@y};#{px/4},#{py/4}; #{(@x - px/4).abs <= 1 && (@py - py/4).abs <= 1}"
    #return (@x - px/4).abs <= 1 && (@py - py/4).abs <= 1
    return (@px - px).abs <= @cx && (@py - py).abs <= @cy
  end
  #-------------------------------------------------------------------------------
  # * Alias: Frame update
  #-------------------------------------------------------------------------------
  def update
    sas_update
    update_step_action if @step_action
  end
  #-------------------------------------------------------------------------------
  # * Alias: Straighten
  #-------------------------------------------------------------------------------
  def straighten
    sas_straighten
    @step_action = false
    @step_timer = 0
  end
  #-------------------------------------------------------------------------------
  #  New: Update_step_action
  #-------------------------------------------------------------------------------
  def update_step_action
    case @step_timer
    when 12; @pattern = 0
    when 8; @pattern = 1
    when 4; @pattern = 2
    when 0
      @step_action = false
      @pattern = 1
      return
    end
    @step_timer -= 1
  end
  #-------------------------------------------------------------------------------
  # * New: Do_step
  #-------------------------------------------------------------------------------
  def do_step
    @step_action = true
    @step_timer = 12
  end
  #-------------------------------------------------------------------------------
  # * Alias: init public vars
  #-------------------------------------------------------------------------------
  def init_public_members
    sas_public_members
    @x = @x.to_f
    @y = @y.to_f
    @px = (@x*Pixel).to_i
    @py = (@y*Pixel).to_i
    @cx = Default_Collision_X
    @cy = Default_Collision_Y
    @step_action = false
    @step_timer = 0
  end
  #-------------------------------------------------------------------------------
  # * Alias: moveto address immediately
  #-------------------------------------------------------------------------------
  def moveto(x,y)
    kp_moveto(x,y)
    @x = @x.to_f
    @y = @y.to_f
    @px = (@x*Pixel).to_i
    @py = (@y*Pixel).to_i
  end
  #-------------------------------------------------------------------------------
  # * New: Pixel passable?
  #-------------------------------------------------------------------------------
  def pixel_passable?(px,py,d)
    nx = px + Tile_Range[d][0]
    ny = py + Tile_Range[d][1]
    return false unless $game_map.pixel_valid?(nx,ny)
    return true  if @through || debug_through?
    return false if $game_map.pixel_table[nx,ny,0] == 0
    return false if collision?(nx,ny)
    return true
  end
  #-------------------------------------------------------------------------------
  # * New: Collision?
  # tag: effectus
  #-------------------------------------------------------------------------------
  def collision?(px, py)
    return false if through_character?
    for event in $game_map.events.values
      if (event.px - px).abs <= event.cx && (event.py - py).abs <= event.cy
        next if event.through || event == self
        return true if event.priority_type == 1
      end
    end
    
    if @priority_type == 1
      return true if ($game_player.px - px).abs <= @cx && ($game_player.py - py).abs <= @cy && !$game_player.dead?
    end
    return false
  end
  #-------------------------------------------------------------------------------
  def collision_character?(char)
    return false if char == self
    return (char.px - px) <= char.cx && (char.py - py).abs <= char.cy
  end
  #-------------------------------------------------------------------------------
  # * Overwrite: move_straight
  #-------------------------------------------------------------------------------
  def move_straight(d,turn_ok = true)
    move_pixel(d,turn_ok)
    battler.update_shadow_point if battler != self
  end
  #-------------------------------------------------------------------------------
  # * Overwrite: move diagonal
  #-------------------------------------------------------------------------------
  def move_diagonal(horz, vert)
    move_dpixel(horz,vert)
    battler.update_shadow_point if battler != self
  end
  #-------------------------------------------------------------------------------
  # * New: move_pixel     # tag: movement
  #-------------------------------------------------------------------------------
  def move_pixel(d,t = true)
    return if moving?
    $game_player.followers.move if self.is_a?(Game_Player)
    @move_succeed = pixel_passable?(@px, @py, d)
    if @move_succeed
      set_direction(d)
      @px += Tile_Range[d][0]
      @py += Tile_Range[d][1]
      @real_x = @x
      @real_y = @y
      @x += Pixel_Range[d][0]
      @y += Pixel_Range[d][1]
      increase_steps
    elsif t
      set_direction(d)
      return front_pixel_touch?(@px + Tile_Range[d][0],@py + Tile_Range[d][1])
    end
  end
  #-------------------------------------------------------------------------------
  # * New: move diagonal pixel
  #-------------------------------------------------------------------------------
  def move_dpixel(h,v)
    return if moving?
    @move_succeed = false
    touched = false
    
    if pixel_passable?(@px,@py,v)
      @move_succeed = true
      @real_x = @x
      @real_y = @y
      set_direction(v)
      @px += Tile_Range[v][0]
      @py += Tile_Range[v][1]
      @x += Pixel_Range[v][0]
      @y += Pixel_Range[v][1]
      increase_steps
    else
      set_direction(v)
      touched |= front_pixel_touch?(@px + Tile_Range[v][0],@py + Tile_Range[v][1])
    end
    
    if pixel_passable?(@px,@py,h)
      unless @move_succeed 
        @real_x = @x
        @real_y = @y
        @move_succeed = true
      end
      set_direction(h)
      @px += Tile_Range[h][0]
      @py += Tile_Range[h][1]
      @x += Pixel_Range[h][0]
      @y += Pixel_Range[h][1]
      increase_steps
    else
      set_direction(h)
      touched |= front_pixel_touch?(@px + Tile_Range[h][0],@py + Tile_Range[h][1])
    end
    $game_player.followers.move if self.is_a?(Game_Player)
    return touched
  end
  #-------------------------------------------------------------------------------
  # * Overwrite: on bush tile?
  #-------------------------------------------------------------------------------
  def bush?
    return $game_map.pixel_table[@px, @py, 4] == 1
  end
  #-------------------------------------------------------------------------------
  # * Overwrite: on ladder tile?
  #-------------------------------------------------------------------------------
  def ladder?
    return $game_map.pixel_table[@px, @py, 3] == 1
  end
  #-------------------------------------------------------------------------------
  # * Overwrite: return current terrain tag
  #-------------------------------------------------------------------------------
  def terrain_tag
    rx = ((@px % Pixel) > 1 ? @x.to_i + 1 : @x.to_i)
    ry = ((@py % Pixel) > 1 ? @y.to_i + 1 : @y.to_i)
    return $game_map.terrain_tag(rx,ry)
  end
  #-------------------------------------------------------------------------------
  # * Overwrite: return current region id
  #-------------------------------------------------------------------------------
  def region_id
    rx = ((@px % Pixel) > 1 ? @x.to_i + 1 : @x.to_i)
    ry = ((@py % Pixel) > 1 ? @y.to_i + 1 : @y.to_i)
    return $game_map.region_id(rx, ry)
  end
  #-------------------------------------------------------------------------------
  # * New: Front collision detect, save for latter use
  #-------------------------------------------------------------------------------
  def front_pixel_touch?(x,y)
  end
end
#-------------------------------------------------------------------------------
# * Game Character
#-------------------------------------------------------------------------------
class Game_Character < Game_CharacterBase
  #-------------------------------------------------------------------------------
  # * Public instance variables
  #-------------------------------------------------------------------------------
  attr_accessor :pattern 
  #-------------------------------------------------------------------------------
  # * Alias methods
  #-------------------------------------------------------------------------------
  alias kp_force_move_route force_move_route
  alias kp_move_toward_character move_toward_character
  alias kp_move_away_from_character move_away_from_character
  alias kp_jump jump
  #-------------------------------------------------------------------------------
  # * Alias: force move route
  #-------------------------------------------------------------------------------
  def force_move_route(route)
    kp_force_move_route(route.clone)
    multiply_commands
  end
  #-------------------------------------------------------------------------------
  # * multiply movements by 4 to a tile
  #-------------------------------------------------------------------------------
  def multiply_commands
    return unless Multiply_Commands
    return if @move_route.list.empty?
    new_route = []
    for cmd in @move_route.list
      if Commands.include?(cmd.code)
        Pixel.times do
          new_route << cmd
        end
      else
        new_route << cmd
      end
    end
    @move_route.list = new_route
  end
  #-------------------------------------------------------------------------------
  # * Overwrite: move toeard character
  # return: touch any chatacter?
  #-------------------------------------------------------------------------------
  def move_toward_character(character)
    dx = @px - character.px
    dy = @py - character.py
    if dx.abs < character.cx
      unless dy.abs < character.cy
        move_pixel(dy < 0 ? 2 : 8) 
        unless @move_succeed
          return if dx.abs - Chase_Axis[@direction][0] <= @cx && dy.abs - Chase_Axis[@direction][1] <= @cy
          move_dpixel(dx < 0 ? 6 : 4, dy < 0 ? 2 : 8)
        end
      end
    else
      if dy.abs < character.cy
        move_pixel(dx < 0 ? 6 : 4)
        unless @move_succeed
          return if dx.abs - Chase_Axis[@direction][0] <= @cx && dy.abs - Chase_Axis[@direction][1] <= @cy
          move_dpixel(dx < 0 ? 6 : 4, dy < 0 ? 2 : 8)
        end
      else
        move_dpixel(dx < 0 ? 6 : 4, dy < 0 ? 2 : 8)
      end
    end
  end
  #-------------------------------------------------------------------------------
  # * Overwrite: move away from character
  #-------------------------------------------------------------------------------
  def move_away_from_character(character)
    dx = @px - character.px
    dy = @py - character.py
    if dx == 0
      move_pixel(dy > 0 ? 2 : 8,true)
    else
      if dy == 0 
        move_pixel(dx > 0 ? 6 : 4,true)
      else
        move_dpixel(dx > 0 ? 6 : 4, dy > 0 ? 2 : 8)
      end
    end
  end
  #-------------------------------------------------------------------------------
  # * Alias: jump
  #-------------------------------------------------------------------------------
  def jump(xp,yp)
    kp_jump(xp,yp)
    @px = @x*Pixel
    @py = @y*Pixel
  end
end
#-------------------------------------------------------------------------------
# * Game Player
#-------------------------------------------------------------------------------
class Game_Player < Game_Character
  #-------------------------------------------------------------------------------
  # * Overwite: Determine if Same Position Event is Triggered
  #-------------------------------------------------------------------------------
  def check_event_trigger_here(triggers)
    for event in $game_map.events.values
      if (event.px - @px).abs <= event.cx && (event.py - @py).abs <= event.cy
        event.start if triggers.include?(event.trigger) && event.priority_type != 1
      end
    end
  end
  #-------------------------------------------------------------------------------
  # * Overwite: Determine if Front Event is Triggered
  #-------------------------------------------------------------------------------
  def check_event_trigger_there(triggers)
    fx = @px+Trigger_Range[@direction][0]
    fy = @py+Trigger_Range[@direction][1]
    for event in $game_map.events.values
      if (event.px - fx).abs <= event.cx && (event.py - fy).abs <= event.cy
        if triggers.include?(event.trigger) && event.normal_priority?
          event.start
          return
        end
      end
    end
    if $game_map.pixel_table[fx,fy,5] == 1
      fx += Counter_Range[@direction][0]
      fy += Counter_Range[@direction][1]
      for event in $game_map.events.values
        if (event.px - fx).abs <= event.cx && (event.py - fy).abs <= event.cy
          if triggers.include?(event.trigger) && event.normal_priority?
            event.start
            return
          end
        end
      end
    end
  end
  #-------------------------------------------------------------------------------
  # * Front pixel collision check
  #-------------------------------------------------------------------------------
  def front_pixel_touch?(px,py)
    return if $game_map.interpreter.running?
    for event in $game_map.events.values
      if (event.px - px).abs <= event.cx && (event.py - py).abs <= event.cy
        if [1,2].include?(event.trigger) && event.normal_priority?
          event.start
          result = true
        end
      end
    end
  end
  #-------------------------------------------------------------------------------
  # * Pixel move passable?
  #-------------------------------------------------------------------------------
  def pixel_passable?(px,py,d)
    nx = px + Tile_Range[d][0]
    ny = py + Tile_Range[d][1]
    return false unless $game_map.pixel_valid?(nx,ny)
    return true if @through || debug_through?
    #puts "#{nx} #{ny} #{px} #{py} #{d} #{$game_map.pixel_table[nx,ny,0]}"
    return false if $game_map.pixel_table[nx,ny,0] == 0
    return false if collision?(nx,ny)
    return true
  end
  #-------------------------------------------------------------------------------
  # * Overwrite: Processing of Movement via Input from Directional Buttons
  #-------------------------------------------------------------------------------
  def move_by_input
    return if !movable? || $game_map.interpreter.running?
    d = Input.dir8
    case d
    when 1; move_dpixel(4,2)
    when 2; move_pixel(2,true)
    when 3; move_dpixel(6,2)
    when 4; move_pixel(4,true)
    when 6; move_pixel(6,true)
    when 7; move_dpixel(4,8)
    when 8; move_pixel(8,true)
    when 9; move_dpixel(6,8)
    end
    update_cancel_action if d > 0
  end
  #-------------------------------------------------------------------------------
  # * Disable damage floor
  #-------------------------------------------------------------------------------
  def on_damage_floor?
    return false
  end
  #-------------------------------------------------------------------------------
  # * Collision check
  #-------------------------------------------------------------------------------
  def collision?(px, py)
    return false if through_character?
    for event in $game_map.events.values
      if (event.px - px).abs <= event.cx && (event.py - py).abs <= event.cy
        next if event.through
        return true if event.priority_type == 1
      end
    end
    return false
  end
  #-------------------------------------------------------------------------------
  def move_straight(d, turn_ok = true)
    super(d, turn_ok)
  end
  #-------------------------------------------------------------------------------
  def move_diagonal(horz, vert)
    super(horz, vert)
  end
  
end
#-------------------------------------------------------------------------------
# * Game Event
#-------------------------------------------------------------------------------
class Game_Event < Game_Character
  #-------------------------------------------------------------------------------
  # * Alias methods
  #-------------------------------------------------------------------------------
  alias sas_initialize initialize
  alias kp_move_type_toward_player move_type_toward_player
  alias kp_setup_page_settings setup_page_settings
  #-------------------------------------------------------------------------------
  # * Alias: initialize
  #-------------------------------------------------------------------------------
  def initialize(m,e)
    sas_initialize(m,e)
    setup_collision
  end
  #-------------------------------------------------------------------------------
  #
  #-------------------------------------------------------------------------------
  def move_type_toward_player
    move_toward_player if near_the_player?
  end
  #-------------------------------------------------------------------------------
  #
  #-------------------------------------------------------------------------------
  def setup_page_settings
    kp_setup_page_settings
    setup_collision
    multiply_commands
  end
  #-------------------------------------------------------------------------------
  def collision?(px, py)
    return false if through_character?
    for event in $game_map.events.values
      if (event.px - px).abs <= event.cx && (event.py - py).abs <= event.cy
        next if event.through || event == self
        return true if event.priority_type == 1
      end
    end
    
    for follower in $game_player.followers
      next unless follower.actor || follower.through
      return false if follower.dead?
      return true if (follower.px - px).abs <= follower.cx && (follower.py - py).abs <= follower.cy
    end
    
    if @priority_type == 1
      return true if ($game_player.px - px).abs <= @cx && ($game_player.py - py).abs <= @cy && !$game_player.dead?
    end
    return false
  end
  #-------------------------------------------------------------------------------
  #
  #-------------------------------------------------------------------------------
  def setup_collision
    @cx = Default_Collision_X
    @cy = Default_Collision_Y
    unless @list.nil?
      for value in 0...@list.size
        next if @list[value].code != 108 && @list[value].code != 408
        if @list[value].parameters[0].include?("[collision_x ")
          @list[value].parameters[0].scan(/\[collision_x ([0.0-9.9]+)\]/)
          @cx = $1.to_i
        end
        if @list[value].parameters[0].include?("[collision_y ")
          @list[value].parameters[0].scan(/\[collision_y ([0.0-9.9]+)\]/)
          @cy = $1.to_i
        end
      end
    end
  end
  #-------------------------------------------------------------------------------
  #
  #-------------------------------------------------------------------------------
  def front_pixel_touch?(px,py)
    return if $game_map.interpreter.running?
    if @enemy.nil?
      if @trigger == 2 && ($game_player.px - px).abs <= @cx && ($game_player.py - py).abs <= @cy
        start if !jumping? && normal_priority?
      end
    else
      return# if jumping? || @recover > 0 || @enemy.nature == 2 || @enemy.object
      #attack if $game_map.sas_active && ($game_player.px - px).abs <= @cx && ($game_player.py - py).abs <= @cy
    end
  end
  
end
#==============================================================================
# ** Game_Follower
#------------------------------------------------------------------------------
#  This class handles followers. A follower is an allied character, other than
# the front character, displayed in the party. It is referenced within the
# Game_Followers class.
#==============================================================================
class Game_Follower < Game_Character
  #-------------------------------------------------------------------------------
  # * Collision check
  #-------------------------------------------------------------------------------
  def collision?(px, py)
    return false if through_character?
    for event in $game_map.events.values
      if (event.px - px).abs <= event.cx && (event.py - py).abs <= event.cy
        next if event.through
        return true if event.priority_type == 1
      end
    end
    
    return false
  end
  
end

#==============================================================================
# ** Game_Follower
# tag: follower
#------------------------------------------------------------------------------
#  This class handles followers. A follower is an allied character, other than
# the front character, displayed in the party. It is referenced within the
# Game_Followers class.
#==============================================================================
class Game_Follower < Game_Character
  #--------------------------------------------------------------------------
  # tag: follower
  Followers_Distance        = 16
  Follwers_Margin           = 4
  #--------------------------------------------------------------------------
  attr_accessor :swap_with_leader
  #--------------------------------------------------------------------------
  # * Alias: Object Initialization
  #--------------------------------------------------------------------------
  alias init_game_follower_comp initialize
  def initialize(member_index, preceding_character)
    init_game_follower_comp(member_index, preceding_character)
    @force_chase = false
    @swap_with_leader = false
  end
  #--------------------------------------------------------------------------
  # * Move to Designated Position
  #--------------------------------------------------------------------------
  alias moveto_comp moveto
  def moveto(x, y, forced = false)
    return if @targeted_character != nil && !@swap_with_leader && !forced
    moveto_comp(x, y)
  end
  #--------------------------------------------------------------------------
  def normal_walk?
    return false if !@current_target.nil?
    return false if command_holding?
    return true
  end
  #--------------------------------------------------------------------------
  # * Overwrite: Pursue Preceding Character
  # tag: follower
  #--------------------------------------------------------------------------
  alias chase_preceding_character_dnd chase_preceding_character
  def chase_preceding_character
    return if !movable?
    if !normal_walk?
      @force_chase = false
      return
    end
    return process_pathfinding_movement if !@pathfinding_moves.empty?
    return process_move_route if !@move_route.nil?
    return if moving? && !@force_chase
    @move_poll.clear if !@move_poll.empty? && distance_preceding_leader < 1
    dist = distance_preceding_character
    return chase_preceding_pathfinding if dist > 1.5
    return chase_preceding_normal
  end
  #--------------------------------------------------------------------------
  def chase_preceding_pathfinding
    @force_chase = true
    reachable = move_to_position($game_player.x, $game_player.y, goal:$game_player)
    moveto($game_player.x,$game_player.y) if !reachable
  end
  #--------------------------------------------------------------------------
  def chase_preceding_normal
    @force_chase = false
    dist = Followers_Distance / 32.0
    mrgn = Follwers_Margin / 32.0
    goal = command_gathering? ? $game_player : @preceding_character
    sx = distance_x_from(goal.x)
    sy = distance_y_from(goal.y)
    sd = Math.hypot(sx, sy)
    #if sx != 0 && sy != 0
    #  move_dpixel(sx > 0 ? 4 : 6, sy > 0 ? 8 : 2)
    if(sd > dist && sx.abs > mrgn && sy.abs > mrgn)
      dir = (sx > 0 ? -1 : 1) + (sy > 0 ? 8 : 2)
      case dir
      when 1; move_dpixel(4,2);
      when 3; move_dpixel(6,2);
      when 7; move_dpixel(4,8);
      when 9; move_dpixel(6,8);
      end
    elsif sx.abs > dist && sx.abs > sy.abs
      move_pixel(sx > 0 ? 4 : 6, true)
    elsif sy.abs > dist && sx.abs < sy.abs
      move_pixel(sy > 0 ? 8 : 2, true)
    end # if @board
  end
  #--------------------------------------------------------------------------
  # * Process move route command
  #--------------------------------------------------------------------------
  def process_move_route
    command = @move_route.list[@move_route_index]
    if command
      process_move_command(command)
      advance_move_route_index
    end
  end
  #--------------------------------------------------------------------------
  # * The Distance To Preceding Character
  #--------------------------------------------------------------------------
  def distance_preceding_character
    sx = distance_x_from(@preceding_character.x)
    sy = distance_y_from(@preceding_character.y)
    return Math.hypot(sx, sy)
  end
  #--------------------------------------------------------------------------
  # * The Distance To Leader
  #--------------------------------------------------------------------------
  def distance_preceding_leader
    sx = distance_x_from($game_player.x)
    sy = distance_y_from($game_player.y)
    return Math.hypot(sx, sy)
  end
  #--------------------------------------------------------------------------
  # * New: Processes Movement
  #--------------------------------------------------------------------------
  def process_move(horz, vert)
    super(horz, vert)
    dist = Followers_Distance / 32.0
    if distance_preceding_character > dist && @move_poll.size == 0
      @force_chase = true
      chase_preceding_character
      @force_chase = false
    end
  end
  #--------------------------------------------------------------------------
  # * New: Sets the Character To Board
  #--------------------------------------------------------------------------
  def board
    @board = true
  end
end

#==============================================================================
# 
# ▼ Yanfly Engine Ace - System Options v1.00
# -- Last Updated: 2012.01.01
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-SystemOptions"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.01 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script replaces the "Game End" option in the Main Menu with a "System"
# menu where the player can adjust various settings in the game. Of them, the
# player can change the window colour, the volume for BGM, BGS, SFX, set
# automatic dashing, message text to display instantly, and speed up battles by
# hiding battle animations.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Script Calls - These commands are used with script calls.
# -----------------------------------------------------------------------------
# $game_system.volume_change(:bgm, x)
# $game_system.volume_change(:bgs, x)
# $game_system.volume_change(:sfx, x)
# Unlike the previous Yanfly Engines, this version does not bind volume to a
# variable. Use the script call to change the bgm, bgs, or sfx sound rate by
# x increment. Use a negative value to lower the volume.
# 
# $game_system.set_autodash(true)
# $game_system.set_autodash(false)
# Turns autodash on (true) or off (false).
# 
# $game_system.set_instantmsg(true)
# $game_system.set_instantmsg(false)
# Turns instant messages on (true) or off (false).
# 
# $game_system.set_animations(true)
# $game_system.set_animations(false)
# Turns battle animations on (true) or off (false).
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
module YEA
  module SYSTEM
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Setting -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These are the general settings that govern the System settings. This will
    # change the "Game End" vocab, and disable or enable autodash, instant
    # messages, or animations by default.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMAND_NAME = "System"      # Command name used to replace Game End.
    DEFAULT_AUTODASH   = false    # Enable automatic dashing by default?
    DEFAULT_INSTANTMSG = false   # Enable instant message text by default?
    DEFAULT_ANIMATIONS = true    # Enable battle animations by default?
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Command Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These settings adjust the commands shown in the command list. Add, remove
    # or rearrange the commands as you see fit. Here's a list of which commands
    # do what:
    # 
    # -------------------------------------------------------------------------
    # :command         Description
    # -------------------------------------------------------------------------
    # :blank           Inserts an empty blank space.
    # 
    # :window_red      Changes the red tone for all windows.
    # :window_grn      Changes the green tone for all windows.
    # :window_blu      Changes the blue tone for all windows.
    # 
    # :volume_bgm      Changes the BGM volume used.
    # :volume_bgs      Changes the BGS volume used.
    # :volume_sfx      Changes the SFX volume used.
    # 
    # :autodash        Sets the player to automatically dash.
    # :instantmsg      Sets message text to appear instantly.
    # :animations      Enables battle animations or disables them.
    # 
    # :to_title        Returns to the title screen.
    # :shutdown        Shuts down the game.
    # 
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMANDS =[
      #:window_red,   # Changes the red tone for all windows.
      #:window_grn,   # Changes the green tone for all windows.
      #:window_blu,   # Changes the blue tone for all windows.
      :volume_bgm,   # Changes the BGM volume used.
      :volume_bgs,   # Changes the BGS volume used.
      :volume_sfx,   # Changes the SFX volume used.
      #:blank,
      #:autodash,     # Sets the player to automatically dash.
      #:instantmsg,   # Sets message text to appear instantly.
      #:animations,   # Enables battle animations or disables them.
      :blank,
      #:switch_1,     # auto save
      #:variable_1,   # step
      #:switch_4,     # b4 combat
      #:blank,
     
      :blank,
      :language,
      :to_title,     # Returns to the title screen.
      :shutdown,     # Shuts down the game.
    ] # Do not remove this.
    
    #--------------------------------------------------------------------------
    # - Custom Switches -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # If you want your game to have system options other than just the ones
    # listed above, you can insert custom switches here to produce such an
    # effect. Adjust the settings here as you see fit.
    #--------------------------------------------------------------------------
    CUSTOM_SWITCHES ={
    # -------------------------------------------------------------------------
    # :switch    => [Switch, Name, Off Text, On Text, 
    #                Help Window Description
    #               ], # Do not remove this.
    # -------------------------------------------------------------------------
      :switch_1  => [ 4, Vocab::System::AutoSave, "OFF", "ON",
                     Vocab::System::AutoSaveDec
                    ],
    # -------------------------------------------------------------------------
      :switch_4  => [ 7, Vocab::System::AutoSaveCombat, "OFF", "ON",
                    Vocab::System::AutoSaveCombatDec
                    ],
    # -------------------------------------------------------------------------
      :switch_7  => [ 12, Vocab::System::WarCry, "ON", "OFF",
                      Vocab::System::WarCryDec
                    ],
    # -------------------------------------------------------------------------
    } # Do not remove this.
    
    #--------------------------------------------------------------------------
    # - Custom Variables -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # If you want your game to have system options other than just the ones
    # listed above, you can insert custom variables here to produce such an
    # effect. Adjust the settings here as you see fit.
    #--------------------------------------------------------------------------
    CUSTOM_VARIABLES ={
    # -------------------------------------------------------------------------
    # :variable   => [Switch, Name, Colour1, Colour2, Min, Max,
    #                 Help Window Description,init value
    #                ], # Do not remove this.
    # -------------------------------------------------------------------------
      :variable_1 => [ 16, Vocab::System::AutoSaveStep ,9, 1, 0, 1000,
                      Vocab::System::AutoSaveStepDec
                     ],
    # ------------------------------------------------------------------------- 
      :variable_5 => [ 33, Vocab::System::Difficulty, 30,31 , 0,3,
                      Vocab::System::DifficultyDec
                     ],
                     
    # -------------------------------------------------------------------------
    } # Do not remove this.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Vocab Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This hash adjusts the vocab used for both the commands and the help
    # description that appears above the command window. Note that for the
    # command help descriptions, you may use text codes. Use \n to linebreak.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMAND_VOCAB ={
    # -------------------------------------------------------------------------
    # :command    => [Command Name, Option1, Option2
    #                 Help Window Description,
    #                ], # Do not remove this.
    # -------------------------------------------------------------------------
      :blank      => ["", "None", "None",
                      ""
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :window_red => ["Window Red", "None", "None",
                      "Change the red colour tone for windows.\n" +
                      "Hold SHIFT to change increment by 10."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :window_grn => ["Window Green", "None", "None",
                      "Change the green colour tone for windows.\n" +
                      "Hold SHIFT to change increment by 10."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :window_blu => ["Window Blue", "None", "None",
                      "Change the blue colour tone for windows.\n" +
                      "Hold SHIFT to change increment by 10."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
#      :volume_bgm => ["BGM Volume", 12, 4, # Options 1 & 2 are Gauge Colours.
 #                     "Change the volume used for background music.\n" +
 #                     "Hold SHIFT to change increment by 10."
 #                    ], # Do not remove this.
    # -------------------------------------------------------------------------
      :volume_bgm => [Vocab::System::BGM, 12, 4, # Options 1 & 2 are Gauge Colours.
                      Vocab::System::BGMDec
                     ], # Do not remove this.
                     
    # -------------------------------------------------------------------------
      :volume_bgs => [Vocab::System::BGS, 13, 5, # Options 1 & 2 are Gauge Colours.
                      Vocab::System::BGSDec
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :volume_sfx => [Vocab::System::SE , 14, 6, # Options 1 & 2 are Gauge Colours.
                      Vocab::System::SEDec
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :autodash   => ["Auto-Dash", "Off", "On",
                      "Walk/Run when you are NOT holding shift"
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :instantmsg => ["Instant Text", "Normal", "Instant",
                      "Set message text to appear one-by-one or instantly."
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :animations => ["Battle Animations", "Hide", "Show",
                      "Hide animations during battle to speed up battles?"
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :language   => [Vocab::System::Language, "None", "None", 
                      Vocab::System::LanguageDec
                     ],
    # -------------------------------------------------------------------------
      :to_title   => [Vocab::System::ToTitle, "None", "None",
                      Vocab::System::ToTitleDec
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
      :shutdown   => [Vocab::System::ShutDown, "None", "None",
                      Vocab::System::ShutDownDec
                     ], # Do not remove this.
    # -------------------------------------------------------------------------
    } # Do not remove this.
    
  end # SYSTEM
end # YEA
#tag: system
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
#==============================================================================
# ■ Vocab
#==============================================================================
module Vocab
  
  #--------------------------------------------------------------------------
  # overwrite method: self.game_end
  #--------------------------------------------------------------------------
  def self.game_end
    return ::YEA::SYSTEM::COMMAND_NAME
  end
  
end # Vocab
#==============================================================================
# ■ RPG::BGM
#==============================================================================
class RPG::BGM < RPG::AudioFile
  
  #--------------------------------------------------------------------------
  # overwrite method: play
  #--------------------------------------------------------------------------
  def play(pos = 0)
    if @name.empty?
      Audio.bgm_stop
      @@last = RPG::BGM.new
    else
      volume = @volume
      volume *= $game_system.volume(:bgm) * 0.01 unless $game_system.nil?
      Audio.bgm_play('Audio/BGM/' + @name, volume, @pitch, pos)
      @@last = self.clone
    end
  end
  
end # RPG::BGM
#==============================================================================
# ■ RPG::ME
#==============================================================================
class RPG::ME < RPG::AudioFile
  
  #--------------------------------------------------------------------------
  # overwrite method: play
  #--------------------------------------------------------------------------
  def play
    if @name.empty?
      Audio.me_stop
    else
      volume = @volume
      volume *= $game_system.volume(:bgm) * 0.01 unless $game_system.nil?
      Audio.me_play('Audio/ME/' + @name, volume, @pitch)
    end
  end
  
end # RPG::ME
#==============================================================================
# ■ RPG::BGS
#==============================================================================
class RPG::BGS < RPG::AudioFile
  
  #--------------------------------------------------------------------------
  # overwrite method: play
  #--------------------------------------------------------------------------
  def play(pos = 0)
    if @name.empty?
      Audio.bgs_stop
      @@last = RPG::BGS.new
    else
      volume = @volume
      volume *= $game_system.volume(:bgs) * 0.01 unless $game_system.nil?
      Audio.bgs_play('Audio/BGS/' + @name, volume, @pitch, pos)
      @@last = self.clone
    end
  end
  
end # RPG::BGS
#==============================================================================
# ■ RPG::SE
#==============================================================================
class RPG::SE < RPG::AudioFile
  
  #--------------------------------------------------------------------------
  # overwrite method: play
  #--------------------------------------------------------------------------
  def play
    unless @name.empty?
      volume = @volume
      volume *= $game_system.volume(:sfx) * 0.01 unless $game_system.nil?
      Audio.se_play('Audio/SE/' + @name, volume, @pitch)
    end
  end
  
end # RPG::SE
#==============================================================================
# ■ Game_System
#==============================================================================
class Game_System
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias game_system_initialize_so initialize
  def initialize
    game_system_initialize_so
    init_volume_control
    init_autodash
    init_instantmsg
    init_animations
  end
  
  #--------------------------------------------------------------------------
  # new method: init_volume_control
  #--------------------------------------------------------------------------
  def init_volume_control
    @volume = {}
    if $sound_volume.nil?
      @volume[:bgm] = 100
      @volume[:bgs] = 100
      @volume[:sfx] = 100
    else
      @volume[:bgm] = $sound_volume[0]
      @volume[:bgs] = $sound_volume[1]
      @volume[:sfx] = $sound_volume[2]
    end
  end
  #--------------------------------------------------------------------------
  # new method: get volume setting
  #--------------------------------------------------------------------------
  def get_volume_setting; @volume end
  #--------------------------------------------------------------------------
  # new method: volume
  #--------------------------------------------------------------------------
  def volume(type)
    init_volume_control if @volume.nil?
    return [[@volume[type], 0].max, 100].min
  end
  #--------------------------------------------------------------------------
  # new method: volume_change
  #--------------------------------------------------------------------------
  def volume_change(type, increment)
    init_volume_control if @volume.nil?
    @volume[type] += increment
    @volume[type] = [[@volume[type], 0].max, 100].min
    
    goal = sprintf("[%d,%d,%d]",@volume[:bgm],@volume[:bgs],@volume[:sfx])
    FileManager.write_ini('Option', 'Volume', goal)
  end
  #--------------------------------------------------------------------------
  def set_volume(type, value)
    init_volume_control if @volume.nil?
    @volume[type] = value
    @volume[type] = [[@volume[type], 0].max, 100].min
    
    goal = sprintf("[%d,%d,%d]",@volume[:bgm],@volume[:bgs],@volume[:sfx])
    FileManager.write_ini('Option', 'Volume', goal)
  end
  #--------------------------------------------------------------------------
  # new method: init_autodash
  #--------------------------------------------------------------------------
  def init_autodash
    @autodash = YEA::SYSTEM::DEFAULT_AUTODASH
  end
  
  #--------------------------------------------------------------------------
  # new method: autodash?
  #--------------------------------------------------------------------------
  def autodash?
    init_autodash if @autodash.nil?
    return @autodash
  end
  
  #--------------------------------------------------------------------------
  # new method: set_autodash
  #--------------------------------------------------------------------------
  def set_autodash(value)
    @autodash = value
  end
  
  #--------------------------------------------------------------------------
  # new method: init_instantmsg
  #--------------------------------------------------------------------------
  def init_instantmsg
    @instantmsg = YEA::SYSTEM::DEFAULT_INSTANTMSG
  end
  
  #--------------------------------------------------------------------------
  # new method: instantmsg?
  #--------------------------------------------------------------------------
  def instantmsg?
    init_instantmsg if @instantmsg.nil?
    return @instantmsg
  end
  
  #--------------------------------------------------------------------------
  # new method: set_instantmsg
  #--------------------------------------------------------------------------
  def set_instantmsg(value)
    @instantmsg = value
  end
  
  #--------------------------------------------------------------------------
  # new method: init_animations
  #--------------------------------------------------------------------------
  def init_animations
    @animations = YEA::SYSTEM::DEFAULT_ANIMATIONS
  end
  
  #--------------------------------------------------------------------------
  # new method: animations?
  #--------------------------------------------------------------------------
  def animations?
    init_animations if @animations.nil?
    return @animations
  end
  
  #--------------------------------------------------------------------------
  # new method: set_animations
  #--------------------------------------------------------------------------
  def set_animations(value)
    @animations = value
  end
  
end # Game_System
#==============================================================================
# ■ Scene_Battle
#==============================================================================
class Scene_Battle < Scene_Base
  
  #--------------------------------------------------------------------------
  # alias method: show_fast?
  #--------------------------------------------------------------------------
  alias scene_battle_show_fast_so show_fast?
  def show_fast?
    return true unless $game_system.animations?
    return scene_battle_show_fast_so
  end
  
  #--------------------------------------------------------------------------
  # alias method: show_normal_animation
  #--------------------------------------------------------------------------
  alias scene_battle_show_normal_animation_so show_normal_animation
  def show_normal_animation(targets, animation_id, mirror = false)
    return unless $game_system.animations?
    scene_battle_show_normal_animation_so(targets, animation_id, mirror)
  end
  
end # Scene_Battle
#==============================================================================
# ■ Window_Message
#==============================================================================
class Window_Message < Window_Base
  
  #--------------------------------------------------------------------------
  # alias method: clear_flags
  #--------------------------------------------------------------------------
  alias window_message_clear_flags_so clear_flags
  def clear_flags
    window_message_clear_flags_so
    @show_fast = true if $game_system.instantmsg?
  end
  
end # Window_Message
#==============================================================================
# ■ Window_SystemOptions
#==============================================================================
class Window_SystemOptions < Window_Command
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(help_window)
    @help_window = help_window
    #tag: modified
    super(0, @help_window.height)
    @scroll_enable = true
    create_overlay_window
    refresh
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return Graphics.width; end
  
  #--------------------------------------------------------------------------
  # window_height
  #--------------------------------------------------------------------------
  def window_height; return Graphics.height - @help_window.height; end
  
  #--------------------------------------------------------------------------
  # update_help
  #--------------------------------------------------------------------------
  def update_help
    if current_symbol == :custom_switch || current_symbol == :custom_variable
      text = @help_descriptions[current_ext]
    else
      text = @help_descriptions[current_symbol]
    end
    text = "" if text.nil?
    @help_window.set_text(text)
  end
  #--------------------------------------------------------------------------
  # ok_enabled?
  #--------------------------------------------------------------------------
  def ok_enabled?
    return true if [:to_title, :shutdown].include?(current_symbol)
    return false
  end
  #--------------------------------------------------------------------------
  # make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    @help_descriptions = {}
    for command in YEA::SYSTEM::COMMANDS
      case command
      when :blank
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :window_red, :window_grn, :window_blu
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :volume_bgm, :volume_bgs, :volume_sfx
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :autodash, :instantmsg, :animations
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :to_title, :shutdown
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      else
        process_custom_switch(command)
        process_custom_variable(command)
      end
    end
  end
  #--------------------------------------------------------------------------
  # process_custom_switch
  #--------------------------------------------------------------------------
  def process_custom_switch(command)
    return unless YEA::SYSTEM::CUSTOM_SWITCHES.include?(command)
    name = YEA::SYSTEM::CUSTOM_SWITCHES[command][1]
    add_command(name, :custom_switch, true, command)
    @help_descriptions[command] = YEA::SYSTEM::CUSTOM_SWITCHES[command][4]
  end
  
  #--------------------------------------------------------------------------
  # process_custom_variable
  #--------------------------------------------------------------------------
  def process_custom_variable(command)
    return unless YEA::SYSTEM::CUSTOM_VARIABLES.include?(command)
    name = YEA::SYSTEM::CUSTOM_VARIABLES[command][1]
    add_command(name, :custom_variable, true, command)
    @help_descriptions[command] = YEA::SYSTEM::CUSTOM_VARIABLES[command][6]
    #precent overflow
  end
  #--------------------------------------------------------------------------
  # * Get bar rect of value stuff
  #--------------------------------------------------------------------------
  def get_value_rect
    rect = item_rect(index)
    dx = contents.width / 2
    return Rect.new(dx, rect.y + 12, contents.width - dx - 48, rect.height)
  end
  #--------------------------------------------------------------------------
  def calc_mouseclick_value(value_rect, minn, maxn)
    rect = value_rect.dup; rect.width += 24
    return unless Mouse.collide_sprite?(rect)
    delta   = maxn - minn
    percent = ((Mouse.pos[0] - value_rect.x).to_f / value_rect.width)
    return (delta * percent).round
  end
  #--------------------------------------------------------------------------
  # * draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    reset_font_settings
    rect = item_rect(index)
    contents.clear_rect(rect)
    case @list[index][:symbol]
    when :window_red, :window_grn, :window_blu
      draw_window_tone(rect, index, @list[index][:symbol])
    when :volume_bgm, :volume_bgs, :volume_sfx
      draw_volume(rect, index, @list[index][:symbol])
    when :autodash, :instantmsg, :animations
      draw_toggle(rect, index, @list[index][:symbol])
    when :to_title, :shutdown
      draw_text(item_rect_for_text(index), command_name(index), 1)
    when :custom_switch
      draw_custom_switch(rect, index, @list[index][:ext])
    when :custom_variable
      draw_custom_variable(rect, index, @list[index][:ext])
    end
  end
  #--------------------------------------------------------------------------
  # draw_window_tone
  #--------------------------------------------------------------------------
  def draw_window_tone(rect, index, symbol)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    tone = $game_system.window_tone
    
    case symbol
    when :window_red
      rate = (tone.red + 255.0) / 510.0
      colour1 = Color.new(128, 0, 0)
      colour2 = Color.new(255, 0, 0)
      value = tone.red.to_i
    when :window_grn
      rate = (tone.green + 255.0) / 510.0
      colour1 = Color.new(0, 128, 0)
      colour2 = Color.new(0, 255, 0)
      value = tone.green.to_i
    when :window_blu
      rate = (tone.blue + 255.0) / 510.0
      colour1 = Color.new(0, 0, 128)
      colour2 = Color.new(0, 0, 255)
      value = tone.blue.to_i
    end
    draw_gauge(dx, rect.y, contents.width - dx - 48, rate, colour1, colour2)
    draw_text(dx, rect.y, contents.width - dx - 48, line_height, value, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_volume
  #--------------------------------------------------------------------------
  def draw_volume(rect, index, symbol)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    case symbol
    when :volume_bgm
      rate = $game_system.volume(:bgm)
    when :volume_bgs
      rate = $game_system.volume(:bgs)
    when :volume_sfx
      rate = $game_system.volume(:sfx)
    end
    colour1 = text_color(YEA::SYSTEM::COMMAND_VOCAB[symbol][1])
    colour2 = text_color(YEA::SYSTEM::COMMAND_VOCAB[symbol][2])
    value = sprintf("%d%%", rate)
    rate *= 0.01
    draw_gauge(dx, rect.y, contents.width - dx - 48, rate, colour1, colour2)
    draw_text(dx, rect.y, contents.width - dx - 48, line_height, value, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_toggle
  #--------------------------------------------------------------------------
  def draw_toggle(rect, index, symbol)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    case symbol
    when :autodash
      enabled = $game_system.autodash?
    when :instantmsg
      enabled = $game_system.instantmsg?
    when :animations
      enabled = $game_system.animations?
    end
    dx = contents.width/2
    change_color(normal_color, !enabled)
    option1 = YEA::SYSTEM::COMMAND_VOCAB[symbol][1]
    draw_text(dx, rect.y, contents.width/4, line_height, option1, 1)
    dx += contents.width/4
    change_color(normal_color, enabled)
    option2 = YEA::SYSTEM::COMMAND_VOCAB[symbol][2]
    draw_text(dx, rect.y, contents.width/4, line_height, option2, 1)
  end
  
  #--------------------------------------------------------------------------
  # cursor_right
  #--------------------------------------------------------------------------
  def draw_custom_switch(rect, index, ext)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    enabled = $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]]
    dx = contents.width/2
    change_color(normal_color, !enabled)
    option1 = YEA::SYSTEM::CUSTOM_SWITCHES[ext][2]
    draw_text(dx, rect.y, contents.width/4, line_height, option1, 1)
    dx += contents.width/4
    change_color(normal_color, enabled)
    option2 = YEA::SYSTEM::CUSTOM_SWITCHES[ext][3]
    draw_text(dx, rect.y, contents.width/4, line_height, option2, 1)
  end
  
  #--------------------------------------------------------------------------
  # draw_custom_variable
  #--------------------------------------------------------------------------
  def draw_custom_variable(rect, index, ext)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    id = YEA::SYSTEM::CUSTOM_VARIABLES[ext][0]
    value = $game_variables[id]
    colour1 = text_color(YEA::SYSTEM::CUSTOM_VARIABLES[ext][2])
    colour2 = text_color(YEA::SYSTEM::CUSTOM_VARIABLES[ext][3])
    minimum = YEA::SYSTEM::CUSTOM_VARIABLES[ext][4]
    maximum = YEA::SYSTEM::CUSTOM_VARIABLES[ext][5]
    rate = (value - minimum).to_f / [(maximum - minimum).to_f, 0.01].max
    dx = contents.width/2
    draw_gauge(dx, rect.y, contents.width - dx - 48, rate, colour1, colour2)
    show_text = value
    draw_text(dx, rect.y, contents.width - dx - 48, line_height,show_text, 2)
    #prevent overflow
    $game_variables[id] = minimum if value < minimum
    $game_variables[id] = maximum if value > maximum
  end
  #--------------------------------------------------------------------------
  # * Cursor Movement Processing
  #--------------------------------------------------------------------------
  def process_cursor_move
    super
    process_mouse_click if Mouse.click?(1)
    process_mouse_press if Mouse.press?(1)
  end
  #--------------------------------------------------------------------------
  def process_mouse_click
    case current_symbol
    when :custom_switch
      change_custom_switch(:xor)
    end
  end
  #--------------------------------------------------------------------------
  def process_mouse_press
    rect = get_value_rect
    rect.y += self.y
    case current_symbol
    when :volume_bgm
      value = calc_mouseclick_value(rect, 0, 100)
      set_volume(value) if value
    when :volume_bgs
      value = calc_mouseclick_value(rect, 0, 100)
      set_volume(value) if value
    when :volume_sfx
      value = calc_mouseclick_value(rect, 0, 100)
      set_volume(value) if value
    when :custom_variable
      ext = current_ext
      minn = YEA::SYSTEM::CUSTOM_VARIABLES[ext][4]
      maxn = YEA::SYSTEM::CUSTOM_VARIABLES[ext][5]
      value = calc_mouseclick_value(rect, minn, maxn)
      change_custom_variables(nil, value) if value
    end
  end
  #--------------------------------------------------------------------------
  # cursor_right
  #--------------------------------------------------------------------------
  def cursor_right(wrap = false)
    cursor_change(:right)
    super(wrap)
  end
  #--------------------------------------------------------------------------
  # cursor_left
  #--------------------------------------------------------------------------
  def cursor_left(wrap = false)
    cursor_change(:left)
    super(wrap)
  end
  #--------------------------------------------------------------------------
  # cursor_change
  #--------------------------------------------------------------------------
  def cursor_change(direction)
    case current_symbol
    when :window_red, :window_blu, :window_grn
      change_window_tone(direction)
    when :volume_bgm, :volume_bgs, :volume_sfx
      change_volume(direction)
    when :autodash, :instantmsg, :animations
      change_toggle(direction)
    when :custom_switch
      change_custom_switch(direction)
    when :custom_variable
      change_custom_variables(direction)
    end
  end
  #--------------------------------------------------------------------------
  # change_window_tone
  #--------------------------------------------------------------------------
  def change_window_tone(direction)
    Sound.play_cursor
    value = direction == :left ? -1 : 1
    value *= 10 if Input.press?(:A)
    tone = $game_system.window_tone.clone
    case current_symbol
    when :window_red; tone.red += value
    when :window_grn; tone.green += value
    when :window_blu; tone.blue += value
    end
    $game_system.window_tone = tone
    draw_item(index)
  end
  #--------------------------------------------------------------------------
  # change_window_tone
  #--------------------------------------------------------------------------
  def change_volume(direction)
    Sound.play_cursor
    value = direction == :left ? -1 : 1
    value *= 10 if Input.press?(:A)
    case current_symbol
    when :volume_bgm
      $game_system.volume_change(:bgm, value)
      RPG::BGM::last.play
    when :volume_bgs
      $game_system.volume_change(:bgs, value)
      RPG::BGS::last.play
    when :volume_sfx
      $game_system.volume_change(:sfx, value)
    end
    draw_item(index)
  end
  #--------------------------------------------------------------------------
  def set_volume(value)
    case current_symbol
    when :volume_bgm
      $game_system.set_volume(:bgm, value)
      RPG::BGM::last.play
    when :volume_bgs
      $game_system.set_volume(:bgs, value)
      RPG::BGS::last.play
    when :volume_sfx
      $game_system.set_volume(:sfx, value)
    end
    draw_item(index)
  end
  #--------------------------------------------------------------------------
  # * change_toggle
  #--------------------------------------------------------------------------
  def change_toggle(direction)
    value = direction == :left ? false : true
    case current_symbol
    when :autodash
      current_case = $game_system.autodash?
      $game_system.set_autodash(value)
    when :instantmsg
      current_case = $game_system.instantmsg?
      $game_system.set_instantmsg(value)
    when :animations
      current_case = $game_system.animations?
      $game_system.set_animations(value)
    end
    Sound.play_cursor if value != current_case
    draw_item(index)
  end
  
  #--------------------------------------------------------------------------
  # change_custom_switch
  #--------------------------------------------------------------------------
  def change_custom_switch(direction)
    value = direction == :left ? false : true
    ext = current_ext
    current_case = $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]]
    current_id = YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]
    return unless allow_to_change_switch?(current_id)
    if direction == :xor
      $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]] ^= 1
    else
      $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]] = value
    end
    Sound.play_cursor if value != current_case
    draw_item(index)
  end
  
  #--------------------------------------------------------------------------
  # change_custom_variables
  #--------------------------------------------------------------------------
  def change_custom_variables(direction = nil, d_value = nil)
    value = direction == :left ? -1 : 1
    value *= 10 if Input.press?(:A)
    directly_set = !direction && d_value
    value = d_value   if directly_set
    Sound.play_cursor if !directly_set
    ext = current_ext
    var = YEA::SYSTEM::CUSTOM_VARIABLES[ext][0]
    minimum = YEA::SYSTEM::CUSTOM_VARIABLES[ext][4]
    maximum = YEA::SYSTEM::CUSTOM_VARIABLES[ext][5]
    $game_variables[var] = directly_set ? value : $game_variables[var] + value
    $game_variables[var] = [[$game_variables[var], minimum].max, maximum].min
    draw_item(index)
  end
  
end # Window_SystemOptions
#==============================================================================
# ■ Scene_Menu
#==============================================================================
class Scene_Menu < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # overwrite method: command_game_end
  #--------------------------------------------------------------------------
  def command_game_end
    SceneManager.call(Scene_System)
  end
  
end # Scene_Menu
#==============================================================================
# ■ Scene_System
#==============================================================================
class Scene_System < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # start
  #--------------------------------------------------------------------------
  def start
    super
    create_help_window
    create_command_window
  end
  
  #--------------------------------------------------------------------------
  # create_command_window
  #--------------------------------------------------------------------------
  def create_command_window
    @command_window = Window_SystemOptions.new(@help_window)
    @command_window.set_handler(:cancel, method(:return_scene))
    @command_window.set_handler(:to_title, method(:command_to_title))
    @command_window.set_handler(:shutdown, method(:command_shutdown))
  end
  #--------------------------------------------------------------------------
  # * Create Background
  #--------------------------------------------------------------------------
  def create_background
    super
  end
  #--------------------------------------------------------------------------
  # * Free Background
  #--------------------------------------------------------------------------
  def dispose_background
    super
  end
  #--------------------------------------------------------------------------
  # command_to_title
  # tag: modified
  #--------------------------------------------------------------------------
  def command_to_title
    BlockChain.clear
    fadeout_all
    SceneManager.goto(Scene_Title)
  end
  
  #--------------------------------------------------------------------------
  # command_shutdown
  #--------------------------------------------------------------------------
  def command_shutdown
    fadeout_all
    SceneManager.exit
  end
  
end # Scene_System
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
# ■ Window_SystemOptions
#==============================================================================
class Window_SystemOptions < Window_Command
  #--------------------------------------------------------------------------
  # * Check if allow to change_custom_switch
  #--------------------------------------------------------------------------
  def allow_to_change_switch?(id)
    case id
    when 0;
    end
    return true
  end
  #--------------------------------------------------------------------------
  # * Overwrite: change_custom_switch
  #--------------------------------------------------------------------------
  def change_custom_switch(direction)
    value = direction == :left ? false : true
    ext = current_ext
    current_case = $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]]
    current_id = YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]
    
    return unless allow_to_change_switch?(current_id)
    
    if direction == :xor
      $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]] ^= 1
    else
      $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]] = value
    end
    
    on_switch_change(current_id, $game_switches[YEA::SYSTEM::CUSTOM_SWITCHES[ext][0]])
    Sound.play_cursor if value != current_case
    draw_item(index)
  end
  #--------------------------------------------------------------------------
  def on_switch_change(id, stat)
    case id
    when 0;
    end
  end
  #--------------------------------------------------------------------------
  # Overwrite: draw_custom_variable
  #--------------------------------------------------------------------------
  def draw_custom_variable(rect, index, ext)
    name = @list[index][:name]
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    #---
    dx = contents.width / 2
    id = YEA::SYSTEM::CUSTOM_VARIABLES[ext][0]
    value = $game_variables[id]
    colour1 = text_color(YEA::SYSTEM::CUSTOM_VARIABLES[ext][2])
    colour2 = text_color(YEA::SYSTEM::CUSTOM_VARIABLES[ext][3])
    minimum = YEA::SYSTEM::CUSTOM_VARIABLES[ext][4]
    maximum = YEA::SYSTEM::CUSTOM_VARIABLES[ext][5]
    rate = (value - minimum).to_f / [(maximum - minimum).to_f, 0.01].max
    dx = contents.width/2
    draw_gauge(dx, rect.y, contents.width - dx - 48, rate, colour1, colour2)
    
    show_text = get_setting_type_text(id, value)
    show_text = value if !show_text
    draw_text(dx, rect.y, contents.width - dx - 48, line_height,show_text, 2)
    # prevent overflow
    $game_variables[id] = minimum if value < minimum
    $game_variables[id] = maximum if value > maximum
  end
  #--------------------------------------------------------------------------
  def get_setting_type_text(id, value)
    case id
    when 33 # Combat difficulty
      return Vocab::System::DifficultyName[0] if value == 0
      return Vocab::System::DifficultyName[1] if value == 1
      return Vocab::System::DifficultyName[2] if value == 2
      return Vocab::System::DifficultyName[3] if value == 3
    end
  end
  #--------------------------------------------------------------------------
  # Alias: ok_enabled?
  #--------------------------------------------------------------------------
  alias :language_ok_enabled? :ok_enabled?
  def ok_enabled?
    return true if [:language].include?(current_symbol)
    return language_ok_enabled?
  end
  #--------------------------------------------------------------------------
  # Overwrite: make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    @help_descriptions = {}
    for command in YEA::SYSTEM::COMMANDS
      case command
      when :blank
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :window_red, :window_grn, :window_blu
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :volume_bgm, :volume_bgs, :volume_sfx
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :autodash, :instantmsg, :animations
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :to_title, :shutdown
        next if SceneManager.scene_is?(Scene_Title)
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      when :language
        add_command(YEA::SYSTEM::COMMAND_VOCAB[command][0], command)
        @help_descriptions[command] = YEA::SYSTEM::COMMAND_VOCAB[command][3]
      else
        process_custom_switch(command)
        process_custom_variable(command)
      end
    end
  end
  #--------------------------------------------------------------------------
  # * Overwrite: draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    reset_font_settings
    rect = item_rect(index)
    contents.clear_rect(rect)
    case @list[index][:symbol]
    when :window_red, :window_grn, :window_blu
      draw_window_tone(rect, index, @list[index][:symbol])
    when :volume_bgm, :volume_bgs, :volume_sfx
      draw_volume(rect, index, @list[index][:symbol])
    when :autodash, :instantmsg, :animations
      draw_toggle(rect, index, @list[index][:symbol])
    when :to_title, :shutdown
      draw_text(item_rect_for_text(index), command_name(index), 1)
    when :language
      draw_language_setting(index)
    when :custom_switch
      draw_custom_switch(rect, index, @list[index][:ext])
    when :custom_variable
      draw_custom_variable(rect, index, @list[index][:ext])
    end
  end
  #--------------------------------------------------------------------------
  def draw_language_setting(index)
    rect = item_rect(index)
    name = command_name(index)
    draw_text(0, rect.y, contents.width/2, line_height, name, 1)
    dx   = contents.width / 2
    option = $supported_languages[GameManager.get_language_setting]
    draw_text(dx, rect.y, contents.width/4, line_height, option, 1)
  end
  #--------------------------------------------------------------------------
  def create_overlay_window
    info = Vocab::System::UnsavedInfo
    @overlay_window = Window_Confirm.new(nil, nil, nil, nil, info)
  end
  #--------------------------------------------------------------------------
  def call_ok_handler
    if current_symbol == :to_title || current_symbol == :shutdown
      raise_overlay(nil, :call_handler, current_symbol)
    else
      super
    end
  end
  #--------------------------------------------------------------------------
end
#==============================================================================
# ■ Scene_System
#==============================================================================
class Scene_System < Scene_MenuBase
  #--------------------------------------------------------------------------
  # * Alias: start
  #--------------------------------------------------------------------------
  alias start_lanwin start
  def start
    start_lanwin
    create_language_window
  end
  #--------------------------------------------------------------------------
  # * Create Background
  #--------------------------------------------------------------------------
  def create_background
    @background_sprite = Sprite.new
    @background_sprite.bitmap = Cache.background("canterlot_library")
  end
  #--------------------------------------------------------------------------
  # Alias: create_command_window
  #--------------------------------------------------------------------------
  alias create_command_lan_window create_command_window
  def create_command_window
    create_command_lan_window
    @command_window.set_handler(:language, method(:command_language))
  end
  #--------------------------------------------------------------------------
  def create_language_window
    ww = 400 # window width
    wh = 320 # height
    cx = Graphics.center_width(ww)
    cy = Graphics.center_height(wh)
    @language_window = Window_LanguageList.new(cx, cy, ww, wh)
    @language_window.set_handler(:ok, method(:on_language_ok))
    @language_window.set_handler(:cancel, method(:on_language_cancel))
    @language_window.z = @command_window.z + 1
    @language_window.refresh
    @language_window.hide
  end
  #--------------------------------------------------------------------------
  def command_language
    @language_window.show
    @language_window.activate
    cur_index = GameManager.get_language_setting
    cur_index = ($supported_languages.keys.find_index(cur_index) || 0)
    @language_window.select(cur_index)
  end
  #--------------------------------------------------------------------------
  def on_language_ok
    symbol = @language_window.item
    raise_overlay_window(:popinfo, Vocab::System::Restart)
    on_language_cancel
    FileManager.write_ini('Option', 'Language', symbol.to_s)
    language_index = -1
    data = @command_window.list
    data.each_index{|i| language_index = i if data[i][:symbol] == :language}
    @command_window.draw_item(language_index) if language_index > 0
  end
  #--------------------------------------------------------------------------
  def on_language_cancel
    @language_window.hide
    @command_window.activate
  end
  #--------------------------------------------------------------------------
end

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Ace Core Engine v1.09
# -- Last Updated: 2012.02.19
# -- Level: Easy, Normal
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-CoreEngine"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.02.19 - Bug Fixed: Parallax updating works properly with looping maps.
# 2012.02.10 - Bug Fixed: Forced actions no longer cancel out other actions
#              that have been queued up for later.
# 2012.01.08 - Font resets no longer reset bold and italic to off, but instead
#              to whatever default you've set.
# 2011.12.26 - New Bugfix: When using substitute, allies will no longer take
#              place of low HP allies for friendly skills.
# 2011.12.20 - New Bugfix: Force Action no longer cancels out an actor's queue.
#              Credits to Yami for finding and making the fix for!
#              Switch added for those who want removed forced action battlers.
# 2011.12.15 - Updated for better menu gauge appearance.
# 2011.12.10 - Bug Fixed: Right and bottom sides of the map would show
#              the left and top sides of the map.
#            - Bug Fixed: Viewport sizes didn't refresh from smaller maps.
# 2011.12.07 - New Bugfix: Dual weapon normal attacks will now play both
#              animations without one animation interrupting the other.
# 2011.12.04 - Updated certain GUI extensions for increased screen size.
#            - More efficient digit grouping method credits to TDS.
# 2011.12.01 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This is the core engine for Yanfly Engine Ace, made for RPG Maker VX Ace.
# This script provides various changes made to the main engine including bug
# fixes and GUI upgrades.
# 
# -----------------------------------------------------------------------------
# Bug Fix: Animation Overlay
# -----------------------------------------------------------------------------
# - It's the same bug from VX. When an all-screen animation is played against a
# group of enemies, the animation bitmap is actually made multiple times, thus
# causing a pretty extreme overlay when there are a lot of enemies on screen.
# This fix will cause the animation to play only once.
# 
# -----------------------------------------------------------------------------
# Bug Fix: Animation Interruption
# -----------------------------------------------------------------------------
# - A new bug. When a character dual wields and attacks a single target, if an
# animation lasts too long, it will interrupt and/or halt the next animation
# from occurring. This script will cause the first animation to finish playing
# and then continue forth.
# 
# -----------------------------------------------------------------------------
# Bug Fix: Battle Turn Order Fix
# -----------------------------------------------------------------------------
# - Same bug from VX. For those who use the default battle system, once a
# turn's started, the action order for the turn becomes set and unchanged for
# the remainder of that turn. Any changes to a battler's AGI will not be
# altered at all even if the battler were to receive an AGI buff or debuff.
# This fix will cause the speed to be updated properly upon each action.
# 
# -----------------------------------------------------------------------------
# Bug Fix: Forced Action Fix
# -----------------------------------------------------------------------------
# - A new bug. When a battler is forced to perform an action, the battler's
# queued action is removed and the battler loses its place in battle. This
# fix will resume queue after a forced action.
# 
# -----------------------------------------------------------------------------
# Bug Fix: Gauge Overlap Fix
# -----------------------------------------------------------------------------
# - Same bug from VX. When some values exceed certain amounts, gauges can
# overextend past the width they were originally designed to fit in. This fix
# will prevent any overextending from gauges.
# 
# -----------------------------------------------------------------------------
# Bug Fix: Held L and R Menu Scrolling
# -----------------------------------------------------------------------------
# - Before in VX, you can scroll through menus by holding down L and R buttons
# (Q and W on the keyboard) to scroll through menus quickly. This fix will
# re-enable the ability to scroll through menus in such a fashion. Disable it
# in the module if you wish to.
# 
# -----------------------------------------------------------------------------
# Bug Fix: Substitute Healing
# -----------------------------------------------------------------------------
# If an actor has the substitute (cover) flag on them, they will attempt to
# take the place of low HP allies when they're the target of attack. However,
# this is also the case for friendly skills such as heal. This script will fix
# it where if a battler targets an ally, no substitutes will take place.
# 
# -----------------------------------------------------------------------------
# New Feature: Screen Resolution Size
# -----------------------------------------------------------------------------
# - The screen can now be resized from 544x416 with ease and still support maps
# that are smaller than 544x416. Maps smaller than 544x416 will be centered on
# the screen without having sprites jumping all over the place.
# 
# -----------------------------------------------------------------------------
# New Feature: Adjust Animation Speed
# -----------------------------------------------------------------------------
# - RPG Maker VX Ace plays animations at a rate of 15 FPS by default. Speed up
# the animations by changing a simple constant in the module.
# 
# -----------------------------------------------------------------------------
# New Feature: GUI Modifications
# -----------------------------------------------------------------------------
# - There are quite a lot of different modifications you can do to the GUI.
# This includes placing outlines around your gauges, changing the colours of 
# each individual font aspect, and more. Also, you can change the default font
# setting for your games here.
# 
# -----------------------------------------------------------------------------
# New Feature: Numeric Digit Grouping
# -----------------------------------------------------------------------------
# This will change various scenes to display numbers in groups where they are
# separated by a comma every three digits. Thus, a number like 1234567 will
# show up as 1,234,567. This allows for players to read numbers quicker.
# 
# And that's all for the bug fixes and features!
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
module YEA
  module CORE
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Screen Resolution Size -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # RPG Maker VX Ace has the option of having larger width and height for
    # your games. Resizing the width and height will have these changes:
    # 
    #              Default   Resized   Min Tiles Default   Min Tiles New
    #    Width       544       640           17                 20
    #    Height      416       480           13                 15
    # 
    # * Note: Maximum width is 640 while maximum height is 480.
    #         Minimum width is 110 while maximum height is 10.
    #         These are limitations set by RPG Maker VX Ace's engine.
    # 
    # By selecting resize, all of the default menus will have their windows
    # adjusted, but scripts provided by non-Yanfly Engine sources may or may
    # not adjust themselves properly.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    RESIZE_WIDTH  = 640
    RESIZE_HEIGHT = 416
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Adjust Animation Speed -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # By default, the animation speed played in battles operates at 15 FPS
    # (frames per second). For those who would like to speed it up, change this
    # constant to one of these values:
    #   RATE   Speed
    #     4      15 fps
    #     3      20 fps
    #     2      30 fps
    #     1      60 fps
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    ANIMATION_RATE = 4
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Digit Grouping -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Setting this to true will cause numbers to be grouped together when they
    # are larger than a thousand. For example, 12345 will appear as 12,345.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    GROUP_DIGITS = true
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Font Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Adjust the default font settings for your game here. The various settings
    # will be explained below.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    FONT_NAME = ["Celestia Medium Redux"]
    # This adjusts the fonts used for your game. If the font at the start of
    # the array doesn't exist on the player's computer, it'll use the next one.
    FONT_SIZE = 24       # Adjusts font size. Default: 24
    FONT_BOLD = false   # Makes font bold. Default: false
    FONT_ITALIC = false  # Makes font italic. Default: false
    FONT_SHADOW = false  # Gives font a shadow. Default: false
    FONT_OUTLINE = true  # Gives font an outline. Default: true
    FONT_COLOUR = Color.new(255, 255, 255, 255)   # Default: 255, 255, 255, 255
    FONT_OUTLINE_COLOUR = Color.new(0, 0, 0, 128) # Default:   0,   0,   0, 128
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Forced Action Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # For those who would like to allow the game to remove a forced action
    # battler from the queue list, use the switch below. If you don't want to
    # use this option, set the switch ID to 0.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    FORCED_ACTION_REMOVE_SWITCH = 0
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Gauge Appearance Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # You can modify the way your gauges appear in the game. If you wish for
    # them to have an outline, it's possible. You can also adjust the height
    # of the gauges, too.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    GAUGE_OUTLINE = true
    GAUGE_HEIGHT = 3 #Default 12
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Held L and R Menu Scrolling -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # VX gave the ability to scroll through menus quickly through holding the
    # L and R buttons (Q and W on the keyboard). VX Ace disabled it. Now, you
    # can re-enable the ability to scroll faster by setting this constant to
    # true. To disable it, set this constant to false.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    QUICK_SCROLLING = true
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - System Text Colours -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Sometimes the system text colours are boring as just orange for HP, blue
    # for MP, and green for TP. Change the values here. Each number corresponds
    # to the colour index of the Window.png skin found in Graphics\System.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COLOURS ={
    # :text       => ID
      :normal     =>  0,   # Default:  0
      :system     => 16,   # Default: 16
      :crisis     => 17,   # Default: 17
      :knockout   => 18,   # Default: 18
      :gauge_back => 19,   # Default: 19
      :hp_gauge1  => 28,   # Default: 20
      :hp_gauge2  => 29,   # Default: 21
      :mp_gauge1  => 22,   # Default: 22
      :mp_gauge2  => 23,   # Default: 23
      :mp_cost    => 23,   # Default: 23
      :power_up   => 24,   # Default: 24
      :power_down => 25,   # Default: 25
      :tp_gauge1  => 10,   # Default: 28
      :tp_gauge2  =>  2,   # Default: 29
      :tp_cost    =>  2,   # Default: 29
    } # Do not remove this.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - System Text Options -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Here, you can adjust the transparency used for disabled items, the %
    # needed for HP and MP to enter "crisis" mode.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    TRANSPARENCY = 160   # Adjusts transparency of disabled items. Default: 160
    HP_CRISIS = 0.25     # When HP is considered critical. Default: 0.25
    MP_CRISIS = 0.25     # When MP is considered critical. Default: 0.25
    ITEM_AMOUNT = "×%s"  # The prefix used for item amounts.
    
  end # CORE
end # YEA
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
Graphics.resize_screen(YEA::CORE::RESIZE_WIDTH, YEA::CORE::RESIZE_HEIGHT)
Font.default_name = YEA::CORE::FONT_NAME
Font.default_size = YEA::CORE::FONT_SIZE
Font.default_bold = YEA::CORE::FONT_BOLD
Font.default_italic = YEA::CORE::FONT_ITALIC
Font.default_shadow = YEA::CORE::FONT_SHADOW
Font.default_outline = YEA::CORE::FONT_OUTLINE
Font.default_color = YEA::CORE::FONT_COLOUR
Font.default_out_color = YEA::CORE::FONT_OUTLINE_COLOUR
#==============================================================================
# ■ Numeric
#==============================================================================
class Numeric  
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  def group
    return self.to_s unless YEA::CORE::GROUP_DIGITS
    self.to_s.gsub(/(\d)(?=\d{3}+(?:\.|$))(\d{3}\..*)?/,'\1,\2')
  end
  
end # Numeric
#==============================================================================
# ■ Switch
#==============================================================================
module Switch
  
  #--------------------------------------------------------------------------
  # self.forced_action_remove
  #--------------------------------------------------------------------------
  def self.forced_action_remove
    return false if YEA::CORE::FORCED_ACTION_REMOVE_SWITCH <= 0
    return $game_switches[YEA::CORE::FORCED_ACTION_REMOVE_SWITCH]
  end
  
end # Switch
#==============================================================================
# ■ BattleManager
#==============================================================================
module BattleManager
  
  #--------------------------------------------------------------------------
  # overwrite method: turn_start
  #--------------------------------------------------------------------------
  def self.turn_start
    @phase = :turn
    clear_actor
    $game_troop.increase_turn
    @performed_battlers = []
    make_action_orders
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: next_subject
  #--------------------------------------------------------------------------
  def self.next_subject
    @performed_battlers = [] if @performed_battlers.nil?
    loop do
      @action_battlers -= @performed_battlers
      battler = @action_battlers.shift
      return nil unless battler
      next unless battler.index && battler.alive?
      @performed_battlers.push(battler)
      return battler
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: force_action
  #--------------------------------------------------------------------------
  def self.force_action(battler)
    @action_forced = [] if @action_forced == nil
    @action_forced.push(battler)
    return unless Switch.forced_action_remove
    @action_battlers.delete(battler)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: action_forced?
  #--------------------------------------------------------------------------
  def self.action_forced?
    @action_forced != nil
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: action_forced_battler
  #--------------------------------------------------------------------------
  def self.action_forced_battler
    @action_forced.shift
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: clear_action_force
  #--------------------------------------------------------------------------
  def self.clear_action_force
    @action_forced = nil if @action_forced.empty?
  end
  
end # BattleManager
#==============================================================================
# ■ Game_Battler
#==============================================================================
class Game_Battler < Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :pseudo_ani_id
  
  #--------------------------------------------------------------------------
  # alias method: clear_sprite_effects
  #--------------------------------------------------------------------------
  alias game_battler_clear_sprite_effects_ace clear_sprite_effects
  def clear_sprite_effects
    game_battler_clear_sprite_effects_ace
    @pseudo_ani_id = 0
  end
  
  #--------------------------------------------------------------------------
  # alias method: force_action
  #--------------------------------------------------------------------------
  alias game_battler_force_action_ace force_action
  def force_action(skill_id, target_index)
    clone_current_actions
    game_battler_force_action_ace(skill_id, target_index)
  end
  
  #--------------------------------------------------------------------------
  # new method: clone_current_actions
  #--------------------------------------------------------------------------
  def clone_current_actions
    @cloned_actions = @actions.dup
  end
  
  #--------------------------------------------------------------------------
  # new method: restore_cloned_actions
  #--------------------------------------------------------------------------
  def restore_cloned_actions
    return if @cloned_actions.nil?
    @actions = @cloned_actions.dup
    @cloned_actions = nil
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_action_end
  #--------------------------------------------------------------------------
  alias game_battler_on_action_end_ace on_action_end
  def on_action_end
    game_battler_on_action_end_ace
    restore_cloned_actions
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_battle_end
  #--------------------------------------------------------------------------
  alias game_battler_on_battle_end_ace on_battle_end
  def on_battle_end
    game_battler_on_battle_end_ace
    @cloned_actions = nil
  end
  
end # Game_Battler
#==============================================================================
# ■ Game_Troop
#==============================================================================
class Game_Troop < Game_Unit
  
  #--------------------------------------------------------------------------
  # overwrite method: setup
  #--------------------------------------------------------------------------
  def setup(troop_id)
    clear
    @troop_id = troop_id
    @enemies = []
    troop.members.each do |member|
      next unless $data_enemies[member.enemy_id]
      enemy = Game_Enemy.new(@enemies.size, member.enemy_id)
      enemy.hide if member.hidden
      enemy.screen_x = member.x + (Graphics.width - 544)/2
      enemy.screen_y = member.y + (Graphics.height - 416)
      @enemies.push(enemy)
    end
    init_screen_tone
    make_unique_names
  end
  
end # Game_Troop
#==============================================================================
# ■ Game_Map
#==============================================================================
class Game_Map
  
  #--------------------------------------------------------------------------
  # overwrite method: scroll_down
  #--------------------------------------------------------------------------
  def scroll_down(distance)
    if loop_vertical?
      @display_y += distance
      @display_y %= @map.height * 256
      @parallax_y += distance if @parallax_loop_y
    else
      last_y = @display_y
      dh = Graphics.height > height * 32 ? height : screen_tile_y
      @display_y = [@display_y + distance, height - dh].min
      @parallax_y += @display_y - last_y
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: scroll_right
  #--------------------------------------------------------------------------
  def scroll_right(distance)
    if loop_horizontal?
      @display_x += distance
      @display_x %= @map.width * 256
      @parallax_x += distance if @parallax_loop_x
    else
      last_x = @display_x
      dw = Graphics.width > width * 32 ? width : screen_tile_x
      @display_x = [@display_x + distance, width - dw].min
      @parallax_x += @display_x - last_x
    end
  end
  
end # Game_Map
#==============================================================================
# ■ Game_Event
#==============================================================================
class Game_Event < Game_Character
  
  #--------------------------------------------------------------------------
  # overwrite method: near_the_screen?
  #--------------------------------------------------------------------------
  def near_the_screen?(dx = nil, dy = nil)
    dx = [Graphics.width, $game_map.width * 256].min/32 - 5 if dx.nil?
    dy = [Graphics.height, $game_map.height * 256].min/32 - 5 if dy.nil?
    ax = $game_map.adjust_x(@real_x) - Graphics.width / 2 / 32
    ay = $game_map.adjust_y(@real_y) - Graphics.height / 2 / 32
    ax >= -dx && ax <= dx && ay >= -dy && ay <= dy
  end
  
end # Game_Event
#==============================================================================
# ■ Sprite_Base
#==============================================================================
class Sprite_Base < Sprite
  
  #--------------------------------------------------------------------------
  # overwrite method: set_animation_rate
  #--------------------------------------------------------------------------
  def set_animation_rate
    @ani_rate = YEA::CORE::ANIMATION_RATE
  end
  
  #--------------------------------------------------------------------------
  # new method: start_pseudo_animation
  #--------------------------------------------------------------------------
  def start_pseudo_animation(animation, mirror = false)
    dispose_animation
    @animation = animation
    return if @animation.nil?
    @ani_mirror = mirror
    set_animation_rate
    @ani_duration = @animation.frame_max * @ani_rate + 1
    @ani_sprites = []
  end
  
end # Sprite_Base
#==============================================================================
# ■ Sprite_Battler
#==============================================================================
class Sprite_Battler < Sprite_Base
  
  #--------------------------------------------------------------------------
  # alias method: setup_new_animation
  #--------------------------------------------------------------------------
  alias sprite_battler_setup_new_animation_ace setup_new_animation
  def setup_new_animation
    sprite_battler_setup_new_animation_ace
    return if @battler.nil?
    return if @battler.pseudo_ani_id.nil?
    return if @battler.pseudo_ani_id <= 0
    animation = $data_animations[@battler.pseudo_ani_id]
    mirror = @battler.animation_mirror
    start_pseudo_animation(animation, mirror)
    @battler.pseudo_ani_id = 0
  end
  
end # Sprite_Battler
#==============================================================================
# ■ Spriteset_Map
#==============================================================================
class Spriteset_Map
  
  #--------------------------------------------------------------------------
  # overwrite method: create_viewports
  #--------------------------------------------------------------------------
  def create_viewports
    if Graphics.width > $game_map.width * 32 && !$game_map.loop_horizontal?
      dx = (Graphics.width - $game_map.width * 32) / 2
    else
      dx = 0
    end
    dw = [Graphics.width, $game_map.width * 32].min
    dw = Graphics.width if $game_map.loop_horizontal?
    if Graphics.height > $game_map.height * 32 && !$game_map.loop_vertical?
      dy = (Graphics.height - $game_map.height * 32) / 2
    else
      dy = 0
    end
    dh = [Graphics.height, $game_map.height * 32].min
    dh = Graphics.height if $game_map.loop_vertical?
    @viewport1 = Viewport.new(dx, dy, dw, dh)
    @viewport2 = Viewport.new(dx, dy, dw, dh)
    @viewport3 = Viewport.new(dx, dy, dw, dh)
    @viewport2.z = 50
    @viewport3.z = 100
    
  end
  
  #--------------------------------------------------------------------------
  # new method: update_viewport_sizes
  #--------------------------------------------------------------------------
  def update_viewport_sizes
    if Graphics.width > $game_map.width * 32 && !$game_map.loop_horizontal?
      dx = (Graphics.width - $game_map.width * 32) / 2
    else
      dx = 0
    end
    dw = [Graphics.width, $game_map.width * 32].min
    dw = Graphics.width if $game_map.loop_horizontal?
    if Graphics.height > $game_map.height * 32 && !$game_map.loop_vertical?
      dy = (Graphics.height - $game_map.height * 32) / 2
    else
      dy = 0
    end
    dh = [Graphics.height, $game_map.height * 32].min
    dh = Graphics.height if $game_map.loop_vertical?
    rect = Rect.new(dx, dy, dw, dh)
    for viewport in [@viewport1, @viewport2, @viewport3]
      viewport.rect = rect
    end
  end
  
end # Spriteset_Map
#==============================================================================
# ■ Window_Base
#==============================================================================
class Window_Base < Window
  
  #--------------------------------------------------------------------------
  # overwrite method: reset_font_settings
  #--------------------------------------------------------------------------
  def reset_font_settings
    change_color(normal_color)
    contents.font.size = Font.default_size
    contents.font.bold = Font.default_bold
    contents.font.italic = Font.default_italic
    contents.font.out_color = Font.default_out_color
  end
  
  #--------------------------------------------------------------------------
  # overwrite methods: color
  #--------------------------------------------------------------------------
  def normal_color;      text_color(YEA::CORE::COLOURS[:normal]);      end;
  def system_color;      text_color(YEA::CORE::COLOURS[:system]);      end;
  def crisis_color;      text_color(YEA::CORE::COLOURS[:crisis]);      end;
  def knockout_color;    text_color(YEA::CORE::COLOURS[:knockout]);    end;
  def gauge_back_color;  text_color(YEA::CORE::COLOURS[:gauge_back]);  end;
  def hp_gauge_color1;   text_color(YEA::CORE::COLOURS[:hp_gauge1]);   end;
  def hp_gauge_color2;   text_color(YEA::CORE::COLOURS[:hp_gauge2]);   end;
  def mp_gauge_color1;   text_color(YEA::CORE::COLOURS[:mp_gauge1]);   end;
  def mp_gauge_color2;   text_color(YEA::CORE::COLOURS[:mp_gauge2]);   end;
  def mp_cost_color;     text_color(YEA::CORE::COLOURS[:mp_cost]);     end;
  def power_up_color;    text_color(YEA::CORE::COLOURS[:power_up]);    end;
  def power_down_color;  text_color(YEA::CORE::COLOURS[:power_down]);  end;
  def tp_gauge_color1;   text_color(YEA::CORE::COLOURS[:tp_gauge1]);   end;
  def tp_gauge_color2;   text_color(YEA::CORE::COLOURS[:tp_gauge2]);   end;
  def tp_cost_color;     text_color(YEA::CORE::COLOURS[:tp_cost]);     end;
  
  #--------------------------------------------------------------------------
  # overwrite method: translucent_alpha
  #--------------------------------------------------------------------------
  def translucent_alpha
    return YEA::CORE::TRANSPARENCY
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: hp_color
  #--------------------------------------------------------------------------
  def hp_color(actor)
    return knockout_color if actor.hp == 0  
    return crisis_color if actor.hp < actor.mhp * YEA::CORE::HP_CRISIS
    return normal_color
  end
  #--------------------------------------------------------------------------
  # overwrite method: mp_color
  #--------------------------------------------------------------------------
  def mp_color(actor)
    return crisis_color if actor.mp < actor.mmp * YEA::CORE::MP_CRISIS
    return normal_color
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_gauge
  #--------------------------------------------------------------------------
  def draw_gauge(dx, dy, dw, rate, color1, color2)
    dw -= 2 if YEA::CORE::GAUGE_OUTLINE
    fill_w = [(dw * rate).to_i, dw].min
    gauge_h = YEA::CORE::GAUGE_HEIGHT
    gauge_y = dy + line_height - 2 - gauge_h
    if YEA::CORE::GAUGE_OUTLINE
      outline_colour = gauge_back_color
      outline_colour.alpha = translucent_alpha
      contents.fill_rect(dx, gauge_y-1, dw+2, gauge_h+2, outline_colour)
      dx += 1
    end
    contents.fill_rect(dx, gauge_y, dw, gauge_h, gauge_back_color)
    contents.gradient_fill_rect(dx, gauge_y, fill_w, gauge_h, color1, color2)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_actor_level
  #--------------------------------------------------------------------------
  def draw_actor_level(actor, dx, dy)
    change_color(system_color)
    draw_text(dx, dy, 32, line_height, Vocab::level_a)
    change_color(normal_color)
    draw_text(dx + 32, dy, 24, line_height, actor.level.group, 2)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_current_and_max_values
  #--------------------------------------------------------------------------
  def draw_current_and_max_values(dx, dy, dw, current, max, color1, color2)
    current = current.to_i; max = max.to_i;
    total = current.group + "/" + max.group
    if dw < text_size(total).width + text_size(Vocab.hp_a).width
      change_color(color1)
      draw_text(dx, dy, dw, line_height, current.group, 2)
    else
      xr = dx + text_size(Vocab.hp).width
      dw -= text_size(Vocab.hp).width
      change_color(color2)
      text = "/" + max.group
      draw_text(xr, dy, dw, line_height, text, 2)
      dw -= text_size(text).width
      change_color(color1)
      draw_text(xr, dy, dw, line_height, current.group, 2)
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_actor_tp
  #--------------------------------------------------------------------------
  def draw_actor_tp(actor, x, y, width = 124)
    draw_gauge(x, y, width, actor.tp_rate, tp_gauge_color1, tp_gauge_color2)
    change_color(system_color)
    draw_text(x, y, 30, line_height, Vocab::tp_a)
    change_color(tp_color(actor))
    draw_text(x + width - 42, y, 42, line_height, actor.tp.to_i.group, 2)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_actor_param
  #--------------------------------------------------------------------------
  def draw_actor_param(actor, x, y, param_id)
    change_color(system_color)
    draw_text(x, y, 120, line_height, Vocab::param(param_id))
    change_color(normal_color)
    draw_text(x + 120, y, 36, line_height, actor.param(param_id).group, 2)
  end
=begin
  #--------------------------------------------------------------------------
  # overwrite method: draw_currency_value
  #--------------------------------------------------------------------------
  def draw_currency_value(value, unit, x, y, width)
    cx = text_size(unit).width
    change_color(normal_color)
    draw_text(x, y, width - cx - 2, line_height, value.group, 2)
    change_color(system_color)
    draw_text(x, y, width, line_height, unit, 2)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_actor_simple_status
  #--------------------------------------------------------------------------
  def draw_actor_simple_status(actor, dx, dy)
    draw_actor_name(actor, dx, dy)
    draw_actor_level(actor, dx, dy + line_height * 1)
    draw_actor_icons(actor, dx, dy + line_height * 2)
    dw = contents.width - dx - 124
    draw_actor_class(actor, dx + 120, dy, dw)
    draw_actor_hp(actor, dx + 120, dy + line_height * 1, dw)
    draw_actor_mp(actor, dx + 120, dy + line_height * 2, dw)
  end
=end
end # Window_Base
#==============================================================================
# ■ Window_ItemList
#==============================================================================
class Window_ItemList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    return if item.nil?
    rect = item_rect(index)
    rect.width -= 4
    draw_item_name(item, rect.x, rect.y, enable?(item), rect.width - 24)
    draw_item_number(rect, item)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_item_number
  #--------------------------------------------------------------------------
  def draw_item_number(rect, item)
    text = sprintf(YEA::CORE::ITEM_AMOUNT, $game_party.item_number(item).group)
    draw_text(rect, text, 2)
  end
  
end # Window_ItemList
#==============================================================================
# ■ Window_Status
#==============================================================================
class Window_Status < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_exp_info
  #--------------------------------------------------------------------------
  def draw_exp_info(x, y)
    s1 = @actor.max_level? ? "-------" : @actor.exp
    s2 = @actor.max_level? ? "-------" : @actor.next_level_exp - @actor.exp
    s2 = Vocab::Upgradeable if s2 <= 0
    s_next = sprintf(Vocab::ExpNext, Vocab::level)
    change_color(system_color)
    draw_text(x, y + line_height * 0, 180, line_height, Vocab::ExpTotal)
    draw_text(x, y + line_height * 2, 180, line_height, s_next)
    change_color(normal_color)
    s1 = s1.group if s1.is_a?(Integer)
    s2 = s2.group if s2.is_a?(Integer)
    draw_text(x, y + line_height * 1, 180, line_height, s1, 2)
    draw_text(x, y + line_height * 3, 180, line_height, s2, 2)
  end
  
end # Window_Status
#==============================================================================
# ■ Window_ShopBuy
#==============================================================================
class Window_ShopBuy < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    rect = item_rect(index)
    draw_item_name(item, rect.x, rect.y, enable?(item))
    rect.width -= 4
    draw_text(rect, price(item).group, 2)
  end
  
end # Window_ShopBuy
#==============================================================================
# ■ Scene_Map
#==============================================================================
class Scene_Map < Scene_Base
  
  #--------------------------------------------------------------------------
  # alias method: post_transfer
  #--------------------------------------------------------------------------
  alias scene_map_post_transfer_ace post_transfer
  def post_transfer
    @spriteset.update_viewport_sizes
    scene_map_post_transfer_ace
  end
  
end # Scene_Map
#==============================================================================
# ■ Scene_Battle
#==============================================================================
class Scene_Battle < Scene_Base
  
  #--------------------------------------------------------------------------
  # alias method: check_substitute
  #--------------------------------------------------------------------------
  alias scene_battle_check_substitute_ace check_substitute
  def check_substitute(target, item)
    return false if @subject.actor? == target.actor?
    return scene_battle_check_substitute_ace(target, item)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: process_forced_action
  #--------------------------------------------------------------------------
  def process_forced_action
    while BattleManager.action_forced?
      last_subject = @subject
      @subject = BattleManager.action_forced_battler
      process_action
      @subject = last_subject
      BattleManager.clear_action_force
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: show_attack_animation
  #--------------------------------------------------------------------------
  def show_attack_animation(targets)
    if @subject.actor?
      show_normal_animation(targets, @subject.atk_animation_id1, false)
      wait_for_animation
      show_normal_animation(targets, @subject.atk_animation_id2, true)
    else
      Sound.play_enemy_attack
      abs_wait_short
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: show_normal_animation
  #--------------------------------------------------------------------------
  def show_normal_animation(targets, animation_id, mirror = false)
    animation = $data_animations[animation_id]
    return if animation.nil?
    ani_check = false
    targets.each do |target|
      if ani_check && target.animation_id <= 0
        target.pseudo_ani_id = animation_id
      else
        target.animation_id = animation_id
      end
      target.animation_mirror = mirror
      abs_wait_short unless animation.to_screen?
      ani_check = true if animation.to_screen?
    end
    abs_wait_short if animation.to_screen?
  end
  
end # Scene_Battle
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#-------------------------------------------------------------------------------
# * [ACE] Khas Awesome Light Effects
#-------------------------------------------------------------------------------
# * By Khas Arcthunder - arcthunder.site40.net
# * Version: 1.0 EN
# * Released on: 17/01/2012
#
#-------------------------------------------------------------------------------
# * Terms of Use
#-------------------------------------------------------------------------------
# When using any Khas script, you agree with the following terms:
# 1. You must give credit to Khas;
# 2. All Khas scripts are licensed under a Creative Commons license;
# 3. All Khas scripts are for non-commercial projects. If you need some script 
#    for your commercial project (I accept requests for this type of project), 
#    send an email to nilokruch@live.com with your request;
# 4. All Khas scripts are for personal use, you can use or edit for your own 
#    project, but you are not allowed to post any modified version;
# 5. You can’t give credit to yourself for posting any Khas script;
# 6. If you want to share a Khas script, don’t post the direct download link, 
#    please redirect the user to arcthunder.site40.net
#
#-------------------------------------------------------------------------------
# * Features
#-------------------------------------------------------------------------------
# - Realistic Light
# - Light does not pass over walls, blocks and roofs
# - Static Light Sources
# - Dynamic Light Sources (like a player's lantern)
# - Multiple effects
# - Easy to use (comments)
#
#-------------------------------------------------------------------------------
# * WARNING - Performance
#-------------------------------------------------------------------------------
# This script may be too heavy to old processors! The Awesome Light Effects was
# tested on a Core 2 Duo E4500 and on a Core i5, without any lag. However,
# there's other factors that may influence the script performance:
#
# 1. Map size
# This script searches surfaces on the map, in order to cut the light pictures.
# In a huge map, the number of surfaces may increase a lot, affecting the
# DYNAMIC LIGHT SOURCE only. Map size does not influence the static sources.
#
# 2. Number of effects
# This script draws the effects on the screen, but before drawing, it checks 
# if the effect is out of screen (in this case, the script will skip the 
# light drawing). Too much effects may cause lag, but this is just a prevision.
#
# 3. Effect's picture size
# The picture size of the DYNAMIC LIGHT SOURCE influences directly on your 
# game's performace. The bigger is the picture, the slower it will be to
# draw it dynamically. The recommended maximum size is 200x200 pixels
# 
#-------------------------------------------------------------------------------
# * WARNING - Light pictures
#-------------------------------------------------------------------------------
# In order to run this script correctly, the light pictures MUST obey the
# following conditions:
# 1. The picture's size MUST be multiple of 2. Example: 150x150
# 2. The picture's width MUST be equal to it's height. Example: 156x156
# 3. The picture's colors MUST be inverted! This is necessary because
#    the script inverts the colors to draw the effect. The black color
#    will be transparent!
#
#-------------------------------------------------------------------------------
# * Instructions - 1. Setup your effects!
#-------------------------------------------------------------------------------
# In order to setup your static effects, go to the setup part and define your
# effects inside the Effects hash. Do as the following mode:
#
# X => [picture,opacity,variation,cut],   <= Remember to put a comma here!
#
# Where:
# picture => Picture's name, inside the Graphics/Lights folder;
# opacity => Effect's opacity;
# variation => Effect's opacity variation;
# cut => Put true to cut the effect or false to don't;
# X => The effect's ID, it will be used on events. 
#
# Check the default effects to understand how they work.
#
#-------------------------------------------------------------------------------
# * Instructions - 2. Use your effects!
#-------------------------------------------------------------------------------
# In order to use a effect, put the following comment on a event:
# 
# [light x]
#
# Where x must be the Effect's ID.
# 
#-------------------------------------------------------------------------------
# * Instructions - 3. Use an awesome lantern!
#-------------------------------------------------------------------------------
# The dynamic light source (lantern) is initialized invisible by default. 
# You may call the following commands:
# 
# l = $game_map.lantern
# Gets the lantern into a variable
# l.set_graphic(i)
# Sets the lantern's graphic to i, where i must be the picture's file name on 
# Graphics/Lights folder.
#
# l.set_multiple_graphics(h)
# Sets the lantern's graphics to h, where h must be a hash with the following
# structure:
#
# h = {2=>"ld",4=>"ll",6=>"lr",8=>"lu"}
# 
# Where: 
# "ld" is the name of the picture when the lantern's owner is looking down;
# "ll" is the name of the picture when the lantern's owner is looking left;
# "lr" is the name of the picture when the lantern's owner is looking right;
# "lu" is the name of the picture when the lantern's owner is looking up.
#
# l.change_owner(char)
# Sets the lantern's owner to char. Char must be ONE of the following commands:
# $game_player           <= The player itself;
# self_event             <= The event where the command was called;
# $game_map.events[x]    <= The event ID x.
#
# l.set_opacity(o,p)
# Sets the lantern's opacity, where:
# o is the opacity itself;
# p is the opacity variation.
#
# l.show
# After setting the lantern with the commands above, you may set it to visible
# using this command.
#
# l.hide
# Use this command to set the lantern as invisible.
#
#-------------------------------------------------------------------------------
# * Instructions - 4. Use the effect's surface!
#-------------------------------------------------------------------------------
# The Awesome Light Effects draws the effects on a surface. In order to make
# the effects visible, the effect's surface MUST be visible. The Effect's 
# Surface is initialized with it's opacity set to zero. You can call the
# following commands:
#
# s = $game_map.effect_surface
# Gets the Effect's Surface into a variable
#
# s.set_color(r,g,b)
# Changes the Effect's Surface color instantly, where:
# r => red level;
# g => green level;
# b => blue level;
#
# s.set_alpha(a)
# Changes the Effect's Surface opacity instantly to a.
#
# s.change_color(time,r,g,b)
# Changes the Effect's Surface color ONLY in a certain time, where:
# time => The change's time (frames);
# r => red level;
# g => green level;
# b => blue level;
#
# s.change_color(time,r,g,b,a)
# Changes the Effect's Surface color and it's opacity in a certain time, where:
# time => The change's time (frames);
# r => red level;
# g => green level;
# b => blue level;
# a => opacity
#
# s.change_alpha(time,a)
# Changes the Effect's Surface opacity in a certain time, where:
# time => The change's time (frames);
# a => opacity
#
#-------------------------------------------------------------------------------
# * Instructions - 5. Use the effect's surface with Tone command!
#-------------------------------------------------------------------------------
# You can access the Effect's Surface with the "Screen Tone" command. In order
# to turn this feature on, set the "Surface_UE" constant to true.
#
# If you decided to use this feature, please note some details:
# 1. The colors values must be between 0 and 255;
# 2. The time is in frames;
# 3. The "gray" value will be sent as the opacity value
#
#-------------------------------------------------------------------------------
# * Instructions - 6. Setup your Tileset Tags!
#-------------------------------------------------------------------------------
# In order to cut the effect's picture correctly, there's 3 types of behavior
# for a tile: wall, block and roof. Walls will make shadows as real walls, 
# blocks as blocks and roofs as roofs. So, the tileset tags MUST be configured.
# Check the demo to understand how this system works. If the tilesets aren't 
# configured correctly, the script won't cut the effects correctly.
# 
#-------------------------------------------------------------------------------
# * Setup Part
#-------------------------------------------------------------------------------
module Light_Core
  Effects = { #  <= DON'T change this!
#-------------------------------------------------------------------------------
# PUT YOUR EFFECTS HERE!
#-------------------------------------------------------------------------------
  0 => ["light",255,0,true],
  1 => ["torch",200,20,true],
  2 => ["torch_m",180,30,true],
  3 => ["light_s",255,0,true],
  4 => ["light_B",255,0,true],
  5 => ["light_C",255,0,true],
  6 => ["light_H",255,0,true],
  
#-------------------------------------------------------------------------------
# End of effecs configuration
#------------------------------------------------------------------------------- 
  } #  <= DON'T change this!
  
  # Z coordinate of the Effect's Surface
  Surface_Z = 99
  
  # Enable Effect's Surface control by "Screen Tone" command?
  Surface_UE = true
  
  # Roof behavior tag
  Roof_Tag = 5
  # Wall behavior tag
  Wall_Tag = 6
  # Block behavior tag
  Block_Tag = 7
  
  # Don't change this!
  ACC = Math.tan(Math::PI/26)
end
#-------------------------------------------------------------------------------
# Script
#-------------------------------------------------------------------------------
module Cache
  def self.light(filename)
    load_bitmap("Graphics/Lights/", filename)
  end
end
module Light_Bitcore
  include Light_Core
  def self.initialize
    @@buffer = {}
    Effects.values.each { |effect| Light_Bitcore.push(effect[0])}
  end
  def self::[](key)
    return @@buffer[key]
  end
  def self.push(key)
    return if @@buffer.keys.include?(key)
    @@buffer[key] = Cache.light(key)
  end
end
Light_Bitcore.initialize
class Light_SSource
  attr_reader :real_x
  attr_reader :real_y
  attr_reader :range
  attr_accessor :bitmap
  attr_reader :w
  attr_reader :h
  attr_reader :hs
  def initialize(char,bitmap,opacity,plus,hs)
    sync(char)
    @key = bitmap
    @bitmap = Light_Bitcore[@key].clone
    @range = @bitmap.width/2
    @w = @bitmap.width
    @h = @bitmap.height
    @mr = @range - 16
    @opacity = opacity
    @plus = plus
    @hs = hs
    render if @hs
  end
  def render
    return; # tag: modified
    tx = x
    ty = y
    tsx = x + @range
    tsy = y + @range
    dr = @range*2
    for s in $game_map.surfaces
      next if !s.visible?(tsx,tsy) || !s.within?(tx,tx+dr,ty,ty+dr)
      s.render_shadow(tx,ty,tsx,tsy,@range,@bitmap)
    end
  end
  def restore
    return unless @bitmap.nil?
    @bitmap = Light_Bitcore[@key].clone
    render if @hs
  end
  def opacity
    @plus == 0 ? @opacity : (@opacity + rand(@plus))
  end
  def sx
    return $game_map.adjust_x(@real_x)*32-@mr
  end
  def sy
    return $game_map.adjust_y(@real_y)*32-@mr
  end
  def sync(char)
    @real_x = char.real_x
    @real_y = char.real_y
  end
  def x
    return (@real_x*32 - @mr).to_f
  end
  def y
    return (@real_y*32 - @mr).to_f
  end
  def dispose
    return if @bitmap.nil?
    @bitmap.dispose
    @bitmap = nil
  end
end
class Light_DSource < Light_SSource
  attr_reader :bitmap
  attr_reader :visible
  def initialize
    @key = nil
    @bitmap = nil
    @opacity = 255
    @plus = 0
    @char = $game_player
    @visible = false
  end
  def set_opacity(o,p)
    @opacity = o
    @plus = p
  end
  def set_graphic(sb)
    dispose
    @key = {2=>sb,4=>sb,6=>sb,8=>sb}
    Light_Bitcore.push(sb)
    @bitmap = {2=>Light_Bitcore[@key[2]].clone,4=>Light_Bitcore[@key[4]].clone,6=>Light_Bitcore[@key[6]].clone,8=>Light_Bitcore[@key[8]].clone}
    @range = @bitmap[2].width/2
    @w = @bitmap[2].width
    @h = @bitmap[2].height
    @mr = @range - 16
  end
  def set_multiple_graphics(ba)
    dispose
    @key = ba
    @key.values.each {|key| Light_Bitcore.push(key)}
    @bitmap = {2=>Light_Bitcore[@key[2]].clone,4=>Light_Bitcore[@key[4]].clone,6=>Light_Bitcore[@key[6]].clone,8=>Light_Bitcore[@key[8]].clone}
    @range = @bitmap[2].width/2
    @w = @bitmap[2].width
    @h = @bitmap[2].height
    @mr = @range - 16
  end
  def get_graphic
    return @bitmap[@char.direction].clone
  end
  def show
    return if @bitmap.nil?
    @visible = true
  end
  def hide
    @visible = false
  end
  def restore
    return if @key.nil?
    @key.values.each {|key| Light_Bitcore.push(key)}
    @bitmap = {2=>Light_Bitcore[@key[2]].clone,4=>Light_Bitcore[@key[4]].clone,6=>Light_Bitcore[@key[6]].clone,8=>Light_Bitcore[@key[8]].clone}
  end
  def dispose
    return if @bitmap.nil?
    @bitmap.values.each { |b| b.dispose }
    @bitmap = nil
  end
  def change_owner(char)
    @char = char
  end
  
  def render
  end
  
  def sx
    return $game_map.adjust_x(@char.real_x)*32-@mr
  end
  def sy
    return $game_map.adjust_y(@char.real_y)*32-@mr
  end
  def x
    return (@char.real_x*32 - @mr).to_f
  end
  def y
    return (@char.real_y*32 - @mr).to_f
  end
end
class Light_Surface
  def initialize
    @ta = @a = 0
    @tr = @r = 255
    @tg = @g = 255
    @tb = @b = 255
    @va = @vr = @vg = @vb = 0.0
    @timer = 0
  end
  def refresh
    return if @timer == 0
    @a += @va
    @r += @vr
    @g += @vg
    @b += @vb
    $game_map.light_surface.opacity = @a
    @timer -= 1
  end
  def change_color(time,r,g,b,a=nil)
    r = 0 if r < 0; r = 255 if r > 255
    g = 0 if g < 0; g = 255 if g > 255
    b = 0 if b < 0; b = 255 if b > 255
    unless a.nil?
      a = 0 if a < 0; a = 255 if a > 255
    end
    @timer = time
    @tr = 255-r
    @tg = 255-g
    @tb = 255-b
    @va = (a.nil? ? 0 : (a-@a).to_f/@timer)
    @vr = (@tr - @r).to_f/@timer
    @vg = (@tg - @g).to_f/@timer
    @vb = (@tb - @b).to_f/@timer
  end
  def change_alpha(time,a)
    a = 0 if a < 0; a = 255 if a > 255
    @timer = time
    @ta = a
    @vr = @vg = @vb = 0.0
    @va = (a-@a).to_f/@timer
  end
  def set_color(r,g,b)
    r = 0 if r < 0; r = 255 if r > 255
    g = 0 if g < 0; g = 255 if g > 255
    b = 0 if b < 0; b = 255 if b > 255
    @tr = @r = 255-r
    @tg = @g = 255-g
    @tb = @b = 255-b
    @va = @vr = @vg = @vb = 0.0
    @timer = 0
  end
  def set_alpha(a)
    a = 0 if a < 0; a = 255 if a > 255
    @ta = @a = a
    $game_map.light_surface.opacity = @a
    @va = @vr = @vg = @vb = 0.0
    @timer = 0
  end
  def alpha
    return @a
  end
  def color
    return Color.new(@r,@g,@b)
  end
end
class Game_Map
  include Light_Core
  attr_accessor :light_surface
  attr_accessor :light_sources
  attr_accessor :surfaces
  attr_accessor :effect_surface
  attr_accessor :lantern
  alias kbl_setup_events setup_events
  alias kbl_initialize initialize
  alias kbl_update update
  def initialize
    kbl_initialize
    @effect_surface = Light_Surface.new
    @lantern = Light_DSource.new
  end
  def update(main = false)
    @effect_surface.refresh if main # tag: light
    kbl_update(main)
  end
  def first_tag(x,y)
    tag = tileset.flags[tile_id(x,y,0)] >> 12
    return tag > 0 ? tag : 0
  end
  def setup_events
    @light_sources.nil? ? @light_sources = [] : @light_sources.clear
    #setup_surfaces
    #merge_surfaces
    kbl_setup_events
  end
  def setup_surfaces
    @surfaces = []
    for x in 0..(width-1)
      for y in 0..(height-1)
        tag = first_tag(x,y)
        if tag == Wall_Tag
          i = tile_id(x,y,0)
          if i & 0x02 == 0x02
            @surfaces << Block_SD.new(x*32,y*32,x*32+32,y*32)
          end
          if i & 0x04 == 0x04
            @surfaces << Block_WR.new(x*32+31,y*32,x*32+31,y*32+32)
            @surfaces << Block_IL.new(x*32+32,y*32,x*32+32,y*32+32)
          end
          if i & 0x01 == 0x01
            @surfaces << Block_IR.new(x*32-1,y*32,x*32-1,y*32+32)
            @surfaces << Block_WL.new(x*32,y*32,x*32,y*32+32)
          end
        elsif tag == Roof_Tag
          i = tile_id(x,y,0)
          @surfaces << Block_SU.new(x*32,y*32,x*32+32,y*32) if i & 0x02 == 0x02
          @surfaces << Block_SR.new(x*32+31,y*32,x*32+31,y*32+32) if i & 0x04 == 0x04
          @surfaces << Block_SL.new(x*32,y*32,x*32,y*32+32) if i & 0x01 == 0x01
        elsif tag == Block_Tag
          f = tileset.flags[tile_id(x,y,0)]
          @surfaces << Block_SL.new(x*32,y*32,x*32,y*32+32) if f & 0x02 == 0x02
          @surfaces << Block_SR.new(x*32+31,y*32,x*32+31,y*32+32) if f & 0x04 == 0x04
          @surfaces << Block_SU.new(x*32,y*32,x*32+32,y*32) if f & 0x08 == 0x08
        end
      end
    end
  end
  def merge_surfaces
    new_surfaces = []
    hs = []; vs = []
    ws = []; is = []
    for surface in @surfaces
      if surface.type & 0x05 == 0
        hs << surface
      else
        if surface.type & 0x010 == 0
          vs << surface
        else
          if surface.type & 0x08 == 0
            ws << surface
          else
            is << surface
          end
        end
      end
    end
    for surface in hs
      surface.ready ? next : surface.ready = true
      for s in hs
        next if s.ready || s.y1 != surface.y1 || surface.type != s.type
        if s.x2 == surface.x1
          surface.x1 = s.x1
          s.trash = true
          s.ready = true
          surface.ready = false
        elsif s.x1 == surface.x2
          surface.x2 = s.x2
          s.trash = true
          s.ready = true
          surface.ready = false
        end
      end
    end
    hs.each { |s| @surfaces.delete(s) if s.trash}
    for surface in vs
      surface.ready ? next : surface.ready
      for s in vs
        next if s.ready || s.x1 != surface.x1
        if s.y2 == surface.y1
          surface.y1 = s.y1
          s.trash = true
          s.ready = true
          surface.ready = false
        elsif s.y1 == surface.y2
          surface.y2 = s.y2
          s.trash = true
          s.ready = true
          surface.ready = false
        end
      end
    end
    vs.each { |s| @surfaces.delete(s) if s.trash}
    for surface in ws
      surface.ready ? next : surface.ready
      for s in ws
        next if s.ready || s.x1 != surface.x1
        if s.y2 == surface.y1
          surface.y1 = s.y1
          s.trash = true
          s.ready = true
          surface.ready = false
        elsif s.y1 == surface.y2
          surface.y2 = s.y2
          s.trash = true
          s.ready = true
          surface.ready = false
        end
      end
    end
    ws.each { |s| @surfaces.delete(s) if s.trash}
    for surface in is
      surface.ready ? next : surface.ready
      for s in is
        next if s.ready || s.x1 != surface.x1
        if s.y2 == surface.y1
          surface.y1 = s.y1
          s.trash = true
          s.ready = true
          surface.ready = false
        elsif s.y1 == surface.y2
          surface.y2 = s.y2
          s.trash = true
          s.ready = true
          surface.ready = false
        end
      end
    end
    is.each { |s| @surfaces.delete(s) if s.trash}
  end
end
class Game_Event < Game_Character
  
  alias kbl_initialize initialize
  alias kbl_setup_page setup_page
  
  def initialize(m,e)
    @light = nil
    kbl_initialize(m,e)
  end
  
  def setup_page(np)
    kbl_setup_page(np)
    setup_light(np.nil?)
  end
  
  def setup_light(dispose)
    # tag: light
    #return
    unless @light.nil?
      $game_map.light_sources.delete(self)
      @light.bitmap.dispose
      @light.dispose
      @light = nil
    end
    
    unless dispose && @list.nil?
      for command in @list
        if command.code == 108 && command.parameters[0].include?("[light")
          command.parameters[0].scan(/\[light ([0.0-9.9]+)\]/)
          effect = Light_Core::Effects[$1.to_i]
          @light = Light_SSource.new(self,effect[0],effect[1],effect[2],effect[3])
          $game_map.light_sources << self
          return
        end
      end
    end
  end
  
  def draw_light
    sx = @light.sx
    sy = @light.sy
    w = @light.w
    h = @light.h
    return if sx > Graphics.width && sy > Graphics.height && sx + w < 0 && sy + h < 0
    $game_map.light_surface.bitmap.blt(sx,sy,@light.bitmap,Rect.new(0,0,w,h),@light.opacity)
  end
  
  def dispose_light
    @light.dispose
  end
  
  def restore_light
    @light.restore
  end
end
if Light_Core::Surface_UE
  class Game_Interpreter
    def command_223
      $game_map.effect_surface.change_color(@params[1],@params[0].red,@params[0].green,@params[0].blue,@params[0].gray)
      wait(@params[1]) if @params[2]
    end
  end
end
class Game_Interpreter
  def self_event
    return $game_map.events[@event_id]
  end
end
class Block_Surface
  include Light_Core
  attr_accessor :x1
  attr_accessor :y1
  attr_accessor :x2
  attr_accessor :y2
  attr_accessor :ready
  attr_accessor :trash
  def initialize(x1,y1,x2,y2)
    @x1 = x1
    @y1 = y1
    @x2 = x2
    @y2 = y2
    @ready = false
    @trash = false
  end
  def within?(min_x,max_x,min_y,max_y)
    return @x2 > min_x && @x1 < max_x && @y2 > min_y && @y1 < max_y
  end
end
class Block_SL < Block_Surface
  attr_reader :type
  def initialize(x1,y1,x2,y2)
    super(x1,y1,x2,y2)
    @type = 0x01
  end
  def visible?(sx,sy)
    return sx < @x1 
  end
  def render_shadow(phx,phy,sx,sy,range,bitmap)
    @m1 = (@y1-sy)/(@x1-sx)
    @n1 = sy - @m1*sx
    @m2 = (@y2-sy)/(@x2-sx)
    @n2 = sy - @m2*sx
    for x in @x1..(sx+range)
      init = shadow_iy(x)
      bitmap.clear_rect(x-phx,init-phy,1,shadow_fy(x)-init+3)
    end
  end
  def shadow_iy(x)
    return @m1*x+@n1
  end
  def shadow_fy(x)
    return @m2*x+@n2
  end
end
class Block_SR < Block_Surface
  attr_reader :type
  def initialize(x1,y1,x2,y2)
    super(x1,y1,x2,y2)
    @type = 0x04
  end
  def visible?(sx,sy)
    return sx > @x1 
  end
  def render_shadow(phx,phy,sx,sy,range,bitmap)
    @m1 = (@y1-sy)/(@x1-sx)
    @n1 = sy - @m1*sx
    @m2 = (@y2-sy)/(@x2-sx)
    @n2 = sy - @m2*sx
    for x in (sx-range).to_i..@x1
      init = shadow_iy(x)
      bitmap.clear_rect(x-phx,init-phy,1,shadow_fy(x)-init+3)
    end
  end
  def shadow_iy(x)
    return @m1*x+@n1
  end
  def shadow_fy(x)
    return @m2*x+@n2
  end
end
class Block_IL < Block_Surface
  attr_reader :type
  def initialize(x1,y1,x2,y2)
    super(x1,y1,x2,y2)
    @type = 0x019
  end
  def visible?(sx,sy)
    return sx < @x1 && sy > @y1
  end
  def render_shadow(phx,phy,sx,sy,range,bitmap)
    @m1 = (@y1-sy)/(@x1-sx)
    @n1 = @y1 - @m1*@x1
    @m2 = (@y2-sy)/(@x2-sx)
    @m2 = 0 if @m2 > 0
    @n2 = @y2 - @m2*@x2
    for x in @x1..(sx+range)
      init = shadow_iy(x).floor
      bitmap.clear_rect(x-phx,init-3-phy,1,shadow_fy(x)-init+3)
    end
  end
  def shadow_iy(x)
    return @m1*x+@n1
  end
  def shadow_fy(x)
    return @m2*x+@n2
  end
end
class Block_IR < Block_Surface
  attr_reader :type
  def initialize(x1,y1,x2,y2)
    super(x1,y1,x2,y2)
    @type = 0x01c
  end
  def visible?(sx,sy)
    return sx > @x1 && sy > @y1
  end
  def render_shadow(phx,phy,sx,sy,range,bitmap)
    @m1 = (@y1-sy)/(@x1-sx)
    @n1 = @y1 - @m1*@x1
    @m2 = (@y2-sy)/(@x2-sx)
    @m2 = 0 if @m2 < 0
    @n2 = @y2 - @m2*@x2
    for x in (sx-range).to_i..@x1
      init = shadow_iy(x).floor
      bitmap.clear_rect(x-phx,init-3-phy,1,shadow_fy(x)-init+3)
    end
  end
  def shadow_iy(x)
    return @m1*x+@n1
  end
  def shadow_fy(x)
    return @m2*x+@n2
  end
end
class Block_WL < Block_Surface
  attr_reader :type
  def initialize(x1,y1,x2,y2)
    super(x1,y1,x2,y2)
    @type = 0x011
  end
  def visible?(sx,sy)
    return sx < @x1 && sy < @y2
  end
  def render_shadow(phx,phy,sx,sy,range,bitmap)
    @m1 = (@y1-sy)/(@x1-sx)
    @n1 = sy - @m1*sx
    @m2 = (@y2-sy)/(@x2-sx)
    @n2 = sy - @m2*sx
    for x in @x1..(sx+range)
      init = shadow_iy(x)
      bitmap.clear_rect(x-phx,init-phy,1,shadow_fy(x)-init+2)
    end
  end
  def shadow_iy(x)
    return @m1*x+@n1
  end
  def shadow_fy(x)
    return @m2*x+@n2
  end
end
class Block_WR < Block_Surface
  attr_reader :type
  def initialize(x1,y1,x2,y2)
    super(x1,y1,x2,y2)
    @type = 0x014
  end
  def visible?(sx,sy)
    return sx > @x1 && sy < @y2
  end
  def render_shadow(phx,phy,sx,sy,range,bitmap)
    @m1 = (@y1-sy)/(@x1-sx)
    @n1 = sy - @m1*sx
    @m2 = (@y2-sy)/(@x2-sx)
    @n2 = sy - @m2*sx
    for x in (sx-range).to_i..@x1
      init = shadow_iy(x)
      bitmap.clear_rect(x-phx,init-phy,1,shadow_fy(x)-init+2)
    end
  end
  def shadow_iy(x)
    return @m1*x+@n1
  end
  def shadow_fy(x)
    return @m2*x+@n2
  end
end
class Block_SU < Block_Surface
  attr_reader :type
  def initialize(x1,y1,x2,y2)
    super(x1,y1,x2,y2)
    @type = 0x02
  end
  def visible?(sx,sy)
    return sy < @y1
  end
  def render_shadow(phx,phy,sx,sy,range,bitmap)
    if @x1 == sx
      @m1 = nil
    else
      @m1 = (@y1-sy)/(@x1-sx)
      @m1 += ACC if @m1 < -ACC
      @n1 = @y1 - @m1*@x1
    end
    if @x2 == sx
      @m2 = nil
    else
      @m2 = (@y2-sy)/(@x2-sx)
      @n2 = sy - @m2*sx
    end
    for y in @y1..(sy+range)
      init = shadow_ix(y)
      bitmap.clear_rect(init-phx,y-phy,shadow_fx(y)-init+1,1)
    end
  end
  def shadow_ix(y)
    return @m1.nil? ? @x1 : (y-@n1)/@m1
  end
  def shadow_fx(y)
    return @m2.nil? ? @x2 : (y-@n2)/@m2
  end
end
class Block_SD < Block_Surface
  attr_reader :type
  def initialize(x1,y1,x2,y2)
    super(x1,y1,x2,y2)
    @type = 0x08
  end
  def visible?(sx,sy)
    return sy > @y1
  end
  def render_shadow(phx,phy,sx,sy,range,bitmap)
    if @x1 == sx
      @m1 = nil
    else
      @m1 = (@y1-sy)/(@x1-sx)
      @m1 -= ACC if @m1 > ACC
      @n1 = sy - @m1*sx
    end
    if x2 == sx
      @m2 = nil
    else
      @m2 = (@y2-sy)/(@x2-sx)
      @n2 = sy - @m2*sx
    end
    for y in (sy-range).to_i..@y1
      init = shadow_ix(y)
      bitmap.clear_rect(init-phx,y-phy,shadow_fx(y)-init+1,1)
    end
  end
  def shadow_ix(y)
    return @m1.nil? ? @x1 : (y-@n1)/@m1
  end
  def shadow_fx(y)
    return @m2.nil? ? @x2 : (y-@n2)/@m2
  end
end
class Spriteset_Map
  include Light_Core
  alias kbl_initialize initialize
  alias kbl_update update
  alias kbl_dispose dispose
  def initialize
    setup_lights
    kbl_initialize
  end
  def update
    kbl_update
    update_lights
  end
  def dispose
    kbl_dispose
    dispose_lights
  end
  def dispose_lights
    $game_map.dispose_lights
  end
  def update_lights
    #return # tag: light
    $game_map.light_surface.bitmap.clear
    $game_map.light_surface.bitmap.fill_rect(0,0,Graphics.width,Graphics.height,$game_map.effect_surface.color)
    $game_map.light_sources.each { |source| source.draw_light }
    return unless $game_map.lantern.visible
    @btr = $game_map.lantern.get_graphic
    x = $game_map.lantern.x
    y = $game_map.lantern.y
    r = $game_map.lantern.range
    sx = x + r
    sy = y + r
    dr = r*2
    #$game_map.surfaces.each { |s| s.render_shadow(x,y,sx,sy,r,@btr) if s.visible?(sx,sy) && s.within?(x,x+dr,y,y+dr) }
    $game_map.light_surface.bitmap.blt($game_map.lantern.sx,$game_map.lantern.sy,@btr,Rect.new(0,0,dr,dr),$game_map.lantern.opacity)
  end
  def setup_lights
    #return
    # tag: light
    @btr = nil
    $game_map.lantern.restore
    $game_map.light_sources.each { |source| source.restore_light }
    $game_map.light_surface = Sprite.new
    $game_map.light_surface.bitmap = Bitmap.new(Graphics.width,Graphics.height)
    $game_map.light_surface.bitmap.fill_rect(0,0,Graphics.width,Graphics.height,$game_map.effect_surface.color)
    $game_map.light_surface.blend_type = 2
    $game_map.light_surface.opacity = $game_map.effect_surface.alpha
    $game_map.light_surface.z = Surface_Z
  end
end

#==============================================================================
# ** Game_Event
#------------------------------------------------------------------------------
#  This class handles events. Functions include event page switching via
# condition determinants and running parallel process events. Used within the
# Game_Map class.
#==============================================================================
class Game_Event < Game_Character
  
  #--------------------------------------------------------
  # *) setup light
  #--------------------------------------------------------
  def setup_light(dispose)
    
    unless @light.nil?
      $game_map.light_sources.delete(self)
      @light.dispose
      @light = nil
    end
    
    if !dispose && !@list.nil?
      for command in @list
        if command.code == 108 && command.parameters[0].include?("[light")
          command.parameters[0].scan(/\[light ([0.0-9.9]+)\]/)
          effect = Light_Core::Effects[$1.to_i]
          @light = Light_SSource.new(self,effect[0],effect[1],effect[2],effect[3])
          $game_map.light_sources << self
          return
        end # command.code == 108
      end # for command in @list)
    end # unless dispose
    
  end # def setup_light
  
  
  #------------------
end
class Block_Surface
  
  def dispose
    valid = bitmap && !bitmap.disposed? rescue false
    return unless valid
    bitmap.dispose
  end
  
end
#==============================================================================
# ** Game_Map
#------------------------------------------------------------------------------
#  This class handles maps. It includes scrolling and passage determination
# functions. The instance of this class is referenced by $game_map.
#==============================================================================
class Game_Map
end

#==============================================================================
# *** QuestData
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This module contains all the configuration data for the quest journal
#==============================================================================
module QuestData
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Setup Quest
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def self.setup_quest(quest_id)
    q = { objectives: [] }
    case quest_id
    #\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
    #  BEGIN Editable Region B
    #||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
    #    Quest Setup
    #
    #  This is where you set up the data for every quest in the game. While
    # it may seem complicated, I urge you to pay attention and, once you get
    # the hang of it, I am sure it will quickly become second nature. 
    #
    #  Every single quest should be set up in the following format, but note
    # that if you are not setting anything for a particular aspect, you can 
    # delete that line. Anyway, this is what each quest should look like, with
    # the values on the left being the default values if you don't set them:
    #
    #  when quest_id
    #   q[:name]              = "??????"
    #   q[:icon_index]        = 0
    #   q[:level]             = 0
    #   q[:description]       = ""
    #   q[:banner]            = ""
    #   q[:banner_hue]        = 0
    #   q[:objectives][0]     = ""
    #   q[:objectives][1]     = ""
    #   q[:objectives][2]     = ""
    #   q[:objectives][n]     = ""
    #   q[:prime_objectives]  = [0, 1, 2, n]
    #   q[:custom_categories] = []
    #   q[:client]            = ""
    #   q[:location]          = ""
    #   q[:rewards]           = []
    #   q[:common_event_id]   = 0
    #   q[:layout]            = false
    #
    #  For each line, with the exception of objectives, it is only the value on 
    # the right of the equals sign that you will need to change. Now I will 
    # explain each line:
    #
    # when quest_id
    #    quest_id - is an integer of your choosing, and this is how you 
    #        reference a quest in order to advance and do anything else. It 
    #        must be unique for every quest; if you use 1 for the first quest, 
    #        you cannot use 1 for any other quest.
    #
    #   q[:name]              = ""
    #     "" - This line sets the name of the quest which shows in the Quest 
    #        List.
    #   
    #   q[:icon_index]        = 0
    #     0  - This line sets the icon to be used for this quest. It will show
    #        to the left of the quest's name in the Quest List.
    #
    #   q[:level]             = 0
    #     0  - This line sets the level of the quest. If 0, no level will be
    #        shown. See the level options at lines 441-458 for more detail.
    #   
    #   q[:description]       = ""
    #     "" - This line sets the description of the quest. You can use message 
    #        codes in this string, but if you are using "" then you need to use
    #        \\ to identify codes and not just \. Ie. It's \\v[x], not \v[x]
    #
    #   q[:objectives][0]     = ""
    #   q[:objectives][1]     = ""
    #   q[:objectives][2]     = ""
    #   q[:objectives][n]     = ""
    #  Objectives are slightly different. Notice that after q[:objectives] on
    # each line there is an integer enclosed in square brackets:
    #    [n] - This is the ID of the objective, and n MUST be an integer. No 
    #       quest can have more than one objective with the same ID. This is 
    #       how you identify which objective you want to reveal, complete or 
    #       fail. That said, you can make as many objectives as you want, as 
    #       long as you give them all distinct IDs. The IDs should be in 
    #       sequence as well, so there shouldn't be a q[:objectives][5] if 
    #       there is no q[:objectives][4].
    #     "" - This is the text of the objective. You can use message codes in 
    #        this string, but if you are using "" then you will need to use 
    #        \\ to identify codes and not just \. Ie: It's \\v[x], not \v[x]
    #
    #   q[:prime_objectives]  = [0, 1, 2, n]
    #     [0, 1, 2, n] - This array determines what objectives need to be 
    #        completed in order for the quest to be complete. In other words, 
    #        all of the objectives with the IDs in this array need to be 
    #        complete for the quest to be complete. If any one of them is 
    #        failed, the quest will be failed. If you remove this line 
    #        altogether, then all objectives are prime. If you set this to [],
    #        then the quest will never be automatically completed or failed and
    #        you need to use the manual options described at lines 208-219.
    #
    #   q[:custom_categories] = []
    #     [] - This allows you to set an array of custom categories for this
    #        quest, whiich means this quest will show up in each of those 
    #        categories if you add it to the CATEGORIES array at line 370.
    #        Note that each category you make must be identified by a unique 
    #        :symbol, and you must set up all the category details for that 
    #        :symbol. 
    #
    #   q[:banner]            = ""
    #     "" - This line sets the banner to be used for a quest. It must be the
    #        filename of an image in the Pictures folder of Graphics.
    #
    #   q[:banner_hue]        = 0
    #     0 - The hue of the banner graphic, if used
    #
    #   q[:client]            = ""
    #     "" - This line sets the client name for this quest. (basic data)
    #
    #   q[:location]          = ""
    #     "" - This line sets the location of the quest. (basic data)
    #
    #   q[:rewards]           = []
    #    [] - In this array, you can identify particular rewards that will 
    #       show up. Each reward should be in its own array and can be any of
    #       the following:
    #          [:item, ID, n],
    #          [:weapon, ID, n],
    #          [:armor, ID, n],
    #          [:gold, n],
    #          [:exp, n],
    #       where ID is the ID of the item, weapon or armour you want
    #       distributed and n is the amount of the item, weapon, armor, gold, 
    #       or experience you want distributed. Additionally, you can also set
    #       some text to show up in the rewards format but which wouldn't be
    #       automatically distributed. You would need to specify that type of
    #       reward text in the following format:
    #          [:string, icon_index, "string", "vocab"],
    #       where icon_index is the icon to be shown, "string" is what you 
    #       would show up as the amount, and "vocab" is what would show up as a
    #       label between the icon and the amount.
    #      
    #
    #   q[:common_event_id]   = 0
    #     0  - This allows you to call the identified common event immediately
    #        and automatically once the quest is completed. It is generally 
    #        not recommended, as for most quests you should be controlling it
    #        enough not to need this feature.
    #
    #   q[:layout]            = false
    #     false - The default value for this is false, and when it is false the
    #        layout for the quest will be inherited from the default you set at
    #        302. However, you can also give the quest its own layout - the 
    #        format would be the same as you set for the default at line 307.
    #  
    # Template:
    #
    #  When making a new quest, I recommend that you copy and paste the
    # following template, removing whichever lines you don't want to alter. 
    # Naturally, you need to remove the #~. You can do so by highlighting
    # the entire thing and pressing CTRL+Q:
#~     when 2 # <= REMINDER: The Quest ID MUST be unique
#~       q[:name]              = "??????"
#~       q[:icon_index]        = 0
#~       q[:level]             = 0
#~       q[:description]       = ""
#~       # REMINDER: You can make as many objectives as you like, but each must 
#~       # have a unique ID.
#~       q[:objectives][0]     = "" 
#~       q[:objectives][1]     = ""
#~       q[:objectives][2]     = ""
#~       q[:prime_objectives]  = [0, 1, 2]
#~       q[:custom_categories] = []
#~       q[:banner]            = ""
#~       q[:banner_hue]        = 0
#~       q[:client]            = ""
#~       q[:location]          = ""
#~       q[:rewards]           = []
#~       q[:common_event_id]   = 0
    when 1 # Quest 1 - SAMPLE QUEST
      q[:name]              = "Sieged Deadend"
      q[:level]             = 5
      q[:icon_index]        = 7
      q[:description]       = "Crystal Empire is fell to the King Sombra, now must report to the Princess in Canterlot."
      q[:objectives][0]     = "(Main)Escape from Crystal Empire"
      q[:objectives][1]     = "(Selective)Save Crystal Ponies"
      q[:objectives][2]     = "(Selective)Save the librarian"
      q[:objectives][3]     = "Find the mysterious device in the library"
      q[:objectives][4]     = "Gather the infromation in the library, find way to active the device and leave here"
      q[:prime_objectives]  = [1]
      q[:custom_categories] = []
      q[:banner]            = ""
      q[:banner_hue]        = 0
      q[:client]            = "Mainline Mission"
      q[:location]          = "Crystal Empire"
      q[:common_event_id]   = 0
      q[:rewards]           = [
        #[:item, 1, 3],
        [:gold, 100],
      ]
      q[:layout]            = false
    when 2
      q[:name]              = "Tutorial"
      q[:level]             = 1
      q[:icon_index]        = 230
      q[:description]       = "Learn the game mechanics and how to play."
      q[:objectives][0]     = "Enable the tactic mode"
      q[:objectives][1]     = "Enable the tactic mode, command your teammate move to the flag"
      q[:objectives][2]     = "Enable the tactic mode, command yout teammate to attack the enemy"
      
      q[:prime_objectives]  = [1]
      q[:custom_categories] = []
      q[:banner]            = ""
      q[:banner_hue]        = 0
      q[:client]            = "GM"
      q[:location]          = "Celestia Plane"
      q[:common_event_id]   = 0
      q[:rewards]           = [
        [:item, 1, 3],
      ]
      q[:layout]            = false
    #||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
    #  END Editable Region B
    #//////////////////////////////////////////////////////////////////////
    end
    q
  end
end

#==============================================================================
#    Quest Journal [VXA]
#    Version: 1.0.3
#    Author: modern algebra (rmrk.net)
#    Date: 24 September 2012
#    Support: http://rmrk.net/index.php/topic,45127.0.html
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Description:
#
#    This script provides a graphical interface for showing quest progress. It
#   is objective-based, meaning that you choose when to reveal objectives and 
#   you can set it so that they show up as complete or failed. That said, this
#   script does not build quests for you; it is only a supplementary scene for
#   showing them. As such, you need to event all of the quests yourself and
#   update quest progress via script call. Therefore, pay close attention to 
#   the instructions here and in the Editable Regions at lines 232 and 612.
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Instructions:
#
#    Paste this script into its own slot or slots, above Main and below
#   Materials. If you are using the menu access feature, you should put any 
#   other menu scripts above this one. 
#
#    All of the configuration is done in the QuestData module. While it is not 
#   necessary, it is recommended that you separate the configuration module 
#   from the rest of the script by cutting and pasting it into its own slot in
#   the Script Editor (as you will see if you have the demo). The reason for 
#   this is that, if and when this script gets updated, you can preserve the 
#   configuration section and only replace the other parts of the script. If 
#   you wish to do that, you must cut everything from the first line down to 
#   the final end of the module. The first lines of the body script should be 
#   the equals bar right above # ** Game_Quest. Again, it's up to you whether 
#   you do it.
#
#    You can go to EDITABLE REGION A at line 232 to configure the default 
#   settings for the script. All of these will work fine without modification,
#   of course, but even if do not want to configure now, you should familiarize 
#   yourself with all the settings so that you can make the best use of your 
#   script. I have included tons of settings so that you can make the Quest 
#   Journal unique for your game, even down to the order in which each section
#   of the info window is drawn. A brief description of each setting is 
#   included either to the right or directly above each constant.
#
#    EDITABLE REGION B is the real heart of the script however - this is where
#   you fill in all of the details for the quests. Read the instructions at 
#   line 612 very carefully!
#
#    You can activate and access a quest with this code in the Script event 
#   command:
#
#        quest(quest_id)
#          quest_id : the integer ID of the quest you want to access
#
#   From that, you can access or alter any relevant data stored in the quest, 
#   like name, description, objectives, etc... Example:
#         quest(1).name = "Rest in Pieces"
#
#    More relevantly, when it comes to controlling the progress of quests the
#   following codes can be used in a Script event command. The arguments are 
#   the same for each command so I only explain them once. All of them are 
#   pretty self-explanatory and using any of them will activate the quest 
#   (unless you are using the MANUAL REVEAL setting at line 267). 
#    
#        reveal_objective(quest_id, objective_id_1, ..., objective_id_n)
#            quest_id : the integer ID of the quest you want to access.
#            objective_id_1, ..., objective_id_n : a list of the IDs of the 
#              objectives you want to operate on. It can be as few as one or as 
#              many as all of them.
#          Will show the listed objectives in the Quest's information
#
#        conceal_objective(quest_id, objective_id_1, ..., objective_id_n)
#          Will hide the listed objectives in the Quest's information
#
#        complete_objective(quest_id, objective_id_1, ..., objective_id_n)
#          Changes the colour of the listed objectives to the completed colour.
#          The quest is completed once all prime objectives are.
#
#        uncomplete_objective (quest_id, objective_id_1, ..., objective_id_n)
#          Changes the status of the listed complete objectives back to active
#
#        fail_objective(quest_id, objective_id_1, ..., objective_id_n)
#          Changes the colour of the listed objectives to the failed colour.
#          The quest is failed once one prime objective is.
#
#        unfail_objective(quest_id, objective_id_1, ..., objective_id_n)
#          Changes the status of the listed failed objectives back to active
#
#        change_reward_status(quest_id, value)
#            value : either true or false. If excluded, defaults to true.
#          Totally optional, but this is just a personal switch which you can
#          turn on when the reward is given. You can then make it a condition 
#          so you don't reward the players more than once. (see line 180)
#
#  EXAMPLES:
#    reveal_objective(1, 0)
#      This would reveal the first objective of the quest with ID 1
#    complete_objective(6, 2, 3)
#      This would complete the third & fourth objectives of the quest with ID 6
#    change_reward_status(8)
#      This would set the reward switch to true for the quest with ID 8.
#
#   Another new feature is the ability to set rewards that will show up in the
#  menu (see EDITABLE REGION B). In addition to that, you can use the following
#  code to automatically distribute the specified rewards for a quest if the 
#  quest is complete and no reward has yet been given:
#
#        distribute_quest_rewards(quest_id)
#          quest_id : the ID of the quest whose rewards you want to distribute
#
#   Of course, it can only distribute the material rewards (items, weapons,
#   armors, gold, or exp). It won't distribute rewards you specify by string. 
#   To that end though, you can also use this code in a conditional branch and 
#   it will be satisfied only if it distributes the rewards. Thus, if you 
#   wanted to add some special rewards or do things like that, you can just put
#   that in the branch for when it is true. This feature is not really
#   recommended, since I think it is better to do it by events.
#
#    Other codes for the Script event command that can be useful are:
#    
#        reset_quest(quest_id)
#            quest_id : the integer ID of the quest you want to access.
#          This will re-initialize the quest, meaning all quest progress to 
#          date will be lost
#
#        delete_quest(quest_id)
#          Deactivates the quest and resets it
#
#        conceal_quest(quest_id)
#          Deactivates the quest so it won't show up in the scene, but progress
#          is saved
#
#        reveal_quest(quest_id)
#          Activates or reactivates the quest. This command is NECESSARY if 
#          MANUAL_REVEAL at line 284 is true or it has previously been 
#          concealed. Otherwise, it is sufficient just to operate on the quest
#
#        change_quest_access(:symbol)
#          :symbol must be one of six options (include the colon!):
#            :disable - prevents access to the quest scene (greys out in menu)
#            :enable - enables access to the quest scene
#            :disable_menu - this removes the quest option from the menu
#            :enable_menu - this adds the quest option to the menu
#            :disable_map - this prevents access by key from the map
#            :enable_map - this allows access by key to the map
#
#        change_quest_background("bg_filename", bg_opacity, bg_blend_type)
#            bg_filename   : the filename of the picture for the background in  
#              the Pictures folder
#            bg_opacity    : the opacity of the background graphic. If 
#              excluded, this defaults to the value of the setting at line 434.
#            bg_blend_type : the blend type of the background graphic. If 
#              excluded, this defaults to the value of the setting at line 437.
#
#        change_quest_windows ("windowskin_filename", tone, opacity)
#            windowskin_filename : the name of the Window graphic in the
#              System folder of Graphics
#            opacity             : the opacity of the windows. If excluded, 
#              this defaults to the value of the setting at line 423.
#            blend_type          : the blend_type of the windows. If excluded, 
#              this defaults to the value of the setting at line 426.
#
#    Also, there are a few codes that can be used in the Script command of a
#   conditional branch. I note here that all of these are optional. You could
#   use switch and variable checks and monitor quest progress solely through
#   events. However, these commands make it a little easier and they are:
# 
#        quest_revealed?(quest_id)
#            quest_id : the integer ID of the quest you want to access.
#          This is satisfied if the quest has been activated.
#
#        quest_complete?(quest_id)
#          This is satisfied if all prime objectives of the quest are complete
#
#        quest_failed?(quest_id)
#          This is satisfied if any prime objective of the quest is failed
#
#        quest_rewarded?(quest_id)
#          This is satisfied if you have changed the reward status to true.
#
#        objective_revealed?(quest_id, objective_id_1, ... objective_id_n)
#            objective_id_1, ..., objective_id_n : a list of the IDs of the 
#              objectives you want to operate on. It can be as few as one or as 
#              many as all of them.
#          This is satisfied if the listed objectives have been revealed
#
#        objective_active?(quest_id, objective_id_1, ... objective_id_n)
#          This is satisfied if all the listed objectives are revealed and
#          neither complete nor failed.
#
#        objective_complete?(quest_id, objective_id_1, ... objective_id_n)
#          This is satisfied if all the listed objectives have been completed
#
#        objective_failed?(quest_id, objective_id_1, ... objective_id_n)
#          This is satisfied if all the listed objectives have been failed
#
#    If you want to call the Quest scene from an event, you use the following 
#   code in a call script:
# 
#        call_quest_journal
#        call_quest_journal(quest_id)
#          quest_id : ID of the quest you want to open the scene on
#
#  If you do not specify a quest_id (line 198) then it will simply open the 
#  scene as it would normally. If you do specify a quest_id (line 199) then it
#  will open the scene on that quest so long as it has been revealed and it is
#  normally accessible through the quest menu.
#
#   Finally, the default way this script operates is that quests automatically
#  complete or fail based on the status of the prime objectives. However, you
#  can set it so that there are no prime objectives, in which case you can only
#  complete, fail, or (re)activate a quest manually through the following code
#  in a script call:
#
#        manually_complete_quest(quest_id)
#          quest_id : ID of the quest you want to manually complete
#        manually_fail_quest(quest_id)
#          quest_id : ID of the quest you want to manually fail
#        manually_activate_quest(quest_id)
#          quest_id : ID of the quest you want to manually activate
#==============================================================================
$imported ||= {}
$imported[:"MA_QuestJournal_1.0"] = true
$imported[:"MA_QuestJournal_1.0.1"] = true
#==============================================================================
# *** QuestData
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This module contains all the configuration data for the quest journal
#==============================================================================
module QuestData
  #\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
  #  BEGIN Editable Region A
  #||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
  #  MENU_ACCESS - If true, you can access the quest journal through a command 
  # in the menu. If false, there will be no such command.
  MENU_ACCESS = false
  #  MENU_INDEX - If MENU_ACCESS is true, this determines where it appears
  MENU_INDEX = 4
  #  MAP_ACCESS - If true, this allows you to access the quest journal by 
  # pressing a key on the map.
  MAP_ACCESS = false
  #  MAP_BUTTON - If MAP_ACCESS is true, this determines which button calls the
  # Quest Journal
  MAP_BUTTON = :L
  #  OPEN_TO_LAST_REVEALED_QUEST - If true, then the first time you open the
  # quest journal after revealing a new quest, it will open to the new quest.
  OPEN_TO_LAST_REVEALED_QUEST = true
  #  OPEN_TO_LAST_CHANGED_QUEST - If true, then the Quest Journal will open to
  # the last quest whose objective status has changed.
  OPEN_TO_LAST_CHANGED_QUEST = false
  #  LIST_WINDOW_WIDTH - The width, in pixels, of the List Window
  LIST_WINDOW_WIDTH = 192
  #  BASIC_DATA_TYPES  - This lets you set up additional types of data. Just
  # include an identifying signal in the Array. Then, you will need to give 
  # each signal an icon (in the ICONS hash at line 322) and a signal text (in 
  # the VOCAB array at line 333, though it can be an empty string). Then, you 
  # can set the data itself when setting up quests by simply adding a:
  #    q[:symbol] = ""
  # line to the quest. You will also need to include the data type somewhere in
  # the DATA_LAYOUT at line 306. As an example of this, I have included :client
  # and :location by default. You can CTRL+F for anything in this section with
  # one of those symbols (excluding :) and you will there need to add something
  # for any new data types you add.
  BASIC_DATA_TYPES = [:client, :location]
  #  BASIC_DATA_WIDTH - This determines how much room, in pixels, is given to  
  # any basic data types you set up in the data window.
  BASIC_DATA_WIDTH = 240
  #  CONCURRENT_ACTIVITY - If true, then when in the Quest Journal scene, you
  # can switch categories or scroll down the quest list at the same time. If
  # false, you will first need to select a category before you can start 
  # scrolling through the quest list.
  CONCURRENT_ACTIVITY = true
  #  HIDE_CATEGORY_CURSOR - If true, then the Category Window will not have a
  # cursor and will instead just highlight the currently selected category. 
  # This is best when CONCURRENT_ACTIVITY is true.
  HIDE_CATEGORY_CURSOR = true
  #  SHOW_QUEST_ICONS - If true, then the icon you choose for each quest will
  # be displayed to the left of its name in the Quest List window
  SHOW_QUEST_ICONS = true
  #  MANUAL_REVEAL - If false, then quests will be revealed the moment you 
  # first reveal, complete, or fail an objective. If this is true, you will
  # need to specifically reveal each quest via a separate script call:
  #    reveal_quest(quest_id)
  MANUAL_REVEAL = false
  #  DATA_LAYOUT - This controls the way that the quest window lays out all of
  # the relevant data. If you set one of the entries to be an array, then any
  # of the commands there will be drawn at the same y. With exception to :line,
  # none of the commands will be drawn if the quest is not set to have that
  # particular data. The symbols are:
  #    :line        - Draws a horizontal line across the window.
  #    :name        - Draws the name of the quest
  #    :level       - Draws the level of the quest
  #    :banner      - Draws the banner for the quest
  #    :client      - Draws the client set in the quest   (basic data)
  #    :location    - Draws the location set in the quest (basic data)
  #    :description - Draws the quest's description
  #    :objectives  - Draws all the quest's objectives that have been revealed
  #    :rewards     - Draws whatever rewards have been set
  #
  # You will also need to add an entry for any new BASIC_DATA that you place
  # in BASIC_DATA_TYPES at line 264.
  #
  # Remember to place a comma after each entry. Also note that this is only the
  # default layout. You can set a different layout for any quest, and when 
  # viewing that quest, it will be the custom layout that is shown.
  DATA_LAYOUT = [
    [:line, :name, :level], 
    :banner, 
    :client, 
    :location, 
    :description, 
    :objectives, 
    [:line, :rewards], 
    :line,
  ] # <= Do not touch.
  #  ICONS - This is where you setup many of the icons used in the script. The
  # purpose of each is listed next to it. Also, if you make any custom 
  # categories, you NEED to give them an icon by placing a line like the 
  # others. So, if the new custom category is :romance then you would need to
  # set it like this:
  #    romance:     107,
  ICONS = {
    all:         226, # The icon for the All Quests category
    active:      236, # The icon for the Active Quests category
    complete:    238, # The icon for the Complete Quests category
    failed:      227, # The icon for the Failed Quests category
    client:      121, # The icon for client data. If none wanted, set to 0
    location:    231, # The icon for location data. If none wanted, set to 0
    reward_gold: 262, # The icon for gold rewards. If none wanted, set to 0
    reward_exp:  117, # The icon for exp rewards. If none wanted, set to 0
    transaction: 230,
  } # <= Do not touch.
  #  VOCAB - This lets you choose some of the words used in the quest scene
  VOCAB = {
    # menu_label:  The command name in the menu if MENU_ACCESS is true
    menu_label:       "Quests",
    # scene_label: The label at the top of the scene. If empty, no window
    scene_label:      "Quest Journal", 
    # description: The heading to identify the description
    description:      "Description",
    # objectives: The heading to identify the objectives
    objectives:       "Objectives",
    # objective_bullet: The bullet which shows up to the left of every
    #  objective. If %d is included, it shows the objective's ID.
    objective_bullet: ">",#"♦",
    # rewards: The heading to identify the rewards.
    rewards:          "Rewards",
    # reward_amount: For item rewards, this is the text to show the amount. 
    #  It should include %d to show the amount.
    reward_amount:    "x%d",
    # reward_gold: Text to identify gold rewards
    reward_gold:      "",
    # reward_exp: Text to identify exp rewards
    reward_exp:       "",
    # level: If LEVEL_ICON is 0, this is the text which precedes the level
    level:            "Rank: ",
    # location: The text label for quest location
    location:         "",
    # location: The text label for quest client
    client:           "",
  } # <= Do not touch.
  #  CATEGORIES - This array allows you to set which categories are available 
  # in the Quest scene. The default categories are :all, :active, :complete,
  # and :failed, and their names are self-explanatory. You can add custom
  # categories as well, but note that you will need to make sure that each new
  # category has an icon set in the ICONS hash, as well as a label set in the
  # CATEGORY_VOCAB hash (if you are using SHOW_CATEGORY_LABEL). It is also 
  # advisable to give it a sort type, unless you are fine with it being sorted
  # by ID, as is default.
  CATEGORIES = [:active, :complete, :failed, :transaction]
  #  SHOW_CATEGORY_LABEL - This allows you to choose whether to show the name
  # of the currently selected category. If true, it will choose the name out
  # of the CATEGORY_VOCAB hash.
  SHOW_CATEGORY_LABEL = true
  #  CATEGORY_LABEL_IN_SAME_WINDOW - If SHOW_CATEGORY_LABEL is true, then this
  # options lets you choose whether the label is shown in the same window as 
  # the category icons or in a separate window below. true = same window.
  CATEGORY_LABEL_IN_SAME_WINDOW = true
  #  CATEGORY_VOCAB - If SHOW_CATEGORY_LABEL is true, this hash lets you set the
  # label for each category. For any custom categories you create, you will 
  # need to add a line for each below and in the same format:
  #    :category => "Label",
  # Don't forget to add the comma at the end of each line.
  CATEGORY_VOCAB = {
    :all =>      "All Quests",      # The label for the :all category
    :active =>   "Active Quests",   # The label for the :active category
    :complete => "Complete Quests", # The label for the :complete category
    :failed =>   "Failed Quests",   # The label for the :failed category
    :transaction => "Transaction History"
  } # <= Do not touch.
  #  SORT_TYPE - This hash allows you to choose how each category is sorted. 
  # For each category, default or custom, you can set a different sort method
  # There are seven options to choose from:
  #    :id - The quests are sorted from lowest to highest ID
  #    :alphabet - The quests are sorted in alphabetical order
  #    :level - The quests are sorted from the lowest to highest level
  #    :reveal - The quests are sorted from most recently revealed on. 
  #            Every time a new quest is revealed, it will be at the top.
  #    :change - The quests are sorted from the one whose status most recently
  #            changed on. So, every time an objective is modified, that quest
  #            will be thrown to the top.
  #    :complete - The quests are sorted from the most recently completed on.
  #            Every time a quest is completed, it will be thrown to the top.
  #    :failed - The quests are sorted from the most recently failed on. 
  #            Every time a quest is failed, it will be thrown to the top.
  #
  # Additionally, you can put _r at the end of any of the sort options and it
  # will reverse the order. So, for instance, if the sort method for a category
  # is :alphabet_r, then the quests will show up from Z-A
  SORT_TYPE = {
    :all =>      :id,       # Sort type for the All Quests category
    :active =>   :change,   # Sort type for the Active Quests category
    :complete => :complete, # Sort type for the Complete Quests category
    :failed =>   :failed,   # Sort type for the Failed Quests category
  } # <= Do not touch.
  #  WINDOWSKIN - The windowskin for each window in the Quest scene. It must
  # refer to a graphic in the System folder of Graphics. If set to false, then
  # it will use whatever windowskin is default. If you are using a script which
  # lets the player choose the windowskin, false is the recommended value.
  WINDOWSKIN = false
  #  WINDOW_TONE - The tone for each window. It must be an array in the form: 
  #      WINDOW_TONE = [red, green, blue, gray]
  # gray can be excluded, but the other three must be present. If you set this
  # value to false, then the windows will have whatever tone is default.
  WINDOW_TONE = false
  #  WINDOW_OPACITY - The opacity of the windows in the Quest scene. If set to
  # false, it will use the default opacity for windows.
  WINDOW_OPACITY = false
  #  BG_PICTURE - This is a string referring to a picture in the Picture folder
  # of Graphics. If set to "", then there will be no picture. Otherwise, it 
  # will display the selected picture below the windows but above the map in
  # the Quest scene.
  BG_PICTURE = ""
  #  BG_OPACITY - This allows you to set the opacity of the background picture,
  # if you have selected one.
  BG_OPACITY = 255
  #  BG_BLEND_TYPE - This allows you to set the blend type of the background
  # picture, if you have selected one.
  BG_BLEND_TYPE = 0 
  #  DESCRIPTION_IN_BOX - This is a graphical option, and it allows you to 
  # choose whether the description should be shown in a box.
  DESCRIPTION_IN_BOX = true#false
  #  LEVEL_ICON - This sets how levels are shown. If set to an integer, then it
  # will draw the same icon numerous times up to the level of the quest. Ie. If
  # the level's quest is 1, then the icon will only be drawn once, but if the 
  # level's quest is 4, it will be drawn 4 times. LEVEL_ICONS_SPACE determines
  # the space between them. If you set LEVEL_ICON to 0, however, then it will
  # instead draw a signal for the level, corresponding to that index in the 
  # LEVEL_SIGNALS array. If the LEVEL_SIGNALS array is empty, then it will just
  # draw the integer for the level. Finally, LEVEL_ICON can also be an array of
  # integers, in which case the level will be represented only by the icon set
  # which corresponds to it in the array.
  LEVEL_ICON = 125
  #  LEVEL_ICONS_SPACE - If LEVEL_ICON is an integer, this is the amount of
  # space between each time the icon is drawn.
  LEVEL_ICONS_SPACE = 16
  #  LEVEL_SIGNALS - If LEVEL_ICON is 0, this allows you to set what string
  # should be the signal for each level. If this array is empty, then it will
  # just draw the level integer. Ie. if the Quest is Level 4, it will draw 4.
  LEVEL_SIGNALS = ["F", "E", "D", "C", "B", "A", "S"]
  #  COLOURS - This lets you change the colour for various aspects of the 
  # quest scene. Each can be set in one of three ways:
  #    :symbol - If you use a symbol, the colour will be the result of calling 
  #      the method of the same name. For instance, if you set something to 
  #      :system_color, it will set the colour to the result of the Window_Base
  #      system_color method.
  #    Integer - If you set the colour to an integer, then it will take its 
  #      colour from the windowskin palette, just like using \c[x] in messages.
  #    Array - You can also set the rgba values directly with an array in the
  #      format: [red, green, blue, alpha]. alpha can be excluded, but you must
  #      have values for red, green, and blue.
  COLOURS = {
    # active: This sets the colour for active quests in the list and the name
    #  of the active quest when shown in the data window.
    active:           :normal_color,
    # complete: This sets the colour for complete quests in the list and the 
    #  name of the complete quest when shown in the data window.
    complete:         3,
    # failed: This sets the colour for failed quests in the list and the name
    #  of the failed quest when shown in the data window.
    failed:           10,
    # line:  This sets the colour for lines or boxes drawn in the quest scene
    line:             :system_color,
    # line_shadow:  This sets the colour of the shadow for lines or boxes drawn 
    #  in the quest scene
    line_shadow: [0, 0, 0, 128],
    # scene_label: This sets the colour for the scene label, if shown
    scene_label:      :system_color,
    # category_label: This sets the colour for the category label, if shown
    category_label:   :normal_color,
    # level_signal: This sets the colour for the level signal, if shown
    level_signal:     :normal_color,
    # objective_bullet: This sets the colour for objectives; if set to 
    #  :maqj_objective_color, it will reflect the completion status of the
    #  objective, but you can change it to something else if you prefer
    objective_bullet: :maqj_objective_color,
    # reward_amount: The colour of the item amount, when shown
    reward_amount:    :normal_color,
    # heading: The colour of any headings in the script, like "Description"
    heading:          :system_color,
    # basic_label: For basic data, like client, the colour of the label
    basic_label:      :system_color,
    # basic_value: For basic data, like client, the colour of the value
    basic_value:      :normal_color,
  } # <= Do not touch.
  #  HEADING_ALIGN - This sets the alignment for the aspects listed. 0 is Left;
  # 1 is Centre; 2 is Right
  HEADING_ALIGN = {
    description: 0, # Alignment for the Description heading
    objectives:  0, # Alignment for the Objectives heading
    rewards:     1, # Alignment for the Rewards heading
    level:       2  # Alignment when showing the level
  } # <= Do not touch.
  #````````````````````````````````````````````````````````````````````````````
  #    Font Aspects
  # 
  #  All of the following options (FONTNAMES, FONTSIZES, FONTBOLDS, and 
  # FONTITALICS) allow you to alter the fonts used for various aspects of the 
  # scene. The only one listed there by default is normal:, which is the 
  # font used by default for the entire scene. However, you can change the  
  # fonts for almost any aspect - all you need to do is add a line like so:
  #
  #    description: value,
  #
  # and that will change that font aspect when drawing the description. The 
  # following symbols are available for changing:
  #
  #   normal:         The default font used for every part of the scene
  #   list:           The font used in the List Window
  #   scene_label:    The font used when drawing the Scene Label, if shown
  #   category_label: The font used when drawing the Category Label, if shown
  #   heading:        The font used when drawing any headings, like "Description"
  #   name:           The font used when drawing the quest name in data window
  #   description:    The font used when drawing the Description
  #   objectives:     The font used when drawing the objectives
  #   rewards:        The font used when drawing the rewards
  #   client:         The font used when drawing the client
  #   location:       The font used when drawing the location
  #
  # For any of them, you need to set a value. What the value can be depends
  # on which font aspect you are changing and is described below, but for any
  # of them setting it to the false will mean it will simply use the default
  #
  # For any that you add, remember that you must put a comma after the value.
  #````````````````````````````````````````````````````````````````````````````
  #  FONTNAMES - Here you can change the font used for any of the various 
  # options. It can take any of the following types of values:
  #     false    - The default font will be used
  #     "String" - The font with the name "String" will be used.
  #     [Array]  - The array must be in the form: ["String1", "String2", ...]
  #               The font used will be the first one in the array that the 
  #               player has installed.
  #
  #  EXAMPLES:
  #
  #    normal:      false,
  #      The font used for unaltered aspects of the scene is the default font
  #    scene_label: "Algerian",
  #      The font used for the Scene Label will be Algerian.
  #    description: ["Cambria", "Times New Roman"],
  #      The font used when drawing the description will be Cambria if the
  #      player has Cambria installed. If the player does not have Cambria 
  #      installed, then the font used will be Times New Roman
  FONTNAMES = {
    normal: false, # normal: the default font name 
  } # <= Do not touch.
  #  FONTSIZES - Here you can change the size of the font. There are two types
  # of values you can set:
  #    false   - The default fontsize will be used
  #    Integer - The fontsize will be equal to the value of the Integer.
  #  
  # For everything but the label windows, this shouldn't exceed 24, since that 
  # is the line_height. However, for scene_label: and category_label:, the size 
  # of the window will be adjusted to whatever size you set the font.
  FONTSIZES = {
    normal:         false, # normal: default font size
    scene_label:    28,    # scene_label: fontsize for the Scene Label window
    category_label: 24,    # category_label: fontsize for Category Label window
  } # <= Do not touch.
  #  FONTBOLDS - Here you can set whether the font will be bolded. You can set 
  # it to either false, in which case it will not be bolded, or true, in which 
  # case it will be bolded.
  FONTBOLDS = {
    scene_label:  true, # scene_label: whether font is bold for Scene Label
    heading:      true, # heading: whether font is bold for the headings
    level_signal: true, # level_signal: whether font is bold for level
  } # <= Do not touch.
  #  FONTITALICS - Here you can set whether the font will be italicized. You
  # can set it to either false, in which case it will not be italicized, or 
  # true, in which case it will be italicized.
  FONTITALICS = {
  }
  #||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
  #  END Editable Region A
  #//////////////////////////////////////////////////////////////////////////
  CATEGORIES = [:all] if !CATEGORIES || CATEGORIES.empty?
  VOCAB.default = ""
  ICONS.default = 0
  CATEGORY_VOCAB.default = ""
  SORT_TYPE.default = :id
  COLOURS.default = :normal_color
  HEADING_ALIGN.default = 0
  FONTNAMES.default = false
  FONTSIZES.default = false
  FONTBOLDS.default = false
  FONTITALICS.default = false
  
end
#==============================================================================
# *** DataManager
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Summary of Changes:
#    aliased method - self.extract_save_contents
#==============================================================================
class << DataManager
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Extract Save Contents
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias maqj_extractsavecons_2kw5 extract_save_contents
  def extract_save_contents(*args, &block)
    maqj_extractsavecons_2kw5(*args, &block) # Call Original Method
    if $game_party.quests.nil?
      $game_party.init_maqj_data
      $game_system.init_maqj_data
    end
  end
end
#==============================================================================
# ** MAQJ_SortedArray
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This module mixes in to an array to maintain the sorted order when inserting
#==============================================================================
module MAQJ_SortedArray
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Insert to Array
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def maqj_insert_sort(el, &block)
    index = bsearch_index(el, 0, size, &block)
    index ? insert(index, el) : push(el)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Retrieve Index from Binary Search
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def bsearch_index(el, b = 0, e = size, &block)
    return bsearch_index(el, b, e) { |a,b| a <=> b } if block.nil?
    return b if b == e # Return the discovered insertion index
    return if b > e
    m = (b + e) / 2    # Get Middle
    block.call(el, self[m]) > 0 ? b = m + 1 : e = m 
    bsearch_index(el, b, e, &block) 
  end
end
#==============================================================================
# ** Game_Quest
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This class holds all instance data for a quest
#==============================================================================
class Game_Quest
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Public Instance Variables
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  attr_reader   :id                  # Unique identifier for this quest
  attr_reader   :name                # The name to be shown for the quest
  attr_reader   :level               # The level of difficulty of the quest
  attr_reader   :objectives          # An array of objective strings
  attr_reader   :prime_objectives    # An array of crucial objective IDs
  attr_reader   :revealed_objectives # An array of revealed objective IDs
  attr_reader   :complete_objectives # An array of completed objective IDs
  attr_reader   :failed_objectives   # An array of failed objective IDs
  attr_reader   :custom_categories   # An array of category symbols
  attr_accessor :icon_index          # Icon associated with this quest
  attr_accessor :common_event_id     # ID of common event to call upon complete
  attr_accessor :description         # The description for the quest
  attr_accessor :banner              # Picture shown to represent the quest
  attr_accessor :banner_hue          # The hue of the banner
  attr_accessor :layout              # The layout of this quest in scene
  attr_accessor :rewards             # An array of rewards to show
  attr_accessor :reward_given        # Boolean tracking if quest was rewarded
  attr_accessor :concealed           # Whether or not the quest is visible
  attr_accessor :manual_status       # Quest status if not using prime objectives
  QuestData::BASIC_DATA_TYPES.each { |data_type| attr_accessor(data_type) }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Object Initialization
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def initialize(quest_id)
    @id = quest_id
    @concealed = default_value_for(:concealed)
    @reward_given = default_value_for(:reward_given)
    reset
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Reset
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def reset
    data = QuestData.setup_quest(@id)
    data_symbol_array.each { |meth| instance_variable_set(:"@#{meth}", 
      data[meth] ? data[meth] : default_value_for(meth)) }
    @revealed_objectives = [].send(:extend, MAQJ_SortedArray)
    @complete_objectives = [].send(:extend, MAQJ_SortedArray)
    @failed_objectives =   [].send(:extend, MAQJ_SortedArray)
    @manual_status = default_value_for(:manual_status)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Data Symbol Array
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def data_symbol_array
    [:name, :level, :objectives, :prime_objectives, :custom_categories, 
      :icon_index, :description, :banner, :banner_hue, :common_event_id, 
      :layout, :rewards] + QuestData::BASIC_DATA_TYPES
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Default Value
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def default_value_for(method)
    case method
    when :name then "??????"
    when :description, :banner then ""
    when :level, :banner_hue, :icon_index, :common_event_id then 0
    when :objectives, :rewards, :custom_categories then []
    when :prime_objectives then Array.new(objectives.size) { |x| x }
    when :concealed then QuestData::MANUAL_REVEAL
    when :manual_status then :active
    when :layout, :reward_given then false
    else ""
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Reveal/Conceal Objective
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def reveal_objective(*obj)
    valid_obj = obj.select {|x| x < objectives.size && !@revealed_objectives.include?(x) }
    valid_obj.each {|i| @revealed_objectives.maqj_insert_sort(i) }
    unless valid_obj.empty?
      quest_status_changed
      info = sprintf(Vocab::QuestUpdated, @name)
      SceneManager.display_info(info)
      Audio.se_play("Audio/SE/AOE_mission",100, 100) if !@symbol_failed
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def conceal_objective(*obj)
    quest_status_changed unless (obj & @revealed_objectives).empty?
    obj.each { |obj_id| @revealed_objectives.delete(obj_id) }
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Complete/Uncomplete Objective
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def complete_objective(*obj)
    valid_obj = obj.select {|x| x < objectives.size && !@complete_objectives.include?(x) }
    reveal_objective(*valid_obj)
    unfail_objective(*valid_obj)
    was_complete = status?(:complete)
    valid_obj.each {|i| @complete_objectives.maqj_insert_sort(i) }
    quest_status_changed unless valid_obj.empty?
    # If just completed
    if status?(:complete) && !was_complete
      $game_temp.reserve_common_event(common_event_id)
      $game_party.quests.add_to_sort_array(:complete, @id)
    end
  end
  def uncomplete_objective(*obj)
    quest_status_changed unless (obj & @complete_objectives).empty?
    obj.each { |obj_id| @complete_objectives.delete(obj_id) }
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Fail/Unfail Objective
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def fail_objective(*obj)
    @symbol_failed = true
    valid_obj = obj.select {|x| x < objectives.size && !@failed_objectives.include?(x) }
    reveal_objective(*valid_obj)
    uncomplete_objective(*valid_obj)
    was_failed = status?(:failed)
    valid_obj.each {|i| @failed_objectives.maqj_insert_sort(i) }
    unless valid_obj.empty?
      quest_status_changed
      info = sprintf(Vocab::QuestUpdated, @name)
      SceneManager.display_info(info)
      Audio.se_play("Audio/SE/AOE_WW_destroyed",100, 100)
    end
    $game_party.quests.add_to_sort_array(:failed, @id) if status?(:failed) && !was_failed
  end
  def unfail_objective(*obj)
    quest_status_changed unless (obj & @failed_objectives).empty?
    obj.each { |obj_id| @failed_objectives.delete(obj_id) }
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Updates when the quest status has been changed
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def quest_status_changed
    $game_party.quests.add_to_sort_array(:change, @id) 
    $game_system.last_quest_id = @id if QuestData::OPEN_TO_LAST_CHANGED_QUEST
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Objective Status?
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def objective_status?(status_check, *obj)
    return false if obj.empty?
    case status_check
    when :failed   then !(obj & @failed_objectives).empty?
    when :complete then obj.size == (obj & @complete_objectives).size
    when :revealed then obj.size == (obj & @revealed_objectives).size
    when :active then objective_status?(:revealed, *obj) && 
      !objective_status?(:complete, *obj) && !objective_status?(:failed, *obj)
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Status?
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def status?(status_check)
    case status_check
    when :failed  
      @prime_objectives.empty? ? @manual_status == :failed : 
        !(@failed_objectives & @prime_objectives).empty?
    when :complete
      @prime_objectives.empty? ? @manual_status == :complete : !status?(:failed) && 
        ((@prime_objectives & @complete_objectives) == @prime_objectives)
    when :active then !concealed && !status?(:complete) && !status?(:failed)
    when :reward then @reward_given
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Name
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def name=(new_name)
    @name = new_name
    $game_party.quests.add_to_sort_array(:alphabet, @id) if $game_party && 
      $game_party.quests
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Level
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def level=(new_lvl)
    @level = new_lvl
    $game_party.quests.add_to_sort_array(:level, @id) if $game_party && 
      $game_party.quests
  end
end
#==============================================================================
# ** Game_Quests 
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This is a wrapper for an array holding Game_Quest objects
#==============================================================================
class Game_Quests
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Object Initialization
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def initialize
    @data = {}
    @sort_arrays = {
      reveal: [], change: [], complete: [], failed: [],
      id:       [].send(:extend, MAQJ_SortedArray),
      alphabet: [].send(:extend, MAQJ_SortedArray),
      level:    [].send(:extend, MAQJ_SortedArray)
    }
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Get Quest
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def [](quest_id)
    reset_quest(quest_id) if !@data[quest_id]
    @data[quest_id]
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Quest <- Not sure when this would ever be useful.
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def []=(quest_id, value)
    @data[quest_id] = value
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * List
  #    list_type : the type of list to return
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def list(list_type = :all, sort_type = $game_system.quest_sort_type[list_type])
    sort_type_s = sort_type.to_s
    reverse = !(sort_type_s.sub!(/_r$/, "")).nil?
    sort_type = sort_type_s.to_sym
    list = @sort_arrays[sort_type].select { |quest_id| include?(quest_id, list_type) }
    list.reverse! if reverse
    list.collect { |quest_id| @data[quest_id] }
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Include?
  #    determines whether to include a particular quest depending on list type
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def include?(quest_id, list_type = :all)
    return false if !revealed?(quest_id)
    case list_type
    when :all then true
    when :complete, :failed, :active then @data[quest_id].status?(list_type)
    else
      @data[quest_id].custom_categories.include?(list_type)
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Revealed? 
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def revealed?(quest_id)
    (!@data[quest_id].nil? && !@data[quest_id].concealed)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Setup Quest
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def setup_quest(quest_id)
    return if @data[quest_id]
    @data[quest_id] = Game_Quest.new(quest_id)
    # Open to this quest next time the QJ is opened
    $game_system.last_quest_id = quest_id if QuestData::OPEN_TO_LAST_REVEALED_QUEST
    # Save sorting order in separate arrays to avoid re-sorting every time
    @sort_arrays.keys.each { |sym| add_to_sort_array(sym, quest_id) }
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Delete Quest
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def delete_quest(quest_id)
    @data.delete(quest_id)
    @sort_arrays.values.each { |ary| ary.delete(quest_id) }
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Reset Quest
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def reset_quest(quest_id)
    delete_quest(quest_id)
    setup_quest(quest_id)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Add to Sorted Array
  #    sort_type : array to alter
  #    quest_id  : ID of the quest to add.
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def add_to_sort_array(sort_type, quest_id)
    @sort_arrays[sort_type].delete(quest_id) # Make sure always unique
    case sort_type
    when :reveal, :change, :complete, :failed
      @sort_arrays[sort_type].unshift(quest_id)
    when :id
      @sort_arrays[sort_type].maqj_insert_sort(quest_id)
    when :alphabet 
      @sort_arrays[sort_type].maqj_insert_sort(quest_id) { |a, b| @data[a].name.downcase <=> @data[b].name.downcase }
    when :level
      @sort_arrays[sort_type].maqj_insert_sort(quest_id) { |a, b| @data[a].level <=> self[b].level }
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Find Location
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def find_location(quest_id, cat = nil)
    if revealed?(quest_id)
      categories = $game_system.quest_categories.dup
      # If cat specified, check in that category first.
      if cat && categories.include?(cat)
        categories.delete(cat)
        categories.unshift(cat)
      end
      for category in categories # Check all categories
        index = list(category).index(@data[quest_id])
        return category, index if index != nil
      end
    end
    return nil, nil
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Clear
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def clear
    @data.clear
  end
end
#==============================================================================
# ** Game System
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Summary of Changes:
#    new attr_accessor - quest_menu_access; quest_map_access; quest_sort_type;
#      quest_bg_picture; quest_bg_opacity; quest_windowskin; 
#      quest_window_opacity; quest_access_disabled; last_quest_cat; 
#      last_quest_id
#    aliased methods - initialize
#    new methods - init_maqj_data
#==============================================================================
class Game_System
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Public Instance Variables
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  attr_reader   :quest_menu_access     # Whether the scene is called from menu
  attr_accessor :quest_map_access      # Whether the scene is called from map
  attr_accessor :quest_sort_type       # The sort types for each category
  attr_accessor :quest_bg_picture      # The filename of the background picture
  attr_accessor :quest_bg_opacity      # The opacity of the background picture
  attr_accessor :quest_bg_blend_type   # The blend type of the background pic
  attr_accessor :quest_windowskin      # The windowskin used for the scene
  attr_accessor :quest_window_tone     # The tone of windows in the scene
  attr_accessor :quest_window_opacity  # The opacity of windows in the scene
  attr_accessor :quest_access_disabled # Whether access to Quests is disabled
  attr_accessor :quest_categories      # The categories to show in the scene
  attr_accessor :quest_scene_label     # The label to show in the scene
  attr_accessor :last_quest_cat        # The category to open to
  attr_accessor :last_quest_id         # The ID to open to
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Object Initialization
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias maqj_initialze_2cy9 initialize
  def initialize(*args, &block)
    maqj_initialze_2cy9(*args, &block)
    init_maqj_data
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Initialize Quest Data
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def init_maqj_data
    # Initialize new variables
    self.quest_menu_access = QuestData::MENU_ACCESS
    @quest_map_access = QuestData::MAP_ACCESS
    @quest_sort_type = QuestData::SORT_TYPE
    @quest_bg_picture = QuestData::BG_PICTURE
    @quest_bg_opacity = QuestData::BG_OPACITY
    @quest_bg_blend_type = QuestData::BG_BLEND_TYPE
    @quest_windowskin = QuestData::WINDOWSKIN
    @quest_window_tone = QuestData::WINDOW_TONE
    @quest_window_opacity = QuestData::WINDOW_OPACITY
    @quest_access_disabled = false
    @quest_categories = QuestData::CATEGORIES
    @quest_scene_label = QuestData::VOCAB[:scene_label]
    @last_quest_cat = @quest_categories[0]
    @last_quest_id = 0
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Quest Menu Access
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def quest_menu_access=(boolean)
    @quest_menu_access = boolean
    maic_inserted_menu_commands.delete(:quest_journal)
    maic_inserted_menu_commands.push(:quest_journal) if @quest_menu_access 
    maic_inserted_menu_commands.sort!
  end
end
#==============================================================================
# ** Game_Party
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Summary of Changes:
#    new attr_reader - quests
#    aliased method - initialize
#    new method - init_maqj_data
#==============================================================================
class Game_Party
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Public Instance Variables
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  attr_reader :quests
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Object Initialization
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias maqj_intiaze_2si9 initialize
  def initialize(*args, &block)
    maqj_intiaze_2si9(*args, &block) # Call Original Method
    init_maqj_data
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Initialize Quests
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def init_maqj_data
    @quests = Game_Quests.new # Initialize @quests
  end
end
#==============================================================================
# ** Game_Interpreter
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Summary of Changes:
#    new methods - change_quest_access; change_quest_background;
#      change_quest_windows; setup_quest; delete_quest; reset_quest; quest; 
#      reveal_quest; conceal_quest; manually_complete_quest;
#      manually_fail_quest; reveal_objective; conceal_objective; 
#      complete_objective; uncomplete_objective; fail_objective; 
#      unfail_objective; quest_revealed?; quest_complete?; quest_active?; 
#      quest_failed?; objective_complete?; objective_active?; 
#      objective_failed?; distribute_quest_rewards; distribute_quest_reward;
#      call_quest_journal
#==============================================================================
class Game_Interpreter
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Change Quest Access
  #    sym : symbol representing what aspect of access is being changed
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def change_quest_access(sym)
    case sym
    when :enable then $game_system.quest_access_disabled = false
    when :disable then $game_system.quest_access_disabled = true
    when :enable_menu then $game_system.quest_menu_access = true 
    when :disable_menu then $game_system.quest_menu_access = false 
    when :enable_map then $game_system.quest_map_access = true 
    when :disable_map then $game_system.quest_map_access = false 
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Change Quest Background
  #    picture : picture to show in the scene's background
  #    opacity : opacity of the picture shown in the scene's background
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def change_quest_background(picture, opacity = $game_system.quest_bg_opacity,
      blend_type = $game_system.quest_bg_blend_type)
    $game_system.quest_bg_picture = picture
    $game_system.quest_bg_opacity = opacity
    $game_system.quest_bg_blend_type = blend_type
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Change Quest Windows
  #    skin    : windowskin name to use in the scene
  #    tone    : tone for the windowskin
  #    opacity : opacity of windows in the scene
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def change_quest_windows(skin, tone = $game_system.quest_window_tone, 
      opacity = $game_system.quest_window_opacity)
    $game_system.quest_windowskin = skin
    $game_system.quest_window_tone = tone
    $game_system.quest_window_opacity = opacity
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Setup/Delete/Reset Quest
  #    quest_id : ID of the quest to be setup or deleted or reset
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  [:setup_quest, :delete_quest, :reset_quest].each { |method|
    define_method(method) do |quest_id| 
      $game_party.quests.send(method, quest_id)
    end
  }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Retrieve Quest
  #    quest_id : ID of the quest to retrieve
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def quest(quest_id);         $game_party.quests[quest_id];      end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Reveal/Conceal Quest 
  #    quest_id : ID of the quest to be revealed or concealed
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def reveal_quest(quest_id);  quest(quest_id).concealed = false; end
  def conceal_quest(quest_id); quest(quest_id).concealed = true;  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Manually Complete/Fail Quest 
  #    quest_id : ID of the quest to be revealed or concealed
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def manually_complete_quest(quest_id)
    quest(quest_id).prime_objectives.clear
    quest(quest_id).manual_status = :complete
  end
  def manually_fail_quest(quest_id)
    quest(quest_id).prime_objectives.clear
    quest(quest_id).manual_status = :failed
  end
  def manually_activate_quest(quest_id)
    quest(quest_id).manual_status = :active
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Reveal/Complete/Fail/Conceal/Uncomplete/Unfail Objective
  #    quest_id : ID of the quest whose objectives will be modified
  #    *obj     : IDs of objectives to reveal or complete or fail (or opposite)
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  [:reveal_objective, :complete_objective, :fail_objective, :conceal_objective,
  :uncomplete_objective, :unfail_objective].each { |method|
    define_method(method) do |quest_id, *obj| 
      quest(quest_id).send(method, *obj)
    end
  }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Quest Revealed?
  #    quest_id : ID of the quest you are checking is revealed
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def quest_revealed?(quest_id)
    $game_party.quests.revealed?(quest_id)
  end
  [:complete, :failed, :active].each { |method|
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # * Quest Complete/Failed/Active?
    #    quest_id : ID of the quest whose completion status is being checked
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    define_method(:"quest_#{method}?") do |quest_id| 
      quest_revealed?(quest_id) && quest(quest_id).status?(method) 
    end
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # * Objective Complete/Failed/Active?
    #    quest_id : ID of the quest whose objectives are being checked
    #    *obj     : IDs of objectives to check completion status
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    define_method(:"objective_#{method}?") do |quest_id, *obj| 
      quest_revealed?(quest_id) && quest(quest_id).objective_status?(method, *obj) 
    end
  }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Objective Revealed?
  #    quest_id : ID of the quest you are checking is revealed
  #    *obj     : IDs of objectives to check completion status
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def objective_revealed?(quest_id, *obj)
    quest_revealed?(quest_id) && quest(quest_id).objective_status?(:revealed, *obj) 
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Quest Rewarded?
  #    quest_id : ID of the quest you are checking is revealed
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def quest_rewarded?(quest_id)
    quest_revealed?(quest_id) && quest(quest_id).status?(:reward)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Change Reward Status
  #    quest_id : ID of the quest you are checking is revealed
  #    value    : true or false
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def change_reward_status(quest_id, value = true)
    quest(quest_id).reward_given = value
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Distribute Rewards
  #    quest_id : ID of the quest whose rewards are to be distributed
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def distribute_quest_rewards(quest_id)
    if quest_revealed?(quest_id) && !quest_rewarded?(quest_id)
      params = @params.dup
      change_reward_status(quest_id, true)
      quest(quest_id).rewards.each { |reward| distribute_quest_reward(reward) }
      @params = params
      true
    else
      false
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Distribute Reward
  #    reward : an array identifying the reward
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def distribute_quest_reward(reward)
    @params = [reward[1], 0, 0, (reward[2] ? reward[2] : 1)]
    case reward[0]
    when :item, 0 then   command_126 # Item
    when :weapon, 1 then command_127 # Weapon
    when :armor, 2 then  command_128 # Armor
    when :gold, 3   # Gold
      @params = [0, 0, reward[1] ? reward[1] : 0]
      command_125
    when :exp, 4    # Exp
      @params = [0, 0, 0, 0, reward[1] ? reward[1] : 0, true]
      command_315
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Call Quest Journal
  #    quest_id : ID of the quest to open the journal to
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def call_quest_journal(quest_id = nil)
    return if $game_party.in_battle
    $game_system.last_quest_id = quest_id if quest_id
    SceneManager.call(Scene_Quest)
    Fiber.yield
  end
end
unless $imported[:"MA_ParagraphFormat_1.0"]
#==============================================================================
# ** MA_Window_ParagraphFormat
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This module inserts into Window_Base and provides a method to format the
# strings so as to go to the next line if it exceeds a set limit. This is 
# designed to work with draw_text_ex, and a string formatted by this method 
# should go through that, not draw_text.
#==============================================================================
module MA_Window_ParagraphFormat
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Calc Line Width
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def mapf_calc_line_width(line, tw = 0, contents_dummy = false)
    return tw if line.nil?
    line = line.clone
    unless contents_dummy
      real_contents = contents # Preserve Real Contents
      # Create a dummy contents
      self.contents = Bitmap.new(contents_width, 24)
      reset_font_settings
    end
    pos = {x: 0, y: 0, new_x: 0, height: calc_line_height(line)}
    while line[/^(.*?)\e(.*)/]
      tw += text_size($1).width
      line = $2
      # Remove all ancillaries to the code, like parameters
      code = obtain_escape_code(line)
      # If direct setting of x, reset tw.
      tw = 0 if ($imported[:ATS_SpecialMessageCodes] && code.upcase == 'X') ||
        ($imported["YEA-MessageSystem"] && code.upcase == 'PX')
      #  If I need to do something special on the basis that it is testing, 
      # alias process_escape_character and differentiate using @atsf_testing
      process_escape_character(code, line, pos)
    end
    #  Add width of remaining text, as well as the value of pos[:x] under the 
    # assumption that any additions to it are because the special code is 
    # replaced by something which requires space (like icons)
    tw += text_size(line).width + pos[:x]
    unless contents_dummy
      contents.dispose # Dispose dummy contents
      self.contents = real_contents # Restore real contents
    end
    return tw
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Format Paragraph
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def mapf_format_paragraph(text, max_width = contents_width)
    text = text.clone
    #  Create a Dummy Contents - I wanted to boost compatibility by using the 
    # default process method for escape codes. It may have the opposite effect, 
    # for some :( 
    real_contents = contents # Preserve Real Contents
    self.contents = Bitmap.new(contents_width, 24)
    reset_font_settings
    paragraph = ""
    while !text.empty?
      text.lstrip!
      oline, nline, tw = mapf_format_by_line(text.clone, max_width)
      # Replace old line with the new one
      text.sub!(/#{Regexp.escape(oline)}/m, nline)
      paragraph += text.slice!(/.*?(\n|$)/)
    end
    contents.dispose # Dispose dummy contents
    self.contents = real_contents # Restore real contents
    return paragraph
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Format By Line
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def mapf_format_by_line(text, max_width = contents_width)
    oline, nline, tw = "", "", 0
    loop do
      #  Format each word until reach the width limit
      oline, nline, tw, done = mapf_format_by_word(text, nline, tw, max_width)
      return oline, nline, tw if done
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Format By Word
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def mapf_format_by_word(text, line, tw, max_width)
    return line, line, tw, true if text.nil? || text.empty?
    # Extract next word
    if text.sub!(/([ \t\r\f]*)(\S*)([\n\f]?)/, "") != nil
      prespace, word, line_end = $1, $2, $3
      ntw = mapf_calc_line_width(word, tw, true)
      pw = contents.text_size(prespace).width
      if (pw + ntw >= max_width)
        # Insert
        if line.empty?
          # If one word takes entire line
          return prespace + word, word + "\n", ntw, true 
        else
          return line + prespace + word, line + "\n" + word, tw, true
        end
      else
        line += prespace + word
        tw = pw + ntw
        # If the line is force ended, then end 
        return line, line, tw, true if !line_end.empty?
      end
    else
      return line, line, tw, true
    end
    return line, line, tw, false
  end
end
class Window_Base
  include MA_Window_ParagraphFormat
end
$imported[:"MA_ParagraphFormat_1.0"] = true
end
#==============================================================================
# *** MAQJ Window_QuestBase
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This module mixes in with all quest windows
#==============================================================================
module MAQJ_Window_QuestBase
  attr_reader :maqj_objective_color
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Object Initialization
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def initialize(*args, &block)
    super(*args, &block)
    reset_font_settings
    set_data_font(:normal)
    @maqj_default_font = contents.font.dup
    # Change the windowskin, tone if they are set to be changed
    self.windowskin = Cache.system($game_system.quest_windowskin) if $game_system.quest_windowskin
    self.opacity = $game_system.quest_window_opacity if $game_system.quest_window_opacity
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Reset Font Settings
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def reset_font_settings(*args, &block)
    super(*args, &block)
    set_data_font(@maqj_font_data_type) if @maqj_font_data_type
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Data Font
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def set_data_font(data_type)
    @maqj_default_font = contents.font.dup unless @maqj_default_font
    contents.font.name = QuestData::FONTNAMES[data_type] ? 
      QuestData::FONTNAMES[data_type] : @maqj_default_font.name
    contents.font.size = QuestData::FONTSIZES[data_type] ? 
      QuestData::FONTSIZES[data_type] : @maqj_default_font.size
    contents.font.bold = QuestData::FONTBOLDS.keys.include?(data_type) ? 
      QuestData::FONTBOLDS[data_type] : @maqj_default_font.bold
    contents.font.italic = QuestData::FONTITALICS.keys.include?(data_type) ?
      QuestData::FONTITALICS[data_type] : @maqj_default_font.italic
    case data_type
    when :objectives then change_color(@maqj_objective_color) if @maqj_objective_color
    when :name then change_color(quest_name_colour(@quest)) if @quest
    else
      change_color(text_color(QuestData::COLOURS[data_type])) if QuestData::COLOURS.keys.include?(data_type)
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Horizontal Line
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_horizontal_line(y, h = 2)
    contents.fill_rect(0, y, contents_width, h, text_color(QuestData::COLOURS[:line]))
    contents.fill_rect(0, y + h, contents_width, [h / 2, 1].max, text_color(QuestData::COLOURS[:line_shadow]))
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * MA Text Color
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def text_color(param)
    begin 
      colour = case param
      when Integer then super(param) rescue normal_color
      when Symbol then send(param) rescue normal_color
      when Array then Color.new(*param) rescue normal_color
      else
        normal_color
      end
    end
    colour.is_a?(Color) ? colour : normal_color
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Quest Name Colour
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def quest_name_colour(quest = @quest)
    return if !quest
    quest = $game_party.quests[quest] if quest.is_a?(Integer)
    s = [:failed, :complete, :active].find { |status| quest.status?(status) }
    text_color(QuestData::COLOURS[s])
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Quest Objective Colour
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def quest_objective_colour(quest, obj_id)
    return if !quest
    quest = $game_party.quests[quest] if quest.is_a?(Integer)
    s = [:failed, :complete, :active].find { |status| quest.objective_status?(status, obj_id) }
    text_color(QuestData::COLOURS[s])
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Update Tone
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def update_tone
    $game_system.quest_window_tone ? 
      self.tone.set(*$game_system.quest_window_tone) : super
  end
end
unless $imported[:"MA_IconHorzCommand_1.0"]
#==============================================================================
# ** Window_MA_IconHorzCommand
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This window is a base window to show a horizontal command window populated
# with icons.
#==============================================================================
class Window_MA_IconHorzCommand < Window_HorzCommand
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Public Instance Variable
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  attr_reader   :observing_procs
  attr_accessor :cursor_hide
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Object Initialization
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def initialize(*args, &block)
    @observing_procs = {}
    @old_index = -1
    super(*args, &block)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Column Max
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def col_max; [(width - standard_padding) / (24 + spacing), item_max].min; end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Item
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def item
    @list[index] ? @list[index][:symbol] : nil
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Enabled? / Current Item Enabled?
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def enable?(index); self.index == index; end
  def current_item_enabled?; !current_data.nil?; end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Item
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_item(index)
    rect = item_rect(index)
    contents.clear_rect(rect)
    draw_icon(@list[index][:ext], rect.x + ((rect.width - 24) / 2), rect.y, enable?(index))
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Index
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def index=(index)
    return if @old_index == index
    super(index)
    draw_item(@old_index)
    draw_item(index)
    @old_index = index
    Sound.play_cursor
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Frame Update
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def update
    super
    @observing_procs.values.each { |block| block.call(item) }
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Add/Remove Observing Window
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def add_observing_proc(id, &block)
    @observing_procs[id] = block
    update
  end
  def remove_observing_proc(id)     ; @observing_procs.delete(id) ; end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Update Cursor
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def update_cursor
    super
    cursor_rect.empty if @cursor_hide
  end
end
$imported[:"MA_IconHorzCommand_1.0"] = true
end
#==============================================================================
# ** Window_QuestCategory
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This window allows the player to switch between quest categories.
#==============================================================================
class Window_QuestCategory < Window_MA_IconHorzCommand
  include MAQJ_Window_QuestBase
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Object Initialization
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def initialize(x, y, categories = $game_system.quest_categories)
    @cursor_hide = QuestData::HIDE_CATEGORY_CURSOR
    @categories = categories
    super(x, y)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Window Width
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def window_width; QuestData::LIST_WINDOW_WIDTH; end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Category=
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def category=(category)
    self.index = @categories.index(category) if @categories.include?(category)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Make Command List
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def make_command_list
    @categories.each { |cat| 
      add_command("", cat, false, QuestData::ICONS[cat]) }
  end
end
#==============================================================================
# ** Window QuestLabel
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This window simply shows a label for the Quests scene
#==============================================================================
class Window_QuestLabel < Window_Base
  include MAQJ_Window_QuestBase
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Object Initialization
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def initialize(x, y, label = "")
    super(x, y, window_width, window_height)
    refresh(label)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Reset Font Settings
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def reset_font_settings; set_data_font(:scene_label); end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Window Attributes
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def window_width
    w = ($game_system.quest_categories.size > 1 || QuestData::SHOW_CATEGORY_LABEL) ? 
      Graphics.width - QuestData::LIST_WINDOW_WIDTH : QuestData::LIST_WINDOW_WIDTH
  end
  def window_height; line_height + (standard_padding*2); end
  def line_height(*args)
    line_h = super(*args)
    QuestData::FONTSIZES[:scene_label] ? 
      [QuestData::FONTSIZES[:scene_label], line_h].max : line_h
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Refresh
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def refresh(label = @label)
    @label = label.is_a?(String) ? convert_escape_characters(label) : ""
    contents.clear
    reset_font_settings
    tw = mapf_calc_line_width(@label)
    draw_text_ex((contents_width - tw) / 2, 0, @label)
  end
end
#==============================================================================
# ** Window QuestLabel
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This window simply shows a label for category currently selected
#==============================================================================
class Window_QuestCategoryLabel < Window_QuestLabel
  include MAQJ_Window_QuestBase
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Reset Font Settings
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def reset_font_settings; set_data_font(:category_label); end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Window Attributes
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def window_width; QuestData::LIST_WINDOW_WIDTH; end
  def line_height(*args)
    line_h = super(*args)
    QuestData::FONTSIZES[:category_label] ? 
      [QuestData::FONTSIZES[:category_label], line_h].max : line_h
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Category
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def category=(category)
    return if @category == category
    @category = category
    refresh(QuestData::CATEGORY_VOCAB[category])
  end
end
#==============================================================================
# ** Window_QuestCategoryDummy
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This window shows up behind the category and category label window 
#==============================================================================
class Window_QuestCategoryDummy < Window_Base
  include MAQJ_Window_QuestBase
end
#==============================================================================
# ** Window_QuestList
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This window shows all quests in a selected category.
#==============================================================================
class Window_QuestList < Window_Selectable
  include MAQJ_Window_QuestBase
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  attr_reader :category
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Object Initialization
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def initialize(x, y, width, height)
    super
    create_overlay
    @data = []
    @player_transaction_data = player_transacions
    self.index = 0
    activate
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Overlay confirm window
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def create_overlay
    @overlay_window = Window_Confirm.new(nil, nil, 380, 7)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Get player's transactions stored in blockchain, sorted by time stamp
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def player_transacions
    trans = BlockChain.transaction_data(Vocab::Player)
    re = {}
    trans.each do |t|
      (re[hash_date(t)] ||= []) << t
    end
    return re
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def hash_date(trans)
    return (trans.timestamp.to_i / 3600).to_i
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Category
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def category=(category)
    return if @category == category
    @category = category
    refresh
    self.index = 0
    update_help if @help_window
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def transaction_entry(index)
    hashid = @data.keys[index]
    return @data[hashid]
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Get Quest
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def item
    return @data && index >= 0 ? @data[index] : nil unless @category == :transaction
    return transaction_entry(index)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Column/Item Max
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def col_max; 1; end
  def item_max; @data ? @data.size : 1; end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Whether it should be drawn enabled
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def enable?(item); true; end
  def current_item_enabled?
    (@help_window && @help_window.maqj_visible_height < @help_window.contents_height)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Make Item List
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def make_item_list
    if @category == :transaction
      @data = @player_transaction_data
    else
      @data = @category ? $game_party.quests.list(@category) : []
    end
    debug_print("Current category: #{@category}\nDataS: #{@data.size}")
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Item
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_item(index)
    return draw_transaction_item(index) if @category == :transaction
    draw_quest_item(index)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw transaction data
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_transaction_item(index)
    rect = item_rect_for_text(index)
    text = transaction_entry(index).first.timestamp.strftime("%Y-%m-%d:%H")
    draw_text(rect, text)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw quest
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_quest_item(index)
    quest = @data[index]
    if quest
      rect = item_rect_for_text(index)
      if QuestData::SHOW_QUEST_ICONS
        draw_icon(quest.icon_index, rect.x, rect.y, enable?(quest))
        rect.x += 24
        rect.width -= 24
      end
      change_color(quest_name_colour(quest), enable?(quest))
      draw_text(rect, quest.name)
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Refresh
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def refresh
    make_item_list
    create_contents
    set_data_font(:list)
    draw_all_items
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Update Help
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def update_help
    @help_window.category = @category
    @help_window.quest = item
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def call_ok_handler
    if @category == :transaction
      return super if item.size < 10
      info = Vocab::BlockChain::LargeHistory
      raise_overlay(info, :call_handler, :ok)
    else
      super
    end
  end
end
#==============================================================================
# ** Window_QuestData 
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This window shows all quest data
#==============================================================================
class Window_QuestData < Window_Selectable
  include MAQJ_Window_QuestBase
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  attr_accessor :category
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Object Initialization
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def initialize(x, y, w, h, layout = QuestData::DATA_LAYOUT)
    @dest_scroll_oy = 0
    super(x, y, w, h)
    @category = nil
    @dest_scroll_oy = self.oy
    self.layout = layout
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Contents Height
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias maqj_visible_height contents_height
  def contents_height
    @q_contents_height ? [@q_contents_height, maqj_visible_height].max : maqj_visible_height
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Calculate Contents Height
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def calc_contents_height
    @q_contents_height = 0
    if @category == :transaction && @quest
      @q_contents_height = @quest.size * line_height * (Vocab::BlockChain::Info.keys.size - 1)
    else
      @layout.each { |dt| @q_contents_height += data_height(dt) } if @quest
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Data?
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_data?(data_type)
    case data_type
    when :line then true
    when :level then @quest.level > 0 
    when :objectives then !@quest.revealed_objectives.empty?
    when Array then (data_type - [:line]).any? { |dt| draw_data?(dt) }
    else !@quest.send(data_type).empty? # :description, :name, etc...
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Get Data Height
  #    This method calculates the height required for a specified element of
  #   the current quest. This is to calculate the needed space in contents,
  #   as well as advance the @draw_y variable.
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def data_height(data_type)
    return 0 unless draw_data?(data_type)
    return line_height if QuestData::BASIC_DATA_TYPES.include?(data_type)
    @maqj_font_data_type = data_type
    reset_font_settings
    return case data_type
    when :line, :level, :name then line_height
    when :banner
      bmp = Cache.picture(@quest.banner)
      hght = bmp.rect.height
      bmp.dispose
      hght
    when :description
      buff = description_x*2
      paragraph = mapf_format_paragraph(@quest.description, contents_width - buff)
      line_num = FileManager.textwrap(paragraph, contents_width - buff, contents).size
      line_num += (QuestData::DESCRIPTION_IN_BOX ? 2 : 
        !QuestData::VOCAB[:description].empty? ? 1 : 0)
      line_num * line_height
    when :objectives
      objectives = @quest.revealed_objectives.collect { |obj_id| 
        @quest.objectives[obj_id] } 
      line_num = QuestData::VOCAB[:objectives].empty? ? 0 : 1
      buff = (objective_x*2) + text_size(QuestData::VOCAB[:objective_bullet]).width
      objectives.each { |obj|
        paragraph = mapf_format_paragraph(obj, contents_width - buff)
        lines = FileManager.textwrap(paragraph, contents_width - buff, contents)
        line_num += lines.size + 1}
      line_num*line_height
    when :rewards
      line_num = QuestData::VOCAB[:rewards].empty? ? 0 : 1
      (line_num + @quest.rewards.size)*line_height
    when Array then data_height(data_type.max_by { |dt| data_height(dt) })
    else 0
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Quest
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def quest=(value)
    return if @quest == value
    @quest = value
    unless @category == :transaction
      @layout = (@quest && @quest.layout) ? @quest.layout : @default_layout
    end
    refresh
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Layout
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def layout=(value)
    return if @default_layout == value && @layout == value
    @default_layout = value
    @layout = value
    refresh
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Refresh
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def refresh
    contents.clear
    calc_contents_height
    create_contents
    return unless @quest && @layout
    self.oy = 0
    @dest_scroll_oy = 0
    #  The basic idea here is that each draw_ method will rely on and advance 
    # the @draw_y variable. Where they are an array, the elements will be 
    # drawn at the same @draw_y.
    draw_index_data(false)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_index_data(draw_all = false)
    @draw_y = 0
    if @category == :transaction
      draw_transaction_data(draw_all)
    else
      @layout.each {|dt|
        next unless draw_data?(dt)
        dt.is_a?(Array) ? draw_data_array(dt, draw_all) : draw_data(dt)
        break if !draw_all && @draw_y > maqj_visible_height
      }
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw transaction info
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_transaction_data(draw_all = false)
    trans = @quest
    trans.each do |t|
      break if !draw_all && @draw_y > maqj_visible_height
      text = ""
      5.times do |i|
        rect = Rect.new(0, @draw_y, contents_width, line_height)
        cx   = standard_padding
        contents.clear_rect(rect)
        case i
        when 0
          contents.draw_line(cx, @draw_y + 4, contents_width - cx, @draw_y + 4)
        when 1
          info = t.info.length > 0 ? t.info : "N/A"
          text = sprintf(Vocab::BlockChain::Info[:transinfo], info);
        when 2
          text = sprintf(Vocab::BlockChain::Info[:payment], t.source.name, t.recipient.name);
        when 3
          draw_icon(PONY::IconID[:bit], cx, @draw_y)
          cx += 26
          text = sprintf(Vocab::BlockChain::Info[:currency], Vocab::currency_unit, t.value);
        when 4
          if t.goods
            icon_id = (t.goods.icon_index || 0) rescue 0
            if icon_id > 0
              draw_icon(icon_id, cx, @draw_y)
              cx += 26
            end
            text = sprintf(Vocab::BlockChain::Info[:goods] ,t.goods.name, t.good_amount)
          else
            text = Vocab::BlockChain::Info[:nogoods]
          end
        end
        draw_text_ex(cx, @draw_y, text) unless text.empty?
        @draw_y += line_height
      end
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Data
  #    data_type : the data block to draw next
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_data(data_type)
    @maqj_font_data_type = data_type
    reset_font_settings
    send(:"draw_#{data_type}") if self.class.method_defined?(:"draw_#{data_type}")
    @draw_y += data_height(data_type)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Data Array
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_data_array(layout_array, draw_all = true)
    y, max_y = @draw_y, @draw_y
    # Draw each data aspect at the same starting @draw_y
    layout_array.each { |dt|
      @draw_y = y
      draw_data(dt, draw_all)
      break if !draw_all && @draw_y > maqj_visible_height
      max_y = @draw_y if @draw_y > max_y
    }
    @draw_y = max_y
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Line
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_line; draw_horizontal_line(@draw_y + (line_height / 2) - 1, 2); end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Name
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_name
    set_data_font(:name)
    clear_and_draw_text(0, @draw_y, contents_width, line_height, @quest.name, 1)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Level
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_level
    case QuestData::LEVEL_ICON
    when Array then QuestData::LEVEL_ICON.empty? ? draw_level_text : draw_level_array
    when 0 then draw_level_text
    else
      draw_level_stacked
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Stacked Level
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_level_stacked(icon_index = QuestData::LEVEL_ICON)
    align = QuestData::HEADING_ALIGN[:level]
    es = QuestData::LEVEL_ICONS_SPACE*(@quest.level - 1)
    x = align == 2 ? contents_width - 24 : align == 1 ? 
      (contents_width - 24 - (es)) / 2 : es
    @quest.level.times do
      draw_icon(icon_index, x, @draw_y)
      x -= QuestData::LEVEL_ICONS_SPACE
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Array Level
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_level_array(icon_index = QuestData::LEVEL_ICON)
    return if icon_index.empty?
    icon_index = icon_index[@quest.level - 1] ? icon_index[@quest.level - 1] : icon_index[-1]
    align = QuestData::HEADING_ALIGN[:level]
    x = align == 2 ? contents_width - 24 : align == 1 ? (contents_width-24)/2 : 0
    draw_icon(icon_index, x, @draw_y)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Text Level
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_level_text
    reset_font_settings
    level = QuestData::LEVEL_SIGNALS && QuestData::LEVEL_SIGNALS[@quest.level - 1] ? 
      QuestData::LEVEL_SIGNALS[@quest.level - 1] : @quest.level.to_s
    align = QuestData::HEADING_ALIGN[:level]
    tw = text_size(QuestData::VOCAB[:level]).width + 4
    tw2 = text_size(level).width + 2
    space = contents_width - tw - tw2
    x = align == 2 ? space : align == 1 ? space / 2 : 0
    clear_and_draw_text(x, @draw_y, tw, line_height, QuestData::VOCAB[:level])
    set_data_font(:level_signal)
    clear_and_draw_text(x + tw, @draw_y, tw2, line_height, level, 2)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Banner
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_banner
    bmp = Cache.picture(@quest.banner) # Get Picture
    # Shift the hue if requested
    bmp.hue_change(@quest.banner_hue) unless @quest.banner_hue == 0
    x = (contents_width - bmp.rect.width) / 2
    if x < 0 # Stretch horizontally if the banner is too wide
      dest_rect = bmp.rect.dup
      dest_rect.width = contents_width
      contents.stretch_blt(dest_rect, bmp, bmp.rect)
    else
      contents.blt(x, @draw_y, bmp, bmp.rect)
    end
    bmp.dispose
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Description
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_description
    buff = description_x * 2
    paragraph = mapf_format_paragraph(@quest.description, contents_width - buff)
    y = @draw_y
    paragraph = FileManager.textwrap(paragraph, contents_width - buff, contents)
    # Draw Rect
    draw_box(paragraph.size) if QuestData::DESCRIPTION_IN_BOX
    # Draw Description Label
    draw_heading(:description, y) unless QuestData::VOCAB[:description].empty?
    # Draw Description
    y += line_height if !QuestData::VOCAB[:description].empty? || QuestData::DESCRIPTION_IN_BOX
    paragraph.each do |line|
      draw_text_ex(description_x, y, line)
      y += line_height
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Objectives
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_objectives
    y = @desc_bot_y
    unless QuestData::VOCAB[:objectives].empty?
      draw_heading(:objectives, y)
      y += line_height
    end
    @quest.revealed_objectives.each { |obj_id| y = draw_objective(obj_id, y) }
    @objective_bot_y = y + line_height / 2
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Objective
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_objective(obj_id, y)
    bullet = QuestData::VOCAB[:objective_bullet]
    bullet_tw = text_size(bullet).width + 2
    buff = (objective_x*2) + bullet_tw
    paragraph = mapf_format_paragraph(@quest.objectives[obj_id], contents_width - buff)
    # Since draw_text_ex resets the font, set colour here
    @maqj_objective_color = quest_objective_colour(@quest, obj_id)
    change_color(text_color(QuestData::COLOURS[:objective_bullet]))
    draw_text(objective_x, y, bullet_tw, line_height, sprintf(bullet, obj_id + 1))    
    paragraph = FileManager.textwrap(paragraph, contents_width - buff - bullet_tw, contents)
    paragraph.each do |line|
      draw_text_ex(objective_x + bullet_tw, y, line)
      y += line_height
    end
    @maqj_objective_color = false
    return y + line_height
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Rewards
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_rewards
    y = @objective_bot_y
    unless QuestData::VOCAB[:rewards].empty?
      draw_heading(:rewards, y)
      y += line_height
    end
    for i in 0...@quest.rewards.size do draw_reward(i, y + i*line_height) end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Reward
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_reward(r_id, y)
    reward = @quest.rewards[r_id]
    case reward[0]
    when :item, 0   # Item
      draw_item_reward(y, $data_items[reward[1]], reward[2] ? reward[2] : 1)
    when :weapon, 1 # Weapon
      draw_item_reward(y, $data_weapons[reward[1]], reward[2] ? reward[2] : 1)
    when :armor, 2  # Armor
      draw_item_reward(y, $data_armors[reward[1]], reward[2] ? reward[2] : 1)
    when :gold, 3   # Gold
      draw_basic_data(y, QuestData::ICONS[:reward_gold], 
        QuestData::VOCAB[:reward_gold], (reward[1] ? reward[1] : 0).to_s)
    when :exp, 4    # Exp
      draw_basic_data(y, QuestData::ICONS[:reward_exp], 
        QuestData::VOCAB[:reward_exp], (reward[1] ? reward[1] : 0).to_s)
    when :string, 5 # String
      draw_basic_data(y, reward[1] ? reward[1] : 0, reward[3] ? reward[3].to_s : "", 
        reward[2] ? reward[2].to_s : "")
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Item Reward
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_item_reward(y, item, amount = 1)
    w = contents_width
    w = QuestData::BASIC_DATA_WIDTH if QuestData::BASIC_DATA_WIDTH.between?(1, w)
    x = (contents_width - w) / 2
    draw_item_name(item, x, y, true, w - 40)
    if amount > 1
      change_color(text_color(QuestData::COLOURS[:reward_amount]))
      draw_text(x + w - 40, y, 40, line_height, sprintf(QuestData::VOCAB[:reward_amount], amount), 2)
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Basic Data Methods
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  QuestData::BASIC_DATA_TYPES.each { |data_type|
    define_method(:"draw_#{data_type}") {
      draw_basic_data(@draw_y, QuestData::ICONS[data_type], 
        QuestData::VOCAB[data_type], @quest.send(data_type))
    }
  }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Basic Data
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_basic_data(y, icon_index, vocab, value)
    w = contents_width
    w = QuestData::BASIC_DATA_WIDTH if QuestData::BASIC_DATA_WIDTH.between?(1, w)
    x = (contents_width - w) / 2
    unless icon_index == 0
      draw_icon(icon_index, x, y)
      x += 24
      w -= 24
    end
    tw = text_size(vocab).width
    change_color(text_color(QuestData::COLOURS[:basic_label]))
    draw_text(x, y, tw, line_height, vocab)
    change_color(text_color(QuestData::COLOURS[:basic_value]))
    draw_text(x + tw, y, w - tw, line_height, value, 2)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Heading
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_heading(data_type, y)
    set_data_font(:heading)
    clear_and_draw_text(40, y, contents_width - 80, line_height, 
      QuestData::VOCAB[data_type], QuestData::HEADING_ALIGN[data_type])
    reset_font_settings
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Clear and Draw Text
  #    Clear the field before drawing the text
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def clear_and_draw_text(*args)
    rect = []
    while !args[0].is_a?(String) do rect.push(args.shift) end
    rect[0].is_a?(Rect) ? rect = rect[0] : rect = Rect.new(*rect)
    align = args[1] ? args[1] : 0
    ts = text_size(args[0])
    ts.width = [ts.width + 4, rect.width].min
    align == 1 ? ts.x = rect.x + ((rect.width - ts.width) / 2) : 
      align == 2 ? ts.x = rect.x + rect.width - ts.width : ts.x = rect.x
    ts.y = rect.y
    contents.clear_rect(ts)
    ts.x += 2
    draw_text(ts, args[0], align)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Description Box
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_box(line_num)
    return if line_num < 1
    x = (line_height / 2) - 1
    y = @draw_y + (line_height / 2) - 1
    w = contents_width - 2*x
    h = (1 + line_num)*line_height
    @desc_bot_y = y + h
    draw_rect_outline_with_shadow(x, y, w, h) 
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Rect Outline
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_rect_outline(x, y, w, h, colour)
    # Horizontal Lines
    contents.fill_rect(x, y, w, 2, colour)
    contents.fill_rect(x, y + h - 2, w, 2, colour)
    # Vertical Lines
    contents.fill_rect(x, y, 2, h, colour)
    contents.fill_rect(x + w - 2, y, 2, h, colour)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Rect Outline with Shadow
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def draw_rect_outline_with_shadow(x, y, w, h)
    draw_rect_outline(x + 1, y + 1, w, h, text_color(QuestData::COLOURS[:line_shadow]))
    draw_rect_outline(x, y, w, h, text_color(QuestData::COLOURS[:line]))
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Objective/Description X
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def objective_x; line_height / 2; end
  def description_x; QuestData::DESCRIPTION_IN_BOX ? line_height : (line_height/2); end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Update
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def update(*args, &block)
    super(*args, &block)
    if open? && active && @dest_scroll_oy == self.oy
      scroll_down     if Input.press?(:DOWN)
      scroll_up       if Input.press?(:UP)
      scroll_pagedown if Input.trigger?(:R) || Input.repeat?(:R)
      scroll_pageup   if Input.trigger?(:L) || Input.repeat?(:L)
    end
    if self.oy != @dest_scroll_oy
      mod = (@dest_scroll_oy <=> self.oy)
      factor = Input.press?(:kSHIFT) ? 12 : 3
      factor = 24 if @quick_scrolling
      self.oy += factor * mod
      self.oy = @dest_scroll_oy if (@dest_scroll_oy <=> self.oy) != mod
    else
      @quick_scrolling = false
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Scroll Down
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def scroll_down(*args, &block)
    max_oy = contents_height - maqj_visible_height
    dest = ((@dest_scroll_oy / line_height) + 1) * line_height
    @dest_scroll_oy = [dest, max_oy].min
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Scroll Up
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def scroll_up(*args, &block)
    dest = ((@dest_scroll_oy / line_height) - 1)*line_height
    @dest_scroll_oy = [dest, 0].max 
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Page Down
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def scroll_pagedown(*args, &block)
    return if @quick_scrolling
    Audio.se_play("Audio/SE/Book2", 60, 100)
    max_oy = contents_height - maqj_visible_height
    dest = ((@dest_scroll_oy / line_height) + 20) * line_height 
    #self.oy = @dest_scroll_oy = [dest, max_oy].min
    @dest_scroll_oy = [dest, max_oy].min
    @quick_scrolling = true
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Scroll Up
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def scroll_pageup(*args, &block)
    return if @quick_scrolling
    Audio.se_play("Audio/SE/Book2", 60, 100)
    dest = ((@dest_scroll_oy / line_height) - 20) * line_height
    #self.oy = @dest_scroll_oy = [dest, 0].max
    @dest_scroll_oy = [dest, 0].max
    @quick_scrolling = true
  end
  
end

#==============================================================================
# ** Scene_Quest
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  This class handles processing for the Quest scene
#==============================================================================
class Scene_Quest < Scene_MenuBase
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Start Scene Processing
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def start
    super
    @init_category, @init_quest_index = $game_party.quests.find_location($game_system.last_quest_id, $game_system.last_quest_cat)
    create_maqj_picture unless $game_system.quest_bg_picture.empty?
    create_all_windows
    adjust_window_positions
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Terminate Scene
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def terminate
    $game_system.quest_categories = QuestData::CATEGORIES
    $game_system.quest_scene_label = QuestData::VOCAB[:scene_label]
    unless @quest_list_window.category == :transaction
      $game_system.last_quest_id = @quest_list_window.item ? @quest_list_window.item.id : 0
    end
    $game_system.last_quest_cat = @quest_category_window ? 
      @quest_category_window.item : $game_system.quest_categories[0]
    super
    dispose_maqj_picture
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Create Background Picture
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def create_maqj_picture
    @maqj_picture_sprite = Sprite.new
    @maqj_picture_sprite.bitmap = Cache.picture($game_system.quest_bg_picture)
    @maqj_picture_sprite.opacity = $game_system.quest_bg_opacity
    @maqj_picture_sprite.blend_type = $game_system.quest_bg_blend_type
    @maqj_picture_sprite.z = @background_sprite.z + 1 if @background_sprite
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Create All Windows
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def create_all_windows
    create_quest_label_window unless $game_system.quest_scene_label.empty?
    create_quest_category_window if $game_system.quest_categories.size > 1
    create_quest_category_label_window if QuestData::SHOW_CATEGORY_LABEL
    create_dummy_category_window if QuestData::CATEGORY_LABEL_IN_SAME_WINDOW &&
      @quest_category_window && @quest_category_label_window
    create_quest_list_window
    create_quest_data_window
    create_hint_window
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Hint window that activated when on quest item ok
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def create_hint_window
    ww = @quest_list_window.width
    wh = @quest_list_window.line_height * 3 + @quest_list_window.standard_padding * 2
    wy = @quest_list_window.y + @quest_list_window.height - wh
    @hint_window = Window_Base.new(0, wy, ww, wh)
    @hint_window.swap_skin(WindowSkin::Applejack)
    rect = Rect.new(0, 0, @hint_window.contents_width, @hint_window.line_height)
    texts = FileManager.textwrap(Vocab::QuestHint, rect.width)
    texts.each do |line|
      @hint_window.draw_text(rect, line)
      rect.y += @hint_window.line_height
    end
    @hint_window.hide
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Create QuestLabel Window
  #    This window shows the name of the scene
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def create_quest_label_window
    @quest_label_window = Window_QuestLabel.new(0, 0, $game_system.quest_scene_label)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Create QuestCategory Window
  #    This window allows the player to switch categories.
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def create_quest_category_window
    @quest_category_window = Window_QuestCategory.new(0, 0, $game_system.quest_categories)
    @quest_category_window.category = @init_category if @init_category
    @quest_category_window.set_handler(:cancel, method(:on_category_cancel))
    @quest_category_window.set_handler(:ok, method(:on_category_ok)) 
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Create QuestCategoryLabel Window
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def create_quest_category_label_window
    if @quest_category_window
      @quest_category_label_window = Window_QuestCategoryLabel.new(0, @quest_category_window.height)
      @quest_category_window.add_observing_proc(:label) do |category| 
        @quest_category_label_window.category = category 
        @quest_category_window.category = category 
      end
    else
      @quest_category_label_window = Window_QuestCategoryLabel.new(0, 0)
      @quest_category_label_window.category = $game_system.quest_categories ? $game_system.quest_categories[0] : :all
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Create Dummy Category Label Window
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def create_dummy_category_window
    @quest_category_label_window.y -= 12
    @quest_category_label_window.opacity = 0
    @quest_category_window.opacity = 0
    w = [@quest_category_window.width, @quest_category_label_window.width].max
    h = @quest_category_window.height + @quest_category_label_window.height - 12
    @category_dummy_window = Window_QuestCategoryDummy.new(0, 0, w, h)
    @category_dummy_window.z = [@quest_category_window.z, @quest_category_label_window.z].min - 1
    # Draw Horz Line
    @category_dummy_window.draw_horizontal_line(@quest_category_window.height - @quest_category_window.padding - 7, 2)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Create QuestList Window
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def create_quest_list_window
    if @category_dummy_window
      y = @category_dummy_window.height
    else
      y = @quest_category_window ? @quest_category_window.height : 0
      y += @quest_category_label_window ? @quest_category_label_window.height : 0
      y = @quest_label_window.height if y == 0
    end
    @quest_list_window = Window_QuestList.new(0, y, QuestData::LIST_WINDOW_WIDTH, 
      Graphics.height - y)
    @quest_list_window.set_handler(:ok, method(:on_list_ok))
    @quest_list_window.deactivate if !QuestData::CONCURRENT_ACTIVITY
    if !QuestData::CONCURRENT_ACTIVITY || !@quest_category_window
      @quest_list_window.set_handler(:cancel, method(:on_list_cancel))
    end
    if @quest_category_window
      @quest_category_window.add_observing_proc(:list) { |category| 
        @quest_list_window.category = category }
    else
      @quest_list_window.category = $game_system.quest_categories[0]
    end
    @quest_list_window.index = @init_quest_index if @init_quest_index
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Create QuestData Window
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def create_quest_data_window
    x = @quest_list_window.width
    y = (@quest_label_window && (@quest_category_window || 
      @quest_category_label_window)) ? @quest_label_window.height : 0
    @quest_data_window = Window_QuestData.new(x, y, Graphics.width - x, 
      Graphics.height - y)
    @quest_list_window.help_window = @quest_data_window
    @quest_data_window.quest = @quest_list_window.item
    @quest_data_window.set_handler(:ok, method(:on_data_ok))
    @quest_data_window.set_handler(:cancel, method(:on_data_cancel))
  end
  #--------------------------------------------------------------------------
  # * Create Background
  # tag: modified (Quest Log
  #--------------------------------------------------------------------------
  def create_background
    @background_sprite = Sprite.new
    @background_sprite.bitmap = Cache.background("Quest_BG")
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Dispose Background Picture
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def dispose_maqj_picture
    @maqj_picture_sprite.dispose if @maqj_picture_sprite
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Adjust Window Positions
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def adjust_window_positions
    if @quest_label_window && (@quest_category_window || @quest_category_label_window)
      @quest_label_window.x = QuestData::LIST_WINDOW_WIDTH 
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Category OK
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def on_category_ok; @quest_list_window.activate; end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Category Cancel
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def on_category_cancel; return_scene; end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * List OK
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def on_list_ok
    @quest_category_window.deactivate if @quest_category_window
    @quest_data_window.draw_index_data(true)
    @quest_data_window.activate
    @quest_list_window.deactivate
    @hint_window.show
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * List Cancel
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def on_list_cancel
    @quest_category_window ? @quest_category_window.activate : return_scene
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Data OK
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def on_data_ok; on_data_cancel; end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Data Cancel
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def on_data_cancel
    @hint_window.hide
    @quest_list_window.activate
    @quest_category_window.activate if @quest_category_window && QuestData::CONCURRENT_ACTIVITY
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Update All Windows
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def update_all_windows(*args, &block)
    # To accomodate for concurrent activity, must deactivate category
    @quest_category_window.deactivate if @quest_category_window &&
      QuestData::CONCURRENT_ACTIVITY && @quest_list_window.active && 
      Input.trigger?(:C)
    super(*args, &block)
    @quest_category_window.activate if @quest_category_window &&
      QuestData::CONCURRENT_ACTIVITY && @quest_list_window.active
  end
end
#==============================================================================
# ** Scene_Map
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Summary of Changes:
#    aliased method - update_scene
#    new methods - update_call_quest_journal; call_quest_journal
#==============================================================================
class Scene_Map
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Update Scene
  # tag: modified
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #alias maqj_updascne_9kh4 update_scene
  #def update_scene(*args, &block)
  #  maqj_updascne_9kh4(*args, &block)
  #  #update_call_quest_journal if $game_system.quest_map_access && !scene_changing?
  #end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Update Call Quest Journal
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def update_call_quest_journal
    if $game_map.interpreter.running?
      @quest_journal_calling = false
    else
      if Input.trigger?(QuestData::MAP_BUTTON)
        $game_system.quest_access_disabled || $game_party.quests.list.empty? ?
          Sound.play_buzzer : @quest_journal_calling = true
      end
      call_quest_journal if @quest_journal_calling && !$game_player.moving?
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Call Quest Journal
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def call_quest_journal
    @quest_journal_calling = false
    Sound.play_ok
    SceneManager.call(Scene_Quest)
  end
end
# Menu Access
if !$imported[:MA_InsertCommand]
# Initialize the Insertion Hash
MA_COMMAND_INSERTS = {}
MA_InsertableMenuCommand = Struct.new(:name, :index, :enable, :scene, :other)
#==============================================================================
# ** Game_System
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Summary of Changes:
#    new public instance variable - maic_menu_commands
#    aliased method - initialize
#==============================================================================
class Game_System
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Inserted Menu Commands
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def maic_inserted_menu_commands
    # Lazy Instantiation so that old save files are not corrupted
    if !@maic_inserted_menu_commands
      @maic_inserted_menu_commands = MA_COMMAND_INSERTS.keys
      # Sort by index
      @maic_inserted_menu_commands.sort! { |a, b| MA_COMMAND_INSERTS[a].index <=> MA_COMMAND_INSERTS[b].index }
    end
    @maic_inserted_menu_commands
  end
end
#==============================================================================
# ** Window_MenuCommand
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Summary of Changes:
#    aliased method - make_command_list; maic_insert_command
#==============================================================================
class Window_MenuCommand
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Make Command List
  #``````````````````````````````````````````````````````````````````````````
  #  I alias this method instead of add_original_commands because I need to
  # have all commands created before I can insert at the correct index
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias maic_mkcmmndl_6yd2 make_command_list
  def make_command_list(*args, &block)
    maic_mkcmmndl_6yd2(*args, &block) # Run Original Method
    # Insert new commands
    $game_system.maic_inserted_menu_commands.each { |sym| maic_insert_command(sym) }
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Insert Command
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def maic_insert_command(symbol)
    command = MA_COMMAND_INSERTS[symbol]
    # Get the command name
    name = command.name.is_a?(Symbol) ? eval(command.name.to_s) : command.name
    # Check whether enabled
    enabled = case command.enable
    when Integer then command.enable == 0 ? true : $game_switches[command.enable]
    when String then eval(command.enable)
    when Symbol then self.send(command.enable)
    else
      enabled = true
    end
    # Add the command to the list
    add_command(name, symbol, enabled)
    added = @list.pop
    @list.insert([command.index, @list.size].min, added) # Insert at specific index
  end
end
#==============================================================================
# ** Scene_Menu
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Summary of Changes:
#    aliased method - create_command_window; on_personal_ok
#    new methods - maic_set_insert_handler; maic_command_insert
#==============================================================================
class Scene_Menu
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Create Command Window
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias maic_createcndwin_3ey7 create_command_window
  def create_command_window(*args, &block)
    maic_createcndwin_3ey7(*args, &block) # Run Original Method
    # Add handlers for all custom commands
    $game_system.maic_inserted_menu_commands.each { |symbol| maic_set_insert_handler(symbol) }
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Set Inserted Handler
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def maic_set_insert_handler(symbol)
    other = MA_COMMAND_INSERTS[symbol].other
    handler = case other
    when Symbol then method(other)
    when String then lambda { eval(other) }
    when TrueClass then method(:command_personal)
    else
      handler = method(:maic_command_insert)
    end
    @command_window.set_handler(symbol, handler)
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Custom Command
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def maic_command_insert
    SceneManager.call(Kernel.const_get(MA_COMMAND_INSERTS[@command_window.current_symbol].scene))
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Personal OK
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias maic_onpok_3ek9 on_personal_ok
  def on_personal_ok(*args, &block)
    if $game_system.maic_inserted_menu_commands.include?(@command_window.current_symbol)
      maic_command_insert
    else
      maic_onpok_3ek9(*args, &block) # Run Original Method
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # *) command quest
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def command_quest
    SceneManager.call(Scene_Quest)
  end
  
end
$imported[:MA_InsertCommand] = true
end
MA_COMMAND_INSERTS[:quest_journal] = 
  MA_InsertableMenuCommand.new(QuestData::VOCAB[:menu_label], QuestData::MENU_INDEX, 
  "!$game_system.quest_access_disabled && !$game_party.quests.list.empty?", 
  :Scene_Quest, false)

#==============================================================================
#    Remove Quest from Default Categories [Patch for Quest Journal v. 1.0.3]
#    Version: 1.0.0
#    Author: modern algebra (rmrk.net)
#    Date: October 24, 2015
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Description:
#
#    This patch allows you to specify that some quests should ONLY show up in
#   the custom categories to which they belong, and not in the default :all, 
#   :active, :complete, and :failed categories.
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Instructions:
# 
#    Paste this script into the Script Editor below the Quest Journal but above 
#  Main.
#
#    To specify that a quest should only show up in custom categories, include
#  :only in its custom categories array. For example, if you have a custom 
#  :towns category and you only want the quest to show up in that and not in
#  the :active and :all categories, then you would put the following when
#  setting the quest up:
#
#      q[:custom_categories] = [:only, :towns]
#
#  You can set more than one custom category as well. Please note that if you 
#  do not set at least one custom category though, then putting :only in a 
#  quest's custom categories array will make it invisible and inaccessible.
#==============================================================================
#==============================================================================
# ** Game_Quests
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Summary of Changes:
#    overwritten method - include?
#==============================================================================
class Game_Quests
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Include?
  #    determines whether to include a particular quest depending on list type
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def include?(quest_id, list_type = :all)
    return false if !revealed?(quest_id)
    return @data[quest_id].custom_categories.include?(list_type) if @data[quest_id].custom_categories.include?(:only)
    case list_type
    when :all then true
    when :complete, :failed, :active then @data[quest_id].status?(list_type)
    else
      @data[quest_id].custom_categories.include?(list_type)
    end
  end
end
#==============================================================================
# ** Game_Party
#------------------------------------------------------------------------------
#  This class handles parties. Information such as gold and items is included.
# Instances of this class are referenced by $game_party.
#==============================================================================
class Game_Party < Game_Unit
  #------------------------------------------------------------------------------
  # * Reveal quest
  #------------------------------------------------------------------------------
  def reveal_quest(id)
    @quests[id].concealed = false
  end
  #------------------------------------------------------------------------------
  def hide_quest(id)
    @quests[id].concealed = true
  end
  #------------------------------------------------------------------------------
  def reveal_objective(qid, oid)
    @quests[qid].reveal_objective(oid)
  end
  #------------------------------------------------------------------------------
  def hide_objective
    @quests[qid].conceal_objective(oid)
  end
  #------------------------------------------------------------------------------
end

#==============================================================================
#   ** F12 Reset Fix
#   Author: Acezon
#   Date: 2 June 2013
#------------------------------------------------------------------------------
#   Version 2.1
#   - Fixed issue where game window is not in focus
#     when Console_on is set to false
#   - Now compatible with Tsuki's Test Edit script
#   Version 2.0
#   - Console option added
#   - Automatically focuses window after pressing F12
#   Version 1.1
#   - Respawning the exe was better
#   Version 1.0
#   - Initial Release
#------------------------------------------------------------------------------
#   Just credit me. Free to use for commercial/non-commercial games.
#   Thanks to Tsukihime and Cidiomar for the console scriptlet
#==============================================================================
$imported = {} if $imported.nil?
$imported["Acezon-F12ResetFix"] = true
#==============================================================================
# ** START Configuration
#==============================================================================
module Config
  Console_on = false       # duh
end
#==============================================================================
# ** END Configuration
#==============================================================================
alias f12_reset_fix rgss_main
def rgss_main(*args, &block)
  f12_reset_fix(*args) do
    if $run_once_f12
      
      pid = spawn ($TEST ? 'Game.exe test' : 'Game')
      # Tell OS to ignore exit status
      Process.detach(pid)
      sleep(0.01)
      exit
    end
    $run_once_f12 = true
    # Run default rgss_main
    block.call
  end
end
module SceneManager
  class << self
    alias :acezon_f12_first :first_scene_class
  end
  def self.first_scene_class
    focus_game_window
    acezon_f12_first
  end
end

#:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=
#  ▼ Asagi's Gun License
#  Author: Kread-EX
#  Modified by: Trihan
#  Version 1.08x
#  Release date: 13/04/2012
#
#  For Seiryuki.
#
#  Thanks to Angius for finding a bug.
#:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=:=
#-------------------------------------------------------------------------------------------------
#  ▼ UPDATES
#-------------------------------------------------------------------------------------------------
# # 13/04/2012. Bugfix: Gaining a non-ranged weapon caused the script to crash
# # when moving the cursor over the ammo slot in the equipment menu.
# # 10/04/2012. Bugfix: unequipping non-weapon items caused a crash.
# # 10/04/2012. Modifications: Added slot names on a per-weapon basis.
# # 09/04/2012. Modifications: allowed ammo to be assigned on a per-weapon basis
# # rather than classes, and allowed skills to use multiple ammo types/IDs.
# # Implemented ammo costs for skills.
# # Prevented multiple ammo users from equipping the same ammo.
# # Equipped ammo is now removed from the equippable items list.
# # The item list now shows the correct quantity of ammo if a party member has
# # that ammo equipped.
# # 09/03/2012. Bugfix: skills without ammo could crash.
# # 08/03/2012. Bugfix: ammo stopped consuming because of my previous bugfixes.
# # 22/02/2012. Bugfix: some REGEXP didn't work with european characters.
# # 20/02/2012. Bugfix: all skills used to consume ammo.
#-------------------------------------------------------------------------------------------------
#  ▼ TERMS OF USAGE
#-------------------------------------------------------------------------------------------------
# #  You are free to adapt this work to suit your needs.
# #  You can use this work for commercial purposes if you like it.
# #  Credit is appreciated.
# #
# # For support:
# # grimoirecastle.wordpress.com
# # rpgmakervxace.net
# # rpgrevolution.com
#-------------------------------------------------------------------------------------------------
#  ▼ INTRODUCTION
  #-------------------------------------------------------------------------------------------------
  # # Enables the use of ammunition for skills.
#-------------------------------------------------------------------------------------------------
#  ▼ INSTRUCTIONS
#-------------------------------------------------------------------------------------------------
# # Three levels of configuration: Class, Weapon and Skill.
# # Class notetags:
# # <ammo_slot_id: x>
# # This determines the slot in the equip screen which will be replaced by the
# # ammo slot.
# # <ammo_slot_name: string> Just the name of the slot.
# #
# # Weapon notetags:
# # <ammo_type_id: x, y, z>
# # Replace x with the weapon types of the kind of ammo you want the
# # weapon to use.
# #
# # Skill notetags
# # <linked_ammo_types: x>
# # Will require and consume ammo of a specific type.
# # <linked_ammo_ids: x>
# # Will require and consume unique arrows. In this case, x isn't the weapon
# # type but the weapon ID.
# # <ammo_cost: x>
# # Determines how much ammo is required to use the skill, and will be expended
# # on use.
# # <require_armor_types: x>
# # <require_weapon_types: x>
#-------------------------------------------------------------------------------------------------
#  ▼ COMPATIBILITY
#-------------------------------------------------------------------------------------------------
# # List of aliases and overwrites:
# #
# # DataManager
# # load_database (alias)
# # load_ammo_notetags (new method)
# #
# # RPG::Class
# # ammo_slot_id (new attr method)
# # ammo_slot_name (new attr method)
# # load_ammo_notetags (new method)
# # ammo_user? (new method)
# #
# # RPG::Skill
# # ammo_type_id (new attr method)
# # ammo_absolute_id (new attr method)
# # ammo_cost (new attr method)
# # load_ammo_notetags (new method)
# #
# # RPG::Weapon
# # ammo_type_ids (new attr method)
# # already_equipped (new attr method)
# # load_ammo_notetags (new method)
# # ammo_user? (new method)
# #
# # Game_Actor
# # change_equip (alias)
# # equip_slots (alias)
# # equippable? (alias)
# # release_unequippable_items (overload)
# # skill_cost_payable? (alias)
# # skill_ammo_reqs_ok? (new method)
# # pay_skill_cost (alias)
# # consume_ammo (new method)
# # 
# # Game_Party
# # discard_members_equip (overload)
# # 
# # Window_EquipSlot
# # draw_item (alias)
# # slot_name (alias)
# #
# # Window_EquipItem
# # include? (alias)
# # enable? (alias)
#-------------------------------------------------------------------------------------------------
$imported = {} if $imported.nil?
$imported['KRX-AsagisGunLicense'] = true
#puts 'Load: Asagi\'s Gun License v1.03 by Kread-EX'
module KRX
  
  module REGEXP
    AMMO_SLOT_ID = /<ammo_slot_id:[ ]*(\d+)>/i
    AMMO_SLOT_NAME = /<ammo_slot_name:[ ]*(.+)>/
    AMMO_TYPE_ID = /<ammo_type_id:[ ]*(\d+)>/i
    AMMO_CONSUMPTION_TYPES = /<linked_ammo_types:[ ]*(.+?)>/i
    AMMO_CONSUMPTION_IDS = /<linked_ammo_ids:[ ]*(.+?)>/i
    AMMO_COST = /<ammo_cost:[ ]*(\d+)>/i
    REQUIRE_ARMOR_TYPE = /<require_armor_types:[ ]*(.+?)>/i
    REQUIRE_WEAPON_TYPE = /<require_weapon_types:[ ]*(.+?)>/i
  end
  
end
#===========================================================================
# ■ DataManager
#===========================================================================
module DataManager  
	#--------------------------------------------------------------------------
	# ● Loads the database
	#--------------------------------------------------------------------------
	class << self
		alias_method(:krx_ammo_dm_load_database, :load_database)
	end
	def self.load_database
		krx_ammo_dm_load_database
		load_ammo_notetags
	end  
	#--------------------------------------------------------------------------
	# ● Loads the note tags
	#--------------------------------------------------------------------------
	def self.load_ammo_notetags
		groups = [$data_classes, $data_skills, $data_weapons]
		for group in groups
			for obj in group
				next if obj.nil?
				obj.load_ammo_notetags
			end
		end
		#puts "Read: Ammo Requirements Notetags"
	end
end
#===========================================================================
# ■ RPG::Class
#===========================================================================
class RPG::Class < RPG::BaseItem
	#--------------------------------------------------------------------------
	# ● Public instance variables
	#--------------------------------------------------------------------------
  attr_reader     :weapon_slot_id
  attr_reader     :ammo_slot_id
  attr_reader     :ammo_slot_name
	#--------------------------------------------------------------------------
	# ● Loads the note tags
	#--------------------------------------------------------------------------
	def load_ammo_notetags
    @ammo_slot_name = Vocab::Equipment::Ammo # tag: modified
		@note.split(/[\r\n]+/).each do |line|
			case line
			when KRX::REGEXP::AMMO_SLOT_ID
				@ammo_slot_id = $1.to_i
        if @ammo_slot_id == 0
          @weapon_slot_id = 1
        else
          @weapon_slot_id = 0
        end
      #when KRX::REGEXP::AMMO_SLOT_NAME
			#	@ammo_slot_name = $1
			end
		end
	end
	#--------------------------------------------------------------------------
	# ● Determine if this class uses ammo
	#--------------------------------------------------------------------------
  def ammo_user?
    return @ammo_slot_id != nil
  end
end
#===========================================================================
# ■ RPG::Skill
#===========================================================================
class RPG::Skill < RPG::UsableItem
	#--------------------------------------------------------------------------
	# ● Public instance variables
	#--------------------------------------------------------------------------
  attr_reader     :ammo_type_ids
  attr_reader     :ammo_absolute_ids
  attr_reader     :ammo_cost
  attr_reader     :require_armor_type_ids
  attr_reader     :require_weapon_type_ids
	#--------------------------------------------------------------------------
	# ● Loads the note tags
	#--------------------------------------------------------------------------
	def load_ammo_notetags
		@note.split(/[\r\n]+/).each do |line|
			case line
			when KRX::REGEXP::AMMO_CONSUMPTION_TYPES
        @ammo_type_ids = []
				@ammo_type_ids |= $1.scan(/\d+/).collect { |id| id.to_i }
			when KRX::REGEXP::AMMO_CONSUMPTION_IDS
        @ammo_absolute_ids = []
				@ammo_absolute_ids |= $1.scan(/\d+/).collect { |id| id.to_i }
      when KRX::REGEXP::AMMO_COST
        @ammo_cost = $1.to_i
      when KRX::REGEXP::REQUIRE_ARMOR_TYPE
        @require_armor_type_ids = []
				@require_armor_type_ids |= $1.scan(/\d+/).collect { |id| id.to_i }
        debug_str = ""
        for str in @require_armor_type_ids
          debug_str += str.to_s + " "
        end
        p sprintf("[Ammo System]:%s need armor type: %s to execute",self.name,debug_str)
      when KRX::REGEXP::REQUIRE_WEAPON_TYPE
        @require_weapon_type_ids = []
				@require_weapon_type_ids |= $1.scan(/\d+/).collect { |id| id.to_i }
        debug_str = ""
        for str in @require_weapon_type_ids
          debug_str += str.to_s + " "
        end
        p sprintf("[Ammo System]:%s need weapon type: %s to execute",self.name,debug_str)
      
			end
		end
	end
end
class RPG::Weapon < RPG::EquipItem
	#--------------------------------------------------------------------------
	# ● Public instance variables
	#--------------------------------------------------------------------------
  attr_reader     :ammo_type_id
  attr_reader     :ammo_slot_name
  attr_accessor   :already_equipped
  #--------------------------------------------------------------------------
  # ● Constructor
  #--------------------------------------------------------------------------
  alias_method(:krx_ammo_rw_init, :initialize)
  def initialize
    @already_equipped = false
    krx_ammo_rw_init
  end
	#--------------------------------------------------------------------------
	# ● Loads the note tags
	#--------------------------------------------------------------------------
	def load_ammo_notetags
		@note.split(/[\r\n]+/).each do |line|
      case line
      when KRX::REGEXP::AMMO_SLOT_NAME
				@ammo_slot_name = $1
			when KRX::REGEXP::AMMO_TYPE_ID
				@ammo_type_id = $1.to_i
			end
		end
	end
  #--------------------------------------------------------------------------
	# ● Determine if this weapon uses ammo
	#--------------------------------------------------------------------------
  def ammo_user?
    return @ammo_type_id != nil
  end
end
class RPG::Armor < RPG::EquipItem
  
end
#===========================================================================
# ■ Game_Actor
#===========================================================================
class Game_Actor < Game_Battler
  #--------------------------------------------------------------------------
  # ● Gets the available equipment slots
  #--------------------------------------------------------------------------
  alias_method(:krx_ammo_ga_es, :equip_slots)
  def equip_slots
    base = krx_ammo_ga_es
    return base unless self.class.ammo_user?
    ammo_slot = self.class.ammo_slot_id
    result = []
    done = false
    base.each do |x|
      if x == ammo_slot && !done
        result.push(0)
        done = true
      else
        result.push(x)
      end
    end
    result
  end
  #--------------------------------------------------------------------------
  # ● Determines if an item can be equipped
  #--------------------------------------------------------------------------
  alias_method(:krx_ammo_ga_equippable?, :equippable?)
  def equippable?(item)
    if self.class.ammo_user? && item.is_a?(RPG::Weapon)
      weapon_slot = self.class.weapon_slot_id
      if self.equips[weapon_slot]
        return true if item.wtype_id == self.equips[weapon_slot].ammo_type_id
      end
    end
    return krx_ammo_ga_equippable?(item)
  end
  #--------------------------------------------------------------------------
  # ● Performs equipment change
  #--------------------------------------------------------------------------
  alias_method(:krx_ammo_ga_ce, :change_equip)
  def change_equip(slot_id, item)
    if item == nil && equips[slot_id] && equips[slot_id].is_a?(RPG::Weapon)
      equips[slot_id].already_equipped = false
    elsif self.class.ammo_slot_id == slot_id && item.is_a?(RPG::Weapon)
      weapon_slot = self.class.weapon_slot_id
      return unless item.is_a?(RPG::Weapon) && item.wtype_id == self.equips[weapon_slot].ammo_type_id
      return unless trade_item_with_party(item, equips[slot_id])
      if equips[slot_id] != nil && equips[slot_id].is_a?(RPG::Weapon)
        equips[slot_id].already_equipped = false
      end
      item.already_equipped = true
      @equips[slot_id].object = item
      return
    end
    krx_ammo_ga_ce(slot_id, item)
  end
  #--------------------------------------------------------------------------
  # * Remove Equipment that Cannot Be Equipped 
  #     item_gain:  Return removed equipment to party.
  #--------------------------------------------------------------------------
  # tag: equipment
  def release_unequippable_items(item_gain = true)
    loop do
      last_equips = equips.dup
      @equips.each_with_index do |item, i|
        if !equippable?(item.object) || (item.object.etype_id != equip_slots[i] && equip_slots[i] != 1)
          disarm_equip(item, item_gain)
        elsif equip_slots[i] == 1
          disarm_equip(item, item_gain) unless offhoof_equippable?(equip_slots[i], item)
        end
      end
      return if equips == last_equips
    end
  end
  #--------------------------------------------------------------------------
  def offhoof_equippable?(slot_id, item)
    return false  if !([0,1].include?(item.etype_id))
    return true   if item.etype_id == 1
    return false  if actor && !offhoof_skill_learned?
    return [1,2,4,9].include?(item.wtype_id)
  end
  #--------------------------------------------------------------------------
  def disarm_equip(item, item_gain)
    if item.object.is_a?(RPG::Weapon)
      item.object.already_equipped = false if item.object.already_equipped == true
    end
    trade_item_with_party(nil, item.object) if item_gain
    item.object = nil
  end
  #--------------------------------------------------------------------------
  # ● Determine if a skill can be used
  #--------------------------------------------------------------------------
  alias_method(:krx_ammo_ga_scp?, :skill_cost_payable?)
  def skill_cost_payable?(skill)
    return false unless skill_ammo_reqs_ok?(skill)
    return krx_ammo_ga_scp?(skill)
  end
  #--------------------------------------------------------------------------
  # ● Check the ammo requirements for the skill
  #--------------------------------------------------------------------------
  def skill_ammo_reqs_ok?(skill)
    if skill.is_a?(Fixnum)
      skill = $data_skills[skill]
    end
    
    return true if skill.ammo_type_ids.nil? && skill.ammo_absolute_ids.nil? && skill.require_armor_type_ids.nil? && skill.require_weapon_type_ids.nil?
    result = false
    weapon_id = self.class.weapon_slot_id
    slot_id = self.class.ammo_slot_id
    
    
    if skill.require_armor_type_ids != nil
      for equip in equips
        next if equip.nil? || !equip.is_a?(RPG::Armor)
        return true if skill.require_armor_type_ids.include?(equip.atype_id)
      end
    end
    
    if skill.require_weapon_type_ids != nil
      for equip in equips
        next if equip.nil? || !equip.is_a?(RPG::Weapon)
        return true if skill.require_weapon_type_ids.include?(equip.wtype_id)
      end
    end
    
    
    if skill.ammo_type_ids != nil
      return false unless self.class.ammo_user?
      item = @equips[slot_id].object
      return false if item.nil?
      if skill.ammo_cost
        return false if $game_party.item_number(item) < skill.ammo_cost - 1
      end
      result = true if skill.ammo_type_ids.include?(item.wtype_id)
    end
    
    if skill.ammo_absolute_ids != nil
      return false unless self.class.ammo_user?
      item = @equips[slot_id].object
      return false if item.nil?
      if skill.ammo_cost
        return false if $game_party.item_number(item) < skill.ammo_cost - 1
      end
      result = true if skill.ammo_type_ids.include?(item.id)
    end
    result
  end
  
  def skill_equip_ready?(skill)
    skill_ammo_reqs_ok?(skill)
  end
  #--------------------------------------------------------------------------
  # ● Check the ammo requirements for the weapon
  #--------------------------------------------------------------------------
  def weapon_ammo_ready?(weapon)
    return false if weapon.nil?
    
    weapon = $data_weapons[weapon] if weapon.is_a?(Fixnum)
    slot_id   = self.class.ammo_slot_id
    result    = false
    
    if weapon.tool_itemcost_type && weapon.tool_itemcost_type > 0
      item = @equips[slot_id].object
      return false if item.nil?
      return false if $game_party.item_number(item) == 0 && @equips[slot_id].nil?
      result = true if item.wtype_id == weapon.tool_itemcost_type
    else 
      result = true
    end
    
    return result
  end
  
  #--------------------------------------------------------------------------
  # ● Pay the required cost for a skill
  #--------------------------------------------------------------------------
  alias_method(:krx_ammo_ga_psc, :pay_skill_cost)
  def pay_skill_cost(skill)
    krx_ammo_ga_psc(skill)
    consume_ammo(skill) if self.class.ammo_user?
  end
  #--------------------------------------------------------------------------
  # ● Consume the required ammo for a skill
  #--------------------------------------------------------------------------
  def consume_ammo(skill)
    return if skill.ammo_type_ids.nil? && skill.ammo_absolute_ids.nil?
    slot_id = self.class.ammo_slot_id
    item = @equips[slot_id].object
    if skill.ammo_cost
      $game_party.lose_item(item, skill.ammo_cost, true)
    else
      if $game_party.item_number(item) == 0
        self.change_equip(slot_id, nil)
        text = sprintf("%s - run out of ammo", battler.name)
        SceneManager.display_info(text)
      end
      $game_party.lose_item(item, 1, true)
    end
  end
end
#===========================================================================
# ■ Game_Party
#===========================================================================
class Game_Party < Game_Unit
  #--------------------------------------------------------------------------
  # * Discard Members' Equipment
  #--------------------------------------------------------------------------
  def discard_members_equip(item, amount)
    n = amount
    members.each do |actor|
      while n > 0 && actor.equips.include?(item)
        if item.is_a?(RPG::Weapon)
          item.already_equipped = false if item.already_equipped == true
        end
        actor.discard_equip(item)
        n -= 1
      end
    end
  end
end
#===========================================================================
# ■ Window_ItemList
#===========================================================================
class Window_ItemList < Window_Selectable
  #--------------------------------------------------------------------------
  # * Draw Number of Items
  #--------------------------------------------------------------------------
  def draw_item_number(rect, item)
    quantity = 0
    for member in $game_party.all_members
      if member.class.ammo_user?
        if member.equips[member.class.ammo_slot_id]
          if member.equips[member.class.ammo_slot_id].id == item.id
            quantity += 1
          end
        end
      end
    end
    draw_text(rect, sprintf(":%2d", ($game_party.item_number(item) + quantity)), 2)
  end
end
#===========================================================================
# ■ Window_EquipSlot
#===========================================================================
class Window_EquipSlot < Window_Selectable
  #--------------------------------------------------------------------------
  # ● Displays the equipped item
  #--------------------------------------------------------------------------
  alias_method(:krx_ammo_wes_di, :draw_item)
  def draw_item(index)
    krx_ammo_wes_di(index)
    rect = item_rect_for_text(index)
    item = @actor.equips[index]
    name = slot_name(index)
    if @actor.class.ammo_user? && name == @actor.class.ammo_slot_name
      unless item.nil?
        draw_text(rect, sprintf(":%2d", $game_party.item_number(item) + 1), 2)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● Determine the name of the slot
  #--------------------------------------------------------------------------
  alias_method(:krx_ammo_wes_sn, :slot_name)
  def slot_name(index)
    if @actor && @actor.class.ammo_slot_id == index
      return @actor.class.ammo_slot_name
      #if @actor.equips[@actor.class.weapon_slot_id]
        if @actor.equips[@actor.class.weapon_slot_id].ammo_slot_name != nil
          return @actor.equips[@actor.class.weapon_slot_id].ammo_slot_name
        else
          return @actor.class.ammo_slot_name
        end
      #end
    end
    krx_ammo_wes_sn(index)
  end
end
#===========================================================================
# ■ Window_Item
#===========================================================================
class Window_EquipItem < Window_ItemList
  #--------------------------------------------------------------------------
  # ● Determine if an item goes in the list
  #--------------------------------------------------------------------------
  alias_method(:krx_ammo_wei_include?, :include?)
  def include?(item)
    if @actor.class.ammo_user?
      weapon_slot = @actor.class.weapon_slot_id
      if @slot_id == @actor.class.ammo_slot_id
        return true if item.nil?
        return false unless item.is_a?(RPG::Weapon) && @actor.equips[weapon_slot]
        #return false if item.already_equipped == true
        if @actor.equips[@slot_id]
          return false if @actor.equips[@slot_id].id == item.id
        end
        return @actor.equips[weapon_slot].ammo_type_id == item.wtype_id
      else
        if item.is_a?(RPG::Weapon) && @actor.equips[weapon_slot]
          return false if @actor.equips[weapon_slot].ammo_type_id == item.wtype_id
        end
      end
    end
    krx_ammo_wei_include?(item)
  end
  #--------------------------------------------------------------------------
  # ● Determine if an item can be equipped
  #--------------------------------------------------------------------------
  alias_method(:krx_ammo_wei_enable?, :enable?)
  def enable?(item)
    if @actor.class.ammo_user?
      weapon_slot = @actor.class.weapon_slot_id
      if @slot_id == @actor.class.ammo_slot_id && @actor.equips[weapon_slot]
        return true if item.nil?
        return @actor.equips[weapon_slot].ammo_type_id == item.wtype_id
      end
    end
    krx_ammo_wei_enable?(item)
  end
end

# Bitmap Export v5.4 for XP, VX and VXace by Zeus81
# Free for commercial use
# Licence : http://creativecommons.org/licenses/by/4.0/
# Contact : zeusex81@gmail.com
# How to Use :
#   - exporting bitmap :
#       bitmap.export(filename)
#    or bitmap.save(filename)
#
#   - serialize bitmap :
#       open(filename, 'wb') {|file| Marshal.dump(bitmap, file)}
#       bitmap = open(filename, 'rb') {|file| Marshal.load(file)}
#   or
#       save_data(bitmap, filename)
#       bitmap = load_data(filename)
#
#  - snapshot :
#      Graphics.export(filename)
#   or Graphics.save(filename)
#   or Graphics.snapshot(filename)
#   Here filename is optional, and will be replaced by datetime if omitted. 
 
$imported ||= {}
$imported[:Zeus_Bitmap_Export] = __FILE__
 
def xp?() false end; alias vx? xp?; alias vxace? xp?
RUBY_VERSION == '1.8.1' ? defined?(Hangup) ?
def xp?() true  end : def vx?() true  end : def vxace?() true  end
 
class String
  alias getbyte  []
  alias setbyte  []=
  alias bytesize size
end unless vxace?
 
class Font
  def marshal_dump()     end
  def marshal_load(dump) end
end
 
class Bitmap
  RtlMoveMemory = Win32API.new('kernel32', 'RtlMoveMemory', 'ppi', 'i')
  def last_row_address
    return 0 if disposed?
    RtlMoveMemory.call(buf=[0].pack('L'), __id__*2+16, 4)
    RtlMoveMemory.call(buf, buf.unpack('L')[0]+8 , 4)
    RtlMoveMemory.call(buf, buf.unpack('L')[0]+16, 4)
    buf.unpack('L')[0]
  end
  def bytesize
    width * height * 4
  end
  def get_data
    data = [].pack('x') * bytesize
    RtlMoveMemory.call(data, last_row_address, data.bytesize)
    data
  end
  def set_data(data)
    RtlMoveMemory.call(last_row_address, data, data.bytesize)
  end
  def get_data_ptr
    data = String.new
    RtlMoveMemory.call(data.__id__*2, [vxace? ? 0x6005 : 0x2007].pack('L'), 4)
    RtlMoveMemory.call(data.__id__*2+8, [bytesize,last_row_address].pack('L2'), 8)
    def data.free() RtlMoveMemory.call(__id__*2, String.new, 16) end
    return data unless block_given?
    yield data ensure data.free
  end
  def _dump(level)
    get_data_ptr do |data|
      dump = Marshal.dump([width, height, Zlib::Deflate.deflate(data, 9)])
      dump.force_encoding('UTF-8') if vxace?
      dump
    end
  end
  def self._load(dump)
    width, height, data = *Marshal.load(dump)
    data.replace(Zlib::Inflate.inflate(data))
    bitmap = new(width, height)
    bitmap.set_data(data)
    bitmap
  end
  def export(filename)
    case format=File.extname(filename)
    when '.bmp'; export_bmp(filename)
    when '.png'; export_png(filename)
    when ''    ; export_png("#{filename}.png")
    else         print("Export format '#{format}' not supported.")
    end
  end
  alias save export
  def export_bmp(filename)
    get_data_ptr do |data|
      File.open(filename, 'wb') do |file|
        file.write(['BM',data.bytesize+54,0,54,40,width,height,
                    1,32,0,data.bytesize,0,0,0,0].pack('a2L6S2L6'))
        file.write(data)
      end
    end
  end
  def export_png(filename)
    data, i = get_data, 0
    if vxace?
      (0).step(data.bytesize-4, 4) do |i|
        byte2 = data.getbyte(i)
        data.setbyte(i, data.getbyte(i+2))
        data.setbyte(i+2, byte2)
      end
    else
      (0).step(data.bytesize-4, 4) do |i|
        data[i,3] = data[i,3].reverse!
      end
    end
    deflate = Zlib::Deflate.new(9)
      null_char, w4 = [].pack('x'), width*4
      (data.bytesize-w4).step(0, -w4) {|i| deflate << null_char << data[i,w4]}
      data.replace(deflate.finish)
    deflate.close
    File.open(filename, 'wb') do |file|
      def file.write_chunk(chunk)
        write([chunk.bytesize-4].pack('N'))
        write(chunk)
        write([Zlib.crc32(chunk)].pack('N'))
      end
      file.write("\211PNG\r\n\32\n")
      file.write_chunk(['IHDR',width,height,8,6,0,0,0].pack('a4N2C5'))
      file.write_chunk(data.insert(0, 'IDAT'))
      file.write_chunk('IEND')
    end
  end
end
 
module Graphics
  if xp?
    FindWindow             = PONY::API::FindWindow
    GetDC                  = Win32API.new('user32', 'GetDC'                 , 'i'        , 'i')
    ReleaseDC              = Win32API.new('user32', 'ReleaseDC'             , 'ii'       , 'i')
    BitBlt                 = Win32API.new('gdi32' , 'BitBlt'                , 'iiiiiiiii', 'i')
    CreateCompatibleBitmap = Win32API.new('gdi32' , 'CreateCompatibleBitmap', 'iii'      , 'i')
    CreateCompatibleDC     = Win32API.new('gdi32' , 'CreateCompatibleDC'    , 'i'        , 'i')
    DeleteDC               = Win32API.new('gdi32' , 'DeleteDC'              , 'i'        , 'i')
    DeleteObject           = Win32API.new('gdi32' , 'DeleteObject'          , 'i'        , 'i')
    GetDIBits              = Win32API.new('gdi32' , 'GetDIBits'             , 'iiiiipi'  , 'i')
    SelectObject           = Win32API.new('gdi32' , 'SelectObject'          , 'ii'       , 'i')
    def self.snap_to_bitmap
      bitmap  = Bitmap.new(width, height)
      info    = [40,width,height,1,32,0,0,0,0,0,0].pack('LllSSLLllLL')
      hDC     = GetDC.call(hwnd)
      bmp_hDC = CreateCompatibleDC.call(hDC)
      bmp_hBM = CreateCompatibleBitmap.call(hDC, width, height)
      bmp_obj = SelectObject.call(bmp_hDC, bmp_hBM)
      BitBlt.call(bmp_hDC, 0, 0, width, height, hDC, 0, 0, 0xCC0020)
      GetDIBits.call(bmp_hDC, bmp_hBM, 0, height, bitmap.last_row_address, info, 0)
      SelectObject.call(bmp_hDC, bmp_obj)
      DeleteObject.call(bmp_hBM)
      DeleteDC.call(bmp_hDC)
      ReleaseDC.call(hwnd, hDC)
      bitmap
    end
  end
  class << self
    def hwnd() @hwnd ||= FindWindow.call('RGSS Player', nil) end
    def width()  640 end unless method_defined?(:width)
    def height() 480 end unless method_defined?(:height)
    def export(filename=Time.now.strftime("snapshot %Y-%m-%d %Hh%Mm%Ss #{frame_count}"))
      bitmap = snap_to_bitmap
      bitmap.export(filename)
      bitmap.dispose
    end
    alias save     export
    alias snapshot export
  end
end

=begin
#===============================================================================
 Title: Item Rarity
 Author: Hime
 Date: Mar 26, 2014
 URL: http://www.himeworks.com/2014/03/25/item-rarity/
--------------------------------------------------------------------------------
 ** Change log
 Apr 11, 2014
   - fixed bug where item color affects other rows as well
 Mar 26, 2014
   - Fixed bug where loading skills crashed. You can now tag skills with rarity
   - Extended to all base item objects
 Mar 25, 2014
   - Initial release
--------------------------------------------------------------------------------   
 ** Terms of Use
 * Free to use in non-commercial projects
 * Contact me for commercial use
 * No real support. The script is provided as-is
 * Will do bug fixes, but no compatibility patches
 * Features may be requested but no guarantees, especially if it is non-trivial
 * Credits to Hime Works in your project
 * Preserve this header
--------------------------------------------------------------------------------
 ** Description
 
 This script allows you to assign item rarities to items and equips.
 
 Rarity is indicated by name colour: by default, all names are white. 
 You can customize this so that different rarity levels have different
 colours.
 
--------------------------------------------------------------------------------
 ** Installation
 
 In the script editor, place this script below Materials and above Main
--------------------------------------------------------------------------------
 ** Usage 
 
 To specify rarity, note-tag items and equips with
 
   <item rarity: x>
   
 Where x is a number.
 In the configuration, you can set up the colours associated with each rarity
 level.
 
#===============================================================================
=end
$imported = {} if $imported.nil?
$imported[:TH_ItemRarity] = true
#===============================================================================
# ** Configuration
#===============================================================================
module TH
  module Item_Rarity
    
    # Colours associated with each rarity. The colours are specified as
    # RGB values. So for example, White is [255, 255, 255]
    Colour_Map = {
      1 => [255, 255, 255], #white
      2 => [204, 255, 137], #green
      3 => [40,60,200], #blue
      4 => [255, 90, 0], #orange
      5 => [150, 40, 160], #purple
      6 => [25,25,45], # very deep blue
      7 => [245, 30, 10] # Red
    }
    
    Regex = /<item[-_ ]rarity:\s*(\d+)\s*>/i
    
#===============================================================================
# ** Rest of script
#===============================================================================
    @@rarity_colour_map = nil
    
    def self.rarity_colour_map
      unless @@rarity_colour_map
        @@rarity_colour_map = {}
        Colour_Map.each do |i, arr|
          @@rarity_colour_map[i] = Color.new(*arr)
        end
      end
      return @@rarity_colour_map
    end
  end
end
module RPG
 
  class BaseItem
    def rarity
      load_notetag_item_rarity unless @rarity
      return @rarity
    end
    
    def load_notetag_item_rarity
      @rarity = 1
      res = self.note.match(TH::Item_Rarity::Regex)
      if res
        @rarity = res[1].to_i
      end
    end
    
    def rarity_colour
      TH::Item_Rarity.rarity_colour_map[self.rarity]
    end
  end
end
class Window_Base < Window
  
  #-----------------------------------------------------------------------------
  # Replaced
  #-----------------------------------------------------------------------------
  def draw_item_name(item, x, y, enabled = true, width = 172)
    return unless item
    draw_icon(item.icon_index, x, y, enabled)
    change_color(item.rarity_colour, enabled)
    draw_text(x + 24, y, width, line_height, item.name)
		change_color(normal_color, enabled)
  end
end
#===============================================================================
# Instance Item extension
#===============================================================================
if $imported["TH_InstanceItems"]
  module RPG
    class BaseItem
      alias :th_item_rarity_refresh :refresh
      def refresh
        th_item_rarity_refresh
        refresh_item_rarity
      end
      
      def refresh_item_rarity
        var = InstanceManager.get_template(self).rarity
        @rarity = make_item_rarity(InstanceManager.make_full_copy(var))
      end
      def make_item_rarity(rarity)
        rarity
      end
    end
  end
end

###--------------------------------------------------------------------------###
#  CP Keyboard Input script                                                    #
#  Version 1.0a                                                                #
#                                                                              #
#      Credits:                                                                #
#  Original code by: Neon Black                                                #
#  Modified by:                                                                                 #
#                                                                                                        #
#  This work is licensed under the Creative Commons Attribution-NonCommercial  #
#  3.0 Unported License. To view a copy of this license, visit                 #
#  http://creativecommons.org/licenses/by-nc/3.0/.                             #
#  Permissions beyond the scope of this license are available at               #
#  http://cphouseset.wordpress.com/liscense-and-terms-of-use/.                 #
#                                                                                                                   #
#      Contact:                                                                #
#  NeonBlack - neonblack23@live.com (e-mail) or "neonblack23" on skype         #
###--------------------------------------------------------------------------###
###--------------------------------------------------------------------------###
#      Revision information:                                                   #
#  V1.0a - 11.15.2012                                                          #
#   Input module bug fix                                                       #
#  V1.0 - 8.11.2012                                                            #
#   Split the console and keyboard module                                      #
#  V0.1 - 7.9.2012                                                             #
#   Wrote and debugged main script                                             #
###--------------------------------------------------------------------------###
###--------------------------------------------------------------------------###
#      Instructions:                                                           #
#  Place this script in the "Materials" section of the scripts above main.     #
#  This script adds keyboard usage to your scripts with the use of the new     #
#  "Keyboard" module.  You can do this using both the "Input" module and the   #
#  "Keyboard" module the same way, ie. Keyboard.trigger?(:kA) or               #
#  Input.trigger?(:kA) will both have the same effect.  To specify keyboard    #
#  input on any given key, this script uses the letter "k" followed by the     #
#  name of the key in all caps.  For example, a letter would be ":kA" or       #
#  ":kK" or some other similar form, numbers would be ":k1", ":k2", etc., and  #
#  named keys would be ":kENTER" or some other key name.                       #
#  To see all the available keys, search for the "Ascii" module.               #
###--------------------------------------------------------------------------###
###--------------------------------------------------------------------------###
#  The following lines are the actual core code of the script.  While you are  #
#  certainly invited to look, modifying it may result in undesirable results.  #
#  Modify at your own risk!                                                    #
###--------------------------------------------------------------------------###
$imported = {} if $imported == nil
$imported["CP_KEYBOARD"] = 1.0
module V  ## Checks a virtual key.
  def self.K(key)
    return Ascii::SYM[key]
  end
end
# tag: input
module Ascii  ## Only the keys I bothered to name.  Some have 2 names.
  SYM = { :k0 => 48, :k1 => 49, :k2 => 50, :k3 => 51, :k4 => 52, :k5 => 53,
          :k6 => 54, :k7 => 55, :k8 => 56, :k9 => 57,
          
          :kA => 65, :kB => 66, :kC => 67, :kD => 68, :kE => 69, :kF => 70,
          :kG => 71, :kH => 72, :kI => 73, :kJ => 74, :kK => 75, :kL => 76,
          :kM => 77, :kN => 78, :kO => 79, :kP => 80, :kQ => 81, :kR => 82,
          :kS => 83, :kT => 84, :kU => 85, :kV => 86, :kW => 87, :kX => 88,
          :kY => 89, :kZ => 90,
          
          :kENTER => 13,    :kRETURN => 13,  :kBACKSPACE => 8, :kSPACE => 32,
          :kESCAPE => 27,   :kESC => 27,     :kSHIFT => 16,    :kTAB => 9,
          :kALT => 18,      :kCTRL => 17,    :kDELETE => 46,   :kDEL => 46,
          :kINSERT => 45,   :kINS => 45,     :kPAGEUP => 33,   :kPUP => 33,
          :kPAGEDOWN => 34, :kPDOWN => 34,   :kHOME => 36,     :kEND => 35,
          :kLALT => 164,    :kLCTRL => 162,  :kRALT => 165,    :kRCTRL => 163,
          :kLSHIFT => 160,  :kRSHIFT => 161,
          
          :kLEFT => 37, :kRIGHT => 39, :kUP => 38, :kDOWN => 40,
          
          :kCOLON => 186,     :kAPOSTROPHE => 222, :kQUOTE => 222,
          :kCOMMA => 188,     :kPERIOD => 190,     :kSLASH => 191,
          :kBACKSLASH => 220, :kLEFTBRACE => 219,  :kRIGHTBRACE => 221,
          :kMINUS => 189,     :kUNDERSCORE => 189, :kPLUS => 187,
          :kEQUAL => 187,     :kEQUALS => 187,     :kTILDE => 192,
          
          :kF1 => 112,  :kF2 => 113,  :kF3 => 114, :kF4 => 115, :kF5 => 116,
          :kF6 => 117,  :kF7 => 118,  :kF8 => 119, :kF9 => 120, :kF10 => 121,
          :kF11 => 122, :kF12 => 123,
          
          :kArrows => 224,
        }
end
module Keyboard  ## The DLL file, function, import, and export.
  @key_state = PONY::API::GetKeyState
  @key_paste = PONY::API::GetClipboardData
  
  @trigger = Array.new(256, false)  ## All 3 of the related arrays for checks.
  @press   = Array.new(256, false)
  @repeat  = Array.new(256, 0)
  @checked = false  ## Sets the check state.
  
  def self.update  ## Resets the check state each frame.
    @checked = false
  end
  
  def self.get_key_state  ## Sets the key states.
    @checked = true
    256.times do |vk|  ## All virtual keys are checked.
      check = @key_state.call(vk)  ## Use the DLL to check the key state.
      unless check == 1 or check == 0  ## -128 and -127 would be held down keys.
        unless @press[vk]
          @press[vk] = true  ## Start pressing.
          @trigger[vk] = true  ## Set the trigger.
        else
          @trigger[vk] = false  ## Depress trigger on later frames.
        end
        @repeat[vk] += 1  ## And change the repeat.
      else
        @press[vk] = false  ## Disable all checks on the key.
        @trigger[vk] = false
        @repeat[vk] = 0
      end
    end
  end
  
  def self.press?(sym)  ## Checks if a key <sym> is pressed down.
    return get_symb(sym, :press)
  end
  
  def self.trigger?(sym)  ## Checks trigger as above.
    return get_symb(sym, :trigger)
  end
  
  def self.repeat?(sym)  ## Checks repeat as above.
    return get_symb(sym, :repeat)
  end
  def self.get_symb(sym, type)  ## Check if the <sym> key is <type>.
    res = sym.is_a?(Symbol) ? V.K(sym) : sym  ## Gets the key's numeric.
    return false if res.nil?  ## Returns if key is not accepted.
    get_key_state unless @checked  ## Sets key states.
    
    case type  ## Checks the key by numeric.
    when :press;   return ch_press?(res)
    when :trigger; return ch_trigger?(res)
    when :repeat;  return ch_repeat?(res)
    end
    return false
  end
          ## The three proper checks.  Need a numeric value for a key to check.
  def self.ch_press?(sym)  ## Held down.
    return @press[sym]
  end
  
  def self.ch_trigger?(sym)  ## Pressed this frame.
    return @trigger[sym]
  end
  
  def self.ch_repeat?(sym)  ## Alternates every few frames.
    return true if @repeat[sym] == 1
    return true if (@repeat[sym] >= 24 && (@repeat[sym] % 6) == 0)
    return false
  end
  
  def self.shifted?  ## Checks the state of both shift keys.
    return true if press?(16)
    return true if caps_on?
    return false
  end
  
  def self.caps_on?  ## Checks the state of capslock.
    return true if @key_state.call(20) == 1
    return false
  end
  
  def self.bittype(text)  ## The keys accepted by typing.
    for i in 48..57  ## Numbers.
      if repeat?(i)
        text += add_char(i)
      end
    end
    for i in 65..90  ## Letters.
      if repeat?(i)
        text += add_char(i)
      end
    end
    for i in 186..192  ## Symbols.
      if repeat?(i)
        text += add_char(i)
      end
    end
    for i in 219..222  ## More symbols.
      if repeat?(i)
        text += add_char(i)
      end
    end
    text += " " if repeat?(32)  ## Space.
    if repeat?(8)  ## Backspace.
      text.chop!
    end
    return text
  end
  
  def self.add_char(key)  ## Adds typed characters.
    caps = press?(16)
    case key
    when 48..57
      return (key - 48).to_s unless caps
      return '!' if key == 49
      return '@' if key == 50
      return '#' if key == 51
      return '$' if key == 52
      return '%' if key == 53
      return '^' if key == 54
      return '&' if key == 55
      return '*' if key == 56
      return '(' if key == 57
      return ')' if key == 48
    when 65..90
      string = "abcdefghijklmnopqrstuvwxyz"
      string.swapcase! if caps
      string.swapcase! if caps_on?
      return string[key - 65]
    when 186; return !caps ? ';' : ':'
    when 187; return !caps ? '=' : '+'
    when 188; return !caps ? ',' : '<'
    when 189; return !caps ? '-' : '_'
    when 190; return !caps ? '.' : '>'
    when 191; return !caps ? '/' : '?'
    when 192; return !caps ? '`' : '~'
    when 219; return !caps ? '[' : '{'
    when 220; return !caps ? '\\' : '|'
    when 221; return !caps ? ']' : '}'
    when 222; return !caps ? '\'' : '"'
    end
  end
  
  def self.press_any_key  ## The keys accepted by "any key"
    for i in 48..57
      return true if trigger?(i)
    end
    for i in 65..90
      return true if trigger?(i)
    end
    for i in 186..192
      return true if trigger?(i)
    end
    for i in 219..222
      return true if trigger?(i)
    end
    [13, 22, 27, 192, 32].each {|i| return true if trigger?(i)}
    return false
  end
end
module Input
class << self
  alias cp_keyboard_update update unless $@
  alias cp_keyboard_press? press? unless $@
  alias cp_keyboard_trigger? trigger? unless $@
  alias cp_keyboard_repeat? repeat? unless $@
end
  
  def self.update
    Keyboard.update
    cp_keyboard_update
  end
  
  def self.press?(*sym)
    if $imported["CP_INPUT"]
      cp_keyboard_press?(*sym)
    else
      sym.any? do |key|
        (Keyboard.press?(key) || cp_keyboard_press?(key))
      end
    end
  end
  
  def self.trigger?(*sym)
    if $imported["CP_INPUT"]
      cp_keyboard_trigger?(*sym)
    else
      sym.any? do |key|
        (Keyboard.trigger?(key) || cp_keyboard_trigger?(key))
      end
    end
  end
  
  def self.repeat?(*sym)
    if $imported["CP_INPUT"]
      cp_keyboard_repeat?(*sym)
    else
      sym.any? do |key|
        (Keyboard.repeat?(key) || cp_keyboard_repeat?(key))
      end
    end
  end
  
end
module Input
  
  class << self; alias :trigger_wasd? :trigger?; end
  def self.trigger?(sym)
    case sym
    when :UP;     return trigger_wasd?(sym) || trigger_wasd?(:kW);
    when :LEFT;   return trigger_wasd?(sym) || trigger_wasd?(:kA);
    when :DOWN;   return trigger_wasd?(sym) || trigger_wasd?(:kS);
    when :RIGHT;  return trigger_wasd?(sym) || trigger_wasd?(:kD);
    when :R;      return trigger_wasd?(sym) || trigger_wasd?(:kE);
    else;         return trigger_wasd?(sym);
    end
  end
  
  class << self; alias :press_wasd? :press?; end
  def self.press?(sym)
    case sym
    when :UP;     return press_wasd?(sym) || press_wasd?(:kW);
    when :LEFT;   return press_wasd?(sym) || press_wasd?(:kA);
    when :DOWN;   return press_wasd?(sym) || press_wasd?(:kS);
    when :RIGHT;  return press_wasd?(sym) || press_wasd?(:kD);
    when :R;      return press_wasd?(sym) || press_wasd?(:kE);
    else;         return press_wasd?(sym);
    end
  end
  
  class << self; alias :repeat_wasd? :repeat?; end
  def self.repeat?(sym)
    case sym
    when :UP;     return repeat_wasd?(sym) || repeat_wasd?(:kW);
    when :LEFT;   return repeat_wasd?(sym) || repeat_wasd?(:kA);
    when :DOWN;   return repeat_wasd?(sym) || repeat_wasd?(:kS);
    when :RIGHT;  return repeat_wasd?(sym) || repeat_wasd?(:kD);
    when :R;      return repeat_wasd?(sym) || repeat_wasd?(:kE);
    else;         return repeat_wasd?(sym);
    end
  end
end
###--------------------------------------------------------------------------###
#  End of script.                                                              #
###--------------------------------------------------------------------------###

#==============================================================================
#** Text Input script
#------------------------------------------------------------------------------
# author:  erpicci
# version: 1.0
# require: CP Keyboard Input script  by Neon Black
##------------------------------------------------------------------------------
# * Introduction
#------------------------------------------------------------------------------
# This script allows the player to insert a medium-sized text by typing
# directly from the keyboard. Inserted text is returned as a string.
## Requires Neon Black's Keyboard Input Script to work.
## It is completely free, both for commercial and non-commercial use. All you
# are asked to do is to give me credits for the script.
##------------------------------------------------------------------------------
# * Installation
#------------------------------------------------------------------------------
# Be sure to have Neon Black's Keyboard Input Script installed.
# Place this script in the "Materials" section of the scripts above main.
# To insert a text using an event, create a script event like:
#   text_var = text_input("Window Title")
#
# To have a script call the text input, use:
#   text_var = Scene_Text.read("Window Title")
#
#Only window title is mandatory. As optional arguments, you can set:
#  * alignment: "center" (default), "left", "right"
#  * maximum number of character: default is 104
#  * left-to-right: default is true, use false to get a right-to-left input
#
#------------------------------------------------------------------------------
# * Examples
#------------------------------------------------------------------------------
#Open a window whose title is "Talk to Bobby", text is centered, allows
#  
# to enter up to 20 characters, writing is right-to-left
#   variable = Scene_Text.read("Talk to Bobby", "center", 20, false)
#    Open a window whose title is "Tell me something", text is aligned to   
# right, allows to enter up to 88 characters, writing is left-to-right
#
# (default)
#   variable = Scene_Text.read("Tell me something", "center", 20)#
#   # Open a window whose title is "Insert text", text is centered (default),#   
# accepts up to 104 characters (default), writing is left-to-right (default)
#   variable = Scene_Text.read("Insert text")
#====================================================================
module Text_Input  ACCEPTED_KEYS = {    
  :k0 => 48, :k1 => 49, :k2 => 50, :k3 => 51, :k4 => 52,    
  :k5 => 53, :k6 => 54, :k7 => 55, :k8 => 56, :k9 => 57,        
  :kA => 65, :kB => 66, :kC => 67, :kD => 68, :kE => 69, 
  :kF => 70,    :kG => 71, :kH => 72, :kI => 73, :kJ => 74, 
  :kK => 75, :kL => 76,    :kM => 77, :kN => 78, :kO => 79,
  :kP => 80, :kQ => 81, :kR => 82,    :kS => 83, :kT => 84,
  :kU => 85, :kV => 86, :kW => 87, :kX => 88,   
  :kY => 89, :kZ => 90,       
  :kCOLON     => 186, :kQUOTE     => 222, :kSPACE      => 32,  
  :kCOMMA     => 188, :kPERIOD    => 190, :kSLASH      => 191, 
  :kBACKSLASH => 220, :kLEFTBRACE => 219, :kRIGHTBRACE => 221,  
  :kMINUS     => 189, :kEQUAL     => 187, :kTILDE      => 192, 
  }
end
#====================================================================
# ** Scene_Text
#------------------------------------------------------------------------
#  This class shows an input field for the player.
#=========================================================================
class Scene_Text < Scene_MenuBase  
  ALIGN    = "center"  
  MAX_CHAR = 104  
  LTR      = true    
  #-------------------------------------------------------------------------- 
  # * Show a dialog window to the player
  #--------------------------------------------------------------------------  
  def self.read(title, align = ALIGN, max_char = MAX_CHAR, ltr = LTR)    
    #$game_system.menu_cursor_name = "Hidden_Cursor"
    @@text     = ""    
    @@title    = title    
    @@align    = align    
    @@max_char = max_char
    @@ltr      = ltr    
    SceneManager.call(Scene_Text)    
    Fiber.yield while SceneManager.scene_is?(Scene_Text)    
      return @@text
    end  
  #--------------------------------------------------------------------------  
  # * Start Processing  
  #--------------------------------------------------------------------------
  def start  
    super
    @edit_window  = Window_TextEdit.new(@@title, @@align, @@max_char, @@ltr)    
    @edit_window.set_handler(:ok, method(:on_input_ok))  
  end  
  #-------------------------------------------------------------------------- 
  # * Set text when done  
  #-------------------------------------------------------------------------- 
  def on_input_ok    
    @@text = @edit_window.text  
    #$game_system.menu_cursor_name = $cursor.to_s
    return_scene 
  end
end
#===========================================================
# ** Window_TextEdit
#------------------------------------------------------------------------------
#  This window allows to edit a text.
#=======================================================================
class Window_TextEdit < Window_Selectable  
  include Text_Input  
  #--------------------------------------------------------------------------  
  # * Public Instance Variables  
  #--------------------------------------------------------------------------  
  attr_reader   :text
  attr_reader   :input_list
  #--------------------------------------------------------------------------  
  # * Object Initialization 
  #-------------------------------------------------------------------------- 
  def initialize(title, align = "center", max_char = 104, ltr = true) 
    x = 0  
    y = Graphics.height - fitting_height(6)   
    super(x, y, Graphics.width, fitting_height(6))
    @text     = ""   
    @title    = title   
    @align    = align   
    @max_char = max_char 
    @ltr      = ltr   
    @index    = @text.size
    @list_index = -1
    activate  
    refresh 
  end  
  #-------------------------------------------------------------------------  
  # * Revert to Default Text  
  #--------------------------------------------------------------------------  
  def restore_default    
    @text = ""    
    @index = @text.size   
    refresh   
    return !@text.empty?  
  end  
  #--------------------------------------------------------------------------  
  # * Get Character Width 
  #-------------------------------------------------------------------------- 
  def char_width   
    text_size($game_system.japanese? ? "‚ " : "A").width   
  end
  #--------------------------------------------------------------------------
  # * Get Number of Items
  #--------------------------------------------------------------------------
  def item_max
    return @text.size + 1 rescue 1
  end
  #-------------------------------------------------------------------------- 
  # * Get Number of Columns 
  #-------------------------------------------------------------------------- 
  def max_col  
    [(Graphics.width - 32) / char_width, @max_char].min 
  end  
  #-------------------------------------------------------------------------- 
  # * Get Left Padding  
  #-------------------------------------------------------------------------- 
  def left(n)  
    return 10 if @align == "left"  
    return (width - 32 - n * char_width)     if @align == "right"   
    return (width - 32 - n * char_width) / 2 # if align == "center"  
  end 
  #--------------------------------------------------------------------------
  # * Get Rectangle for Displaying Item 
  #--------------------------------------------------------------------------  
  def item_rect(index)    
    index -= 1 if index == @max_char    
    x = index % max_col    
    y = index / max_col    
    n = [(@max_char - y * max_col), max_col].min        
    x = left(n) + x * char_width    
    x = width - x - 48 if not @ltr    
    y = 24      + y * (line_height + 4)
    Rect.new(x, y, char_width, line_height) 
    end
  #-------------------------------------------------------------------------  
  # * Get Underline Rectangle  
  #-------------------------------------------------------------------------- 
  def underline_rect(index)    
    rect = item_rect(index)    
    rect.x += 1
    rect.y += rect.height    
    rect.width -= 2
    rect.height = 2
    rect  
  end
  #--------------------------------------------------------------------------
  # * Get Current Line
  #--------------------------------------------------------------------------
  def row
    index / ((width - 32) / char_width)
  end
  #--------------------------------------------------------------------------  
  # * Get Underline Color  
  #--------------------------------------------------------------------------  
  def underline_color    
    color = normal_color   
    color.alpha = 48    
    color  
  end 
  #--------------------------------------------------------------------------  
  # * Draw Underline  
  #--------------------------------------------------------------------------  
  def draw_underline(index)    
    contents.fill_rect(underline_rect(index), underline_color)  
  end  
  #--------------------------------------------------------------------------  
  # * Draw Text  
  #--------------------------------------------------------------------------  
  def draw_char(index)   
    rect       = item_rect(index)    
    rect.x     += 4
    rect.width += 4
    change_color(normal_color) 
    draw_text(rect, @text[index] || "") 
  end  
  #-------------------------------------------------------------------------- 
  # * Draw Title 
  #-------------------------------------------------------------------------- 
  def draw_title 
    draw_text(0, 0, self.width, line_height, @title, 1) 
  end  
  #--------------------------------------------------------------------------  
  # * Refresh 
  #--------------------------------------------------------------------------
  def refresh  
    contents.clear
    draw_title   
    @text.size.times {|i| draw_char(i) } 
    @max_char.times  {|i| draw_underline(i) }   
    cursor_rect.set(item_rect(@index))  
  end 
  #--------------------------------------------------------------------------
  # * Handle Process
  #--------------------------------------------------------------------------  
  def process_handling  
    return unless open? && active 
    process_delete if Input.repeat?(:kBACKSPACE) 
    process_abort  if Input.trigger?(:kESC)    
    process_ok     if Input.trigger?(:kENTER) 
   
    process_keyboard  
  end  
  #-------------------------------------------------------------------------- 
  # * Check Input From Keyboard 
  #-------------------------------------------------------------------------- 
  def process_keyboard
    ACCEPTED_KEYS.each { |key|  
      if Input.repeat?(key[0])   
        c = (key[0] != :kSPACE) ? Keyboard.add_char(Ascii::SYM[key[0]]) : " "      
        process_add(c)      
        Sound.play_ok     
      end   
    }  
  end 
  #-------------------------------------------------------------------------- 
  # * Add One Character 
  #--------------------------------------------------------------------------
  def process_add(c)  
    return if @index > @max_char 
    if @index == @max_char
      @text[@index - 1] = c   
    else
      @text.insert(@index, c)
      @index += 1    
    end    
    refresh 
  end  
  #-------------------------------------------------------------------------- 
  # * Delete One Character  
  #--------------------------------------------------------------------------  
  def process_delete   
    return if @index == 0   
    @index -= 1
    @text.delete_at(@index)
    Sound.play_cancel   
    refresh  
  end  
  #--------------------------------------------------------------------------  
  # * Abort Text Input  
  #-------------------------------------------------------------------------- 
  def process_abort   
    restore_default   
    Sound.play_cancel  
    call_ok_handler 
  end 
  #-------------------------------------------------------------------------- 
  # * Complete Text Input
  #--------------------------------------------------------------------------  
  def process_ok
    $game_system.push_console(@text)
    Sound.play_ok  
    call_ok_handler 
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Down
  #--------------------------------------------------------------------------
  def cursor_down(wrap = false)
    return if @list_index <= 0
    cmd_record = $game_system.console_list
    @list_index -= 1
    @text = cmd_record[@list_index].dup if cmd_record[@list_index]
    select(@text.size)
    refresh
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Up
  #--------------------------------------------------------------------------
  def cursor_up(wrap = false)
    cmd_record = $game_system.console_list
    return if @list_index >= cmd_record.size - 1
    @list_index += 1
    @text = cmd_record[@list_index].dup if cmd_record[@list_index]
    select(@text.size)
    refresh
  end
  #--------------------------------------------------------------------------
  # * Move Cursor Right
  #--------------------------------------------------------------------------
  def cursor_right(wrap = false)
    if index < item_max - col_max || (wrap && col_max == 1)
      select((index + col_max) % item_max)
    end
  end
  #---------------------------------------- ----------------------------------
  # * Move Cursor Left
  #--------------------------------------------------------------------------
  def cursor_left(wrap = false)
    if index >= col_max || (wrap && col_max == 1)
      select((index - col_max + item_max) % item_max)
    end
  end
  #--------------------------------------------------------------------------
  # * Move Cursor One Page Down
  #--------------------------------------------------------------------------
  def cursor_pagedown
  end
  #--------------------------------------------------------------------------
  # * Move Cursor One Page Up
  #--------------------------------------------------------------------------
  def cursor_pageup
  end
  
end
#==============================================================================
# ** Game_Interpreter
#------------------------------------------------------------------------------
#  An interpreter for executing event commands. This class is used within the
# Game_Map, Game_Troop, and Game_Event classes.
#==============================================================================
class Game_Interpreter  
  #--------------------------------------------------------------------------  
  # * Insert a text 
  #--------------------------------------------------------------------------  
  def text_input(title, align = "center", max_char = 103, ltr = true)
    Scene_Text.read(title, align, max_char, ltr)
  end
end

#Basic Window Resizer v1.1
#----------#
#Features: Allows you to resize the window to whatever size you like! (This is not
#            like Graphics.resize, this will scale to fit)
#
#Usage:   Script calls:
#           Window_Resize.r(width, height)     - Self-explanatory
#           Window_Resize.f                    - fits the game window to monitor size
#           Window_Resize.full                 - switches to full screen unless already fullscreened
#           Window_Resize.window               - same as full but opposite
#           Window_Resize.toggle               - toggles between full and window
#
#No Customization
#
#----------#
#-- Script by: V.M of D.T
#
#- Questions or comments can be:
#    given by email: sumptuaryspade@live.ca
#    provided on facebook: http://www.facebook.com/DaimoniousTailsGames
#   All my other scripts and projects can be found here: http://daimonioustails.weebly.com/
#
#--- Free to use in any project, commercial or non-commercial, with credit given
# - - Though a donation's always a nice way to say thank you~ (I also accept actual thank you's)
 
SWPO = PONY::API::SetWindowPos
WINX = PONY::API::FindWindowEX
SMET = PONY::API::GetSystemMetrics
 
module Window_Resize
  
  def self.r(width, height)
    resw = SMET.call(0)
    resh = SMET.call(1)
    window_loc = WINX.call(0,0,"RGSS Player",0)
    width += (SMET.call(5) + SMET.call(45)) * 2
    height += (SMET.call(6) + SMET.call(45)) * 2 + SMET.call(4)
    x = (resw - width) / 2; y = (resh - height) / 2
    y = 0 if y < 0;x = 0 if x < 0
    SWPO.call(window_loc,0,x,y,width,height,0)
  end
  
  def self.f
    resw = SMET.call(0)
    resh = SMET.call(1)
    window_loc = WINX.call(0,0,"RGSS Player",0)
    SWPO.call(window_loc,0,0,0,resw,resh,0)
  end
  
  def self.full
    resw = SMET.call(0)
    return unless resw > 640
    toggle
  end
  
  def self.window
    resw = SMET.call(0)
    return unless resw <= 640
    toggle
  end
  
  def self.toggle
    keybd = Win32API.new 'user32.dll', 'keybd_event', ['i', 'i', 'l', 'l'], 'v'
    keybd.call 0xA4, 0, 0, 0
    keybd.call 13, 0, 0, 0
    keybd.call 13, 0, 2, 0
    keybd.call 0xA4, 0, 2, 0
  end
  
end

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Party System v1.08
# -- Last Updated: 2012.01.23
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-PartySystem"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.23 - Bug fixed: Party members are now rearranged when newly added.
# 2012.01.14 - New Feature: Maximum Battle Members Variable added.
# 2012.01.07 - Bug fixed: Error with removing members.
# 2012.01.05 - Bug fixed: Escape skill/item effects no longer counts as death.
# 2011.12.26 - Compatibility Update: New Game+
# 2011.12.17 - Updated Spriteset_Battle to have updated sprite counts.
# 2011.12.13 - Updated to provide better visual display when more than 5 pieces
#              of equipment are equipped on an actor at a time.
# 2011.12.05 - Added functionality to display faces in the Party Select Window.
#            - Fixed bug that doesn't refresh the caterpillar when new members
#              join the party.
# 2011.12.04 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# RPG Maker VX Ace comes with a very nice party system. However, changing the
# maximum number of members isn't possible without the aid of a script. This
# script enables you the ability to change the maximum number of party members,
# change EXP rates, and/or open up a separate party menu (if desired). In
# addition to that, you can lock the position of actors within a party and
# require other actors to be in the active party before continuing.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Script Calls - These commands are used with script calls.
# -----------------------------------------------------------------------------
# *IMPORTANT* These script calls require the new party menu to be enabled to
# use them. Otherwise, nothing will happen.
# 
# lock_actor(x)
# unlock_actor(x)
# This will lock actor x in its current position in the party if the actor is
# in the current party. The actor is unable to switch position and must remain
# in that position until the lock is removed. Use the unlock script call to
# remove the locked status. This script requires the actor to have joined and
# in the current party before the script call will work.
# 
# require_actor(x)
# unrequire_actor(x)
# This will cause the party to require actor x in order to continue. If the
# actor isn't in the current party but is in the reserve party, the party menu
# will open up and prompt the player to add the required actor into the party
# before being able to continue. This script call will not function unless the
# specific actor has joined the party, whether it is in the current or reserve.
# 
# call_party_menu
# This will open up the party menu. This script call requires for the party
# menu to be enabled to use.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
module YEA
  module PARTY
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Party Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # In this section, you can adjust the general party settings for your game
    # such as the maximum amount of members and whatnot, the EXP rate for
    # party members in the reserve, etc.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    MAX_BATTLE_MEMBERS   = 4     # Maximum party members. Default: 4
    SPLIT_EXP            = false  # Splits EXP with more members in the party.
    RESERVE_EXP_RATE     = 0.50   # Reserve EXP Rate. Default: 1.00
    
    # If you wish to be able to change the maximum number of battle members
    # during the middle of your game, set this constant to a variable ID. If
    # that variable ID is a number greater than 0, that variable will determine
    # the current maximum number of battle members. Be cautious about using
    # this during battle.
    MAX_MEMBERS_VARIABLE = 30
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Party Menu Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This section contains various menu settings for those who wish to use a
    # menu separate for the party system. Here, adjust the menu command order,
    # icons used, and other settings.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    ENABLE_MENU = true   # Enables party menu. Default: false
    COMMANDS =[          # The order at which the menu items are shown.
    # [:command,  "Display"],
      [ :change,  Vocab::Party::Change],
      [ :remove,  Vocab::Party::Remove],
      [ :revert,  Vocab::Party::Revert],
      [ :finish,  Vocab::Party::Finish],
    ] # Do not remove this.
    COMMAND_ALIGN    = 1     # 0:Left Align, 1:Center Align, 2:Right Align
    
    # These settings here are used for the upper right window: the Party Select
    # window where the player selects a member to swap out or remove.
    
    
    PARTY_FONT_SIZE  = 20    # Font size used for party member names.
    LOCK_FIRST_ACTOR = false # Lock the first actor by default?
    LOCKED_ICON      = 125   # Icon used for locked members.
    REQUIRED_ICON    = 126   # Icon used for required members.
    EMPTY_TEXT = Vocab::Party::TextEmpty   # Text used when a member isn't present.
    DISPLAY_FACE     = false # Display faces instead of sprites?
    
    # These settings here are used for the lower left window: the Party List
    # window where the player selects a member to replace.
    REMOVE_ICON      = 185          # Icon used for removing members.
    REMOVE_TEXT      = Vocab::Party::TextRemove   # Text used for remove member command.
    ACTOR_Y_BUFFER   = 12           # Amount the actor graphic be adjusted by.
    
    # These settings here are used for the lower right window: the Party Status
    # window where info about a selected actor is shown.
    NO_DATA         = Vocab::Party::TextEmpty # Text used for when no actor is shown.
    IN_PARTY_COLOUR = 6             # Text colour used for in party members.
    STAT_FONT_SIZE  = 20            # Font size used for stats.
    EQUIP_TEXT      = Vocab::Party::TextEquip   # Text used to display equipment.
    
  end # PARTY
end # YEA
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
#==============================================================================
# ■ Icon
#==============================================================================
module Icon
  
  #--------------------------------------------------------------------------
  # self.locked_party
  #--------------------------------------------------------------------------
  def self.locked_party; return YEA::PARTY::LOCKED_ICON; end
  
  #--------------------------------------------------------------------------
  # self.required_party
  #--------------------------------------------------------------------------
  def self.required_party; return YEA::PARTY::REQUIRED_ICON; end
  
  #--------------------------------------------------------------------------
  # self.remove_party
  #--------------------------------------------------------------------------
  def self.remove_party; return YEA::PARTY::REMOVE_ICON; end
    
end # Icon
#==============================================================================
# ■ Variable
#==============================================================================
module Variable
  
  #--------------------------------------------------------------------------
  # self.max_battle_members
  #--------------------------------------------------------------------------
  def self.max_battle_members
    default = YEA::PARTY::MAX_BATTLE_MEMBERS
    return default if YEA::PARTY::MAX_MEMBERS_VARIABLE <= 0
    return default if $game_variables[YEA::PARTY::MAX_MEMBERS_VARIABLE] <= 0
    return $game_variables[YEA::PARTY::MAX_MEMBERS_VARIABLE]
  end
  
end # Variable
#==============================================================================
# ■ Numeric
#==============================================================================
class Numeric
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
    
end # Numeric
#==============================================================================
# ■ Game_Actor
#==============================================================================
class Game_Actor < Game_Battler
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :locked
  attr_accessor :required
  
  #--------------------------------------------------------------------------
  # alias method: setup
  #--------------------------------------------------------------------------
  alias game_actor_setup_ps setup
  def setup(actor_id)
    game_actor_setup_ps(actor_id)
    @locked = false
    @required = false
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: final_exp_rate
  #--------------------------------------------------------------------------
  def final_exp_rate
    n = exr * (battle_member? ? 1 : reserve_members_exp_rate)
    if $game_party.in_battle
      n /= [$game_party.battle_members.size, 1].max if YEA::PARTY::SPLIT_EXP
    end
    return n
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: reserve_members_exp_rate
  #--------------------------------------------------------------------------
  def reserve_members_exp_rate
    $data_system.opt_extra_exp ? YEA::PARTY::RESERVE_EXP_RATE : 0
  end
  
end # Game_Actor
#==============================================================================
# ■ Game_Party
#==============================================================================
class Game_Party < Game_Unit
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :battle_members_array
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias game_party_initialize_ps initialize
  def initialize
    game_party_initialize_ps
    @battle_members_array = nil
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: max_battle_members
  #--------------------------------------------------------------------------
  def max_battle_members; return Variable.max_battle_members; end
  
  #--------------------------------------------------------------------------
  # alias method: setup_starting_members
  #--------------------------------------------------------------------------
  alias setup_starting_members_ps setup_starting_members
  def setup_starting_members(mode)
    setup_starting_members_ps(mode)
    initialize_battle_members
    return unless YEA::PARTY::LOCK_FIRST_ACTOR
    return if members[0].nil?
    members[0].locked = true
  end
  
  #--------------------------------------------------------------------------
  # alias method: setup_battle_test_members
  #--------------------------------------------------------------------------
  alias setup_battle_test_members_ps setup_battle_test_members
  def setup_battle_test_members
    setup_battle_test_members_ps
    return unless YEA::PARTY::LOCK_FIRST_ACTOR
    return if members[0].nil?
    members[0].locked = true
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: battle_members
  #--------------------------------------------------------------------------
  def battle_members
    initialize_battle_members if initialize_battle_members?
    array = []
    for actor_id in @battle_members_array
      break if array.size > max_battle_members
      next if actor_id.nil?
      next if $game_actors[actor_id].nil?
      next unless $game_actors[actor_id].exist?
      array.push($game_actors[actor_id])
    end
    return array
  end
  
  #--------------------------------------------------------------------------
  # new method: initialize_battle_members?
  #--------------------------------------------------------------------------
  def initialize_battle_members?
    return true if @battle_members_array.nil?
    return @battle_members_array.size != max_battle_members
  end
  
  #--------------------------------------------------------------------------
  # new method: initialize_battle_members
  #--------------------------------------------------------------------------
  def initialize_battle_members
    @battle_members_array = []
    for i in 0...max_battle_members
      @battle_members_array.push(@actors[i]) unless @actors[i].nil?
      @battle_members_array.push(0) if @actors[i].nil?
    end
    $game_player.refresh
  end
  
  #--------------------------------------------------------------------------
  # alias method: add_actor
  #--------------------------------------------------------------------------
  alias game_party_add_actor_ps add_actor
  def add_actor(actor_id)
    game_party_add_actor_ps(actor_id)
    return if @battle_members_array.include?(actor_id)
    return unless @battle_members_array.include?(0)
    index = @battle_members_array.index(0)
    @battle_members_array[index] = actor_id
    $game_player.refresh
    $game_map.need_refresh = true
    rearrange_actors
  end
  
  #--------------------------------------------------------------------------
  # alias method: remove_actor
  #--------------------------------------------------------------------------
  alias game_party_remove_actor_ps remove_actor
  def remove_actor(actor_id)
    game_party_remove_actor_ps(actor_id)
    return unless @battle_members_array.include?(actor_id)
    index = @battle_members_array.index(actor_id)
    @battle_members_array[index] = 0
    $game_player.refresh
    $game_map.need_refresh = true
    rearrange_actors
  end
  
  #--------------------------------------------------------------------------
  # new method: rearrange_actors
  #--------------------------------------------------------------------------
  def rearrange_actors
    initialize_battle_members if @battle_members_array.nil?
    rearrange_battlers
    array = []
    for actor_id in @battle_members_array
      next if [0, nil].include?(actor_id)
      next if $game_actors[actor_id].nil?
      array.push(actor_id)
    end
    for actor_id in @actors
      next if array.include?(actor_id)
      next if $game_actors[actor_id].nil?
      array.push(actor_id)
    end
    @actors = array
  end
  #--------------------------------------------------------------------------
  def rearrange_battlers
    osize = @battle_members_array.size
    @battle_members_array = @battle_members_array.compact.select{|id| id > 0}
    (osize - @battle_members_array.size).times do |i|
      @battle_members_array << 0
    end
  end
end # Game_Party
#==============================================================================
# ■ Game_Interpreter
#==============================================================================
class Game_Interpreter
  
  #--------------------------------------------------------------------------
  # new method: lock_actor
  #--------------------------------------------------------------------------
  def lock_actor(actor_id)
    return unless YEA::PARTY::ENABLE_MENU
    actor = $game_actors[actor_id]
    return unless $game_party.battle_members.include?(actor.id)
    actor.locked = true
  end
  
  #--------------------------------------------------------------------------
  # new method: unlock_actor
  #--------------------------------------------------------------------------
  def unlock_actor(actor_id)
    return unless YEA::PARTY::ENABLE_MENU
    actor = $game_actors[actor_id]
    return unless $game_party.battle_members.include?(actor.id)
    actor.locked = false
  end
  
  #--------------------------------------------------------------------------
  # new method: require_actor
  #--------------------------------------------------------------------------
  def require_actor(actor_id)
    return unless YEA::PARTY::ENABLE_MENU
    return if $game_system.formation_disabled
    actor = $game_actors[actor_id]
    return unless $game_party.all_members.include?(actor)
    actor.required = true
    call_party_menu unless $game_party.battle_members.include?(actor)
  end
  
  #--------------------------------------------------------------------------
  # new method: unrequire_actor
  #--------------------------------------------------------------------------
  def unrequire_actor(actor_id)
    return unless YEA::PARTY::ENABLE_MENU
    return if $game_system.formation_disabled
    actor = $game_actors[actor_id]
    return unless $game_party.all_members.include?(actor)
    actor.required = false
    call_party_menu unless $game_party.battle_members.include?(actor)
  end
  
  #--------------------------------------------------------------------------
  # new method: call_party_menu
  #--------------------------------------------------------------------------
  def call_party_menu
    return unless YEA::PARTY::ENABLE_MENU
    return if $game_system.formation_disabled
    SceneManager.call(Scene_Party)
  end
  
end # Game_Interpreter
#==============================================================================
# ■ Spriteset_Battle
#==============================================================================
class Spriteset_Battle
  
  #--------------------------------------------------------------------------
  # overwrite method: create_actors
  #--------------------------------------------------------------------------
  def create_actors
    total = $game_party.max_battle_members
    @actor_sprites = Array.new(total) { Sprite_Battler.new(@viewport1) }
  end
  
end # Spriteset_Battle
#==============================================================================
# ■ Window_PartyMenuCommand
#==============================================================================
class Window_PartyMenuCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return 160; end
  
  #--------------------------------------------------------------------------
  # visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; 4; end
  
  #--------------------------------------------------------------------------
  # alignment
  #--------------------------------------------------------------------------
  def alignment
    return Menu.command_window_align if $imported["YEA-AceMenuEngine"]
    return YEA::PARTY::COMMAND_ALIGN
  end
  
  #--------------------------------------------------------------------------
  # scene
  #--------------------------------------------------------------------------
  def scene; return SceneManager.scene; end
  
  #--------------------------------------------------------------------------
  # make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    for command in YEA::PARTY::COMMANDS
      case command[0]
      when :change, :remove, :revert
        add_command(command[1], command[0])
      when :finish
        add_command(command[1], command[0], enable_cancel?)
      else; next
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # process_cancel
  #--------------------------------------------------------------------------
  def process_cancel
    unless enable_cancel?
      Sound.play_buzzer
      return
    end
    super
  end
  
  #--------------------------------------------------------------------------
  # in_party?
  #--------------------------------------------------------------------------
  def in_party?(actor)
    return $game_party.battle_members.include?(actor)
  end
  
  #--------------------------------------------------------------------------
  # enable_cancel?
  #--------------------------------------------------------------------------
  def enable_cancel?
    return false if $game_party.battle_members.size <= 0
    for actor in $game_party.all_members
      next if in_party?(actor)
      return false if actor.required
      return false if actor.locked
    end
    return true
  end
  
end # Window_PartyMenuCommand
#==============================================================================
# ■ Window_PartySelect
#==============================================================================
class Window_PartySelect < Window_Selectable
  
  #--------------------------------------------------------------------------
  # initialize
  #-------------------------------------------------------------------------
  def initialize(command_window)
    @command_window = command_window
    super(160, 0, window_width, fitting_height(visible_line_number))
    select(0)
    deactivate
    refresh
  end
  
  #--------------------------------------------------------------------------
  # col_max
  #--------------------------------------------------------------------------
  def col_max; return $game_party.max_battle_members; end
  
  #--------------------------------------------------------------------------
  # item_max
  #--------------------------------------------------------------------------
  def item_max; return $game_party.max_battle_members; end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return Graphics.width - 160; end
  
  #--------------------------------------------------------------------------
  # visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; 4; end
  
  #--------------------------------------------------------------------------
  # item_rect
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = Rect.new
    rect.width = contents.width / item_max
    rect.height = contents.height
    rect.x = index * rect.width
    rect.y = 0
    return rect
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    make_item_list
    create_contents
    draw_all_items
  end
  
  #--------------------------------------------------------------------------
  # make_item_list
  #--------------------------------------------------------------------------
  def make_item_list
    @data = $game_party.battle_members_array.clone
  end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    actor = $game_actors[@data[index]]
    rect = item_rect(index)
    if actor.nil?
      draw_empty(rect.clone)
      return
    end
    dx = rect.width / 2
    dy = rect.height - 16
    draw_actor_face(actor, rect.x, rect.y) if display_face?
    draw_actor_graphic(actor, rect.x + dx, rect.y + dy) unless display_face?
    draw_actor_name(actor, rect)
    draw_locked_icon(actor, rect)
    draw_required_icon(actor, rect)
  end
  
  #--------------------------------------------------------------------------
  # display_face?
  #--------------------------------------------------------------------------
  def display_face?
    return YEA::PARTY::DISPLAY_FACE
  end
  
  #--------------------------------------------------------------------------
  # draw_empty
  #--------------------------------------------------------------------------
  def draw_empty(rect)
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect.x += 2
    rect.y += 2
    rect.width -= 4
    rect.height -= 4
    contents.fill_rect(rect, colour)
    reset_font_settings
    change_color(system_color)
    text = YEA::PARTY::EMPTY_TEXT
    draw_text(rect, text, 1)
    reset_font_settings
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_name
  #--------------------------------------------------------------------------
  def draw_actor_name(actor, rect)
    contents.font.size = YEA::PARTY::PARTY_FONT_SIZE
    change_color(normal_color, actor.exist?)
    draw_text(rect.x+4, rect.y, rect.width-8, line_height, actor.name, 1)
  end
  
  #--------------------------------------------------------------------------
  # draw_face
  #--------------------------------------------------------------------------
  def draw_face(face_name, face_index, dx, dy, enabled = true)
    bitmap = Cache.face(face_name)
    dw = [96, item_rect(0).width-4].min
    rect = Rect.new(face_index % 4 * 96, face_index / 4 * 96, dw, 92)
    contents.blt(dx+2, dy+2, bitmap, rect, enabled ? 255 : translucent_alpha)
    bitmap.dispose
  end
  
  #--------------------------------------------------------------------------
  # draw_locked_icon
  #--------------------------------------------------------------------------
  def draw_locked_icon(actor, rect)
    return unless actor_locked?(actor)
    draw_icon(Icon.locked_party, rect.x+rect.width-26, rect.height - 26)
  end
  
  #--------------------------------------------------------------------------
  # draw_required_icon
  #--------------------------------------------------------------------------
  def draw_required_icon(actor, rect)
    return if actor_locked?(actor)
    return unless actor_required?(actor)
    draw_icon(Icon.required_party, rect.x+rect.width-26, rect.height - 26)
  end
  
  #--------------------------------------------------------------------------
  # actor_locked?
  #--------------------------------------------------------------------------
  def actor_locked?(actor); return actor.locked; end
  
  #--------------------------------------------------------------------------
  # actor_required?
  #--------------------------------------------------------------------------
  def actor_required?(actor)
    return false if actor.locked
    return actor.required
  end
  
  #--------------------------------------------------------------------------
  # current_item_enabled?
  #--------------------------------------------------------------------------
  def current_item_enabled?; enable?(@data[index]); end
  
  #--------------------------------------------------------------------------
  # enable?
  #--------------------------------------------------------------------------
  def enable?(item)
    case @command_window.current_symbol
    when :change
      return true if item.nil?
      return true if item == 0
    when :remove
      return false if item.nil?
      return false if item == 0
    end
    actor = $game_actors[item]
    return false if actor.locked
    return false if actor.required
    return true
  end
  
  #--------------------------------------------------------------------------
  # process_handling
  #--------------------------------------------------------------------------
  def process_handling
    return unless open? && active
    return process_ok       if ok_enabled?        && Input.trigger?(:C)
    return process_cancel   if cancel_enabled?    && Input.trigger?(:B)
    return process_pagedown if handle?(:pagedown) && Input.repeat?(:R)
    return process_pageup   if handle?(:pageup)   && Input.repeat?(:L)
  end
  
  #--------------------------------------------------------------------------
  # cur_actor
  #--------------------------------------------------------------------------
  def cur_actor
    actor_id = @data[index]
    return $game_actors[actor_id]
  end
  
  #--------------------------------------------------------------------------
  # prev_actor
  #--------------------------------------------------------------------------
  def prev_actor
    id = index == 0 ? @data.size - 1 : index - 1
    actor_id = @data[id]
    return $game_actors[actor_id]
  end
  
  #--------------------------------------------------------------------------
  # next_actor
  #--------------------------------------------------------------------------
  def next_actor
    id = index == @data.size - 1 ? 0 : index + 1
    actor_id = @data[id]
    return $game_actors[actor_id]
  end
  
  #--------------------------------------------------------------------------
  # process_pageup
  #--------------------------------------------------------------------------
  def process_pageup
    allow = true
    allow = false if !prev_actor.nil? && prev_actor.locked
    allow = false if !cur_actor.nil? && cur_actor.locked
    Sound.play_buzzer unless allow
    if allow
      super
      activate
      select(index == 0 ? @data.size - 1 : index - 1)
    end
  end
  
  #--------------------------------------------------------------------------
  # process_pagedown
  #--------------------------------------------------------------------------
  def process_pagedown
    allow = true
    allow = false if !next_actor.nil? && next_actor.locked
    allow = false if !cur_actor.nil? && cur_actor.locked
    Sound.play_buzzer unless allow
    if allow
      super
      activate
      select(index == @data.size - 1 ? 0 : index + 1)
    end
  end
  
  #--------------------------------------------------------------------------
  # * item
  #--------------------------------------------------------------------------
  def item; return @data[index] rescue nil; end
  
end # Window_PartySelect
#==============================================================================
# ■ Window_PartyList
#==============================================================================
class Window_PartyList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # initialize
  #-------------------------------------------------------------------------
  def initialize(party_window)
    super(0, fitting_height(4), window_width, window_height)
    @party_window = party_window
    select(1)
    deactivate
    refresh
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return 200; end
  
  #--------------------------------------------------------------------------
  # window_height
  #--------------------------------------------------------------------------
  def window_height; return Graphics.height - fitting_height(4); end
  
  #--------------------------------------------------------------------------
  # item_max
  #--------------------------------------------------------------------------
  def item_max; return @data ? @data.size : 1; end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    make_item_list
    create_contents
    draw_all_items
  end
  
  #--------------------------------------------------------------------------
  # make_item_list
  #--------------------------------------------------------------------------
  def make_item_list
    @data = [0]
    for member in $game_party.all_members
      next if member.nil?
      @data.push(member.id)
    end
    @data.push(0)
  end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    clear_item(index)
    rect = item_rect(index)
    if @data[index] == 0
      draw_remove(rect)
      return
    end
    actor = $game_actors[@data[index]]
    draw_actor(actor, rect)
    draw_actor_locked(actor, rect)
    draw_actor_required(actor, rect)
  end
  
  #--------------------------------------------------------------------------
  # draw_remove
  #--------------------------------------------------------------------------
  def draw_remove(rect)
    reset_font_settings
    draw_icon(Icon.remove_party, rect.x+4, rect.y)
    text = YEA::PARTY::REMOVE_TEXT
    draw_text(rect.x+32, rect.y, rect.width-32, line_height, text)
  end
  
  #--------------------------------------------------------------------------
  # draw_actor
  #--------------------------------------------------------------------------
  def draw_actor(actor, rect)
    buffer = YEA::PARTY::ACTOR_Y_BUFFER
    draw_actor_graphic(actor, rect.x + 16, rect.y + rect.height + buffer)
    text = actor.name
    change_color(list_colour(actor), enabled?(actor))
    draw_text(rect.x+32, rect.y, rect.width-32, line_height, text)
  end
  
  #--------------------------------------------------------------------------
  # list_colour
  #--------------------------------------------------------------------------
  def list_colour(actor)
    return text_color(YEA::PARTY::IN_PARTY_COLOUR) if in_party?(actor)
    return normal_color
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_locked
  #--------------------------------------------------------------------------
  def draw_actor_locked(actor, rect)
    return unless actor.locked
    draw_icon(Icon.locked_party, rect.width-24, rect.y)
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_required
  #--------------------------------------------------------------------------
  def draw_actor_required(actor, rect)
    return if actor.locked
    return unless actor.required
    draw_icon(Icon.required_party, rect.width-24, rect.y)
  end
  
  #--------------------------------------------------------------------------
  # enabled?
  #--------------------------------------------------------------------------
  def enabled?(actor)
    return false if actor.locked
    return false if actor.required && in_party?(actor)
    return actor.exist?
  end
  
  #--------------------------------------------------------------------------
  # in_party?
  #--------------------------------------------------------------------------
  def in_party?(actor); return $game_party.battle_members.include?(actor); end
  
  #--------------------------------------------------------------------------
  # current_item_enabled?
  #--------------------------------------------------------------------------
  def current_item_enabled?
    actor = $game_actors[item]
    replace = $game_actors[@party_window.item]
    unless actor.nil?
      return false if actor.locked && in_party?(actor)
      return false if actor.required && in_party?(actor)
    end
    return true if replace.nil?
    return false if replace.locked
    return false if replace.required
    return true if actor.nil?
    return actor.exist?
  end
  
  #--------------------------------------------------------------------------
  # item
  #--------------------------------------------------------------------------
  def item; return @data[index] rescue nil; end
  
end # Window_PartyList
#==============================================================================
# ** Window_PartyStatus
#==============================================================================
class Window_PartyStatus < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(party_window, list_window)
    super(200, fitting_height(4), window_width, window_height)
    @party_window = party_window
    @list_window = list_window
    @actor = active_actor
    refresh
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; Graphics.width - 200; end
  
  #--------------------------------------------------------------------------
  # window_height
  #--------------------------------------------------------------------------
  def window_height; Graphics.height - fitting_height(4); end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    refresh if @actor != active_actor
  end
  
  #--------------------------------------------------------------------------
  # active_actor
  #--------------------------------------------------------------------------
  def active_actor
    if @list_window.active
      actor = @list_window.item
    else
      actor = @party_window.item
    end
    return nil if [0, nil].include?(actor)
    return actor
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    @actor = active_actor
    reset_font_settings
    if @actor.nil?
      draw_nil_actor
      return
    end
    actor = $game_actors[@actor]
    draw_actor_face(actor, 0, 0)
    draw_actor_name(actor, 108, 0)
    draw_actor_class(actor, 228, 0, contents.width-232)
    draw_actor_level(actor, 108, line_height)
    draw_actor_icons(actor, 228, line_height, contents.width-232)
    draw_actor_hp(actor, 108, line_height*2, contents.width-112)
    draw_actor_mp(actor, 108, line_height*3, contents.width-112)
    draw_actor_parameters(actor, 0, line_height*4 + line_height/2)
    draw_equipments(actor, contents.width/2, line_height*4 + line_height/2)
  end
  
  #--------------------------------------------------------------------------
  # draw_nil_actor
  #--------------------------------------------------------------------------
  def draw_nil_actor
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(0, 0, contents.width, contents.height)
    contents.fill_rect(rect, colour)
    change_color(system_color)
    text = YEA::PARTY::NO_DATA
    draw_text(rect, text, 1)
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_parameters
  #--------------------------------------------------------------------------
  def draw_actor_parameters(actor, dx, dy)
    dw = contents.width/2 - 4
    rect = Rect.new(dx+1, dy+1, dw - 2, line_height - 2)
    contents.font.size = YEA::PARTY::STAT_FONT_SIZE
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    array = [:atk, :def, :mat, :mdf, :agi, :luk]
    cx = 4
    for stat in array
      case stat
      when :atk
        param = Vocab::param(2)
        value = actor.atk.group
      when :def
        param = Vocab::param(3)
        value = actor.def.group
      when :mat
        param = Vocab::param(4)
        value = actor.mat.group
      when :mdf
        param = Vocab::param(5)
        value = actor.mdf.group
      when :agi
        param = Vocab::param(6)
        value = actor.agi.group
      when :luk
        param = Vocab::param(7)
        value = actor.luk.group
      else; next
      end
      contents.fill_rect(rect, colour)
      change_color(system_color)
      draw_text(rect.x + cx, rect.y, rect.width-cx*2, line_height, param, 0)
      change_color(normal_color)
      draw_text(rect.x + cx, rect.y, rect.width-cx*2, line_height, value, 2)
      rect.y += line_height
    end
    reset_font_settings
  end
  
  #--------------------------------------------------------------------------
  # draw_equipments
  #--------------------------------------------------------------------------
  def draw_equipments(actor, dx, dy)
    text = YEA::PARTY::EQUIP_TEXT
    change_color(system_color)
    draw_text(dx, dy, contents.width - dx, line_height, text, 1)
    dy += line_height
    if actor.equips.size <= 5
      actor.equips.each_with_index do |item, i|
        draw_item_name(item, dx, dy + line_height * i)
      end
    else
      orig_x = dx
      actor.equips.each_with_index do |item, i|
        next if item.nil?
        draw_icon(item.icon_index, dx, dy)
        dy += line_height if dx + 48 > contents.width
        dx = dx + 48 > contents.width ? orig_x : dx + 24
      end
    end
  end
  
end # Window_PartyStatus
#==============================================================================
# ■ Scene_Menu
#==============================================================================
class Scene_Menu < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # overwrite method: command_formation
  #--------------------------------------------------------------------------
  if YEA::PARTY::ENABLE_MENU
  def command_formation
    SceneManager.call(Scene_Party)
  end
  end # YEA::PARTY::ENABLE_MENU
  
end # Scene_Menu
#==============================================================================
# ■ Scene_Party
#==============================================================================
class Scene_Party < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # start
  #--------------------------------------------------------------------------
  def start
    super
    @former_party = $game_party.battle_members_array.clone
    create_command_window
    create_party_window
    create_list_window
    create_status_window
  end
  
  #--------------------------------------------------------------------------
  # create_command_window
  #--------------------------------------------------------------------------
  def create_command_window
    @command_window = Window_PartyMenuCommand.new(0, 0)
    @command_window.set_handler(:change, method(:adjust_members))
    @command_window.set_handler(:remove, method(:adjust_members))
    @command_window.set_handler(:revert, method(:revert_party))
    @command_window.set_handler(:finish, method(:return_scene))
    @command_window.set_handler(:cancel, method(:return_scene))
  end
  
  #--------------------------------------------------------------------------
  # create_party_window
  #--------------------------------------------------------------------------
  def create_party_window
    @party_window = Window_PartySelect.new(@command_window)
    @party_window.set_handler(:ok,       method(:on_party_ok))
    @party_window.set_handler(:cancel,   method(:on_party_cancel))
    @party_window.set_handler(:pageup,   method(:on_party_pageup))
    @party_window.set_handler(:pagedown, method(:on_party_pagedown))
  end
  
  #--------------------------------------------------------------------------
  # * Create Background
  #--------------------------------------------------------------------------
  def create_background
    @background_sprite = Sprite.new
    @background_sprite.bitmap = Cache.background("CanterlotPalaceHallWay")
  end
  
  #--------------------------------------------------------------------------
  # create_list_window
  #--------------------------------------------------------------------------
  def create_list_window
    @list_window = Window_PartyList.new(@party_window)
    @list_window.set_handler(:ok,     method(:on_list_ok))
    @list_window.set_handler(:cancel, method(:on_list_cancel))
  end
  
  #--------------------------------------------------------------------------
  # create_status_window
  #--------------------------------------------------------------------------
  def create_status_window
    @status_window = Window_PartyStatus.new(@party_window, @list_window)
  end
  
  #--------------------------------------------------------------------------
  # adjust_members
  #--------------------------------------------------------------------------
  def adjust_members
    @party_window.activate
  end
  
  #--------------------------------------------------------------------------
  # window_refresh
  #--------------------------------------------------------------------------
  def window_refresh
    $game_party.rearrange_actors
    @command_window.refresh
    @party_window.refresh
    @list_window.refresh
    $game_player.refresh
    $game_map.need_refresh = true
  end
  
  #--------------------------------------------------------------------------
  # revert_party
  #--------------------------------------------------------------------------
  def revert_party
    @command_window.activate
    $game_party.battle_members_array = @former_party.clone
    window_refresh
  end
  
  #--------------------------------------------------------------------------
  # on_party_ok
  #--------------------------------------------------------------------------
  def on_party_ok
    case @command_window.current_symbol
    when :change
      @list_window.activate
    when :remove
      index = @party_window.index
      actor = $game_actors[$game_party.battle_members_array[index]]
      Sound.play_equip
      $game_party.battle_members_array[index] = 0
      window_refresh
      @party_window.activate
    end
  end
  
  #--------------------------------------------------------------------------
  # on_party_cancel
  #--------------------------------------------------------------------------
  def on_party_cancel
    @command_window.activate
  end
  
  #--------------------------------------------------------------------------
  # on_party_pageup
  #--------------------------------------------------------------------------
  def on_party_pageup
    Sound.play_equip
    actor_id1 = @party_window.item
    actor_id2 = @party_window.prev_actor.nil? ? 0 : @party_window.prev_actor.id
    max = @party_window.item_max-1
    index1 = @party_window.index
    index2 = @party_window.index == 0 ? max : index1-1
    $game_party.battle_members_array[index1] = actor_id2
    $game_party.battle_members_array[index2] = actor_id1
    window_refresh
  end
  
  #--------------------------------------------------------------------------
  # on_party_pagedown
  #--------------------------------------------------------------------------
  def on_party_pagedown
    Sound.play_equip
    actor_id1 = @party_window.item
    actor_id2 = @party_window.next_actor.nil? ? 0 : @party_window.next_actor.id
    max = @party_window.item_max-1
    index1 = @party_window.index
    index2 = @party_window.index == max ? 0 : index1+1
    $game_party.battle_members_array[index1] = actor_id2
    $game_party.battle_members_array[index2] = actor_id1
    window_refresh
  end
  
  #--------------------------------------------------------------------------
  # on_list_cancel
  #--------------------------------------------------------------------------
  def on_list_cancel
    @party_window.activate
  end
  
  #--------------------------------------------------------------------------
  # on_list_ok
  #--------------------------------------------------------------------------
  def on_list_ok
    Sound.play_equip
    replace = $game_actors[@party_window.item]
    actor = $game_actors[@list_window.item]
    index1 = @party_window.index
    actor_id1 = actor.nil? ? 0 : actor.id
    if actor.nil?
      $game_party.battle_members_array[index1] = 0
      window_refresh
      @party_window.activate
      return
    end
    actor_id2 = replace.nil? ? 0 : replace.id
    if $game_party.battle_members_array.include?(actor_id1)
      index2 = $game_party.battle_members_array.index(actor_id1)
      $game_party.battle_members_array[index2] = actor_id2
    end
    $game_party.battle_members_array[index1] = actor_id1
    window_refresh
    @party_window.activate
  end
  
end # Scene_Party
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Gab Window v1.00
# -- Last Updated: 2012.01.23
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-GabWindow"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.23 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# Sometimes there's random jibber jabber that does not warrant a message box.
# The Gab Window fulfills that jibber jabber by placing such text outside of
# the message window box and at the corner of the screen. The gab text will
# appear briefly and then disappear, not showing up again until the gab text is
# updated with something else.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Script Calls - These commands are used with script calls.
# -----------------------------------------------------------------------------
# These script calls can only be used from a map. The Gab Window will not
# appear in battle or anywhere else.
# 
# gab(string)
# This will cause the Gab Window to appear with the string shown. Text codes
# can be used inside the string. When using text codes, remember to use "\\"
# for a single slash.
# 
# gab(string, actor_id)
# This will cause the Gab Window to appear with the string and the actor's
# sprite. Text codes can be used inside the string. When using text codes,
# remember to use "\\" for a single slash. There are special ID's that
# can be used in place of the actor_id:
#      0 - Party Leader
#     -1 - 1st non-leader member.
#     -2 - 2nd non-leader member. So on.
# 
# gab(string, char_name, char_index)
# This will cause the Gab Window to appear with the string shown and a sprite
# using char_name as the filename of the character sprite and char_index as the
# index of the character sprite. Text codes can be used inside the string. When
# using text codes, remember to use "\\" for a single slash.
# 
# clear_gab
# This will cause the gab window to clear itself and immediately go invisible.
# This will also allow a previously used gab prior to the clearing to reappear
# immediately if followed up by another gab.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
# This script is compatible with Yanfly Engine Ace - Ace Message System v1.04+.
# The positioning of these two scripts relative to each other does not matter.
# 
#==============================================================================
module YEA
  module GAB_WINDOW
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Gab Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These are the general settings used involving the Gab Window. Here, you
    # can change the Y location of the window (remember, it's two lines tall),
    # default font size, the position of the character sprites, and the amount
    # of time the Gab Window will remain fully visible before fading.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    Y_LOCATION    = 365   # This sets the Y location of the gab window.
    FONT_SIZE     = 16   # This is the font size used for the gab window.
    
    CHAR_X_POS    = 24   # This sets the X location of the character shown.
    CHAR_Y_POS    = 40   # This sets the Y location of the character shown.
    
    BASE_TIME     = 1   # Minimum frames the window will stay visible for.
    TIME_PER_TEXT =  4   # Frames added per text character.
    
    HIDE_SWITCH   = 25   # If switch is ON, Gab Window will not appear.
    
  end # GAB_WINDOW
end # YEA
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
#==============================================================================
# ■ Switch
#==============================================================================
module Switch
  
  #--------------------------------------------------------------------------
  # self.hide_gab_window
  #--------------------------------------------------------------------------
  def self.hide_gab_window
    return false if YEA::GAB_WINDOW::HIDE_SWITCH <= 0
    return $game_switches[YEA::GAB_WINDOW::HIDE_SWITCH]
  end
    
end # Switch
#==============================================================================
# ■ Game_Interpreter
#==============================================================================
class Game_Interpreter
  
  #--------------------------------------------------------------------------
  # new method: gab
  #--------------------------------------------------------------------------
  def gab(text,duration = YEA::GAB_WINDOW::BASE_TIME, case1 = nil, case2 = nil)
    return unless SceneManager.scene_is?(Scene_Map)
    
    if case1.is_a?(Integer)
      text = "  :" + text
      
      case1 = $game_party.members[case1.abs].id if case1 <= 0
      actor = $game_actors[case1]
      if !actor.nil?
        case1 = actor.character_name
        case2 = actor.character_index
      end
    elsif case1.is_a?(String)
      case2 = 0 if case2.nil?
    end
  
    SceneManager.scene.setup_gab_window(text,duration, case1, case2)
  end
  
  #--------------------------------------------------------------------------
  # new method: clear_gab
  #--------------------------------------------------------------------------
  def clear_gab
    return unless SceneManager.scene_is?(Scene_Map)
    SceneManager.scene.clear_gab
  end
  
end # Game_Interpreter
#==============================================================================
# ■ Window_Gab
#==============================================================================
class Window_Gab < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx = -standard_padding, dy = YEA::GAB_WINDOW::Y_LOCATION)
    #dx = -standard_padding
    #dy = YEA::GAB_WINDOW::Y_LOCATION
    super(dx, dy, Graphics.width + standard_padding, fitting_height(2))
    setup_message_font if $imported["YEA-MessageSystem"]
    clear
  end
  
  #--------------------------------------------------------------------------
  # clear
  #--------------------------------------------------------------------------
  def clear
    self.opacity = 0
    self.contents_opacity = 0
    @opacity_timer = 0
    clear_settings
  end
  
  #--------------------------------------------------------------------------
  # clear_settings
  #--------------------------------------------------------------------------
  def clear_settings
    @text = ""
    @graphic = nil
    @index = nil
  end
  
  #--------------------------------------------------------------------------
  # reset_font_settings
  #--------------------------------------------------------------------------
  def reset_font_settings
    super
    contents.font.size = YEA::GAB_WINDOW::FONT_SIZE
  end
  
  #--------------------------------------------------------------------------
  # setup
  #--------------------------------------------------------------------------
  def setup(text,graphic, index,duration)
    #return if settings_match?(text, graphic, index)
    
    @text = text
    @graphic = graphic
    @index = index
    @opacity_timer = duration
    @opacity_timer += YEA::GAB_WINDOW::TIME_PER_TEXT * @text.size
    refresh
  end
  
  #--------------------------------------------------------------------------
  # settings_match?
  #--------------------------------------------------------------------------
  def settings_match?(text, graphic, index)
    return false if @text != text
    return false if @graphic != graphic
    return false if @index != index
    return true
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    self.visible = show_window?
    update_contents_opacity
  end
  
  #--------------------------------------------------------------------------
  # show_window?
  #--------------------------------------------------------------------------
  def show_window?
    return false if $game_message.visible && $game_message.position == 0
    return !Switch.hide_gab_window
  end
  
  #--------------------------------------------------------------------------
  # update_contents_opacity
  #--------------------------------------------------------------------------
  def update_contents_opacity
    if @opacity_timer > 0 && self.contents_opacity >= 255
      return @opacity_timer -= 1
    end
    self.contents_opacity += @opacity_timer > 0 ? 16 : -4
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    draw_background_colour
    draw_graphic
    draw_text_ex(24, line_height / 2, @text)
  end
  
  #--------------------------------------------------------------------------
  # draw_background_colour
  #--------------------------------------------------------------------------
  def draw_background_colour
    temp_rect = contents.rect.clone
    temp_rect.width *= 0.667
    temp_rect.height *= 0.6
    temp_rect.y += 9
    back_colour1 = Color.new(0, 0, 0, 192)
    back_colour2 = Color.new(0, 0, 0, 0)
    contents.gradient_fill_rect(temp_rect, back_colour1, back_colour2)
  end
  
  #--------------------------------------------------------------------------
  # draw_graphic
  #--------------------------------------------------------------------------
  def draw_graphic
    char_name = @graphic
    char_index = @index
    dx = YEA::GAB_WINDOW::CHAR_X_POS
    dy = YEA::GAB_WINDOW::CHAR_Y_POS
    draw_character(char_name, char_index, dx, dy)
  end
  
  #--------------------------------------------------------------------------
  #  move_up
  #--------------------------------------------------------------------------
  def move_up
    self.y -= 30
    refresh
  end
  #--------------------------------------------------------------------------
  #  time_up?
  #--------------------------------------------------------------------------
  def time_up?
    @opacity_timer == 0 && self.contents_opacity < 10
  end
  
  #-----------
end # Window_Gab
#==============================================================================
# ■ Scene_Map
#==============================================================================
class Scene_Map < Scene_Base
  
  #--------------------------------------------------------------------------
  # alias method: create_all_windows
  #--------------------------------------------------------------------------
  alias scene_map_create_all_windows_gab create_all_windows
  def create_all_windows
    scene_map_create_all_windows_gab
    create_gab_window
  end
  
  #--------------------------------------------------------------------------
  # new method: create_gab_window
  #--------------------------------------------------------------------------
  def create_gab_window
    @gab_windows = [Window_Gab.new]
  end
  
  #--------------------------------------------------------------------------
  # * alias method: Update All Windows
  #--------------------------------------------------------------------------
  alias update_gab_window update_all_windows
  def update_all_windows
    update_gab_window
    
    @gab_windows.each do |window|
      window.update
      @gab_windows.delete(window) if window.time_up?
    end
    
  end
  
  #--------------------------------------------------------------------------
  # new method: setup_gab_window
  #--------------------------------------------------------------------------
  def setup_gab_window(text, duration = YEA::GAB_WINDOW::BASE_TIME,graphic = nil, index = nil)
    
    for window in @gab_windows
      window.move_up
    end
    
    window = Window_Gab.new
    @gab_windows.push(window)
    @gab_windows.at(-1).setup(text, graphic, index,duration)
  end
  
  #--------------------------------------------------------------------------
  # new method: clear_gab
  #--------------------------------------------------------------------------
  def clear_gab
    @gab_windows.each do |window|
      window.clear
    end
    
  end
  
  #--------------------------------------------------------------------------
  # alias method: pre_transfer
  #--------------------------------------------------------------------------
  alias scene_map_pre_transfer_gab pre_transfer
  def pre_transfer
    scene_map_pre_transfer_gab
    clear_gab
  end
  
end # Scene_Map
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Ace Message System v1.05
# -- Last Updated: 2012.01.13
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-MessageSystem"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.07.21 - Fixed REGEXP error at line 824
# 2012.01.13 - Bug Fixed: Negative tags didn't display other party members.
# 2012.01.12 - Compatibility Update: Message Actor Codes
# 2012.01.10 - Added Feature: \pic[x] text code.
# 2012.01.04 - Bug Fixed: \ic tag was \ii. No longer the case.
#            - Added: Scroll Text window now uses message window font.
# 2011.12.31 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# While RPG Maker VX Ace certainly improved the message system a whole lot, it
# wouldn't hurt to add in a few more features, such as name windows, converting
# textcodes to write out the icons and/or names of items, weapons, armours, and
# more in quicker fashion. This script also gives the developer the ability to
# adjust the size of the message window during the game, give it a separate
# font, and to give the player a text fast-forward feature.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Message Window text Codes - These go inside of your message window.
# -----------------------------------------------------------------------------
#  Default:    Effect:
#    \v[x]     - Writes variable x's value.
#    \n[x]     - Writes actor x's name.
#    \p[x]     - Writes party member x's name.
#    \g        - Writes gold currency name.
#    \c[x]     - Changes the colour of the text to x.
#    \i[x]     - Draws icon x at position of the text.
#    \{        - Makes text bigger by 8 points.
#    \}        - Makes text smaller by 8 points.
#    \$        - Opens gold window.
#    \.        - Waits 15 frames (quarter second).
#    \|        - Waits 60 frames (a full second).
#    \!        - Waits until key is pressed.
#    \>        - Following text is instant.
#    \<        - Following text is no longer instant.
#    \^        - Skips to the next message.
#    \\        - Writes a "\" in the window.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Wait:       Effect:
#    \w[x]     - Waits x frames (60 frames = 1 second). Message window only.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  NameWindow: Effect:
#    \n<x>     - Creates a name box with x string. Left side. *Note
#    \nc<x>    - Creates a name box with x string. Centered. *Note
#    \nr<x>    - Creates a name box with x string. Right side. *Note
# 
#              *Note: Works for message window only.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Position:   Effect:
#    \px[x]    - Sets x position of text to x.
#    \py[x]    - Sets y position of text to y.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Picture:    Effect:
#    \pic[x]   - Draws picture x from the Graphics\Pictures folder.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Outline:    Effect:
#    \oc[x]    - Sets outline colour to x.
#    \oo[x]    - Sets outline opacity to x.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Font:       Effect:
#    \fr       - Resets all font changes.
#    \fz[x]    - Changes font size to x.
#    \fn[x]    - Changes font name to x.
#    \fb       - Toggles font boldness.
#    \fi       - Toggles font italic.
#    \fo       - Toggles font outline.
#    \fs       - Toggles font shadow.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Actor:      Effect:
#    \af[x]    - Shows face of actor x. *Note
#    \ac[x]    - Writes out actor's class name. *Note
#    \as[x]    - Writes out actor's subclass name. Req: Class System. *Note
#    \an[x]    - Writes out actor's nickname. *Note
# 
#              *Note: If x is 0 or negative, it will show the respective
#               party member's face instead.
#                   0 - Party Leader
#                  -1 - 1st non-leader member.
#                  -2 - 2nd non-leader member. So on.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Names:      Effect:
#    \nc[x]    - Writes out class x's name.
#    \ni[x]    - Writes out item x's name.
#    \nw[x]    - Writes out weapon x's name.
#    \na[x]    - Writes out armour x's name.
#    \ns[x]    - Writes out skill x's name.
#    \nt[x]    - Writes out state x's name.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Icon Names: Effect:
#    \ic[x]    - Writes out class x's name including icon. *
#    \ii[x]    - Writes out item x's name including icon.
#    \iw[x]    - Writes out weapon x's name including icon.
#    \ia[x]    - Writes out armour x's name including icon.
#    \is[x]    - Writes out skill x's name including icon.
#    \it[x]    - Writes out state x's name including icon.
# 
#              *Note: Requires YEA - Class System
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
# And those are the text codes added with this script. Keep in mind that some
# of these text codes only work for the Message Window. Otherwise, they'll work
# for help descriptions, actor biographies, and others.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
module YEA
  module MESSAGE
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Message Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The following below will adjust the basic settings and that will affect
    # the majority of the script. Adjust them as you see fit.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This button is the button used to make message windows instantly skip
    # forward. Hold down for the effect. Note that when held down, this will
    # speed up the messages, but still wait for the pauses. However, it will
    # automatically go to the next page when prompted.
    TEXT_SKIP = :A     # Input::A is the shift button on keyboard.
    
    # This variable adjusts the number of visible rows shown in the message
    # window. If you do not wish to use this feature, set this constant to 0.
    # If the row value is 0 or below, it will automatically default to 4 rows.
    VARIABLE_ROWS  = 21
    
    # This variable adjusts the width of the message window shown. If you do
    # not wish to use this feature, set this constant to 0. If the width value
    # is 0 or below, it will automatically default to the screen width.
    VARIABLE_WIDTH = 22
    
    # This is the amount of space that the message window will indent whenever
    # a face is used. Default: 112
    FACE_INDENT_X = 112
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Name Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The name window is a window that appears outside of the main message
    # window box to display whatever text is placed inside of it like a name.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    NAME_WINDOW_X_BUFFER = -20     # Buffer x position of the name window.
    NAME_WINDOW_Y_BUFFER = 0       # Buffer y position of the name window.
    NAME_WINDOW_PADDING  = 20      # Padding added to the horizontal position.
    NAME_WINDOW_OPACITY  = 255     # Opacity of the name window.
    NAME_WINDOW_COLOUR   = 6       # Text colour used by default for names.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Message Font Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Ace Message System separates the in-game system font form the message
    # font. Adjust the settings here for your fonts.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This array constant determines the fonts used. If the first font does not
    # exist on the player's computer, the next font in question will be used
    # in place instead and so on.
    MESSAGE_WINDOW_FONT_NAME = ["Verdana", "Arial", "Courier New"]
    
    # These adjust the other settings regarding the way the game font appears
    # including the font size, whether or not the font is bolded by default,
    # italic by default, etc.
    MESSAGE_WINDOW_FONT_SIZE    = 24       # Font size.
    MESSAGE_WINDOW_FONT_BOLD    = false    # Default bold?
    MESSAGE_WINDOW_FONT_ITALIC  = false    # Default italic?
    MESSAGE_WINDOW_FONT_OUTLINE = true     # Default outline?
    MESSAGE_WINDOW_FONT_SHADOW  = false    # Default shadow?
    
  end # MESSAGE
end # YEA
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
#==============================================================================
# ■ Variable
#==============================================================================
module Variable
  
  #--------------------------------------------------------------------------
  # self.message_rows
  #--------------------------------------------------------------------------
  def self.message_rows
    return 4 if YEA::MESSAGE::VARIABLE_ROWS <= 0 || $game_variables.nil?
    return 4 if $game_variables[YEA::MESSAGE::VARIABLE_ROWS] <= 0
    return $game_variables[YEA::MESSAGE::VARIABLE_ROWS]
  end
  
  #--------------------------------------------------------------------------
  # self.message_width
  #--------------------------------------------------------------------------
  def self.message_width
    return Graphics.width if YEA::MESSAGE::VARIABLE_WIDTH <= 0
    return Graphics.width if $game_variables[YEA::MESSAGE::VARIABLE_WIDTH] <= 0
    return $game_variables[YEA::MESSAGE::VARIABLE_WIDTH]
  end
  
end # Variable
#==============================================================================
# ■ Game_Interpreter
#==============================================================================
class Game_Interpreter
  
  #--------------------------------------------------------------------------
  # overwrite method: command_101
  #--------------------------------------------------------------------------
  def command_101
    wait_for_message
    $game_message.face_name = @params[0]
    $game_message.face_index = @params[1]
    $game_message.background = @params[2]
    $game_message.position = @params[3]
    
    while continue_message_string?
      @index += 1
      if @list[@index].code == 401
        $game_message.add(@list[@index].parameters[0])
      end
      break if $game_message.texts.size >= Variable.message_rows
    end
    case next_event_code
    when 102
      @index += 1
      setup_choices(@list[@index].parameters)
    when 103
      @index += 1
      setup_num_input(@list[@index].parameters)
    when 104
      @index += 1
      setup_item_choice(@list[@index].parameters)
    end
    wait_for_message
  end
  
  #--------------------------------------------------------------------------
  # new method: continue_message_string?
  #--------------------------------------------------------------------------
  def continue_message_string?
    return true if next_event_code == 101 && Variable.message_rows > 4
    return next_event_code == 401
  end
  
end # Game_Interpreter
#==============================================================================
# ■ Window_Base
#==============================================================================
class Window_Base < Window
  
  #--------------------------------------------------------------------------
  # new method: setup_message_font
  #--------------------------------------------------------------------------
  def setup_message_font
    @message_font = true
    change_color(normal_color)
    contents.font.out_color = Font.default_out_color
    contents.font.name = YEA::MESSAGE::MESSAGE_WINDOW_FONT_NAME
    contents.font.size = YEA::MESSAGE::MESSAGE_WINDOW_FONT_SIZE
    contents.font.bold = YEA::MESSAGE::MESSAGE_WINDOW_FONT_BOLD
    contents.font.italic = YEA::MESSAGE::MESSAGE_WINDOW_FONT_ITALIC
    contents.font.outline = YEA::MESSAGE::MESSAGE_WINDOW_FONT_OUTLINE
    contents.font.shadow = YEA::MESSAGE::MESSAGE_WINDOW_FONT_SHADOW
  end
  
  #--------------------------------------------------------------------------
  # alias method: reset_font_settings
  #--------------------------------------------------------------------------
  alias window_base_reset_font_settings_ams reset_font_settings
  def reset_font_settings
    if @message_font
      setup_message_font
    else
      window_base_reset_font_settings_ams
      contents.font.out_color = Font.default_out_color
      contents.font.outline = Font.default_outline
      contents.font.shadow = Font.default_shadow
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: convert_escape_characters
  #--------------------------------------------------------------------------
  alias window_base_convert_escape_characters_ams convert_escape_characters
  def convert_escape_characters(text)
    result = window_base_convert_escape_characters_ams(text)
    result = convert_ace_message_system_new_escape_characters(result)
    result = FileManager.convert_eval_string(result)
    return result
  end
  #--------------------------------------------------------------------------
  # new method: convert_ace_message_system_new_escape_characters
  #--------------------------------------------------------------------------
  def convert_ace_message_system_new_escape_characters(result)
    #---
    result.gsub!(/\eFR/i) { "\eAMSF[0]" }
    result.gsub!(/\eFB/i) { "\eAMSF[1]" }
    result.gsub!(/\eFI/i) { "\eAMSF[2]" }
    result.gsub!(/\eFO/i) { "\eAMSF[3]" }
    result.gsub!(/\eFS/i) { "\eAMSF[4]" }
    #---
    result.gsub!(/\eAC\[([-+]?\d+)\]/i) { escape_actor_class_name($1.to_i) }
    result.gsub!(/\eAS\[([-+]?\d+)\]/i) { escape_actor_subclass_name($1.to_i) }
    result.gsub!(/\eAN\[([-+]?\d+)\]/i) { escape_actor_nickname($1.to_i) }
    #---
    result.gsub!(/\eNC\[(\d+)\]/i) { $data_classes[$1.to_i].name }
    result.gsub!(/\eNI\[(\d+)\]/i) { $data_items[$1.to_i].name }
    result.gsub!(/\eNW\[(\d+)\]/i) { $data_weapons[$1.to_i].name }
    result.gsub!(/\eNA\[(\d+)\]/i) { $data_armors[$1.to_i].name }
    result.gsub!(/\eNS\[(\d+)\]/i) { $data_skills[$1.to_i].name }
    result.gsub!(/\eNT\[(\d+)\]/i) { $data_states[$1.to_i].name }
    #---
    result.gsub!(/\eIC\[(\d+)\]/i) { escape_icon_item($1.to_i, :class) }
    result.gsub!(/\eII\[(\d+)\]/i) { escape_icon_item($1.to_i, :item) }
    result.gsub!(/\eIW\[(\d+)\]/i) { escape_icon_item($1.to_i, :weapon) }
    result.gsub!(/\eIA\[(\d+)\]/i) { escape_icon_item($1.to_i, :armour) }
    result.gsub!(/\eIS\[(\d+)\]/i) { escape_icon_item($1.to_i, :skill) }
    result.gsub!(/\eIT\[(\d+)\]/i) { escape_icon_item($1.to_i, :state) }
    #---
    return result
  end
  
  #--------------------------------------------------------------------------
  # new method: escape_actor_class_name
  #--------------------------------------------------------------------------
  def escape_actor_class_name(actor_id)
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    return actor.class.name
  end
  
  #--------------------------------------------------------------------------
  # new method: actor_subclass_name
  #--------------------------------------------------------------------------
  def escape_actor_subclass_name(actor_id)
    return "" unless $imported["YEA-ClassSystem"]
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    return "" if actor.subclass.nil?
    return actor.subclass.name
  end
  
  #--------------------------------------------------------------------------
  # new method: escape_actor_nickname
  #--------------------------------------------------------------------------
  def escape_actor_nickname(actor_id)
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    return actor.nickname
  end
  
  #--------------------------------------------------------------------------
  # new method: escape_icon_item
  #--------------------------------------------------------------------------
  def escape_icon_item(data_id, type)
    case type
    when :class
      return "" unless $imported["YEA-ClassSystem"]
      icon = $data_classes[data_id].icon_index
      name = $data_items[data_id].name
    when :item
      icon = $data_items[data_id].icon_index
      name = $data_items[data_id].name
    when :weapon
      icon = $data_weapons[data_id].icon_index
      name = $data_weapons[data_id].name
    when :armour
      icon = $data_armors[data_id].icon_index
      name = $data_armors[data_id].name
    when :skill
      icon = $data_skills[data_id].icon_index
      name = $data_skills[data_id].name
    when :state
      icon = $data_states[data_id].icon_index
      name = $data_states[data_id].name
    else; return ""
    end
    text = "\eI[#{icon}]" + name
    return text
  end
  
  #--------------------------------------------------------------------------
  # alias method: process_escape_character
  #--------------------------------------------------------------------------
  alias window_base_process_escape_character_ams process_escape_character
  def process_escape_character(code, text, pos)
    return if code.nil?
    case code.upcase
    #---
    when 'FZ'
      contents.font.size = obtain_escape_param(text)
    when 'FN'
      text.sub!(/\[(.*?)\]/, "")
      font_name = $1.to_s
      font_name = Font.default_name if font_name.nil?
      contents.font.name = font_name.to_s
    #---
    when 'OC'
      colour = text_color(obtain_escape_param(text))
      contents.font.out_color = colour
    when 'OO'
      contents.font.out_color.alpha = obtain_escape_param(text)
    #---
    when 'AMSF'
      case obtain_escape_param(text)
      when 0; reset_font_settings
      when 1; contents.font.bold = !contents.font.bold
      when 2; contents.font.italic = !contents.font.italic
      when 3; contents.font.outline = !contents.font.outline
      when 4; contents.font.shadow = !contents.font.shadow
      end
    #---
    when 'PX'
      pos[:x] = obtain_escape_param(text)
    when 'PY'
      pos[:y] = obtain_escape_param(text)
    #---
    when 'PIC'
      text.sub!(/\[(.*?)\]/, "")
      bmp = Cache.picture($1.to_s)
      rect = Rect.new(0, 0, bmp.width, bmp.height)
      contents.blt(pos[:x], pos[:y], bmp, rect)
    #---
    else
      window_base_process_escape_character_ams(code, text, pos)
    end
  end
  
end # Window_Base
#==============================================================================
# ■ Window_ChoiceList
#==============================================================================
class Window_ChoiceList < Window_Command
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias window_choicelist_initialize_ams initialize
  def initialize(message_window)
    window_choicelist_initialize_ams(message_window)
    setup_message_font
  end
  
end # Window_ChoiceList
#==============================================================================
# ■ Window_ScrollText
#==============================================================================
class Window_ScrollText < Window_Base
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias window_scrolltext_initialize_ams initialize
  def initialize
    window_scrolltext_initialize_ams
    setup_message_font
  end
  
end # Window_ScrollText
#==============================================================================
# ■ Window_NameMessage
#==============================================================================
class Window_NameMessage < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(message_window)
    @message_window = message_window
    super(0, 0, Graphics.width, fitting_height(1))
    self.opacity = YEA::MESSAGE::NAME_WINDOW_OPACITY
    self.z = @message_window.z + 1
    self.openness = 0
    setup_message_font
    @close_counter = 0
    deactivate
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return if self.active
    return if self.openness == 0
    return if @closing
    @close_counter -= 1
    return if @close_counter > 0
    close
  end
  
  #--------------------------------------------------------------------------
  # start_close
  #--------------------------------------------------------------------------
  def start_close
    @close_counter = 4
    deactivate
  end
  
  #--------------------------------------------------------------------------
  # force_close
  #--------------------------------------------------------------------------
  def force_close
    @close_counter = 0
    deactivate
    close
  end
  
  #--------------------------------------------------------------------------
  # start
  #--------------------------------------------------------------------------
  def start(text, x_position)
    @text = text.clone
    set_width
    create_contents
    set_x_position(x_position)
    set_y_position
    refresh
    activate
    open
  end
  
  #--------------------------------------------------------------------------
  # set_width
  #--------------------------------------------------------------------------
  def set_width
    text = @text.clone
    dw = standard_padding * 2 + text_size(text).width
    dw += YEA::MESSAGE::NAME_WINDOW_PADDING * 2
    dw += calculate_size(text.slice!(0, 1), text) until text.empty?
    self.width = dw
  end
  
  #--------------------------------------------------------------------------
  # calculate_size
  #--------------------------------------------------------------------------
  def calculate_size(code, text)
    case code
    when "\e"
      return calculate_escape_code_width(obtain_escape_code(text), text)
    else
      return 0
    end
  end
  
  #--------------------------------------------------------------------------
  # calculate_escape_code_width
  #--------------------------------------------------------------------------
  def calculate_escape_code_width(code, text)
    dw = -text_size("\e").width - text_size(code).width
    case code.upcase
    when 'C', 'OC', 'OO'
      dw += -text_size("[" + obtain_escape_param(text).to_s + "]").width
      return dw
    when 'I'
      dw += -text_size("[" + obtain_escape_param(text).to_s + "]").width
      dw += 24
      return dw
    when '{'
      make_font_bigger
    when '}'
      make_font_smaller
    when 'FZ'
      contents.font.size = obtain_escape_param(text)
    when 'FN'
      text.sub!(/\[(.*?)\]/, "")
      font_name = $1.to_s
      font_name = Font.default_name if font_name.nil?
      contents.font.name = font_name.to_s
    when 'AMSF'
      case obtain_escape_param(text)
      when 0; reset_font_settings
      when 1; contents.font.bold = !contents.font.bold
      when 2; contents.font.italic = !contents.font.italic
      when 3; contents.font.outline = !contents.font.outline
      when 4; contents.font.shadow = !contents.font.shadow
      end
    else
      return dw
    end
  end
  
  #--------------------------------------------------------------------------
  # set_y_position
  #--------------------------------------------------------------------------
  def set_x_position(x_position)
    case x_position
    when 1 # Left
      self.x = @message_window.x
      self.x += YEA::MESSAGE::NAME_WINDOW_X_BUFFER
    when 2 # 3/10
      self.x = @message_window.x
      self.x += @message_window.width * 3 / 10
      self.x -= self.width / 2
    when 3 # Center
      self.x = @message_window.x
      self.x += @message_window.width / 2
      self.x -= self.width / 2
    when 4 # 7/10
      self.x = @message_window.x
      self.x += @message_window.width * 7 / 10
      self.x -= self.width / 2
    when 5 # Right
      self.x = @message_window.x + @message_window.width
      self.x -= self.width
      self.x -= YEA::MESSAGE::NAME_WINDOW_X_BUFFER
    end
    self.x = [[self.x, Graphics.width - self.width].min, 0].max
  end
  
  #--------------------------------------------------------------------------
  # set_y_position
  #--------------------------------------------------------------------------
  def set_y_position
    case $game_message.position
    when 0
      self.y = @message_window.height
      self.y -= YEA::MESSAGE::NAME_WINDOW_Y_BUFFER
    else
      self.y = @message_window.y - self.height
      self.y += YEA::MESSAGE::NAME_WINDOW_Y_BUFFER
    end
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    reset_font_settings
    @text = sprintf("\eC[%d]%s", YEA::MESSAGE::NAME_WINDOW_COLOUR, @text)
    draw_text_ex(YEA::MESSAGE::NAME_WINDOW_PADDING, 0, @text)
  end
  
end # Window_NameMessage
#==============================================================================
# ■ Window_Message
#==============================================================================
class Window_Message < Window_Base
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias window_message_initialize_ams initialize
  def initialize
    window_message_initialize_ams
    setup_message_font
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: window_width
  #--------------------------------------------------------------------------
  def window_width
    return Variable.message_width
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: window_height
  #--------------------------------------------------------------------------
  def window_height
    return fitting_height(Variable.message_rows)
  end
  
  #--------------------------------------------------------------------------
  # alias method: create_all_windows
  #--------------------------------------------------------------------------
  alias window_message_create_all_windows_ams create_all_windows
  def create_all_windows
    window_message_create_all_windows_ams
    @name_window = Window_NameMessage.new(self)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: create_back_bitmap
  #--------------------------------------------------------------------------
  def create_back_bitmap
    @back_bitmap = Bitmap.new(width, height)
    rect1 = Rect.new(0, 0, Graphics.width, 12)
    rect2 = Rect.new(0, 12, Graphics.width, fitting_height(4) - 24)
    rect3 = Rect.new(0, fitting_height(4) - 12, Graphics.width, 12)
    @back_bitmap.gradient_fill_rect(rect1, back_color2, back_color1, true)
    @back_bitmap.fill_rect(rect2, back_color1)
    @back_bitmap.gradient_fill_rect(rect3, back_color1, back_color2, true)
  end
  
  #--------------------------------------------------------------------------
  # alias method: dispose_all_windows
  #--------------------------------------------------------------------------
  alias window_message_dispose_all_windows_ams dispose_all_windows
  def dispose_all_windows
    window_message_dispose_all_windows_ams
    @name_window.dispose
  end
  
  #--------------------------------------------------------------------------
  # alias method: update_all_windows
  #--------------------------------------------------------------------------
  alias window_message_update_all_windows_ams update_all_windows
  def update_all_windows
    window_message_update_all_windows_ams
    @name_window.update
    @name_window.back_opacity = self.back_opacity
    @name_window.opacity = self.opacity
  end
  
  #--------------------------------------------------------------------------
  # alias method: update_show_fast
  #--------------------------------------------------------------------------
  alias window_message_update_show_fast_ams update_show_fast
  def update_show_fast
    @show_fast = true if Input.press?(YEA::MESSAGE::TEXT_SKIP)
    window_message_update_show_fast_ams
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: input_pause
  #--------------------------------------------------------------------------
  def input_pause
    self.pause = true
    wait(10)
    Fiber.yield until Input.trigger?(:B) || Input.trigger?(:C) ||
      Input.press?(YEA::MESSAGE::TEXT_SKIP)
    Input.update
    self.pause = false
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: convert_escape_characters
  #--------------------------------------------------------------------------
  def convert_escape_characters(text)
    result = super(text.to_s.clone)
    result = namebox_escape_characters(result)
    result = message_escape_characters(result)
    return result
  end
  
  #--------------------------------------------------------------------------
  # new method: namebox_escape_characters
  #--------------------------------------------------------------------------
  def namebox_escape_characters(result)
    result.gsub!(/\eN\<(.+?)\>/i)  { namewindow($1, 1) }
    result.gsub!(/\eN1\<(.+?)\>/i) { namewindow($1, 1) }
    result.gsub!(/\eN2\<(.+?)\>/i) { namewindow($1, 2) }
    result.gsub!(/\eNC\<(.+?)\>/i) { namewindow($1, 3) }
    result.gsub!(/\eN3\<(.+?)\>/i) { namewindow($1, 3) }
    result.gsub!(/\eN4\<(.+?)\>/i) { namewindow($1, 4) }
    result.gsub!(/\eN5\<(.+?)\>/i) { namewindow($1, 5) }
    result.gsub!(/\eNR\<(.+?)\>/i) { namewindow($1, 5) }
    return result
  end
  
  #--------------------------------------------------------------------------
  # new method: namebox
  #--------------------------------------------------------------------------
  def namewindow(text, position)
    @name_text = text
    @name_position = position
    return ""
  end
  
  #--------------------------------------------------------------------------
  # new method: message_escape_characters
  #--------------------------------------------------------------------------
  def message_escape_characters(result)
    result.gsub!(/\eAF\[(-?\d+)]/i) { change_face($1.to_i) }
    return result
  end
  
  #--------------------------------------------------------------------------
  # new method: change_face
  #--------------------------------------------------------------------------
  def change_face(actor_id)
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    $game_message.face_name = actor.face_name
    $game_message.face_index = actor.face_index
    return ""
  end
  
  #--------------------------------------------------------------------------
  # alias method: new_page
  #--------------------------------------------------------------------------
  alias window_message_new_page_ams new_page
  def new_page(text, pos)
    adjust_message_window_size
    window_message_new_page_ams(text, pos)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: new_line_x
  #--------------------------------------------------------------------------
  def new_line_x
    return $game_message.face_name.empty? ? 0 : YEA::MESSAGE::FACE_INDENT_X
  end
  
  #--------------------------------------------------------------------------
  # new method: adjust_message_window_size
  #--------------------------------------------------------------------------
  def adjust_message_window_size
    self.height = window_height
    self.width = window_width
    create_contents
    update_placement
    self.x = (Graphics.width - self.width) / 2
    start_name_window
  end
  
  #--------------------------------------------------------------------------
  # new method: clear_name_window
  #--------------------------------------------------------------------------
  def clear_name_window
    @name_text = ""
    @name_position = 0
  end
  
  #--------------------------------------------------------------------------
  # new method: start_name_window
  #--------------------------------------------------------------------------
  def start_name_window
    return if @name_text == ""
    @name_window.start(@name_text, @name_position)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: fiber_main
  #--------------------------------------------------------------------------
  def fiber_main
    $game_message.visible = true
    update_background
    update_placement
    loop do
      process_all_text if $game_message.has_text?
      process_input
      $game_message.clear
      @gold_window.close
      @name_window.start_close
      Fiber.yield
      break unless text_continue?
    end
    close_and_wait
    $game_message.visible = false
    @fiber = nil
  end
  
  #--------------------------------------------------------------------------
  # alias method: open_and_wait
  #--------------------------------------------------------------------------
  alias window_message_open_and_wait_ams open_and_wait
  def open_and_wait
    clear_name_window
    adjust_message_window_size
    window_message_open_and_wait_ams
  end
  
  #--------------------------------------------------------------------------
  # alias method: close_and_wait
  #--------------------------------------------------------------------------
  alias window_message_close_and_wait_ams close_and_wait
  def close_and_wait
    @name_window.force_close
    window_message_close_and_wait_ams
  end
  
  #--------------------------------------------------------------------------
  # alias method: all_close?
  #--------------------------------------------------------------------------
  alias window_message_all_close_ams all_close?
  def all_close?
    return window_message_all_close_ams && @name_window.close?
  end
  
  #--------------------------------------------------------------------------
  # alias method: process_escape_character
  #--------------------------------------------------------------------------
  alias window_message_process_escape_character_ams process_escape_character
  def process_escape_character(code, text, pos)
    case code.upcase
    when 'W' # Wait
      wait(obtain_escape_param(text))
    else
      window_message_process_escape_character_ams(code, text, pos)
    end
  end
  
end # Window_Message
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
# 
# ?\ Yanfly Engine Ace - Ace Save Engine v1.03
# -- Last Updated: 2012.07.22
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-SaveEngine"] = true
#==============================================================================
# ?\ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.07.22 - Fixed: Location Drawing.
# 2012.01.23 - Anti-crash method added for removed maps.
# 2011.12.26 - Compatibility Update: New Game+
# 2011.12.26 - Started Script and Finished.
# 
#==============================================================================
# ?\ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script provides a new save interface for the player. Along with a new
# interface, the player can also load and delete saves straight from the menu
# itself. This will in turn make the save command from the Main Menu always
# available, but the save option within the new save menu will be enabled
# depending on whether or not it is allowed or disallowed. From the interface,
# the player is given more information regarding the save file including the
# the location the player saved at, the amount of gold available, and any
# variables that you want to show the player as well.
# 
#==============================================================================
# ?\ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ?\ Materials/�ef?T but above ?\ Main. Remember to save.
# 
# For first time installers, be warned that loading this script the first time
# may not display all information in the status window for save files made
# before the installation of this script. To remedy this, just load up the save
# and save the file again.
# 
#==============================================================================
# ?\ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
module YEA
  module SAVE
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Slot Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This section adjusts how the slot window appears on the left side of the
    # screen. This also adjusts the maximum number of saves a player can make,
    # the way the slot names appear, and the icons used.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    NormalFiles = 50
    MAX_FILES   = 55         # Maximum saves a player can make. Default: 16
    SLOT_NAME = Vocab::SaveLoad::Slot # How the file slots will be named.
    
    # These are the icons
    SAVE_ICON  = 368       # Icon used to indicate a save is present.
    EMPTY_ICON = 375       # Icon used to indicate an empty file.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Action Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This section adjusts how the action window appears, the sound effect
    # played when deleting files, and what appears in the help window above.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    ACTION_LOAD   = Vocab::SaveLoad::ACTION_LOAD # Text used for loading games.
    ACTION_SAVE   = Vocab::SaveLoad::ACTION_SAVE # Text used for saving games.
    ACTION_DELETE = Vocab::SaveLoad::ACTION_DELETE # Text used for deleting games.
    DELETE_SOUND  = RPG::SE.new("Break", 80, 100) # Sound for deleting.
    
    # These text settings adjust what displays in the help window.
    SELECT_HELP = Vocab::SaveLoad::SELECT_HELP
    LOAD_HELP   = Vocab::SaveLoad::LOAD_HELP
    SAVE_HELP   = Vocab::SaveLoad::SAVE_HELP
    DELETE_HELP = Vocab::SaveLoad::DELETE_HELP
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Status Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This section adjusts how the status window appears in the middle of the
    # screen (that displays the game's data) such as the total playtime, total
    # times saved, total gold, the party's current location, and the variables
    # to be displayed.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    EMPTY_TEXT = Vocab::SaveLoad::EMPTY_TEXT  # Text used when no save data is present.
    PLAYTIME   = Vocab::SaveLoad::PLAYTIME    # Text used for total playtime.
    TOTAL_SAVE = Vocab::SaveLoad::TOTAL_SAVE  # Text used to indicate total saves.
    TOTAL_GOLD = Vocab::SaveLoad::TOTAL_GOLD  # Text used to indicate total gold.
    LOCATION   = Vocab::SaveLoad::LOCATION    # Text used to indicate current location.
    
    # These variables will be shown in each of the two columns for those who
    # would want to display more information than just what's shown. Input the
    # variables into the arrays below to designate what data will be shown.
    COLUMN1_VARIABLES = [0, 0, 0]
    COLUMN2_VARIABLES = [0, 0, 0]
    
  end # SAVE
end # YEA
#==============================================================================
# ?\ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
#==============================================================================
# ?! Icon
#==============================================================================
module Icon
  
  #--------------------------------------------------------------------------
  # self.save_icon
  #--------------------------------------------------------------------------
  def self.save_icon; return YEA::SAVE::SAVE_ICON; end
  
  #--------------------------------------------------------------------------
  # self.empty_icon
  #--------------------------------------------------------------------------
  def self.empty_icon; return YEA::SAVE::EMPTY_ICON; end
    
end # Icon
#==============================================================================
# ?! Numeric
#==============================================================================
class Numeric
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
    
end # Numeric
#==============================================================================
# ?! DataManager
#==============================================================================
module DataManager
  
  #--------------------------------------------------------------------------
  # overwrite method: savefile_max
  #--------------------------------------------------------------------------
  def self.savefile_max
    return YEA::SAVE::MAX_FILES
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: self.make_save_header
  #--------------------------------------------------------------------------
  def self.make_save_header
    header = {}
    header[:characters]    = $game_party.characters_for_savefile
    header[:playtime_s]    = $game_system.playtime_s
    header[:system]        = Marshal.load(Marshal.dump($game_system))
    header[:timer]         = Marshal.load(Marshal.dump($game_timer))
    header[:message]       = Marshal.load(Marshal.dump($game_message))
    header[:switches]      = Marshal.load(Marshal.dump($game_switches))
    header[:variables]     = Marshal.load(Marshal.dump($game_variables))
    header[:self_switches] = Marshal.load(Marshal.dump($game_self_switches))
    header[:actors]        = Marshal.load(Marshal.dump($game_actors))
    header[:party]         = Marshal.load(Marshal.dump($game_party))
    header[:troop]         = Marshal.load(Marshal.dump($game_troop))
    
    begin
      header[:map] = Marshal.load(Marshal.dump($game_map))
    rescue Exception => e
      errfilename = "SaveErr.txt"
      info = sprintf(Vocab::Errno::SaveErr, e, errfilename)
      SceneManager.scene.raise_overlay_window(:popinfo, info);
      info = sprintf("%s\n%s\n%s\n", SPLIT_LINE, Time.now.to_s, e)
      e.backtrace.each{|line| info += line + 10.chr}
      puts "#{info}"
      File.open(errfilename, 'a') do |file|
        file.write(info)
      end
      return false
    end
    header[:player] = Marshal.load(Marshal.dump($game_player))
    header
  end
  
end # DataManager
=begin
#==============================================================================
# ?! Window_MenuCommand
#==============================================================================
class Window_MenuCommand < Window_HorzCommand
  
  #--------------------------------------------------------------------------
  # overwrite method: save_enabled
  #--------------------------------------------------------------------------
  def save_enabled; return true; end
  
end # Window_MenuCommand
=end
#==============================================================================
# ?! Window_FileList
#==============================================================================
class Window_FileList < Window_Selectable
  #--------------------------------------------------------------------------
  MouseTimer = 0
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy)
    super(dx, dy, 128, Graphics.height - dy)
    refresh
    activate
    select(SceneManager.scene.first_savefile_index)
  end
  
  #--------------------------------------------------------------------------
  # item_max
  #--------------------------------------------------------------------------
  def item_max; return DataManager.savefile_max; end
  
  #--------------------------------------------------------------------------
  # current_item_enabled?
  #--------------------------------------------------------------------------
  def current_item_enabled?
    header = DataManager.load_header(index)
    return false if header.nil? && SceneManager.scene_is?(Scene_Load)
    return true
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    create_contents
    draw_all_items
  end
  
  #--------------------------------------------------------------------------
  # draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    header = DataManager.load_header(index)
    enabled = !header.nil?
    rect = item_rect(index)
    rect.width -= 4
    draw_icon(save_icon?(header), rect.x, rect.y, enabled)
    change_color(normal_color, enabled)
    spec_loc = index.to_i + 1
    
    case spec_loc
    when 51
      text = sprintf(Vocab::SaveLoad::ASaveSlot, 1)
      super(index, "This slot is read-only")
    when 52
      text = sprintf(Vocab::SaveLoad::ASaveSlot, 2)
      super(index, "This slot is read-only")
    when 53
      text = sprintf(Vocab::SaveLoad::ASaveSlot, 3)
      super(index, "This slot is read-only")
    when 54
      text = sprintf(Vocab::SaveLoad::QSaveSlot, 1)
    when 55
      text = sprintf(Vocab::SaveLoad::QSaveSlot, 2)
    else
      text = sprintf(YEA::SAVE::SLOT_NAME, (index + 1).group)
    end
    
    draw_text(rect.x+24, rect.y, rect.width-24, line_height, text)
  end
  
  #--------------------------------------------------------------------------
  # save_icon?
  #--------------------------------------------------------------------------
  def save_icon?(header)
    return Icon.empty_icon if header.nil?
    return Icon.save_icon
  end
  #--------------------------------------------------------------------------
  def get_mouse_timer
    return MouseTimer
  end
  #--------------------------------------------------------------------------
end # Window_FileList
#==============================================================================
# ?! Window_FileStatus
#==============================================================================
class Window_FileStatus < Window_Base
  attr_reader :file_window
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy, file_window)
    super(dx, dy, Graphics.width - dx, Graphics.height - dy)
    @file_window = file_window
    @current_index = @file_window.index
    refresh
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return if @file_window.index < 0
    return if @current_index == @file_window.index
    @current_index = @file_window.index
    refresh
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    reset_font_settings
    @header = DataManager.load_header(@file_window.index)
    
    if @header.nil?
      draw_empty
    else
      draw_save_contents
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_empty
  #--------------------------------------------------------------------------
  def draw_empty
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(0, 0, contents.width, contents.height)
    contents.fill_rect(rect, colour)
    text = YEA::SAVE::EMPTY_TEXT
    change_color(system_color)
    draw_text(rect, text, 1)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_slot
  #--------------------------------------------------------------------------
  def draw_save_slot(dx, dy, dw)
    reset_font_settings
    change_color(system_color)
    text = sprintf(YEA::SAVE::SLOT_NAME, "")
    draw_text(dx, dy, dw, line_height, text)
    cx = text_size(text).width
    change_color(normal_color)
    draw_text(dx+cx, dy, dw-cx, line_height, (@file_window.index+1).group)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_playtime
  #--------------------------------------------------------------------------
  def draw_save_playtime(dx, dy, dw)
    return if @header[:playtime_s].nil?
    reset_font_settings
    change_color(system_color)
    draw_text(dx, dy, dw, line_height, YEA::SAVE::PLAYTIME, 0)
    change_color(normal_color)
    draw_text(dx, dy, dw, line_height, @header[:playtime_s], 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_total_saves
  #--------------------------------------------------------------------------
  def draw_save_total_saves(dx, dy, dw)
    return if @header[:system].nil?
    reset_font_settings
    change_color(system_color)
    text = YEA::SAVE::TOTAL_SAVE
    draw_text(dx, dy, dw, line_height, text)
    cx = text_size(text).width
    change_color(normal_color)
    draw_text(dx+cx, dy, dw-cx, line_height, @header[:system].save_count.group)
  end
  
  #--------------------------------------------------------------------------
  # * draw_save_gold
  #--------------------------------------------------------------------------
  def draw_save_gold(dx, dy, dw)
    return if @header[:party].nil?
    reset_font_settings
    change_color(system_color)
    draw_text(dx, dy, dw, line_height, YEA::SAVE::TOTAL_GOLD)
    text = Vocab::currency_unit
    draw_text(dx, dy, dw, line_height, text, 2)
    cx = text_size(text).width
    change_color(normal_color)
    bits = PONY.DecryptInt(@header[:party].gold(true))
    text = bits.group # tag: modified
    filename = DataManager.make_chainfilename(@file_window.index)
    contents = BlockChain.load_file_header(filename)
    text = contents[:player_balance].group
    draw_text(dx, dy, dw-cx, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_location
  #--------------------------------------------------------------------------
  def draw_save_location(dx, dy, dw)
    return if @header[:map].nil?
    reset_font_settings
    change_color(system_color)
    draw_text(dx, dy, dw, line_height, YEA::SAVE::LOCATION)
    change_color(normal_color)
    cx = text_size(YEA::SAVE::LOCATION).width
    return if $data_mapinfos[@header[:map].map_id].nil?
    text = @header[:map].display_name
    text = $data_mapinfos[@header[:map].map_id].name if text == ""
    draw_text(dx+cx, dy, dw-cx, line_height, text)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_characters
  #--------------------------------------------------------------------------
  def draw_save_characters(dx, dy)
    return if @header[:party].nil?
    reset_font_settings
    make_font_smaller
    dw = (contents.width - dx) / @header[:party].max_battle_members
    dx += dw/2
    for member in @header[:party].battle_members
      next if member.nil?
      member = @header[:actors][member.id]
      change_color(normal_color)
      draw_actor_graphic(member, dx, dy)
      text = member.name
      draw_text(dx-dw/2, dy, dw, line_height, text, 1)
      text = member.level.group
      draw_text(dx-dw/2, dy-line_height, dw-4, line_height, text, 2)
      cx = text_size(text).width
      change_color(system_color)
      text = Vocab::level_a
      draw_text(dx-dw/2, dy-line_height, dw-cx-4, line_height, text, 2)
      dx += dw
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_save_column1
  #--------------------------------------------------------------------------
  def draw_save_column1(dx, dy, dw)
    data = YEA::SAVE::COLUMN1_VARIABLES
    draw_column_data(data, dx, dy, dw)
  end
  
  #--------------------------------------------------------------------------
  # draw_save_column2
  #--------------------------------------------------------------------------
  def draw_save_column2(dx, dy, dw)
    data = YEA::SAVE::COLUMN2_VARIABLES
    draw_column_data(data, dx, dy, dw)
  end
  
  #--------------------------------------------------------------------------
  # draw_column_data
  #--------------------------------------------------------------------------
  def draw_column_data(data, dx, dy, dw)
    return if @header[:variables].nil?
    reset_font_settings
    for variable_id in data
      next if $data_system.variables[variable_id].nil?
      change_color(system_color)
      name = $data_system.variables[variable_id]
      draw_text(dx, dy, dw, line_height, name, 0)
      value = @header[:variables][variable_id]
      if value.is_a? Numeric then value = value.group end
      change_color(normal_color)
      draw_text(dx, dy, dw, line_height, value, 2)
      dy += line_height
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_save_contents
  #--------------------------------------------------------------------------
  def draw_save_contents
    draw_save_slot(4, 0, contents.width/2-8)
    draw_save_playtime(contents.width/2+4, 0, contents.width/2-8)
    draw_save_total_saves(4, line_height, contents.width/2-8)
    draw_save_gold(contents.width/2+4, line_height, contents.width/2-8)
    draw_save_location(4, line_height*2, contents.width-8)
    draw_save_characters(0, line_height*5 + line_height/3)
    draw_save_column1(16, line_height*7, contents.width/2-48)
    draw_save_column2(contents.width/2+16, line_height*7, contents.width/2-48)
  end
  
end # Window_FileStatus
#==============================================================================
# ?! Window_FileAction
#==============================================================================
class Window_FileAction < Window_HorzCommand
  attr_reader :file_window
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy, file_window)
    @file_window = file_window
    super(dx, dy)
    @overlay_window = Window_Confirm.new
    deactivate
    unselect
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; Graphics.width - 128; end
  
  #--------------------------------------------------------------------------
  # col_max
  #--------------------------------------------------------------------------
  def col_max; return 3; end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return if @file_window.index < 0
    return if @current_index == @file_window.index
    @current_index = @file_window.index
    refresh
  end
  
  #--------------------------------------------------------------------------
  # make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    @header = DataManager.load_header(@file_window.index)
    add_load_command
    add_save_command
    add_delete_command
  end
  
  #--------------------------------------------------------------------------
  # add_load_command
  #--------------------------------------------------------------------------
  def add_load_command
    add_command(YEA::SAVE::ACTION_LOAD, :load, load_enabled?)
  end
  
  #--------------------------------------------------------------------------
  # load_enabled?
  #--------------------------------------------------------------------------
  def load_enabled?
    return false if @header.nil?
    return true
  end
  
  #--------------------------------------------------------------------------
  # add_save_command
  #--------------------------------------------------------------------------
  def add_save_command
    add_command(YEA::SAVE::ACTION_SAVE, :save, save_enabled?)
  end
  #--------------------------------------------------------------------------
  # * Call OK Handler
  # tag: modified
  #--------------------------------------------------------------------------
  def call_ok_handler
    if current_symbol == :load && !SceneManager.stack.at(0).is_a?(Scene_Title)
      info = Vocab::System::UnsavedInfo
      raise_overlay(info , :call_handler, current_symbol)
    elsif current_symbol == :save && DataManager.save_file_exists?($game_system.game_mode, @file_window.index + 1)
      info = Vocab::System::Overwrite
      raise_overlay(info , :call_handler, current_symbol)
    elsif current_symbol == :delete
      info = Vocab::System::Delete
      raise_overlay(info , :call_handler, current_symbol)
    else
      super
    end
  end
  #--------------------------------------------------------------------------
  # * Quick save and Auto save not allowed to load
  #--------------------------------------------------------------------------
  def at_special_slot?
    spec_loc = @file_window.index.to_i + 1
    if 51 <= spec_loc && spec_loc <= 55
      return true
    else
      return false
    end
  end
  
  #--------------------------------------------------------------------------
  # save_enabled?
  # tag: modified
  #--------------------------------------------------------------------------
  def save_enabled?
    return false if @header.nil? && SceneManager.scene_is?(Scene_Load)
    return false if SceneManager.scene_is?(Scene_Load)
    return false if $game_system.save_disabled
    return false if at_special_slot?
    return false if BattleManager.in_battle?
    return true
  end
  
  #--------------------------------------------------------------------------
  # add_delete_command
  #--------------------------------------------------------------------------
  def add_delete_command
    add_command(YEA::SAVE::ACTION_DELETE, :delete, delete_enabled?)
  end
  
  #--------------------------------------------------------------------------
  # delete_enabled?
  #--------------------------------------------------------------------------
  def delete_enabled?
    return false if @header.nil?
    return true
  end
  
  #--------------------------------------------------------------------------
  # update_help
  #--------------------------------------------------------------------------
  def update_help
    case current_symbol
    when :load; @help_window.set_text(YEA::SAVE::LOAD_HELP)
    when :save; @help_window.set_text(YEA::SAVE::SAVE_HELP)
    when :delete; @help_window.set_text(YEA::SAVE::DELETE_HELP)
    end
  end
  
end # Window_FileAction
#==============================================================================
# ?! Scene_File
#==============================================================================
class Scene_File < Scene_MenuBase
  
  attr_reader :file_window
  #--------------------------------------------------------------------------
  # overwrite method: start
  #--------------------------------------------------------------------------
  def start
    super
    create_all_windows
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: terminate
  #--------------------------------------------------------------------------
  def terminate
    super
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: update
  #--------------------------------------------------------------------------
  def update
    super
  end
  
  #--------------------------------------------------------------------------
  # new method: create_all_windows
  #--------------------------------------------------------------------------
  def create_all_windows
    create_help_window
    create_file_window
    create_action_window
    create_status_window
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: create_help_window
  #--------------------------------------------------------------------------
  def create_help_window
    @help_window = Window_Help.new
    info = sprintf("%s", Vocab::SaveLoad::SELECT_HELP)
    @help_window.set_text(info)
  end  
  #--------------------------------------------------------------------------
  # new method: create_file_window
  #--------------------------------------------------------------------------
  def create_file_window
    wy = @help_window.height
    @file_window = Window_FileList.new(0, wy)
    @file_window.set_handler(:ok, method(:on_file_ok))
    @file_window.set_handler(:cancel, method(:return_scene))
  end
  
  #--------------------------------------------------------------------------
  # new method: create_action_window
  #--------------------------------------------------------------------------
  def create_action_window
    wx = @file_window.width
    wy = @help_window.height
    @action_window = Window_FileAction.new(wx, wy, @file_window)
    @action_window.help_window = @help_window
    @action_window.set_handler(:cancel, method(:on_action_cancel))
    @action_window.set_handler(:load, method(:on_action_load))
    @action_window.set_handler(:save, method(:on_action_save))
    @action_window.set_handler(:delete, method(:on_action_delete))
  end
  
  #--------------------------------------------------------------------------
  # new method: create_status_window
  #--------------------------------------------------------------------------
  def create_status_window
    wx = @action_window.x
    wy = @action_window.y + @action_window.height
    @status_window = Window_FileStatus.new(wx, wy, @file_window)
  end
  
  #--------------------------------------------------------------------------
  # new method: on_file_ok
  #--------------------------------------------------------------------------
  def on_file_ok
    @action_window.activate
    index = SceneManager.scene_is?(Scene_Load) ? 0 : 1
    @action_window.select(index)
  end
  
  #--------------------------------------------------------------------------
  # new method: on_action_cancel
  #--------------------------------------------------------------------------
  def on_action_cancel
    @action_window.unselect
    @file_window.activate
    @help_window.set_text(YEA::SAVE::SELECT_HELP)
  end
  #--------------------------------------------------------------------------
  # new method: on_action_load
  #--------------------------------------------------------------------------
  def on_action_load
    Sound.play_load
    fadeout_all
    $game_temp.loading_destroy_delay = true
    result = DataManager.load_game(@file_window.index)
    if result == true
      on_load_success
    else
      @@overlay_windows[:popinfo].assign_last_window(@action_window)
      case result
      when :chainfile_missing
        PONY::ERRNO.raise(:file_missing, nil, nil, "#{DataManager.make_chainfilename(@file_window.index)}")
      when :checksum_missing
        PONY::ERRNO.raise(:file_missing, nil, nil, "#{DataManager.make_hashfilename(@file_window.index)}")
      when :checksum_failed
        PONY::ERRNO.raise(:checksum_failed)
      when :bits_incorrect
        # nothing, already showed the info
      else
        info = " The version of selected file is not compatible with current game version"
        @@overlay_windows[:popinfo].raise_overlay(info)
      end
    end
  end
  #--------------------------------------------------------------------------
  # overwrite method: on_load_success
  #--------------------------------------------------------------------------
  def on_load_success
    $game_system.on_after_load
    SceneManager.goto(Scene_Map)
  end
  
  #--------------------------------------------------------------------------
  # new method: on_action_save
  # tag: modified
  #--------------------------------------------------------------------------
  def on_action_save
    $game_party.skillbar.dispose_layout
    
    @action_window.activate
    BlockChain.mining
    $game_party.sync_blockchain
    if DataManager.save_game(@file_window.index)
      on_save_success
      refresh_windows
    else
      Sound.play_buzzer
    end
  end  
  #--------------------------------------------------------------------------
  # overwrite method: on_save_success
  #--------------------------------------------------------------------------
  def on_save_success; Sound.play_save; end
  
  #--------------------------------------------------------------------------
  # new method: on_action_delete
  #--------------------------------------------------------------------------
  def on_action_delete
    @action_window.activate
    DataManager.delete_save_file(@file_window.index)
    on_delete_success
    refresh_windows
  end
  
  #--------------------------------------------------------------------------
  # new method: on_delete_success
  #--------------------------------------------------------------------------
  def on_delete_success
    YEA::SAVE::DELETE_SOUND.play
  end
  
  #--------------------------------------------------------------------------
  # new method: refresh_windows
  #--------------------------------------------------------------------------
  def refresh_windows
    @file_window.refresh
    @action_window.refresh
    @status_window.refresh
  end
  
end # Scene_File
#==============================================================================
# ?! Scene_Save
#==============================================================================
class Scene_Save < Scene_File
  
  #--------------------------------------------------------------------------
  # overwrite method: on_savefile_ok
  #--------------------------------------------------------------------------
  def on_savefile_ok; super; end
  
  #--------------------------------------------------------------------------
  # overwrite method: on_save_success
  #--------------------------------------------------------------------------
  def on_save_success; super; end
  
end # help_window_text
#==============================================================================
# ?! Scene_Load
#==============================================================================
class Scene_Load < Scene_File
  
  #--------------------------------------------------------------------------
  # overwrite method: on_savefile_ok
  #--------------------------------------------------------------------------
  def on_savefile_ok; super; end
  
  #--------------------------------------------------------------------------
  # overwrite method: on_load_success
  #--------------------------------------------------------------------------
  def on_load_success; super; end
  
end # Scene_Load
#==============================================================================
# 
# ?\ End of File
# 
#==============================================================================

#==============================================================================
# ** Window_EquipStatus
#------------------------------------------------------------------------------
#  This window displays actor parameter changes on the equipment screen.
#==============================================================================
class Window_EquipStatus < Window_Base
  #--------------------------------------------------------------------------
  # * Set Temporary Actor After Equipment Change
  #--------------------------------------------------------------------------
  def set_temp_actor(temp_actor, item = nil)
    return if @temp_actor == temp_actor
    @temp_actor = temp_actor
    @temp_item = item
    refresh
  end
  
  def set_original_item(item)
    @original_item = item
  end
  
end
#==============================================================================
class RPG::Weapon < RPG::EquipItem
  #--------------------------------------------------------------------------
  def initialize
    super
    @wtype_id = 0
    @animation_id = 0
    @features.push(RPG::BaseItem::Feature.new(31, 1, 0))
    @features.push(RPG::BaseItem::Feature.new(22, 0, 0))
  end
  #--------------------------------------------------------------------------
  def performance(actor = nil)
    base = (params[2] + params[4]) * 20
    plus = 0
    for feat in damage_index
      time     = feat[0]
      face     = feat[1]
      bonus    = feat[2]
      element  = feat[3]
      modparam = feat[4]
      plus += (time * face + bonus)
      #plus *= 
    end
    point = base + plus + self.rarity
    return point
  end
  attr_accessor :wtype_id
  attr_accessor :animation_id
end


#==============================================================================
# 
# ▼ Yanfly Engine Ace - Ace Equip Engine v1.06
# -- Last Updated: 2014.05.01
# -- Level: Normal, Hard
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-AceEquipEngine"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2014.05.01 - Bug Fixed: Refresh Equip Item List when change slot.
# 2012.02.02 - Bug Fixed: Crash when changing classes to different equip slots.
# 2012.01.22 - Bug Fixed: <equip slot> notetags updated to factor in spaces.
# 2012.01.05 - Compatibility Update: Equip Dynamic Stats
# 2011.12.30 - Bug Fixed: Stats didn't update.
# 2011.12.23 - Script efficiency optimized.
# 2011.12.18 - Script efficiency optimized.
# 2011.12.13 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# The default equipment system in RPG Maker VX is the standard equipment system
# seen in all of the previous iterations, which consists of weapon, shield,
# headgear, bodygear, and accessory. To break free of that norm, this script
# allows users access to giving actors and/or classes dynamic equipment setups
# (including having multiples of the same categories). In addition to having
# different equip slot setups, newer equipment types can be made to allow for
# more diversity in armour types.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Actor Notetags - These notetags go in the actors notebox in the database.
# -----------------------------------------------------------------------------
# <equip slots>
#  string
#  string
# </equip slots>
# This sets the actor's default slots to whatever is listed in between the two
# notetags. An actor's custom equip slots will take priority over a class's
# custom equip slots, which will take priority over the default equip slots.
# Replace "string" with the proper equipment type name or when in doubt, use
# "equip type: x" with x as the equipment type.
# 
# <starting gear: x>
# <starting gear: x, x>
# Adds armour x to the actor's list of starting gear. This is used primarily
# for the newer pieces of gear that can't be added through the starting set of
# equipment through the RPG Maker VX Ace editor by default. Insert multiple of
# these notetags to add more pieces of starting gear if so desired.
# 
# <fixed equip: x>
# <fixed equip: x, x>
# This will fix the equip type x. Fixed equip slots mean that the equipment
# already on it are unable to be exchanged in or out by the player. This tag
# has been made so that equip types can be fixed for equip type 5 and above.
# Use multiple of these notetags to add more fixed equipment restrictions.
# 
# <sealed equip: x>
# <sealed equip: x, x>
# This will seal the equip type x. Sealed equip slots mean that no equipment
# can be equipped onto that equip type slot. This tag has been made so that
# equip types can be sealed for equip type 5 and above. Use multiple of these
# notetags to add more sealed equipment restrictions.
# 
# -----------------------------------------------------------------------------
# Class Notetags - These notetags go in the class notebox in the database.
# -----------------------------------------------------------------------------
# <equip slots>
#  string
#  string
# </equip slots>
# This sets the class's default slots to whatever is listed in between the two
# notetags. An actor's custom equip slots will take priority over a class's
# custom equip slots, which will take priority over the default equip slots.
# Replace "string" with the proper equipment type name or when in doubt, use
# "equip type: x" with x as the equipment type.
# 
# <fixed equip: x>
# <fixed equip: x, x>
# This will fix the equip type x. Fixed equip slots mean that the equipment
# already on it are unable to be exchanged in or out by the player. This tag
# has been made so that equip types can be fixed for equip type 5 and above.
# Use multiple of these notetags to add more fixed equipment restrictions.
# 
# <sealed equip: x>
# <sealed equip: x, x>
# This will seal the equip type x. Sealed equip slots mean that no equipment
# can be equipped onto that equip type slot. This tag has been made so that
# equip types can be sealed for equip type 5 and above. Use multiple of these
# notetags to add more sealed equipment restrictions.
# 
# -----------------------------------------------------------------------------
# Weapon Notetags - These notetags go in the weapons notebox in the database.
# -----------------------------------------------------------------------------
# <fixed equip: x>
# <fixed equip: x, x>
# This will fix the equip type x. Fixed equip slots mean that the equipment
# already on it are unable to be exchanged in or out by the player. This tag
# has been made so that equip types can be fixed for equip type 5 and above.
# Use multiple of these notetags to add more fixed equipment restrictions.
# 
# <sealed equip: x>
# <sealed equip: x, x>
# This will seal the equip type x. Sealed equip slots mean that no equipment
# can be equipped onto that equip type slot. This tag has been made so that
# equip types can be sealed for equip type 5 and above. Use multiple of these
# notetags to add more sealed equipment restrictions.
# 
# -----------------------------------------------------------------------------
# Armour Notetags - These notetags go in the armour notebox in the database.
# -----------------------------------------------------------------------------
# <equip type: x>
# <equip type: string>
# For the newer equip types, replace x or string with the equip type ID or the
# name of the equip type respectively. This will set that armour to that
# particular equip type.
# 
# <fixed equip: x>
# <fixed equip: x, x>
# This will fix the equip type x. Fixed equip slots mean that the equipment
# already on it are unable to be exchanged in or out by the player. This tag
# has been made so that equip types can be fixed for equip type 5 and above.
# Use multiple of these notetags to add more fixed equipment restrictions.
# 
# <sealed equip: x>
# <sealed equip: x, x>
# This will seal the equip type x. Sealed equip slots mean that no equipment
# can be equipped onto that equip type slot. This tag has been made so that
# equip types can be sealed for equip type 5 and above. Use multiple of these
# notetags to add more sealed equipment restrictions.
# 
# -----------------------------------------------------------------------------
# State Notetags - These notetags go in the states notebox in the database.
# -----------------------------------------------------------------------------
# <fixed equip: x>
# <fixed equip: x, x>
# This will fix the equip type x. Fixed equip slots mean that the equipment
# already on it are unable to be exchanged in or out by the player. This tag
# has been made so that equip types can be fixed for equip type 5 and above.
# Use multiple of these notetags to add more fixed equipment restrictions.
# 
# <sealed equip: x>
# <sealed equip: x, x>
# This will seal the equip type x. Sealed equip slots mean that no equipment
# can be equipped onto that equip type slot. This tag has been made so that
# equip types can be sealed for equip type 5 and above. Use multiple of these
# notetags to add more sealed equipment restrictions.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
module YEA
  module EQUIP
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Equip Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This adjusts the default equip configuration. While actors can have their
    # own unique equipment configurations, it's recommended to not change too
    # much as things get really hairy when it comes to proper eventing.
    # 
    # ID   Equip Type
    # ---  ------------
    #  0   Weapon
    #  1   Shield
    #  2   Headgear
    #  3   Bodygear
    #  4   Accessory
    # 
    # Whatever you set the below slots to, the dual wield setup will be exactly
    # identical except that the second slot will be changed to a weapon (0).
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Adjust this array to set the default slots used for all of your actors
    # and classes if they do not have a custom equipment slot setup.
    DEFAULT_BASE_SLOTS = [ 0,1,2,2,3,5, 6, 7, 4, 4]
    
    # This hash adjusts the new equip types (past 4+). Adjust them to match
    # their names properly. You can choose to allow certain types of equipment
    # be removable or not, or whether or not optimize will affect them.
    TYPES ={
    # TypeID => ["Type Name", Removable?, Optimize?],
           0  => [ Vocab::Equipment::Weapon   ,   true,   true],
           1  => [ Vocab::Equipment::Shield   ,   true,   true],
           2  => [ Vocab::Equipment::Head     ,   true,   true],
           3  => [ Vocab::Equipment::Body     ,   true,   true],
           4  => [ Vocab::Equipment::Accessory,   true,   true],
           5  => [ Vocab::Equipment::Cloak    ,   true,   true],
           6  => [ Vocab::Equipment::Necklace ,   true,   true],
           7  => [ Vocab::Equipment::Boots    ,   true,   true],
           8  => [ Vocab::Equipment::Gem      ,   true,   true],
           9  => [ Vocab::Equipment::Rune     ,   true,  false],
           10 => [ Vocab::Equipment::Ammo     ,   true,   true],
    } # Do not remove this.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Equip Command List -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Here, you can adjust the order at which the commands appear (or even
    # remove commands as you see fit). Here's a list of which does what:
    # 
    # -------------------------------------------------------------------------
    # :command         Description
    # -------------------------------------------------------------------------
    # :equip           Activates the manual equip window. Default.
    # :optimize        Optimizes equipment for the actor. Default.
    # :clear           Clears all equipment from the actor. Default
    # 
    # And that's all of the currently available commands. This list will be
    # updated as more scripts become available.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This array arranges the order of which the commands appear in the Equip
    # Command window in the Equip Scene.
    COMMAND_LIST =[
      :equip,
      :optimize,
      :clear,
    # :custom1,
    # :custom2,
    ] # Do not remove this.
    
    #--------------------------------------------------------------------------
    # - Equip Custom Commands -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # For those who use scripts to that may produce unique effects for
    # equipping, use this hash to manage the custom commands for the Equip
    # Command Window. You can disable certain commands or prevent them from
    # appearing by using switches. If you don't wish to bind them to a switch,
    # set the proper switch to 0 for it to have no impact.
    #--------------------------------------------------------------------------
    CUSTOM_EQUIP_COMMANDS ={
    # :command => ["Display Name", EnableSwitch, ShowSwitch, Handler Method],
      :custom1 => [ "Custom Name",            0,          0, :command_name1],
      :custom2 => [ "Custom Text",           13,          0, :command_name2],
    } # Do not remove this.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Misc Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This section adjusts the minor visuals that you see inside of the newly
    # organized Equip Scene. Adjust the settings as you see fit.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This sets the font size used for the status window in the lower right
    # corner of the screen (which shows stats and comparisons).
    STATUS_FONT_SIZE = 20
    
    # This sets the remove equip command in the item window.
    REMOVE_EQUIP_ICON = 185
    REMOVE_EQUIP_TEXT = Vocab::Equipment::Remove
    
    # This sets the no-equipment text in the slot window.
    NOTHING_ICON = 185
    NOTHING_TEXT = Vocab::Equipment::Empty
    
  end # EQUIP
  
  module SKILL_EQUIP
    
    #===========================================================================
    # - Basic Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The following below will adjust the basic ruleset that the skill equip
    # system will use. Visual settings will also be adjusted here.
    #===========================================================================
    COMMAND = "Equip Skill"     # This is the category title that appears for 
                                # the skill equip option.
    EQUIP_SKILL_SWITCH = 43     # This switch must be enabled in order for the 
                                # Equip Skill command to appear in the skill menu.
    
    # These are the visual settings used when a skill isn't equipped.
    EMPTY_SKILL_HELP = "No skill is equipped in this slot.\n
                        Press Enter to assign skill."
    EMPTY_SKILL_TEXT = "<Empty Slot>"        # Text used for no skill equipped.
    EMPTY_SKILL_ICON = 185                   # Icon used for no skill equipped.
    
    # This constant adjusts the default maximum amount of equipped skills that
    # an actor can have without modifications.
    DEFAULT_MAX_EQUIPS = 4
    
    #===========================================================================
    # - Description Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The following below will adjust the description window, which includes 
    # skill's properties and description.
    # Here's the list of default properties:
    # -------------------------------------------------------------------------
    # :symbol          Description
    # -------------------------------------------------------------------------
    # :stype           Skill Type.
    # :cost            Skill Cost.
    # :speed           Speed Fix.
    # :success         Success Rate.
    #===========================================================================
    
    # Default displayed properties of each skill.
    DEFAULT_PROPERTIES = [ # Start.
        :stype,   # Skill Type
        :cost,    # Mana/TP Cost
        :speed,   # Speed Fix
        :cooldown,
        :range, # Range
        :save,
        :damage,
    ] # End.
    
    # Default displaying texts for properties.
    PROPERTIES = { # Start.
      :stype    =>  Vocab::Equipment::SType,
      :cost     =>  Vocab::Equipment::Cost,
      :speed    =>  Vocab::Equipment::Speed,
      :range    =>  Vocab::Equipment::Range,
      :cooldown =>  Vocab::Equipment::Cooldown,
      :save     =>  Vocab::Equipment::Save,
      :damage   =>  Vocab::Equipment::Damage,
    } # End.
    
  end # SKILLEQUIP
end # YEA
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
module YEA
  module REGEXP
  module BASEITEM
    
    EQUIP_SLOTS_ON  = /<(?:EQUIP_SLOTS|equip slots)>/i
    EQUIP_SLOTS_OFF = /<\/(?:EQUIP_SLOTS|equip slots)>/i
    
    EQUIP_TYPE_INT = /<(?:EQUIP_TYPE|equip type):[ ]*(\d+)>/i
    EQUIP_TYPE_STR = /<(?:EQUIP_TYPE|equip type):[ ]*(.*)>/i
    
    STARTING_GEAR = /<(?:STARTING_GEAR|starting gear):[ ](\d+(?:\s*,\s*\d+)*)>/i
    
    FIXED_EQUIP = /<(?:FIXED_EQUIP|fixed equip):[ ](\d+(?:\s*,\s*\d+)*)>/i
    SEALED_EQUIP = /<(?:SEALED_EQUIP|sealed equip):[ ](\d+(?:\s*,\s*\d+)*)>/i
    
  end # BASEITEM
  end # REGEXP
end # YEA
#==============================================================================
# ■ Vocab
#==============================================================================
module Vocab
  
  #--------------------------------------------------------------------------
  # overwrite method: self.etype
  #--------------------------------------------------------------------------
  def self.etype(etype)
    return $data_system.terms.etypes[etype] if [0,1,2,3,4].include?(etype)
    return ::YEA::EQUIP::TYPES[etype][0] if ::YEA::EQUIP::TYPES.include?(etype)
    return ""
  end
  
end # Vocab
#==============================================================================
# ■ Icon
#==============================================================================
module Icon
  
  #--------------------------------------------------------------------------
  # self.remove_equip
  #--------------------------------------------------------------------------
  def self.remove_equip; return YEA::EQUIP::REMOVE_EQUIP_ICON; end
  
  #--------------------------------------------------------------------------
  # self.nothing_equip
  #--------------------------------------------------------------------------
  def self.nothing_equip; return YEA::EQUIP::NOTHING_ICON; end
    
end # Icon
#==============================================================================
# ■ Numeric
#==============================================================================
class Numeric
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
    
end # Numeric
#==============================================================================
# ■ DataManager
#==============================================================================
module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_aee load_database; end
  def self.load_database
    load_database_aee
    load_notetags_aee
  end
  
  #--------------------------------------------------------------------------
  # new method: load_notetags_aee
  #--------------------------------------------------------------------------
  def self.load_notetags_aee
    groups = [$data_actors, $data_classes, $data_weapons, $data_armors,
      $data_states]
    for group in groups
      for obj in group
        next if obj.nil?
        obj.load_notetags_aee
      end
    end
  end
  
end # DataManager
#==============================================================================
# ■ RPG::BaseItem
#==============================================================================
class RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :base_equip_slots
  attr_accessor :fixed_equip_type
  attr_accessor :sealed_equip_type
  attr_accessor :extra_starting_equips
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_aee
  #--------------------------------------------------------------------------
  def load_notetags_aee
    @base_equip_slots = []
    @equip_slots_on = false
    @fixed_equip_type = []
    @sealed_equip_type = []
    @extra_starting_equips = []
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #---
      when YEA::REGEXP::BASEITEM::EQUIP_SLOTS_ON
        next unless self.is_a?(RPG::Actor) ||self.is_a?(RPG::Class)
        @equip_slots_on = true
      when YEA::REGEXP::BASEITEM::EQUIP_SLOTS_OFF
        next unless self.is_a?(RPG::Actor) ||self.is_a?(RPG::Class)
        @equip_slots_on = false
      #---
      when YEA::REGEXP::BASEITEM::STARTING_GEAR
        next unless self.is_a?(RPG::Actor)
        $1.scan(/\d+/).each { |num| 
        @extra_starting_equips.push(num.to_i) if num.to_i > 0 }
      when YEA::REGEXP::BASEITEM::FIXED_EQUIP
        $1.scan(/\d+/).each { |num| 
        @fixed_equip_type.push(num.to_i) if num.to_i > 0 }
      when YEA::REGEXP::BASEITEM::SEALED_EQUIP
        $1.scan(/\d+/).each { |num| 
        @sealed_equip_type.push(num.to_i) if num.to_i > 0 }
      #---
      when YEA::REGEXP::BASEITEM::EQUIP_TYPE_INT
        next unless self.is_a?(RPG::Armor)
        @etype_id = [1, $1.to_i].max
      when YEA::REGEXP::BASEITEM::EQUIP_TYPE_STR
        next unless self.is_a?(RPG::Armor)
        for key in YEA::EQUIP::TYPES
          id = key[0]
          next if YEA::EQUIP::TYPES[id][0].upcase != $1.to_s.upcase
          @etype_id = [1, id].max
          break
        end
      #---
      else
        if @equip_slots_on
          case line.upcase
          when /EQUIP TYPE[ ](\d+)/i, /EQUIP TYPE:[ ](\d+)/i
            id = $1.to_i
            @base_equip_slots.push(id) if [0,1,2,3,4].include?(id)
            @base_equip_slots.push(id) if YEA::EQUIP::TYPES.include?(id)
          when /WEAPON/i
            @base_equip_slots.push(0)
          when /SHIELD/i
            @base_equip_slots.push(1)
          when /HEAD/i
            @base_equip_slots.push(2)
          when /BODY/i, /ARMOR/i, /ARMOUR/i
            @base_equip_slots.push(3)
          when /ETC/i, /OTHER/i, /ACCESSOR/i
            @base_equip_slots.push(4)
          else
            text = line.upcase.delete(" ")
            for key in YEA::EQUIP::TYPES
              id = key[0]
              next if YEA::EQUIP::TYPES[id][0].upcase.delete(" ")!= text
              @base_equip_slots.push(id)
              break
            end
          end
        end
      end
    } # self.note.split
    #---
    return unless self.is_a?(RPG::Class)
    if @base_equip_slots.empty?
      @base_equip_slots = YEA::EQUIP::DEFAULT_BASE_SLOTS.clone
    end
  end
  
end # RPG::BaseItem
#==============================================================================
# ■ Game_Temp
#==============================================================================
class Game_Temp
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :eds_actor
  attr_accessor :scene_equip_index
  attr_accessor :scene_equip_oy
  
end # Game_Temp
#==============================================================================
# ■ Game_BaseItem
#==============================================================================
class Game_BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :item_id
  
end # Game_BaseItem
#==============================================================================
# ■ Game_BattlerBase
#==============================================================================
class Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # alias method: equip_type_fixed?
  #--------------------------------------------------------------------------
  alias game_battlerbase_equip_type_fixed_aee equip_type_fixed?
  def equip_type_fixed?(etype_id)
    return true if fixed_etypes.include?(etype_id) if actor?
    return game_battlerbase_equip_type_fixed_aee(etype_id)
  end
  
  #--------------------------------------------------------------------------
  # alias method: equip_type_sealed?
  #--------------------------------------------------------------------------
  alias game_battlerbase_equip_type_sealed_aee equip_type_sealed?
  def equip_type_sealed?(etype_id)
    return true if sealed_etypes.include?(etype_id) if actor?
    return game_battlerbase_equip_type_sealed_aee(etype_id)
  end
  
end # Game_BattlerBase
#==============================================================================
# ■ Game_Actor
#==============================================================================
class Game_Actor < Game_Battler
  
  #--------------------------------------------------------------------------
  # alias method: init_equips
  #--------------------------------------------------------------------------
  alias game_actor_init_equips_aee init_equips
  def init_equips(equips)
    game_actor_init_equips_aee(equips)
    equip_extra_starting_equips
  end
  
  #--------------------------------------------------------------------------
  # new method: equip_extra_starting_equips
  #--------------------------------------------------------------------------
  def equip_extra_starting_equips
    for equip_id in actor.extra_starting_equips
      armour = $data_armors[equip_id]
      next if armour.nil?
      etype_id = armour.etype_id
      next unless equip_slots.include?(etype_id)
      slot_id = empty_slot(etype_id)
      @equips[slot_id].set_equip(etype_id == 0, armour.id)
    end
    refresh
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: equip_slots
  #--------------------------------------------------------------------------
  def equip_slots
    return equip_slots_dual if dual_wield?
    return equip_slots_normal
  end
  
  #--------------------------------------------------------------------------
  # new method: equip_slots_normal
  #--------------------------------------------------------------------------
  def equip_slots_normal
    return self.actor.base_equip_slots if self.actor.base_equip_slots != []
    return self.class.base_equip_slots
  end
  
  #--------------------------------------------------------------------------
  # new method: equip_slots_dual
  #--------------------------------------------------------------------------
  def equip_slots_dual
    array = equip_slots_normal.clone
    array[1] = 0 if array.size >= 2
    return array
  end
  
  #--------------------------------------------------------------------------
  # new method: fixed_etypes
  #--------------------------------------------------------------------------
  def fixed_etypes
    array = []
    array |= self.actor.fixed_equip_type
    array |= self.class.fixed_equip_type
    for equip in equips
      next if equip.nil?
      array |= equip.fixed_equip_type
    end
    for state in states
      next if state.nil?
      array |= state.fixed_equip_type
    end
    return array
  end
  
  #--------------------------------------------------------------------------
  # new method: sealed_etypes
  #--------------------------------------------------------------------------
  def sealed_etypes
    array = []
    array |= self.actor.sealed_equip_type
    array |= self.class.sealed_equip_type
    for equip in equips
      next if equip.nil?
      array |= equip.sealed_equip_type
    end
    for state in states
      next if state.nil?
      array |= state.sealed_equip_type
    end
    return array
  end
  
  #--------------------------------------------------------------------------
  # alias method: change_equip
  #--------------------------------------------------------------------------
  alias game_actor_change_equip_aee change_equip
  def change_equip(slot_id, item)
    if item.nil? && !@optimize_clear
      etype_id = equip_slots[slot_id]
      return unless YEA::EQUIP::TYPES[etype_id][1]
    elsif item.nil? && @optimize_clear
      etype_id = equip_slots[slot_id]
      return unless YEA::EQUIP::TYPES[etype_id][2]
    end
    @equips[slot_id] = Game_BaseItem.new if @equips[slot_id].nil?
    game_actor_change_equip_aee(slot_id, item)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: optimize_equipments
  #--------------------------------------------------------------------------
  def optimize_equipments
    $game_temp.eds_actor = self
    @optimize_clear = true
    clear_equipments
    @optimize_clear = false
    equip_slots.size.times do |i|
      next if !equip_change_ok?(i)
      next unless can_optimize?(i)
      items = $game_party.equip_items.select do |item|
        item.etype_id == equip_slots[i] &&
        equippable?(item) && item.performance >= 0
      end
      change_equip(i, items.max_by {|item| item.performance })
    end
    $game_temp.eds_actor = nil
  end
  
  #--------------------------------------------------------------------------
  # new method: can_optimize?
  #--------------------------------------------------------------------------
  def can_optimize?(slot_id)
    etype_id = equip_slots[slot_id]
    return YEA::EQUIP::TYPES[etype_id][2]
  end
  
  #--------------------------------------------------------------------------
  # alias method: force_change_equip
  #--------------------------------------------------------------------------
  alias game_actor_force_change_equip_aee force_change_equip
  def force_change_equip(slot_id, item)
    @equips[slot_id] = Game_BaseItem.new if @equips[slot_id].nil?
    game_actor_force_change_equip_aee(slot_id, item)
  end
  
  #--------------------------------------------------------------------------
  # alias method: weapons
  #--------------------------------------------------------------------------
  alias game_actor_weapons_aee weapons
  def weapons
    anti_crash_equips
    return game_actor_weapons_aee
  end
  
  #--------------------------------------------------------------------------
  # alias method: armors
  #--------------------------------------------------------------------------
  alias game_actor_armors_aee armors
  def armors
    anti_crash_equips
    return game_actor_armors_aee
  end
  
  #--------------------------------------------------------------------------
  # alias method: equips
  #--------------------------------------------------------------------------
  alias game_actor_equips_aee equips
  def equips
    anti_crash_equips
    return game_actor_equips_aee
  end
  
  #--------------------------------------------------------------------------
  # new method: equips
  #--------------------------------------------------------------------------
  def anti_crash_equips
    for i in 0...@equips.size
      next unless @equips[i].nil?
      @equips[i] = Game_BaseItem.new
    end
  end
  
end # Game_Actor
#==============================================================================
# ■ Game_Interpreter
#==============================================================================
class Game_Interpreter
  
  #--------------------------------------------------------------------------
  # overwrite method: change equip
  #--------------------------------------------------------------------------
  def command_319
    actor = $game_actors[@params[0]]
    return if actor.nil?
    if @params[1] == 0 && @params[2] != 0
      item = $data_weapons[@params[2]]
      return unless actor.equip_slots.include?(0)
      slot_id = actor.empty_slot(0)
    elsif @params[2] != 0
      item = $data_armors[@params[2]]
      return unless actor.equip_slots.include?(item.etype_id)
      slot_id = actor.empty_slot(item.etype_id)
    else
      slot_id = @params[1]
    end
    actor.change_equip_by_id(slot_id, @params[2])
  end
  
end # Game_Interpreter
#==============================================================================
# ■ Window_EquipStatus
#==============================================================================
class Window_EquipStatus < Window_Base
  include DND::Utility
  #--------------------------------------------------------------------------
  # overwrite method: initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy)
    super(dx, dy, window_width, Graphics.height - dy)
    @actor = nil
    @temp_actor = nil
    refresh
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: window_width
  #--------------------------------------------------------------------------
  def window_width; return Graphics.width * 2 / 5; end
  
  #--------------------------------------------------------------------------
  # new method: update_dndparams
  #--------------------------------------------------------------------------
  def update_dndparams
    contents.clear
    reset_font_settings
    return if @actor.nil? || !@temp_item.nil?
    
    cnt = 0
    for id in 0..8 do
      case id
      when 0
        draw_actor_attack_bonus(0,line_height * cnt)
        cnt += 1
      when 1
        draw_actor_armor_class(0,line_height * cnt)
        cnt += 1
      when 2
        if @original_item.nil?
          draw_hoof_damage(0,line_height * cnt)
          cnt += 1
        elsif !@original_item.is_ammo?
          draw_dndparam_compare(0,line_height * cnt, 2, true)
          cnt += 1
        end
      when 3
        if !@original_item.nil? && @original_item.is_a?(RPG::Weapon) && !@original_item.is_ammo?
          draw_dndparam_compare(0,line_height * cnt, 3, true)
          cnt += 1
        end
      when 4
        if !@original_item.nil? && @original_item.is_a?(RPG::Weapon)
          draw_weapon_damage(0,line_height * cnt, true)
        end
      when 5
        # under construction
      when 6
        # under construction
      when 7
        # under construction
        when 8
        # under construction
      end
    end # for id 
    
  end
  #--------------------------------------------------------------------------
  # overwrite method: refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    reset_font_settings
    return if @actor.nil?
    update_dndparams
    cnt = 0
    
    if !@temp_item.nil?
      contents.clear
      for id in 0..8 do
        case id
        when 0
          draw_item_type(0,line_height * cnt)
          cnt += 1
        when 1
          draw_dndparam_compare(0,line_height * cnt, 0)
          cnt += 1
          draw_dndparam_compare(0,line_height * cnt, 1)
          cnt += 1
        when 2
          if @temp_item.is_a?(RPG::Weapon) && !@temp_item.is_ammo?
            draw_dndparam_compare(0,line_height * cnt, 2)
            cnt += 1
          end
        when 3
          if @temp_item.is_a?(RPG::Weapon) && !@temp_item.is_ammo?
            draw_dndparam_compare(0,line_height * cnt, 3)
            cnt += 1
          end
        when 4
          if @temp_item.is_a?(RPG::Weapon)
            draw_weapon_damage(0,line_height * cnt)
          end
        when 5
          # under construction
        when 6
          # under construction
        when 7
          # under construction
        when 8
          # under construction
        end
      end # for id 
    elsif !@temp_actor.nil?
      contents.clear
      draw_dndparam_compare(0,line_height * cnt, 0)
      cnt += 1
      draw_dndparam_compare(0,line_height * cnt, 1)
    end # if !@temp_item.nil?
    
  end # refresh
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_item
  # tag: modified
  #--------------------------------------------------------------------------
  def draw_item(dx, dy, param_id)
    # see the stuffs above
  end
  
  #--------------------------------------------------------------------------
  # draw_actor_attack_bonus
  #--------------------------------------------------------------------------
  def draw_actor_attack_bonus(x,y)
    w = contents.width
    change_color(system_color)
    draw_text(0, y, w, line_height, Vocab::Equipment::Thac0)
    change_color(normal_color)
    draw_text(0, y, w, line_height, @actor.attack_bonus, 2)
  end
  #--------------------------------------------------------------------------
  # draw_actor_armor_class
  #--------------------------------------------------------------------------
  def draw_actor_armor_class(x,y)
    w = contents.width
    change_color(system_color)
    draw_text(0, y, w, line_height, Vocab::Equipment::AC)
    change_color(normal_color)
    draw_text(0, y, w, line_height, @actor.armor_class, 2)
  end
  #--------------------------------------------------------------------------
  # draw_damge_index
  #--------------------------------------------------------------------------
  def draw_hoof_damage(x,y)
    w = contents.width
    change_color(system_color)
    
    if @actor.equips[0] && @actor.equips[0].damage_index.size < 1
      draw_text(x, y, w, line_height, Vocab::Equipment::AmmoDMG)
    else
      draw_text(x, y, w, line_height, Vocab::Equipment::WeaponDMG)
    end
    
    change_color(normal_color)
    cnt = 1
    
    if @actor.equips[0].nil?
      info = Vocab::Equipment::None
      draw_text(x, (y + cnt * line_height), w, line_height, info , 2)
    else
      ammo_slot_id = @actor.class.ammo_slot_id
      index = @actor.equips[0].damage_index.size < 1 && @actor.equips[ammo_slot_id] != nil ? @actor.equips[ammo_slot_id].damage_index : @actor.equips[0].damage_index
      for feat in index
        info = sprintf("%dd%d +(%d), %s; %s",feat[0],feat[1],feat[2], get_element_name(feat[3]), get_param_name(feat[4]))
        draw_text(x, (y + cnt * line_height), w, line_height, info , 2)
        cnt += 1
      end
    end
    
  end
  #--------------------------------------------------------------------------
  # draw_item_type
  #--------------------------------------------------------------------------
  def draw_item_type(x,y)
    w = contents.width
    change_color(system_color)
    draw_text(0, y, w, line_height, Vocab::Equipment::Type)
    change_color(normal_color)
    if @temp_item.is_a?(RPG::Weapon)
      wname = Vocab::DND::WEAPON_TYPE_NAME[@temp_item.wtype_id]
      draw_text(0, y, w, line_height, wname , 2)
    elsif @temp_item.is_a?(RPG::Armor)
      aname = Vocab::DND::ARMOR_TYPE_NAME[@temp_item.atype_id]
      draw_text(0, y, w, line_height, aname, 2)
    end
  end
  #--------------------------------------------------------------------------
  # draw attack bonus / AC
  #--------------------------------------------------------------------------
  def draw_dndparam_bonus(x,y)
    w = contents.width
    change_color(system_color)
    if @temp_item.is_a?(RPG::Weapon)
      draw_text(0, y, w, line_height, Vocab::Equipment::Thac0)
      change_color(normal_color)
      draw_text(0, y, w, line_height,@temp_item.attack_bonus, 2)
      
    elsif @temp_item.is_a?(RPG::Armor)
      draw_text(0, y, w, line_height, Vocab::Equipment::AC)
      change_color(normal_color)
      draw_text(0, y, w, line_height,@temp_item.armor_class, 2)
      
    end
  end
  #--------------------------------------------------------------------------
  # draw comparion of equip
  #--------------------------------------------------------------------------
  def draw_dndparam_compare(x,y,type, ori = false)
    #contents.font.size = YEA::EQUIP::STATUS_FONT_SIZE
    change_color(system_color)
    if type == 0
      draw_text(0, y, contents.width, line_height, Vocab::Equipment::Thac0)
    elsif type == 1
      draw_text(0, y, contents.width, line_height, Vocab::Equipment::AC)
    elsif type == 2
      draw_text(0, y, contents.width, line_height, Vocab::Equipment::Speed)
    elsif type == 3
      draw_text(0, y, contents.width, line_height, Vocab::Equipment::Range)
    elsif type == 4
      draw_text(0, y, contents.width, line_height, Vocab::Equipment::Damage)
    end
    
    draw_current_dndparam(x + 4, y, type, ori)   if @actor
    drx = (contents.width + 22) / 2
    draw_right_arrow(drx, y)                     if !ori
    draw_new_dndparam(drx + 22, y, type)         if @temp_actor && !ori
    
    reset_font_settings
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_current_dndparam
  #--------------------------------------------------------------------------
  def draw_current_dndparam(dx, dy, type, ori = false)
    change_color(normal_color)
    dw = ori ? contents.width : (contents.width + 22) / 2
    
    if type == 0
      draw_text(0, dy, dw, line_height, @actor.attack_bonus, 2)
    elsif type == 1
      draw_text(0, dy, dw, line_height, @actor.armor_class, 2)
    elsif type == 2
      v = @original_item.nil? ? Vocab::None : @original_item.wield_speed
      draw_text(0, dy, dw, line_height, v, 2)
    elsif type == 3
      v = @original_item.nil? ? Vocab::None : @original_item.tool_distance
      draw_text(0, dy, dw, line_height, v, 2)
    elsif type == 4
    
    end
    
    reset_font_settings
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_new_dndparam
  #--------------------------------------------------------------------------
  def draw_new_dndparam(dx, dy, type)
    
    info = ""
    if type == 0
      new_value = @temp_actor.attack_bonus
      change_color(param_change_color(new_value - @actor.attack_bonus))
      info = @temp_actor.attack_bonus
    elsif type == 1
      new_value = @temp_actor.armor_class
      change_color(param_change_color(new_value - @actor.armor_class))
      info = @temp_actor.armor_class
    elsif type == 2
      new_value = @temp_item.tool_cooldown
      v = @original_item.nil? ? 0 : @original_item.tool_cooldown
      change_color(param_change_color(v - new_value))
      info = @temp_item.wield_speed
    elsif type == 3
      new_value = @temp_item.tool_distance
      v = @original_item.nil? ? 0 : @original_item.tool_distance
      change_color(param_change_color(new_value - v))
      info = @temp_item.tool_distance
    
    end
    
    draw_text(0, dy, contents.width-4, line_height, info, 2)
    reset_font_settings
  end
  
  #--------------------------------------------------------------------------
  # draw_weapon_speed
  #--------------------------------------------------------------------------
  def draw_weapon_speed(x,y)
    w = contents.width
    change_color(system_color)
    draw_text(0, y, w, line_height, Vocab::Equipment::Speed)
    change_color(normal_color)
    speed = @temp_item.wield_speed
    draw_text(0, y, w, line_height, speed, 2)
  end
  #--------------------------------------------------------------------------
  # draw_weapon_range
  #--------------------------------------------------------------------------
  def draw_weapon_range(x,y)
    w = contents.width
    change_color(system_color)
    draw_text(0, y, w, line_height, YEA::SKILL_EQUIP::PROPERTIES[:range])
    change_color(normal_color)
    draw_text(0, y, w, line_height, @temp_item.tool_distance, 2)
  end
  #--------------------------------------------------------------------------
  # draw_damge_index
  #--------------------------------------------------------------------------
  def draw_weapon_damage(x,y, ori = false)
    w = contents.width
    change_color(system_color)
    draw_text(x, y, w, line_height, YEA::SKILL_EQUIP::PROPERTIES[:damage])
    change_color(normal_color)
    cnt = 1
    ammo_slot_id = @actor.class.ammo_slot_id
    
    item = ori ? @original_item : @temp_item
    item = @actor.equips[ammo_slot_id].nil? || item.damage_index.size > 0 ? item : @actor.equips[ammo_slot_id]
    
    for feat in item.damage_index
      info = sprintf("%dd%d +(%d), %s; %s",feat[0],feat[1],feat[2], get_element_name(feat[3]),get_param_name(feat[4]))
      draw_text(x, (y + cnt * line_height), w, line_height, info , 2)
      cnt += 1
    end
    
  end
  
  
  #--------------------------------------------------------------------------
  # new method: draw_background_colour
  #--------------------------------------------------------------------------
  def draw_background_colour(dx, dy)
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(dx+1, dy+1, contents.width - 2, line_height - 2)
    contents.fill_rect(rect, colour)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_param_name
  #--------------------------------------------------------------------------
  def draw_param_name(dx, dy, param_id)
    contents.font.size = YEA::EQUIP::STATUS_FONT_SIZE
    change_color(system_color)
    draw_text(dx, dy, contents.width, line_height, Vocab::param(param_id))
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_current_param
  #--------------------------------------------------------------------------
  def draw_current_param(dx, dy, param_id)
    change_color(normal_color)
    dw = (contents.width + 22) / 2
    draw_text(0, dy, dw, line_height, @actor.param(param_id).group, 2)
    reset_font_settings
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_new_param
  #--------------------------------------------------------------------------
  def draw_new_param(dx, dy, param_id)
    contents.font.size = YEA::EQUIP::STATUS_FONT_SIZE
    new_value = @temp_actor.param(param_id)
    change_color(param_change_color(new_value - @actor.param(param_id)))
    draw_text(0, dy, contents.width-4, line_height, new_value.group, 2)
    reset_font_settings
  end
  
end # Window_EquipStatus
#==============================================================================
# ■ Window_EquipCommand
#==============================================================================
class Window_EquipCommand < Window_HorzCommand
  
  #--------------------------------------------------------------------------
  # overwrite method: make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    for command in YEA::EQUIP::COMMAND_LIST
      case command
      when :equip
        add_command(Vocab::equip2, :equip)
      when :optimize
        add_command(Vocab::optimize, :optimize)
      when :clear
        add_command(Vocab::clear, :clear)
      else
        process_custom_command(command)
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # process_ok
  #--------------------------------------------------------------------------
  def process_ok
    $game_temp.scene_equip_index = index
    $game_temp.scene_equip_oy = self.oy
    super
  end
  
  #--------------------------------------------------------------------------
  # new method: process_custom_command
  #--------------------------------------------------------------------------
  def process_custom_command(command)
    return unless YEA::EQUIP::CUSTOM_EQUIP_COMMANDS.include?(command)
    show = YEA::EQUIP::CUSTOM_EQUIP_COMMANDS[command][2]
    continue = show <= 0 ? true : $game_switches[show]
    return unless continue
    text = YEA::EQUIP::CUSTOM_EQUIP_COMMANDS[command][0]
    switch = YEA::EQUIP::CUSTOM_EQUIP_COMMANDS[command][1]
    enabled = switch <= 0 ? true : $game_switches[switch]
    add_command(text, command, enabled)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: window_width
  #--------------------------------------------------------------------------
  def window_width; return 160; end
  
  #--------------------------------------------------------------------------
  # overwrite method: contents_width
  #--------------------------------------------------------------------------
  def contents_width; return width - standard_padding * 2; end
  
  #--------------------------------------------------------------------------
  # overwrite method: contents_height
  #--------------------------------------------------------------------------
  def contents_height
    ch = height - standard_padding * 2
    return [ch - ch % item_height, row_max * item_height].max
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; return 4; end
  
  #--------------------------------------------------------------------------
  # overwrite method: col_max
  #--------------------------------------------------------------------------
  def col_max; return 1; end
    
  #--------------------------------------------------------------------------
  # overwrite method: item_rect
  #--------------------------------------------------------------------------
  def item_rect(index)
    rect = Rect.new
    rect.width = item_width
    rect.height = item_height
    rect.x = index % col_max * (item_width + spacing)
    rect.y = index / col_max * item_height
    rect
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: ensure_cursor_visible
  #--------------------------------------------------------------------------
  def ensure_cursor_visible
    self.top_row = row if row < top_row
    self.bottom_row = row if row > bottom_row
  end
    
  #--------------------------------------------------------------------------
  # overwrite method: cursor_down
  #--------------------------------------------------------------------------
  def cursor_down(wrap = false)
    if index < item_max - col_max || (wrap && col_max == 1)
      select((index + col_max) % item_max)
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: cursor_up
  #--------------------------------------------------------------------------
  def cursor_up(wrap = false)
    if index >= col_max || (wrap && col_max == 1)
      select((index - col_max + item_max) % item_max)
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: process_pageup
  #--------------------------------------------------------------------------
  def process_pageup
    Sound.play_cursor
    Input.update
    deactivate
    call_handler(:pageup)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: process_pagedown
  #--------------------------------------------------------------------------
  def process_pagedown
    Sound.play_cursor
    Input.update
    deactivate
    call_handler(:pagedown)
  end
  
end # Window_EquipCommand
#==============================================================================
# ■ Window_EquipSlot
#==============================================================================
class Window_EquipSlot < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy, dw)
    super(dx, dy, dw, Graphics.height - dy)
    @actor = nil
    refresh
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: window_height
  #--------------------------------------------------------------------------
  def window_height; return self.height; end
  
  #--------------------------------------------------------------------------
  # overwrite method: visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; return item_max; end
  
  #--------------------------------------------------------------------------
  # overwrite method: refresh
  #--------------------------------------------------------------------------
  def refresh
    create_contents
    super
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    return unless @actor
    rect = item_rect_for_text(index)
    change_color(system_color, enable?(index))
    draw_text(rect.x, rect.y, 92, line_height, slot_name(index))
    item = @actor.equips[index]
    dx = rect.x + 92
    dw = contents.width - dx - 24
    if item.nil?
      draw_nothing_equip(dx, rect.y, false, dw)
    else
      draw_item_name(item, dx, rect.y, enable?(index), dw)
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_nothing_equip
  #--------------------------------------------------------------------------
  def draw_nothing_equip(dx, dy, enabled, dw)
    change_color(normal_color, enabled)
    draw_icon(Icon.nothing_equip, dx, dy, enabled)
    text = YEA::EQUIP::NOTHING_TEXT
    draw_text(dx + 24, dy, dw - 24, line_height, text)
  end
  
  #--------------------------------------------------------------------------
  # * Overwrite: Update Help Text
  #--------------------------------------------------------------------------
  def update_help
    super
    @help_window.set_item(item) if @help_window
    @status_window.set_temp_actor(nil) if @status_window
    @status_window.set_original_item(item) if @status_window
    @status_window.update_dndparams if @status_window
  end
  
end # Window_EquipSlot
#==============================================================================
# ■ Window_EquipItem
#==============================================================================
class Window_EquipItem < Window_ItemList
  
  #--------------------------------------------------------------------------
  # * overwrite method: col_max
  #--------------------------------------------------------------------------
  def col_max; return 1; end
  
  #--------------------------------------------------------------------------
  # * overwrite method: slot_id=
  #--------------------------------------------------------------------------
  def slot_id=(slot_id)
    return if @slot_id == slot_id
    @slot_id = slot_id
    @last_item = nil
    self.oy = 0
    refresh
  end
  
  #--------------------------------------------------------------------------
  # * overwrite method: draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    rect = item_rect(index)
    rect.width -= 4
    if item.nil?
      draw_remove_equip(rect)
      return
    end
    dw = contents.width - rect.x - 24
    draw_item_name(item, rect.x, rect.y, enable?(item), dw)
    draw_item_number(rect, item)
  end
  #--------------------------------------------------------------------------
  # * new method: draw_remove_equip
  #--------------------------------------------------------------------------
  def draw_remove_equip(rect)
    draw_icon(Icon.remove_equip, rect.x, rect.y)
    text = YEA::EQUIP::REMOVE_EQUIP_TEXT
    rect.x += 24
    rect.width -= 24
    draw_text(rect, text)
  end
  
  #--------------------------------------------------------------------------
  # * overwrite method: include?
  #--------------------------------------------------------------------------
  # tag: equipment
  def include?(item)
    if item.nil? && !@actor.nil?
      etype_id = @actor.equip_slots[@slot_id]
      return YEA::EQUIP::TYPES[etype_id][1]
    end
    return true if item.nil?
    return false unless item.is_a?(RPG::EquipItem)
    
    return false if @slot_id < 0
    
    if item.etype_id != @actor.equip_slots[@slot_id] && @actor.equip_slots[@slot_id] != 1
      return false
    elsif @actor.equip_slots[@slot_id] == 1
      return false unless @actor.offhoof_equippable?(@actor.equip_slots[@slot_id], item)
    end
    
    return @actor.equippable?(item)
  end
  #--------------------------------------------------------------------------
  # * overwrite method: enable?
  #--------------------------------------------------------------------------
  def enable?(item)
    if item.nil? && !@actor.nil?
      etype_id = @actor.equip_slots[@slot_id]
      return YEA::EQUIP::TYPES[etype_id][1]
    end
    return @actor.equippable?(item)
  end
  
  #--------------------------------------------------------------------------
  # * new method: show
  #--------------------------------------------------------------------------
  def show
    @last_item = 0
    update_help
    super
  end
  
  #--------------------------------------------------------------------------
  # * overwrite method: update_help
  #--------------------------------------------------------------------------
  def update_help
    super
    return if @actor.nil?
    return if @status_window.nil?
    return if @last_item == item
    @last_item = item
    temp_actor = Marshal.load(Marshal.dump(@actor))
    temp_actor.force_change_equip(@slot_id, item)
    @status_window.set_temp_actor(temp_actor, item)
  end
  
end # Window_EquipItem
#==============================================================================
# ■ Window_EquipActor
#==============================================================================
class Window_EquipActor < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy)
    super(dx, dy, window_width, fitting_height(4))
    @actor = nil
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return Graphics.width - 160; end
  
  #--------------------------------------------------------------------------
  # actor=
  #--------------------------------------------------------------------------
  def actor=(actor)
    return if @actor == actor
    @actor = actor
    refresh
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    return unless @actor
    draw_actor_face(@actor, 0, 0)
    draw_actor_simple_status(@actor, 108, line_height / 2)
  end
  
end # Window_EquipActor
#==============================================================================
# ■ Scene_Equip
#==============================================================================
class Scene_Equip < Scene_MenuBase
  
  #--------------------------------------------------------------------------
  # overwrite method: create_status_window
  #--------------------------------------------------------------------------
  def create_status_window
    wx = Graphics.width - (Graphics.width * 2 / 5)
    wy = @help_window.height + 120
    @status_window = Window_EquipStatus.new(wx, wy)
    @status_window.viewport = @viewport
    @status_window.actor = @actor
    @status_window.update_dndparams if @status_window
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: create_command_window
  #--------------------------------------------------------------------------
  def create_command_window
    wx = 0
    wy = @help_window.height
    ww = 160
    @command_window = Window_EquipCommand.new(wx, wy, ww)
    @command_window.viewport = @viewport
    @command_window.help_window = @help_window
    if !$game_temp.scene_equip_index.nil?
      @command_window.select($game_temp.scene_equip_index)
      @command_window.oy = $game_temp.scene_equip_oy
    end
    $game_temp.scene_equip_index = nil
    $game_temp.scene_equip_oy = nil
    @command_window.set_handler(:equip,    method(:command_equip))
    @command_window.set_handler(:optimize, method(:command_optimize))
    @command_window.set_handler(:clear,    method(:command_clear))
    @command_window.set_handler(:cancel,   method(:return_scene))
    @command_window.set_handler(:pagedown, method(:next_actor))
    @command_window.set_handler(:pageup,   method(:prev_actor))
    process_custom_equip_commands
    create_actor_window
  end
  
  #--------------------------------------------------------------------------
  # new method: create_actor_window
  #--------------------------------------------------------------------------
  def create_actor_window
    wy = @help_window.height
    @actor_window = Window_EquipActor.new(@command_window.width, wy)
    @actor_window.viewport = @viewport
    @actor_window.actor = @actor
  end
  
  #--------------------------------------------------------------------------
  # new method: process_custom_equip_commands
  #--------------------------------------------------------------------------
  def process_custom_equip_commands
    for command in YEA::EQUIP::COMMAND_LIST
      next unless YEA::EQUIP::CUSTOM_EQUIP_COMMANDS.include?(command)
      called_method = YEA::EQUIP::CUSTOM_EQUIP_COMMANDS[command][3]
      @command_window.set_handler(command, method(called_method))
    end
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: create_slot_window
  #--------------------------------------------------------------------------
  def create_slot_window
    wx = 0
    wy = @command_window.y + @command_window.height
    ww = Graphics.width - @status_window.width
    @slot_window = Window_EquipSlot.new(wx, wy, ww)
    @slot_window.viewport = @viewport
    @slot_window.help_window = @help_window
    @slot_window.status_window = @status_window
    @slot_window.actor = @actor
    @slot_window.set_handler(:ok,       method(:on_slot_ok))
    @slot_window.set_handler(:cancel,   method(:on_slot_cancel))
  end
  #--------------------------------------------------------------------------
  # * Slot [Cancel]
  #--------------------------------------------------------------------------
  alias on_slot_cancel_dnd on_slot_cancel
  def on_slot_cancel
    @status_window.set_original_item(nil) if @status_window
    @status_window.update_dndparams       if @status_window
    on_slot_cancel_dnd
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: create_item_window
  #--------------------------------------------------------------------------
  def create_item_window
    wx = @slot_window.x
    wy = @slot_window.y
    ww = @slot_window.width
    wh = @slot_window.height
    @item_window = Window_EquipItem.new(wx, wy, ww, wh)
    @item_window.viewport = @viewport
    @item_window.help_window = @help_window
    @item_window.status_window = @status_window
    @item_window.actor = @actor
    @item_window.set_handler(:ok,     method(:on_item_ok))
    @item_window.set_handler(:cancel, method(:on_item_cancel))
    @slot_window.item_window = @item_window
    @item_window.hide
    
  end
  
  #--------------------------------------------------------------------------
  # alias method: command_optimize
  #--------------------------------------------------------------------------
  alias scene_equip_command_optimize_aee command_optimize
  def command_optimize
    scene_equip_command_optimize_aee
    @actor_window.refresh
  end
  
  #--------------------------------------------------------------------------
  # alias method: command_clear
  #--------------------------------------------------------------------------
  alias scene_equip_command_clear_aee command_clear
  def command_clear
    scene_equip_command_clear_aee
    @actor_window.refresh
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_slot_ok
  #--------------------------------------------------------------------------
  alias scene_equip_on_slot_ok_aee on_slot_ok
  def on_slot_ok
    scene_equip_on_slot_ok_aee
    @slot_window.hide
    @item_window.refresh
    @item_window.show
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_item_ok
  #--------------------------------------------------------------------------
  alias scene_equip_on_item_ok_aee on_item_ok
  def on_item_ok
    scene_equip_on_item_ok_aee
    @actor_window.refresh
    @slot_window.show
    @item_window.hide
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_item_cancel
  #--------------------------------------------------------------------------
  alias scene_equip_on_item_cancel_aee on_item_cancel
  def on_item_cancel
    scene_equip_on_item_cancel_aee
    @slot_window.show
    @item_window.hide
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_actor_change
  #--------------------------------------------------------------------------
  alias scene_equip_on_actor_change_aee on_actor_change
  def on_actor_change
    scene_equip_on_actor_change_aee
    @actor_window.actor = @actor
  end
  
  #--------------------------------------------------------------------------
  # new method: command_name1
  #--------------------------------------------------------------------------
  def command_name1
    # Do nothing.
  end
  
  #--------------------------------------------------------------------------
  # new method: command_name2
  #--------------------------------------------------------------------------
  def command_name2
    # Do nothing.
  end
  
end # Scene_Equip
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
# VXAce Star Passability Bug Fix
#   by NeonBlack
# -- Level: Easy, Normal
# -- Requires: n/a
# -- This simply checks if the tile is a star before checking passability.  
# If the tile is a star and it is passable, it then checks the tile UNDER it.  
# If not, it returns falseas always. This prevents everything that is a star 
# tile from being passable.
#
# -- Original Topic:
# http://forums.rpgmakerweb.com/index.php?/topic/7625-vxace-passabilities-bug/
#==============================================================================
class Game_Map
  def check_passage(x, y, bit)
    all_tiles(x, y).each do |tile_id|
      flag = tileset.flags[tile_id]
      if flag & 0x10 != 0                   # [☆]: No effect on passage
        next         if flag & bit == 0     # [○] : Passable but star
        return false if flag & bit == bit   # [×] : Impassable
      else
        return true  if flag & bit == 0     # [○] : Passable
        return false if flag & bit == bit   # [×] : Impassable
      end
    end
    return false                                              # Impassable
  end
end

##------
## Display rounding error fix created by Neon Black.
##
## When certain slow display panning speeds are used, events will improperly
## round floating values to determine their position on screen.  This causes
## them to appear off from the tilemap by a single pixel.  Though minor this is
## noticable.  This snippet fixes this behaviour.
##
## This snippet may be used in any project.
##
## -- Original Topic:
## http://forums.rpgmakerweb.com/index.php?/topic/17448-event-jitter-fix-display-rounding-error-fix
##------
class Game_Map ## Rounds X and Y display values DOWN so the nearest 32 is found.
  
  def display_x
    (@display_x * 32).floor.to_f / 32
  end
  
  def display_y
    (@display_y * 32).floor.to_f / 32
  end
  
  def adjust_x(x)
    if loop_horizontal? && x < display_x - (width - screen_tile_x) / 2
      x - display_x + @map.width
    else
      x - display_x
    end
  end
  
  def adjust_y(y)
    if loop_vertical? && y < display_y - (height - screen_tile_y) / 2
      y - display_y + @map.height
    else
      y - display_y
    end
  end
  
end

#==============================================================================
# ** Game_Battler
#------------------------------------------------------------------------------
#  A battler class with methods for sprites and actions added. This class 
# is used as a super class of the Game_Actor class and Game_Enemy class.
#==============================================================================
class Game_Battler < Game_BattlerBase
  
end

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Ace Item Menu v1.02
# -- Last Updated: 2012.01.05
# -- Level: Normal, Hard
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-ItemMenu"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.01.05 - Compatibility Update with Equip Dynamic Stats.
# 2012.01.03 - Started Script and Finished.
#            - Compatibility Update with Ace Menu Engine.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# The Ace Item Menu offers more item categorization control and a better layout
# that simulatenously provides information regarding the items to the player,
# while keeping a good amount of the item list visible on screen at once. The
# script can also be customized to rearrange commands and categories.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Item Notetags - These notetags go in the item notebox in the database.
# -----------------------------------------------------------------------------
# <category: string>
# Places this object into the item category for "string". Whenever the selected
# category is highlighted in the Ace Item Menu command window, this object will
# be included and shown in the item window.
# 
# <image: string>
# Uses a picture from Graphics\Pictures\ of your RPG Maker VX Ace Project's
# directory with the filename of "string" (without the extension) as the image
# picture shown in the Ace Item Menu.
# 
# -----------------------------------------------------------------------------
# Weapon Notetags - These notetags go in the weapon notebox in the database.
# -----------------------------------------------------------------------------
# <category: string>
# Places this object into the item category for "string". Whenever the selected
# category is highlighted in the Ace Item Menu command window, this object will
# be included and shown in the item window.
# 
# <image: string>
# Uses a picture from Graphics\Pictures\ of your RPG Maker VX Ace Project's
# directory with the filename of "string" (without the extension) as the image
# picture shown in the Ace Item Menu.
# 
# -----------------------------------------------------------------------------
# Armour Notetags - These notetags go in the armour notebox in the database.
# -----------------------------------------------------------------------------
# <category: string>
# Places this object into the item category for "string". Whenever the selected
# category is highlighted in the Ace Item Menu command window, this object will
# be included and shown in the item window.
# 
# <image: string>
# Uses a picture from Graphics\Pictures\ of your RPG Maker VX Ace Project's
# directory with the filename of "string" (without the extension) as the image
# picture shown in the Ace Item Menu.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
# tag: translate
module YEA
  module ITEM
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Item Command Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This array adjusts what options appear in the initial item command window
    # before the items are split into separate categories. Add commands, remove
    # commands, or rearrange them. Here's a list of which does what:
    # 
    # -------------------------------------------------------------------------
    # :command         Description
    # -------------------------------------------------------------------------
    # :item            Opens up the various item categories. Default.
    # :weapon          Opens up the various weapon categories. Default.
    # :armor           Opens up the various armour categories. Default.
    # :key_item        Shows a list of the various key items. Default.
    # 
    # :gogototori      Requires Kread-EX's Go Go Totori Synthesis.
    # 
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMANDS =[
      :item,         # Opens up the various item categories. Default.
      :weapon,       # Opens up the various weapon categories. Default.
      :armor,        # Opens up the various armour categories. Default.
      :key_item,     # Shows a list of the various key items. Default.
      :gogototori,   # Requires Kread-EX's Go Go Totori Synthesis.
    # :custom1,      # Custom command 1.
    # :custom2,      # Custom command 2.
    ] # Do not remove this.
    
    #--------------------------------------------------------------------------
    # - Item Custom Commands -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # For those who use scripts to that may produce unique effects for the item
    # scene, use this hash to manage the custom commands for the Item Command
    # Window. You can disable certain commands or prevent them from appearing
    # by using switches. If you don't wish to bind them to a switch, set the
    # proper switch to 0 for it to have no impact.
    #--------------------------------------------------------------------------
    CUSTOM_ITEM_COMMANDS ={
    # :command => ["Display Name", EnableSwitch, ShowSwitch, Handler Method],
      :gogototori => ["Synthesis",            0,         0, :command_totori],
      :custom1 => [ "Custom Name",            0,          0, :command_name1],
      :custom2 => [ "Custom Text",           13,          0, :command_name2],
    } # Do not remove this.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Item Type Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These arrays adjusts and shows the various item types shown for Items,
    # Weapons, and Armours. Note that when using :category symbols, the
    # specific category shown will be equal to the text used for the Display
    # and the included item must contain a category equal to the Display name.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This array contains the order for the Item categories.
    ITEM_TYPES =[
    # [  :symbol,   "Display"],
    # [   :field,     "Field"], # Shows Menu-usable items.
    # [  :battle,    "Battle"], # Shows Battle-usable items.
      [     :all, Vocab::YEA::ITEM::ITEM_TYPES[:all] ], # Shows all usable items.
      [:category, Vocab::YEA::ITEM::ITEM_TYPES[:healings] ],    # <category: Healings>
      [:category, Vocab::YEA::ITEM::ITEM_TYPES[:book] ],        # <category: Book>
      [:category, Vocab::YEA::ITEM::ITEM_TYPES[:scroll] ],      # <category: Scroll>
      [:category, Vocab::YEA::ITEM::ITEM_TYPES[:hdweapons] ],   # <category: Hidden Weapon>
      [:category, Vocab::YEA::ITEM::ITEM_TYPES[:special] ],     # <category: Special>
      [:category, Vocab::YEA::ITEM::ITEM_TYPES[:ingredient] ],  # <category: Ingredient>
      [:category, Vocab::YEA::ITEM::ITEM_TYPES[:music_sheet] ], # <categpry: music_sheet>
      [:category, Vocab::YEA::ITEM::ITEM_TYPES[:misc] ],        # <categpry: misc>
     # [:key_item,  "Key Item"], # Shows all key items.
    ] # Do not remove this.
    
    # tag: modified
    # Match table for database notes
    ITEMTYPE_MATCH_TABLE = {
      "HEALINGS"      => Vocab::YEA::ITEM::ITEM_TYPES[:healings],
      "BOOK"          => Vocab::YEA::ITEM::ITEM_TYPES[:book],
      "SCROLL"        => Vocab::YEA::ITEM::ITEM_TYPES[:scroll],
      "HIDDEN WEAPON" => Vocab::YEA::ITEM::ITEM_TYPES[:hdweapons],
      "SPECIAL"       => Vocab::YEA::ITEM::ITEM_TYPES[:special],
      "INGREDIENT"    => Vocab::YEA::ITEM::ITEM_TYPES[:ingredient],
      "MUSIC SHEET"   => Vocab::YEA::ITEM::ITEM_TYPES[:music_sheet],
      "MISC"          => Vocab::YEA::ITEM::ITEM_TYPES[:misc],
    }
    
    # This array contains the order for the Weapon categories.
    WEAPON_TYPES =[
    # [  :symbol,   "Display"],
    #  [   :types,  "WPNTYPES"], # Lists all of the individual weapon types.
    #  [:category,  "Training"], # Categorized by <category: string>
    #  [:category, "Legendary"], # Categorized by <category: string>
      [     :all,       Vocab::YEA::ITEM::WEAPON_TYPES[:all]], # Shows all weapons.
    ] # Do not remove this.
    
    # This array contains the order for the Armour categories.
    ARMOUR_TYPES =[
    # [  :symbol,   "Display"],
    #  [   :slots,  "ARMSLOTS"], # Lists all of the individual armour slots.
    #  [   :types,  "ARMTYPES"], # Lists all of the individual armours types.
    #  [:category,  "Training"], # Categorized by <category: string>
    #  [:category, "Legendary"], # Categorized by <category: string>
      [     :all,       Vocab::YEA::ITEM::ARMOUR_TYPES[:all]], # Shows all armours.
    ] # Do not remove this.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Item Status Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The item status window displays information about the item in detail.
    # Adjust the settings below to change the way the status window appears.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    STATUS_FONT_SIZE = 20       # Font size used for status window.
    MAX_ICONS_DRAWN  = 10       # Maximum number of icons drawn for states.
    
    # The following adjusts the vocabulary used for the status window. Each
    # of the vocabulary settings are self explanatory.
    VOCAB_STATUS = {
      :empty      => Vocab::YEA::ITEM::VOCAB_STATUS[:empty],      # Text used when nothing is shown.
      :hp_recover => Vocab::YEA::ITEM::VOCAB_STATUS[:hp_recover], # Text used for HP Recovery.
      :mp_recover => Vocab::YEA::ITEM::VOCAB_STATUS[:mp_recover], # Text used for MP Recovery.
      :tp_recover => Vocab::YEA::ITEM::VOCAB_STATUS[:tp_recover], # Text used for TP Recovery.
      :tp_gain    => Vocab::YEA::ITEM::VOCAB_STATUS[:tp_gain],    # Text used for TP Gain.
      :applies    => Vocab::YEA::ITEM::VOCAB_STATUS[:applies],    # Text used for applied states and buffs.
      :removes    => Vocab::YEA::ITEM::VOCAB_STATUS[:removes],    # Text used for removed states and buffs.
    } # Do not remove this.
    
  end # ITEM
end # YEA
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
module YEA
  module REGEXP
  module BASEITEM
    
    CATEGORY = /<(?:CATEGORIES|category):[ ](.*)>/i
    IMAGE    = /<(?:IMAGE|image):[ ](.*)>/i
    
  end # BASEITEM
  end # REGEXP
end # YEA
#==============================================================================
# ■ Numeric
#==============================================================================
class Numeric
  
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
    
end # Numeric
#==============================================================================
# ■ Vocab
#==============================================================================
module Vocab
  
  #--------------------------------------------------------------------------
  # new method: self.item_status
  #--------------------------------------------------------------------------
  def self.item_status(type)
    return YEA::ITEM::VOCAB_STATUS[type]
  end
  
end # Vocab
#==============================================================================
# ■ DataManager
#==============================================================================
module DataManager
  
  #--------------------------------------------------------------------------
  # alias method: load_database
  #--------------------------------------------------------------------------
  class <<self; alias load_database_aim load_database; end
  def self.load_database
    load_database_aim
    load_notetags_aim
  end
  
  #--------------------------------------------------------------------------
  # new method: load_notetags_aim
  #--------------------------------------------------------------------------
  def self.load_notetags_aim
    groups = [$data_items, $data_weapons, $data_armors]
    for group in groups
      for obj in group
        next if obj.nil?
        obj.load_notetags_aim
      end
    end
  end
  
end # DataManager
#==============================================================================
# ■ RPG::BaseItem
#==============================================================================
class RPG::BaseItem
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :category
  attr_accessor :image
  
  #--------------------------------------------------------------------------
  # common cache: load_notetags_aim
  #--------------------------------------------------------------------------
  def load_notetags_aim
    @category = []
    #---
    self.note.split(/[\r\n]+/).each { |line|
      case line
      #--- #tag: modified
      when YEA::REGEXP::BASEITEM::CATEGORY
        name = $1.upcase.to_s
        if YEA::ITEM::ITEMTYPE_MATCH_TABLE.keys.include?(name)
          @category.push(YEA::ITEM::ITEMTYPE_MATCH_TABLE[name])
        else
          @category.push(YEA::ITEM::ITEMTYPE_MATCH_TABLE["MISC"])
        end
      when YEA::REGEXP::BASEITEM::IMAGE
        @image = $1.to_s
      end
    } # self.note.split
    #---
  end
  
end # RPG::BaseItem
#==============================================================================
# ■ Game_Temp
#==============================================================================
class Game_Temp
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :scene_item_index
  attr_accessor :scene_item_oy
  
end # Game_Temp
#==============================================================================
# ■ Window_ItemList
#==============================================================================
class Window_ItemList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_item
  #--------------------------------------------------------------------------
  def draw_item(index)
    item = @data[index]
    return if item.nil?
    rect = item_rect(index)
    rect.width -= 4
    draw_item_name(item, rect.x, rect.y, enable?(item), rect.width - 24)
    draw_item_number(rect, item)
  end
  
end # Window_ItemList
#==============================================================================
# ■ Window_ItemCommand
#==============================================================================
class Window_ItemCommand < Window_Command
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_reader   :item_window
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(x, y)
    super(x, y)
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return 160; end
  
  #--------------------------------------------------------------------------
  # visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; return 4; end
  
  #--------------------------------------------------------------------------
  # process_ok
  #--------------------------------------------------------------------------
  def process_ok
    $game_temp.scene_item_index = index
    $game_temp.scene_item_oy = self.oy
    super
  end
  
  #--------------------------------------------------------------------------
  # make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    for command in YEA::ITEM::COMMANDS
      case command
      #--- Default Commands ---
      when :item
        add_command(Vocab::item, :item)
      when :weapon
        add_command(Vocab::weapon, :weapon)
      when :armor
        add_command(Vocab::armor, :armor)
      when :key_item
        add_command(Vocab::key_item, :key_item)
      #--- Imported ---
      when :gogototori
        next unless $imported["KRX-AlchemicSynthesis"]
        process_custom_command(command)
      #--- Custom Commands ---
      else
        process_custom_command(command)
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # process_custom_command
  #--------------------------------------------------------------------------
  def process_custom_command(command)
    return unless YEA::ITEM::CUSTOM_ITEM_COMMANDS.include?(command)
    show = YEA::ITEM::CUSTOM_ITEM_COMMANDS[command][2]
    continue = show <= 0 ? true : $game_switches[show]
    return unless continue
    text = YEA::ITEM::CUSTOM_ITEM_COMMANDS[command][0]
    switch = YEA::ITEM::CUSTOM_ITEM_COMMANDS[command][1]
    enabled = switch <= 0 ? true : $game_switches[switch]
    add_command(text, command, enabled)
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return unless self.active
    @item_window.category = current_symbol if @item_window
  end
  
  #--------------------------------------------------------------------------
  # item_window=
  #--------------------------------------------------------------------------
  def item_window=(item_window)
    @item_window = item_window
    update
  end
  
end # Window_ItemCommand
#==============================================================================
# ■ Window_ItemType
#==============================================================================
class Window_ItemType < Window_Command
  
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_reader   :item_window
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(x, y)
    super(x, y)
    deactivate
    @type = nil
  end
  
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return 160; end
  
  #--------------------------------------------------------------------------
  # visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; return 4; end
  
  #--------------------------------------------------------------------------
  # reveal
  #--------------------------------------------------------------------------
  def reveal(type)
    @type = type
    refresh
    activate
    select(0)
  end
  
  #--------------------------------------------------------------------------
  # make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    return if @type.nil?
    #---
    case @type
    when :item
      commands = YEA::ITEM::ITEM_TYPES
    when :weapon
      commands = YEA::ITEM::WEAPON_TYPES
    else
      commands = YEA::ITEM::ARMOUR_TYPES
    end
    #---
    for command in commands
      case command[0]
      #---
      when :types
        case @type
        when :weapon
          for i in 1...$data_system.weapon_types.size
            name = $data_system.weapon_types[i]
            add_command(name, :w_type, true, i)
          end
        else
          for i in 1...$data_system.armor_types.size
            name = $data_system.armor_types[i]
            add_command(name, :a_type, true, i)
          end
        end
      #---
      when :slots
        if $imported["YEA-AceEquipEngine"]
          maximum = 1
          for key in YEA::EQUIP::TYPES
            maximum = [maximum, key[0]].max
          end
        else
          maximum = 4
        end
        for i in 1..maximum
          name = Vocab::etype(i)
          add_command(name, :e_type, true, i) if name != ""
        end
      #---
      else
        add_command(command[1], command[0], true, @type)
      end
    end
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return unless self.active
    @item_window.category = current_symbol if @item_window
  end
  
  #--------------------------------------------------------------------------
  # item_window=
  #--------------------------------------------------------------------------
  def item_window=(item_window)
    @item_window = item_window
    update
  end
  
end # Window_ItemType
#==============================================================================
# ■ Window_ItemList
#==============================================================================
class Window_ItemList < Window_Selectable
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias window_itemlist_initialize_aim initialize
  def initialize(dx, dy, dw, dh)
    window_itemlist_initialize_aim(dx, dy, dw, dh)
    @ext = :none
    @name = ""
  end
  
  #--------------------------------------------------------------------------
  # alias method: category=
  #--------------------------------------------------------------------------
  alias window_itemlist_category_aim category=
  def category=(category)
    if @types_window.nil?
      window_itemlist_category_aim(category)
    else
      return unless update_types?(category)
      @category = category
      if @types_window.active
        @name = @types_window.current_data[:name]
        @ext = @types_window.current_ext
      end
      refresh
      self.oy = 0
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: update_types?
  #--------------------------------------------------------------------------
  def update_types?(category)
    return true if @category != category
    return false unless @types_window.active
    if category == :category
      return @name != @types_window.current_data[:name]
    end
    return @ext != @types_window.current_ext
  end
  
  #--------------------------------------------------------------------------
  # new method: types_window=
  #--------------------------------------------------------------------------
  def types_window=(window)
    @types_window = window
  end
  
  #--------------------------------------------------------------------------
  # alias method: include?
  #--------------------------------------------------------------------------
  alias window_itemlist_include_aim include?
  def include?(item)
    if @types_window.nil?
      return window_itemlist_include_aim(item)
    else
      return ace_item_menu_include?(item)
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: ace_item_menu_include?
  #--------------------------------------------------------------------------
  def ace_item_menu_include?(item)
    case @category
    #---
    when :field
      return false unless item.is_a?(RPG::Item)
      return item.menu_ok?
    when :battle
      return false unless item.is_a?(RPG::Item)
      return item.battle_ok?
    #---
    when :w_type
      return false unless item.is_a?(RPG::Weapon)
      return item.wtype_id == @types_window.current_ext
    when :a_type
      return false unless item.is_a?(RPG::Armor)
      return item.atype_id == @types_window.current_ext
    when :e_type
      return false unless item.is_a?(RPG::Armor)
      return item.etype_id == @types_window.current_ext
    #---
    when :all
      case @types_window.current_ext
      when :item
        return item.is_a?(RPG::Item)
      when :weapon
        return item.is_a?(RPG::Weapon)
      else
        return item.is_a?(RPG::Armor)
      end
    #---
    when :category
      case @types_window.current_ext
      when :item
        return false unless item.is_a?(RPG::Item)
      when :weapon
        return false unless item.is_a?(RPG::Weapon)
      else
        return false unless item.is_a?(RPG::Armor)
      end
      return item.category.include?(@types_window.current_data[:name].upcase)
    #---
    else
      return window_itemlist_include_aim(item)
    end
  end
  
end # Window_ItemList
#==============================================================================
# ■ Window_ItemStatus
#==============================================================================
class Window_ItemStatus < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy, item_window)
    super(dx, dy, Graphics.width - dx, fitting_height(4))
    @item_window = item_window
    @item = nil
    refresh
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    update_item(@item_window.item)
  end
  
  #--------------------------------------------------------------------------
  # update_item
  #--------------------------------------------------------------------------
  def update_item(item)
    return if @item == item
    @item = item
    refresh
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    reset_font_settings
    return draw_empty if @item.nil?
    contents.font.size = YEA::ITEM::STATUS_FONT_SIZE
    draw_item_image
    draw_item_stats
    draw_item_effects
  end
  
  #--------------------------------------------------------------------------
  # draw_empty
  #--------------------------------------------------------------------------
  def draw_empty
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(1, 1, 94, 94)
    contents.fill_rect(rect, colour)
    dx = 96; dy = 0
    dw = (contents.width - 96) / 2
    for i in 0...8
      draw_background_box(dx, dy, dw)
      dx = dx >= 96 + dw ? 96 : 96 + dw
      dy += line_height if dx == 96
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_background_box
  #--------------------------------------------------------------------------
  def draw_background_box(dx, dy, dw)
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(dx+1, dy+1, dw-2, line_height-2)
    contents.fill_rect(rect, colour)
  end
  
  #--------------------------------------------------------------------------
  # draw_item_image
  #--------------------------------------------------------------------------
  def draw_item_image
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(1, 1, 94, 94)
    contents.fill_rect(rect, colour)
    if @item.image.nil?
      icon_index = @item.icon_index
      bitmap = Cache.system("Iconset")
      rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
      target = Rect.new(0, 0, 96, 96)
      contents.stretch_blt(target, bitmap, rect)
    else
      bitmap = Cache.picture(@item.image)
      contents.blt(0, 0, bitmap, bitmap.rect, 255)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_item_stats
  #--------------------------------------------------------------------------
  def draw_item_stats
    return unless @item.is_a?(RPG::Weapon) || @item.is_a?(RPG::Armor)
    dx = 96; dy = 0
    dw = (contents.width - 96) / 2
    for i in 0...8
      draw_equip_param(i, dx, dy, dw)
      dx = dx >= 96 + dw ? 96 : 96 + dw
      dy += line_height if dx == 96
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_equip_param
  #--------------------------------------------------------------------------
  def draw_equip_param(param_id, dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::param(param_id))
    if $imported["YEA-EquipDynamicStats"]
      draw_percentage_param(param_id, dx, dy, dw)
    else
      draw_set_param(param_id, dx, dy, dw)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_percentage_param
  #--------------------------------------------------------------------------
  def draw_percentage_param(param_id, dx, dy, dw)
    if @item.per_params[param_id] != 0 && @item.params[param_id] != 0
      text = draw_set_param(param_id, dx, dy, dw)
      dw -= text_size(text).width
      draw_percent_param(param_id, dx, dy, dw)
    elsif @item.per_params[param_id] != 0 && @item.params[param_id] == 0
      draw_percent_param(param_id, dx, dy, dw)
    else
      draw_set_param(param_id, dx, dy, dw)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_set_param
  #--------------------------------------------------------------------------
  def draw_set_param(param_id, dx, dy, dw)
    value = @item.params[param_id]
    if $imported["YEA-EquipDynamicStats"] && @item.var_params[param_id] > 0
      value += $game_variables[@item.var_params[param_id]] rescue 0
    end
    change_color(param_change_color(value), value != 0)
    text = value.group
    text = "+" + text if value > 0
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
    return text
  end
  
  #--------------------------------------------------------------------------
  # draw_percent_param
  #--------------------------------------------------------------------------
  def draw_percent_param(param_id, dx, dy, dw)
    value = @item.per_params[param_id]
    change_color(param_change_color(value))
    text = (@item.per_params[param_id] * 100).to_i.group + "%"
    text = "+" + text if @item.per_params[param_id] > 0
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
    return text
  end
  
  #--------------------------------------------------------------------------
  # draw_item_effects
  #--------------------------------------------------------------------------
  def draw_item_effects
    return unless @item.is_a?(RPG::Item)
    dx = 96; dy = 0
    dw = (contents.width - 96) / 2
    draw_hp_recover(dx, dy + line_height * 0, dw)
    draw_mp_recover(dx, dy + line_height * 1, dw)
    draw_tp_recover(dx + dw, dy + line_height * 0, dw)
    draw_tp_gain(dx + dw, dy + line_height * 1, dw)
    dw = contents.width - 96
    draw_applies(dx, dy + line_height * 2, dw)
    draw_removes(dx, dy + line_height * 3, dw)
  end
  
  #--------------------------------------------------------------------------
  # draw_hp_recover
  #--------------------------------------------------------------------------
  def draw_hp_recover(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:hp_recover))
    per = 0
    set = 0
    for effect in @item.effects
      next unless effect.code == 11
      per += (effect.value1 * 100).to_i
      set += effect.value2.to_i
    end
    if per != 0 && set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
      draw_text(dx+4, dy, dw-8, line_height, text, 2)
      dw -= text_size(text).width
      change_color(param_change_color(per))
      text = per > 0 ? sprintf("+%s%%", per.group) : sprintf("%s%%", per.group)
      draw_text(dx+4, dy, dw-8, line_height, text, 2)
      return
    elsif per != 0
      change_color(param_change_color(per))
      text = per > 0 ? sprintf("+%s%%", per.group) : sprintf("%s%%", per.group)
    elsif set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
    else
      change_color(normal_color, false)
      text = Vocab::item_status(:empty)
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_mp_recover
  #--------------------------------------------------------------------------
  def draw_mp_recover(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:mp_recover))
    per = 0
    set = 0
    for effect in @item.effects
      next unless effect.code == 12
      per += (effect.value1 * 100).to_i
      set += effect.value2.to_i
    end
    if per != 0 && set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
      draw_text(dx+4, dy, dw-8, line_height, text, 2)
      dw -= text_size(text).width
      change_color(param_change_color(per))
      text = per > 0 ? sprintf("+%s%%", per.group) : sprintf("%s%%", per.group)
      draw_text(dx+4, dy, dw-8, line_height, text, 2)
      return
    elsif per != 0
      change_color(param_change_color(per))
      text = per > 0 ? sprintf("+%s%%", per.group) : sprintf("%s%%", per.group)
    elsif set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
    else
      change_color(normal_color, false)
      text = Vocab::item_status(:empty)
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_tp_recover
  #--------------------------------------------------------------------------
  def draw_tp_recover(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:tp_recover))
    set = 0
    for effect in @item.effects
      next unless effect.code == 13
      set += effect.value1.to_i
    end
    if set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
    else
      change_color(normal_color, false)
      text = Vocab::item_status(:empty)
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_tp_gain
  #--------------------------------------------------------------------------
  def draw_tp_gain(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:tp_gain))
    set = @item.tp_gain
    if set != 0
      change_color(param_change_color(set))
      text = set > 0 ? sprintf("+%s", set.group) : set.group
    else
      change_color(normal_color, false)
      text = Vocab::item_status(:empty)
    end
    draw_text(dx+4, dy, dw-8, line_height, text, 2)
  end
  
  #--------------------------------------------------------------------------
  # draw_applies
  #--------------------------------------------------------------------------
  def draw_applies(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:applies))
    icons = []
    for effect in @item.effects
      case effect.code
      when 21
        next unless effect.value1 > 0
        next if $data_states[effect.value1].nil?
        icons.push($data_states[effect.data_id].icon_index)
      when 31
        icons.push($game_actors[1].buff_icon_index(1, effect.data_id))
      when 32
        icons.push($game_actors[1].buff_icon_index(-1, effect.data_id))
      end
      icons.delete(0)
      break if icons.size >= YEA::ITEM::MAX_ICONS_DRAWN
    end
    draw_icons(dx, dy, dw, icons)
  end
  
  #--------------------------------------------------------------------------
  # draw_removes
  #--------------------------------------------------------------------------
  def draw_removes(dx, dy, dw)
    draw_background_box(dx, dy, dw)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::item_status(:removes))
    icons = []
    for effect in @item.effects
      case effect.code
      when 22
        next unless effect.value1 > 0
        next if $data_states[effect.value1].nil?
        icons.push($data_states[effect.data_id].icon_index)
      when 33
        icons.push($game_actors[1].buff_icon_index(1, effect.data_id))
      when 34
        icons.push($game_actors[1].buff_icon_index(-1, effect.data_id))
      end
      icons.delete(0)
      break if icons.size >= YEA::ITEM::MAX_ICONS_DRAWN
    end
    draw_icons(dx, dy, dw, icons)
  end
  
  #--------------------------------------------------------------------------
  # draw_icons
  #--------------------------------------------------------------------------
  def draw_icons(dx, dy, dw, icons)
    dx += dw - 4
    dx -= icons.size * 24
    for icon_id in icons
      draw_icon(icon_id, dx, dy)
      dx += 24
    end
    if icons.size == 0
      change_color(normal_color, false)
      text = Vocab::item_status(:empty)
      draw_text(4, dy, contents.width-8, line_height, text, 2)
    end
  end
  
end # Window_ItemStatus
#==============================================================================
# ■ Scene_Item
#==============================================================================
class Scene_Item < Scene_ItemBase
  
  #--------------------------------------------------------------------------
  # alias method: start
  #--------------------------------------------------------------------------
  alias scene_item_start_aim start
  def start
    scene_item_start_aim
    create_types_window
    create_status_window
    relocate_windows
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: return_scene
  #--------------------------------------------------------------------------
  def return_scene
    $game_temp.scene_item_index = nil
    $game_temp.scene_item_oy = nil
    super
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: create_category_window
  #--------------------------------------------------------------------------
  def create_category_window
    wy = @help_window.height
    @category_window = Window_ItemCommand.new(0, wy)
    @category_window.viewport = @viewport
    @category_window.help_window = @help_window
    @category_window.y = @help_window.height
    if !$game_temp.scene_item_index.nil?
      @category_window.select($game_temp.scene_item_index)
      @category_window.oy = $game_temp.scene_item_oy
    end
    $game_temp.scene_item_index = nil
    $game_temp.scene_item_oy = nil
    @category_window.set_handler(:ok, method(:on_category_ok))
    @category_window.set_handler(:cancel, method(:return_scene))
    @category_window.set_handler(:item, method(:open_types))
    @category_window.set_handler(:weapon, method(:open_types))
    @category_window.set_handler(:armor, method(:open_types))
    process_custom_item_commands
  end
  
  #--------------------------------------------------------------------------
  # new method: process_custom_item_commands
  #--------------------------------------------------------------------------
  def process_custom_item_commands
    for command in YEA::ITEM::COMMANDS
      next unless YEA::ITEM::CUSTOM_ITEM_COMMANDS.include?(command)
      called_method = YEA::ITEM::CUSTOM_ITEM_COMMANDS[command][3]
      @category_window.set_handler(command, method(called_method))
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: create_types_window
  #--------------------------------------------------------------------------
  def create_types_window
    wy = @category_window.y
    @types_window = Window_ItemType.new(Graphics.width, wy)
    @types_window.viewport = @viewport
    @types_window.help_window = @help_window
    @types_window.y = @help_window.height
    @types_window.item_window = @item_window
    @item_window.types_window = @types_window
    @types_window.set_handler(:ok, method(:on_types_ok))
    @types_window.set_handler(:cancel, method(:on_types_cancel))
  end
  
  #--------------------------------------------------------------------------
  # new method: create_status_window
  #--------------------------------------------------------------------------
  def create_status_window
    wx = @category_window.width
    wy = @category_window.y
    @status_window = Window_ItemStatus.new(wx, wy, @item_window)
    @status_window.viewport = @viewport
  end
  
  #--------------------------------------------------------------------------
  # new method: relocate_windows
  #--------------------------------------------------------------------------
  def relocate_windows
    return unless $imported["YEA-AceMenuEngine"]
    case Menu.help_window_location
    when 0 # Top
      @help_window.y = 0
      @category_window.y = @help_window.height
      @item_window.y = @category_window.y + @category_window.height
    when 1 # Middle
      @category_window.y = 0
      @help_window.y = @category_window.height
      @item_window.y = @help_window.y + @help_window.height
    else # Bottom
      @category_window.y = 0
      @item_window.y = @category_window.height
      @help_window.y = @item_window.y + @item_window.height
    end
    @types_window.y = @category_window.y
    @status_window.y = @category_window.y
  end
  
  #--------------------------------------------------------------------------
  # new method: open_categories
  #--------------------------------------------------------------------------
  def open_types
    @category_window.x = Graphics.width
    create_types_window if @types_window.nil?
    @types_window.x = 0
    @types_window.reveal(@category_window.current_symbol)
  end
  
  #--------------------------------------------------------------------------
  # new method: on_types_ok
  #--------------------------------------------------------------------------
  def on_types_ok
    @item_window.activate
    @item_window.select_last
  end
  
  #--------------------------------------------------------------------------
  # new method: on_types_cancel
  #--------------------------------------------------------------------------
  def on_types_cancel
    @category_window.x = 0
    @category_window.activate
    @types_window.unselect
    @types_window.x = Graphics.width
  end
  
  #--------------------------------------------------------------------------
  # alias method: on_item_cancel
  #--------------------------------------------------------------------------
  alias scene_item_on_item_cancel_aim on_item_cancel
  def on_item_cancel
    if @types_window.x <= 0
      @item_window.unselect
      @types_window.activate
    else
      scene_item_on_item_cancel_aim
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: command_totori
  #--------------------------------------------------------------------------
  def command_totori
    SceneManager.call(Scene_Alchemy)
  end
  
  #--------------------------------------------------------------------------
  # new method: command_name1
  #--------------------------------------------------------------------------
  def command_name1
    # Do nothing.
  end
  
  #--------------------------------------------------------------------------
  # new method: command_name2
  #--------------------------------------------------------------------------
  def command_name2
    # Do nothing.
  end
  
end # Scene_Item
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
# 
# ▼ Yanfly Engine Ace - Command Window Icons v1.00
# -- Last Updated: 2011.12.11
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-CommandWindowIcons"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2011.12.11 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# Here's a script that allows you to allocate icons to each of your commands
# provided that the text for the command matches the icon in the script. There
# are, however, some scripts that this won't be compatible with and it's due
# to them using unique way of drawing out their commands. This script does not
# maintain compatibility for those specific scripts.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# Go to the module and match the text under ICON_HASH with a proper Icon ID.
# You can find an icon's ID by opening up the icon select window in the RPG
# Maker VX Ace database and look in the lower left corner.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================
module YEA
  module COMMAND_WINDOW_ICONS
    # tag: icon
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Icon Hash -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This hash controls all of the icon data for what's used with each text
    # item. Any text items without icons won't display icons. The text has to
    # match with the hash (case sensitive) to display icons.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    ICON_HASH = Vocab::YEA::ICON_HASH
    
  end # COMMAND_WINDOW_ICONS
end # YEA
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
#==============================================================================
# ■ Window_Command
#==============================================================================
class Window_Command < Window_Selectable
  
  #--------------------------------------------------------------------------
  # new method: use_icon?
  #--------------------------------------------------------------------------
  def use_icon?(text)
    return YEA::COMMAND_WINDOW_ICONS::ICON_HASH.include?(text)
  end
  
  #--------------------------------------------------------------------------
  # new method: command_icon
  #--------------------------------------------------------------------------
  def command_icon(text)
    return YEA::COMMAND_WINDOW_ICONS::ICON_HASH[text]
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: draw_item
  # tag: modified - ICON
  #--------------------------------------------------------------------------
  def draw_item(index)
    super(index, command_help(index))
    enabled = command_enabled?(index)
    change_color(normal_color, enabled)
    rect = item_rect_for_text(index)
    text = command_name(index)
    if use_icon?(text)
      draw_icon_text(rect.clone, text, alignment, enabled)
    else
      draw_text(rect, text, alignment)
    end
  end
  
  #--------------------------------------------------------------------------
  # new method: draw_icon_text
  #--------------------------------------------------------------------------
  def draw_icon_text(rect, text, alignment, enabled)
    cw = text_size(text).width
    icon = command_icon(text)
    draw_icon(icon, rect.x, rect.y, enabled)
    rect.x += 24
    rect.width -= 24
    draw_text(rect, text, alignment)
  end
  
end # Window_Command
#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================

#==============================================================================
#
# ▼ Yanfly Engine Ace - Ace Status Menu with Elements v1.04
# -- Last Updated: 2012.08.22
# -- Authors: Yanfly, Tsukihime, DisturbedInside
# -- Level: Normal
# -- Requires: n/a
#
#==============================================================================
$imported = {} if $imported.nil?
$imported["YEA-StatusMenu_Elements"] = true
#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2012.08.21 - Fixed problem with window opacity and created new formula for
#			  window size (it should resize properly now)
# 2012.08.21 - Added Tsukihime's Element Info
# 2012.08.06 - Fix Sp Paramater TCR
# 2011.12.26 - Compatibility Update: Rename Actor
# 2011.12.23 - Started Script and Finished.
#
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script changes the status screen completely to something the player can
# interact with more and be able to view actor data with more clarity. The
# player is able to view the general information for an actor (parameters and
# experience), a parameters bar graph, the various hidden extra parameters
# (named properties in the script), and a customizable biography for the actor.
# Also with this script, biographies can be changed at any time using a script
# call to add more of a personal touch to characters.
#
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
#
# -----------------------------------------------------------------------------
# Script Calls - These commands are used with script calls.
# -----------------------------------------------------------------------------
# $game_actors[x].description = string
# Changes the biography description for actor x to that of the string. Use \n
# to designate linebreaks in the string. If you wish to use text codes, write
# them in the strings as \\n[2] or \\c[3] to make them work properly.
#
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
#
#==============================================================================
module YEA
  module STATUS
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Command Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This section adjusts the commands that appear in the command window used
    # for the status screen. Rearrange the commands, add new ones, remove them
    # as you see fit.
    #
    # -------------------------------------------------------------------------
    # :command		 Description
    # -------------------------------------------------------------------------
    # :general  	   Adds general page.
    # :parameters	  Adds parameters page.
    # :properties	  Adds properties page.
    # :biography	   Adds biography page.
    #
    # :rename		  Requires YEA - Rename Actor
    # :retitle		 Requires YEA - Retitle Actor
    #
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    COMMANDS =[ # The order at which the menu items are shown.
    # [    :command,    "Display"],
	  [    :general, Vocab::Status::General],
	  [ :parameters, Vocab::Status::Parameter],
	  [ :properties, Vocab::Status::Property],
    #[ :dnd_properties, "Life Skills"],
    [   :leveling, Vocab::Status::Leveling],
    [     :tactic, Vocab::Status::Tactic],
    #[    :custom1,	 "Skills"],
	 #[    :custom2,  "Equipment"],
	 #[    :custom3,	  "Class"],
	  #[  :biography,  "Biography"],
	  #[	 :rename,	 "Rename"],  # Requires YEA - Rename Actor
	  #[    :retitle,    "Retitle"],  # Requires YEA - Rename Actor
	  #[    :elements,  "Elements"],  # this is the elements command
    ] # Do not remove this.
    #--------------------------------------------------------------------------
    # - Status Custom Commands -
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    # For those who use scripts to that may produce unique effects for the
    # status menu, use this hash to manage the custom commands for the Status
    # Command Window. You can disable certain commands or prevent them from
    # appearing by using switches. If you don't wish to bind them to a switch,
    # set the proper switch to 0 for it to have no impact.
    #--------------------------------------------------------------------------
    CUSTOM_STATUS_COMMANDS ={
    # :command => [EnableSwitch, ShowSwitch, Handler Method, Window Draw],
    :general => [      0,     0, :edit_skillbar, :nil],
	  :custom1 => [		   0,		  0, :command_name1, :draw_custom1],
	  :custom2 => [		   0,		  0, :command_name2, :draw_custom2],
	  :custom3 => [		   0,		  0, :command_name3, :draw_custom3],
    :tactic  => [		   0,		  0, :call_tactic_scene, :draw_tactic_overview],
    } # Do not remove this.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These settings adjust the way the general window visually appears.
    # Not many changes need to be done here other than vocab changes.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    PARAMETERS_VOCAB = Vocab::Status::Parameter		 # Title used for Parameters.
    EXPERIENCE_VOCAB = Vocab::Status::Experience		 # Title used for Experience.
    NEXT_TOTAL_VOCAB = Vocab::Status::Next_Lv_Total  # Label used for total experience.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Parameters Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These settings adjust the way the parameters window visually appears.
    # Each of the stats have a non-window colour. Adjust them as you see fit.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    PARAM_COLOUR ={
    # ParamID => [:stat,	   Colour1,				   Colour2		  ],
		    2 => [ :atk, Color.new(225, 100, 100), Color.new(240, 150, 150)],
		    3 => [ :def, Color.new(250, 150,  30), Color.new(250, 180, 100)],
		    4 => [ :mat, Color.new( 70, 140, 200), Color.new(135, 180, 230)],
		    5 => [ :mdf, Color.new(135, 130, 190), Color.new(170, 160, 220)],
		    6 => [ :agi, Color.new( 60, 180,  80), Color.new(120, 200, 120)],
		    7 => [ :luk, Color.new(255, 240, 100), Color.new(255, 250, 200)],
    } # Do not remove this.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Properties Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These settings adjust the way the properties window visually appears.
    # The properties have abbreviations, but leaving them as such makes things
    # confusing (as it's sometimes hard to figure out what the abbreviations
    # mean). Change the way the appear, whether or not they appear, and what
    # order they will appear in.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    PROPERTIES_FONT_SIZE = 16	    # Font size used for properties.
    # These are the properties that appear in column 1.
    
    PROPERTIES_COLUMN1 =[
	  [:thac0, Vocab::Equipment::Thac0],
	  [:ac,    Vocab::Equipment::AC],
#	  [:cri, "Critical Hit"],
#	  [:cev, "Critical Evade"],
#	  [:mev, "Magic Resist"],
#	  [:mrf, "Magic Reflect"],
#	  [:cnt, "Counter Rate"],
#	  [:tgr, "Target Rate"],
    ] # Do not remove this.
    # These are the properties that appear in column 2.
    PROPERTIES_COLUMN2 =[
	  #[:hrg, "HP Regen"],
	  #[:mrg, "MP Regen"],
	  #[:trg, "TP Regen"],
	  #[:rec, "Recovery"],
#	  [:grd, "Guard Rate"],
    #[:thac0, "Basic Attack Roll"],
    #[:armor_class, "AC"],
    #[:saving_throw01, "Str Saving Throw Bonus"],
    #[:saving_throw02, "Dex Saving Throw Bonus"],
    #[:saving_throw03, "Con Saving Throw Bonus"],
    #[:saving_throw04, "Int Saving Throw Bonus"],
    #[:saving_throw05, "Wis Saving Throw Bonus"],
    #[:saving_throw06, "Cha Saving Throw Bonus"],
	  #[:ppn, "Phy. Penetration"],
	  #[:mpn, "Mag. Penetration"],
	  #[:tcr, "TP Charge"],
    #[:jp,"JP"],
   # [:crafting_level,"Crafting Level"],
    ] # Do not remove this.
    # These are the properties that appear in column 3.
    PROPERTIES_COLUMN3 =[
#	  [:hcr, "HP Cost Rate"],    # Requires YEA - Skill Cost Manager
#	  [:mcr, "MP Cost Rate"],
#	  [:tcr_y, "TP Cost Rate"],    # Requires YEA - Skill Cost Manager
#	  [:cdr, "Cooldown Rate"],   # Requires YEA - Skill Restrictions
#	  [:wur, "Warmup Rate"],	 # Requires YEA - Skill Restrictions
#	  [:pdr, "P. Dmg. Taken"],
#	  [:mdr, "M. Dmg. Taken"],
	  #[:fdr, "Floor Damage"],
#    [:p_str, "Strength"],
#    [:p_dex, "Dexterity"],
#    [:p_con, "Constitution"],
#    [:p_int, "Intelligence"],
#    [:p_wis, "Wisdom"],
#    [:p_cha, "Charisma"],
    ]
    
    PROPERTIES_COLUMN4 =[
      [:str_ath, Vocab::Status::StrAth],
      
      [:dex_acr, Vocab::Status::DexAcr],
      [:dex_sle, Vocab::Status::DexSle],
      [:dex_ste, Vocab::Status::DexSte],
      
      [:int_arc, Vocab::Status::IntArc],
      [:int_his, Vocab::Status::IntHis],
      [:int_inv, Vocab::Status::IntInv],
      [:int_nat, Vocab::Status::IntNat],
      [:int_rel, Vocab::Status::IntRel],
    
    ] # Do not remove this.
    
    PROPERTIES_COLUMN5 =[
      
      [:wis_ani, Vocab::Status::WisAni],
      [:wis_ins, Vocab::Status::WisIns],
      [:wis_med, Vocab::Status::WisMed],
      [:wis_per, Vocab::Status::WisPer],
      [:wis_sur, Vocab::Status::WisSur],
      
      [:cha_dec, Vocab::Status::ChaDec],
      [:cha_int, Vocab::Status::ChaInt],
      [:cha_perfor, Vocab::Status::ChaPerf],
      [:cha_persua, Vocab::Status::ChaPers],
    
    ] # Do not remove this.
    
    PROPERTIES_COLUMN6 =[
    
    
    ] # Do not remove this.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Biography Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # These settings adjust the way the biography appears including the title
    # used at the top, the font size, and whatnot.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    BIOGRAPHY_NICKNAME_TEXT = "%s the %s"   # How the nickname will appear.
    BIOGRAPHY_NICKNAME_SIZE = 32		    # Size of the font used.
  end # STATUS
end # YEA
module Status_Element
  # List of elements that should not be included in the list
  Ignore = ["Absorb", "Physical","物理","吸收"]
  # Element entries. Format: "element name" => [index, icon]
  # The name and icon must match the ones in the database
  Elements = { "Fire"    => [3, 96],
			   "Ice"	 => [4, 97],
			   "Thunder" => [5, 98],
			   "Water"   => [6, 99],
			   "Earth"   => [7, 100],
			   "Wind"    => [8, 101],
			   "Holy"    => [9, 102],
			   "Dark"    => [10, 103]
			 }
			
  # Icons to draw for attack/resistance
  Attack_Icon = 385
  Resist_Icon = 510
end
#==============================================================================
# ▼ Editting anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================
#==============================================================================
# ■ Numeric
#==============================================================================
class Numeric
  #--------------------------------------------------------------------------
  # new method: group_digits
  #--------------------------------------------------------------------------
  unless $imported["YEA-CoreEngine"]
  def group; return self.to_s; end
  end # $imported["YEA-CoreEngine"]
end # Numeric
#==============================================================================
# ■ Game_Temp
#==============================================================================
class Game_Temp
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :scene_status_index
  attr_accessor :scene_status_oy
end # Game_Temp
#==============================================================================
# ■ Game_Actor
#==============================================================================
class Game_Actor < Game_Battler
  #--------------------------------------------------------------------------
  # new method: description=
  #--------------------------------------------------------------------------
  def description=(text)
    @description = text
  end
  #--------------------------------------------------------------------------
  # overwrite method: description
  #--------------------------------------------------------------------------
  def description
    return @description unless @description.nil?
    return actor.description
  end
    def equips_elements(element_id)
  end
    def element_attack
  end
  def element_resist
  end
end # Game_Actor
class Game_Battler < Game_BattlerBase			
  def element_resist
  end
  def element_attack
  end
end
#==============================================================================
# ■ Window_StatusCommand
#==============================================================================
class Window_StatusCommand < Window_Command
  #--------------------------------------------------------------------------
  # public instance variables
  #--------------------------------------------------------------------------
  attr_accessor :item_window
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy)
    super(dx, dy)
    @actor = nil
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
  end
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return 160; end
  #--------------------------------------------------------------------------
  # actor=
  #--------------------------------------------------------------------------
  def actor=(actor)
    return if @actor == actor
    @actor = actor
    refresh
  end
  #--------------------------------------------------------------------------
  # visible_line_number
  #--------------------------------------------------------------------------
  def visible_line_number; return 4; end
  #--------------------------------------------------------------------------
  # ok_enabled?
  #--------------------------------------------------------------------------
  def ok_enabled?
    return handle?(current_symbol)
  end
  #--------------------------------------------------------------------------
  # * make_command_list
  #--------------------------------------------------------------------------
  def make_command_list
    return unless @actor
    
    for command in YEA::STATUS::COMMANDS
      case command[0]
      #--- Default ---
      when :general, :parameters, :properties, :dnd_properties, :biography, :elements
        add_command(command[1], command[0])
      #--- Yanfly Engine Ace ---
      when :rename
        next unless $imported["YEA-RenameActor"]
        add_command(command[1], command[0], @actor.rename_allow?)
      when :retitle
        next unless $imported["YEA-RenameActor"]
        add_command(command[1], command[0], @actor.retitle_allow?)
      #--- Custom Commands ---
      else
        process_custom_command(command)
      end
    end
    
    if !$game_temp.scene_status_index.nil?
      select($game_temp.scene_status_index)
      self.oy = $game_temp.scene_status_oy
    end
    $game_temp.scene_status_index = nil
    $game_temp.scene_status_oy = nil
  end
  #--------------------------------------------------------------------------
  # process_ok
  #--------------------------------------------------------------------------
  def process_ok
    $game_temp.scene_status_index = index
    $game_temp.scene_status_oy = self.oy
    super
  end
  #--------------------------------------------------------------------------
  # process_custom_command
  #--------------------------------------------------------------------------
  def process_custom_command(command)
    return unless YEA::STATUS::CUSTOM_STATUS_COMMANDS.include?(command[0])
    show = YEA::STATUS::CUSTOM_STATUS_COMMANDS[command[0]][1]
    continue = show <= 0 ? true : $game_switches[show]
    return unless continue
    text = command[1]
    switch = YEA::STATUS::CUSTOM_STATUS_COMMANDS[command[0]][0]
    enabled = switch <= 0 ? true : $game_switches[switch]
    add_command(text, command[0], enabled)
  end
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    update_item_window
  end
  #--------------------------------------------------------------------------
  # update_item_window
  #--------------------------------------------------------------------------
  def update_item_window
    return if @item_window.nil?
    return if @current_index == current_symbol
    @current_index = current_symbol
    @item_window.refresh
  end
  #--------------------------------------------------------------------------
  # item_window=
  #--------------------------------------------------------------------------
  def item_window=(window)
    @item_window = window
    update
  end
  #--------------------------------------------------------------------------
  # update_help
  #--------------------------------------------------------------------------
  def update_help
    return if @actor.nil?
    desc = FileManager.textwrap(@actor.actor.description, @help_window.contents_width, @help_window.contents)
    @help_window.set_text(desc)
  end
end # Window_StatusCommand
#==============================================================================
# ■ Window_StatusActor
#==============================================================================
class Window_StatusActor < Window_Base
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy)
    super(dx, dy, window_width, fitting_height(4))
    @actor = nil
      unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
  end
  #--------------------------------------------------------------------------
  # window_width
  #--------------------------------------------------------------------------
  def window_width; return Graphics.width - 160; end
  #--------------------------------------------------------------------------
  # actor=
  #--------------------------------------------------------------------------
  def actor=(actor)
    return if @actor == actor
    @actor = actor
    refresh
  end
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    return unless @actor
    draw_actor_face(@actor, 0, 0)
    draw_actor_simple_status(@actor, 108, line_height / 2)
  end
end # Window_StatusActor
#==============================================================================
# ■ Window_StatusItem
#==============================================================================
class Window_StatusItem < Window_Base
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(dx, dy, command_window)
    super(dx, dy, Graphics.width, Graphics.height - dy)
    @command_window = command_window
    @actor = nil
    refresh
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
  end
  #--------------------------------------------------------------------------
  # actor=
  #--------------------------------------------------------------------------
  def actor=(actor)
    return if @actor == actor
    @actor = actor
    refresh
  end
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    reset_font_settings
    return unless @actor
    draw_window_contents
  end
  #--------------------------------------------------------------------------
  # draw_window_contents
  #--------------------------------------------------------------------------
  def draw_window_contents
    case @command_window.current_symbol
    when :general
      self.opacity = 255
      draw_actor_general
    when :parameters
      self.opacity = 255
      draw_parameter_graph
    when :properties
      self.opacity = 255
      draw_properties_list
    when :dnd_properties
      self.opacity = 255
      draw_dnd_properties_list
    when :elements
      self.opacity = 0
      draw_element_list
    when :biography, :rename, :retitle
      self.opacity = 255
      draw_actor_biography
    else
      draw_custom
    end
  end
  #--------------------------------------------------------------------------
  # draw_element_list
  #--------------------------------------------------------------------------
  def draw_element_list
    create_element_window
    @element_window.show
    @element_window.activate 
  end
  def create_element_window
    wx = Graphics.width - 400
    wy = 192
    @element_window = Window_ElementStatus.new(0, wy, Graphics.width, Graphics.height - wy)
    @element_window.actor = @actor
  end
  #--------------------------------------------------------------------------
  # * draw_actor_general
  #--------------------------------------------------------------------------
  def draw_actor_general
    change_color(system_color)
    text = YEA::STATUS::PARAMETERS_VOCAB
    draw_text(0, 0, contents.width/2, line_height, text, 1)
    text = YEA::STATUS::EXPERIENCE_VOCAB
    draw_text(contents.width/2, 0, contents.width/2, line_height, text, 1)
    draw_general_parameters
    draw_general_experience
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
  end
  #--------------------------------------------------------------------------
  # draw_general_parameters
  #--------------------------------------------------------------------------
  def draw_general_parameters
    dx = 24
    dy = line_height / 2
    draw_actor_level(dx, line_height*1+dy, contents.width/2 - 24)
    draw_actor_param(0, dx, line_height*2+dy, contents.width/2 - 24)
    draw_actor_param(1, dx, line_height*3+dy, contents.width/2 - 24)
    draw_actor_param(2, dx, line_height*4+dy, contents.width/4 - 12)
    draw_actor_param(4, dx, line_height*5+dy, contents.width/4 - 12)
    draw_actor_param(6, dx, line_height*6+dy, contents.width/4 - 12)
    dx += contents.width/4 - 12
    draw_actor_param(3, dx, line_height*4+dy, contents.width/4 - 12)
    draw_actor_param(5, dx, line_height*5+dy, contents.width/4 - 12)
    draw_actor_param(7, dx, line_height*6+dy, contents.width/4 - 12)
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
  end
  #--------------------------------------------------------------------------
  # draw_actor_level
  #--------------------------------------------------------------------------
  def draw_actor_level(dx, dy, dw)
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(dx+1, dy+1, dw-2, line_height-2)
    contents.fill_rect(rect, colour)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::level)
    change_color(normal_color)
    draw_text(dx+4, dy, dw-8, line_height, @actor.level.group, 2)
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
  end
  #--------------------------------------------------------------------------
  # draw_actor_param
  #--------------------------------------------------------------------------
  def draw_actor_param(param_id, dx, dy, dw)
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(dx+1, dy+1, dw-2, line_height-2)
    contents.fill_rect(rect, colour)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, Vocab::param(param_id))
    change_color(normal_color)
    draw_text(dx+4, dy, dw-8, line_height, @actor.param(param_id).group, 2)
unless @element_window.nil?
@element_window.opacity = 0
@element_window.contents_opacity = 0
@element_window.back_opacity = 0
end
  end
  #--------------------------------------------------------------------------
  # draw_general_experience
  #--------------------------------------------------------------------------
  def draw_general_experience
    if @actor.max_level?
	  s1 = @actor.exp.group
	  s2 = "-------"
	  s3 = "-------"
    else
	  s1 = @actor.exp.group
	  s2 = (@actor.next_level_exp - @actor.exp).group
	  s3 = @actor.next_level_exp.group
    end
    s_next = sprintf(Vocab::ExpNext, Vocab::level)
    total_next_text = sprintf(YEA::STATUS::NEXT_TOTAL_VOCAB, Vocab::level)
    change_color(system_color)
    dx = contents.width/2 + 12
    dy = line_height * 3 / 2
    dw = contents.width/2 - 36
    draw_text(dx, dy + line_height * 0, dw, line_height, Vocab::ExpTotal)
    draw_text(dx, dy + line_height * 2, dw, line_height, s_next)
    draw_text(dx, dy + line_height * 4, dw, line_height, total_next_text)
    change_color(normal_color)
    draw_text(dx, dy + line_height * 1, dw, line_height, s1, 2)
    draw_text(dx, dy + line_height * 3, dw, line_height, s2, 2)
    draw_text(dx, dy + line_height * 5, dw, line_height, s3, 2)
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
  end
  #--------------------------------------------------------------------------
  # draw_parameter_graph
  #--------------------------------------------------------------------------
  def draw_parameter_graph
    draw_parameter_title
    dy = line_height * 3/2
    maximum = 1
    minimum = @actor.param_max(2)
    for i in 2..7
      maximum = [@actor.param(i), maximum].max
      minimum = [@actor.param(i), minimum].min
    end
    maximum += minimum * 0.33 unless maximum == minimum
    
    for i in 2..7
      rate = calculate_rate(maximum, minimum, i)
      dy = line_height * i - line_height/2
      draw_param_gauge(i, dy, rate)
      change_color(system_color)
      draw_text(28, dy, contents.width - 56, line_height, Vocab::param(i))
      dw = (contents.width - 48) * rate - 8
      change_color(normal_color)
      
      value = @actor.param(i).group;
      mod   = @actor.param_modifier(i)
      info  = sprintf("%d(%c%d)", value, mod < 0 ? '-' : '+' , mod.abs)
      draw_text(28, dy, dw, line_height, info, 2)
      
      unless @element_window.nil?
        @element_window.opacity = 0
        @element_window.contents_opacity = 0
        @element_window.back_opacity = 0
      end
    end
    
  end
  #--------------------------------------------------------------------------
  # calculate_rate
  #--------------------------------------------------------------------------
  def calculate_rate(maximum, minimum, param_id)
    return 1.0 if maximum == minimum
    rate = (@actor.param(param_id).to_f - minimum) / (maximum - minimum).to_f
    rate *= 0.67
    rate += 0.33
    return rate
  end
  #--------------------------------------------------------------------------
  # draw_param_gauge
  #--------------------------------------------------------------------------
  def draw_param_gauge(param_id, dy, rate)
    dw = contents.width - 48
    colour1 = param_gauge1(param_id)
    colour2 = param_gauge2(param_id)
    draw_gauge(24, dy, dw, rate, colour1, colour2)
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
  end
  #--------------------------------------------------------------------------
  # param_gauge1
  #--------------------------------------------------------------------------
  def param_gauge1(param_id)
    return YEA::STATUS::PARAM_COLOUR[param_id][1]
  end
  #--------------------------------------------------------------------------
  # param_gauge2
  #--------------------------------------------------------------------------
  def param_gauge2(param_id)
    return YEA::STATUS::PARAM_COLOUR[param_id][2]
  end
  #--------------------------------------------------------------------------
  # draw_parameter_title
  #--------------------------------------------------------------------------
  def draw_parameter_title
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(0, 0, contents.width, contents.height)
    contents.fill_rect(rect, colour)
    change_color(system_color)
    text = YEA::STATUS::PARAMETERS_VOCAB
    draw_text(0, line_height/3, contents.width, line_height, text, 1)
  end
  #--------------------------------------------------------------------------
  # draw_properties_list
  #--------------------------------------------------------------------------
  def draw_properties_list
    contents.font.size = YEA::STATUS::PROPERTIES_FONT_SIZE
    draw_properties_column1
    draw_properties_column2
    draw_properties_column3
    reset_font_settings
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
  end
  #--------------------------------------------------------------------------
  # draw_dnd_properties_list
  #--------------------------------------------------------------------------
  def draw_dnd_properties_list
    #puts "Draw dnd proprttires"
    contents.font.size = YEA::STATUS::PROPERTIES_FONT_SIZE
    draw_properties_column4
    draw_properties_column5
    draw_properties_column6
    reset_font_settings
  end
  
  
  #--------------------------------------------------------------------------
  # draw_properties_column1
  #--------------------------------------------------------------------------
  def draw_properties_column1
    dx = 24
    dw = (contents.width - 24) / 3 - 24
    dy = 0
    for property in YEA::STATUS::PROPERTIES_COLUMN1
	  dy = draw_property(property, dx, dy, dw)
    end
  end
  #--------------------------------------------------------------------------
  # draw_properties_column2
  #--------------------------------------------------------------------------
  def draw_properties_column2
    dx = 24 + (contents.width - 24) / 3
    dw = (contents.width - 24) / 3 - 24
    dy = 0
    for property in YEA::STATUS::PROPERTIES_COLUMN2
      
      if property[0] == :crafting_level
        crafting_property = []
        crafting_property.push(:crafting_level)
        
        case @actor.id
        when 1
          crafting_property.push("Alchemy Level")
          dy = draw_property(crafting_property, dx, dy, dw)
        when 2
          crafting_property.push("Smithing Level")
          dy = draw_property(crafting_property, dx, dy, dw)
        when 4
          crafting_property.push("Cooking Level")
          dy = draw_property(crafting_property, dx, dy, dw)
        when 5
          crafting_property.push("Flying Level")
          dy = draw_property(crafting_property, dx, dy, dw)
        when 6
          crafting_property.push("Crafting Level")
          dy = draw_property(crafting_property, dx, dy, dw)
        when 7
          crafting_property.push("Taming Level")
          dy = draw_property(crafting_property, dx, dy, dw)
        end
        next
      end
      dy = draw_property(property, dx, dy, dw)
    end
  end
  #--------------------------------------------------------------------------
  # draw_properties_column3
  #--------------------------------------------------------------------------
  def draw_properties_column3
    dx = 24 + (contents.width - 24) / 3 * 2
    dw = (contents.width - 24) / 3 - 24
    dy = 0
    for property in YEA::STATUS::PROPERTIES_COLUMN3
      dy = draw_property(property, dx, dy, dw)
    end
  end
  
  #--------------------------------------------------------------------------
  # draw_properties_column4
  #--------------------------------------------------------------------------
  def draw_properties_column4
    dx = 24
    dw = (contents.width - 24) / 3 - 24
    dy = 0
    for property in YEA::STATUS::PROPERTIES_COLUMN4
	  dy = draw_property(property, dx, dy, dw)
    end
  end
  #--------------------------------------------------------------------------
  # draw_properties_column5
  #--------------------------------------------------------------------------
  def draw_properties_column5
    dx = 24 + (contents.width - 24) / 3
    dw = (contents.width - 24) / 3 - 24
    dy = 0
    for property in YEA::STATUS::PROPERTIES_COLUMN5
      dy = draw_property(property, dx, dy, dw)
    end
  end
  #--------------------------------------------------------------------------
  # draw_properties_column6
  #--------------------------------------------------------------------------
  def draw_properties_column6
    dx = 24 + (contents.width - 24) / 3 * 2
    dw = (contents.width - 24) / 3 - 24
    dy = 0
    for property in YEA::STATUS::PROPERTIES_COLUMN6
      dy = draw_property(property, dx, dy, dw)
    end
  end
  #--------------------------------------------------------------------------
  # draw_property
  #--------------------------------------------------------------------------
  def draw_property(property, dx, dy, dw)
    fmt = "%1.2f%%"
    dmt = "%d"
    case property[0]
    #---
    when :thac0
      value = sprintf(dmt, @actor.attack_bonus)
    when :ac
      value = sprintf(dmt, @actor.armor_class)
    #---
    else; return dy
    end
    colour = Color.new(0, 0, 0, translucent_alpha/2)
    rect = Rect.new(dx+1, dy+1, dw-2, line_height-2)
    contents.fill_rect(rect, colour)
    change_color(system_color)
    draw_text(dx+4, dy, dw-8, line_height, property[1], 0)
    change_color(normal_color)
    draw_text(dx+4, dy, dw - 8, line_height, value, 2)
    return dy + line_height
  end
  #--------------------------------------------------------------------------
  # draw_actor_biography
  #--------------------------------------------------------------------------
  def draw_actor_biography
    fmt = YEA::STATUS::BIOGRAPHY_NICKNAME_TEXT
    text = sprintf(fmt, @actor.name, @actor.nickname)
    contents.font.size = YEA::STATUS::BIOGRAPHY_NICKNAME_SIZE
    draw_text(0, 0, contents.width, line_height*2, text, 1)
    reset_font_settings
    
    draw_text_ex(24, line_height*2, @actor.description)
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
  end
  #--------------------------------------------------------------------------
  # draw_custom
  #--------------------------------------------------------------------------
  def draw_custom
    current_symbol = @command_window.current_symbol
    return unless YEA::STATUS::CUSTOM_STATUS_COMMANDS.include?(current_symbol)
    method(YEA::STATUS::CUSTOM_STATUS_COMMANDS[current_symbol][3]).call
  end
  #--------------------------------------------------------------------------
  # draw_custom1
  #--------------------------------------------------------------------------
  def draw_custom1
    dx = 0; dy = 0
    for skill in @actor.skills
	  next if skill.nil?
	  next unless @actor.added_skill_types.include?(skill.stype_id)
	  draw_item_name(skill, dx, dy)
	  dx = dx == contents.width / 2 + 16 ? 0 : contents.width / 2 + 16
	  dy += line_height if dx == 0
	  return if dy + line_height > contents.height
    
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
    end
  end
  #--------------------------------------------------------------------------
  # draw_custom2
  #--------------------------------------------------------------------------
  def draw_custom2
    dx = 4; dy = 0; slot_id = 0
    for equip in @actor.equips
	  change_color(system_color)
	  text = Vocab.etype(@actor.equip_slots[slot_id])
	  draw_text(dx, dy, contents.width - dx, line_height, text)
	  reset_font_settings
	  draw_item_name(equip, dx+92, dy) unless equip.nil?
	  slot_id += 1
	  dy += line_height
	  break if dy + line_height > contents.height
    end
    dw = Graphics.width * 2 / 5 - 24
    dx = contents.width - dw; dy = 0
    param_id = 0
    8.times do
	  colour = Color.new(0, 0, 0, translucent_alpha/2)
	  rect = Rect.new(dx+1, dy+1, dw - 2, line_height - 2)
	  contents.fill_rect(rect, colour)
	  size = $imported["YEA-AceEquipEngine"] ? YEA::EQUIP::STATUS_FONT_SIZE : 20
	  contents.font.size = size
	  change_color(system_color)
	  draw_text(dx+4, dy, dw, line_height, Vocab::param(param_id))
	  change_color(normal_color)
	  dwa = (Graphics.width * 2 / 5 - 2) / 2
	  draw_text(dx, dy, dwa, line_height, @actor.param(param_id).group, 2)
	  reset_font_settings
	  change_color(system_color)
	  draw_text(dx + dwa, dy, 22, line_height, "→", 1)
	  param_id += 1
	  dy += line_height
	  break if dy + line_height > contents.height
    unless @element_window.nil?
      @element_window.opacity = 0
      @element_window.contents_opacity = 0
      @element_window.back_opacity = 0
    end
    end
  end
  #--------------------------------------------------------------------------
  # draw_custom3
  #--------------------------------------------------------------------------
  def draw_custom3
    return unless $imported["YEA-ClassSystem"]
    data = []
    for class_id in YEA::CLASS_SYSTEM::CLASS_ORDER
	  next if $data_classes[class_id].nil?
	  item = $data_classes[class_id]
	  next unless @actor.unlocked_classes.include?(item.id) or
	    YEA::CLASS_SYSTEM::DEFAULT_UNLOCKS.include?(item.id)
	  data.push(item)
    end
    dx = 0; dy = 0; class_index = 0
    for class_id in data
	  item = data[class_index]
	  reset_font_settings
	  if item == @actor.class
	    change_color(text_color(YEA::CLASS_SYSTEM::CURRENT_CLASS_COLOUR))
	  elsif item == @actor.subclass
	    change_color(text_color(YEA::CLASS_SYSTEM::SUBCLASS_COLOUR))
	  else
	    change_color(normal_color)
	  end
	  icon = item.icon_index
	  draw_icon(icon, dx, dy)
	  text = item.name
	  draw_text(24, dy, contents.width-24, line_height, text)
	  next if YEA::CLASS_SYSTEM::MAINTAIN_LEVELS
    
	  level = @actor.class_level[item.id]
    
	  contents.font.size = YEA::CLASS_SYSTEM::LEVEL_FONT_SIZE
	  text = sprintf(YEA::CLASS_SYSTEM::CLASS_LEVEL, level.group)
	  dwa = contents.width - (Graphics.width * 2 / 5 - 24) - 28
	  draw_text(dx, dy, dwa, line_height, text, 2)
	  class_index += 1
	  dy += line_height
	  break if dy + line_height > contents.height
    end
    dw = Graphics.width * 2 / 5 - 24
    dx = contents.width - dw; dy = 0
    param_id = 0
    8.times do
	  colour = Color.new(0, 0, 0, translucent_alpha/2)
	  rect = Rect.new(dx+1, dy+1, dw - 2, line_height - 2)
	  contents.fill_rect(rect, colour)
	  contents.font.size = YEA::CLASS_SYSTEM::PARAM_FONT_SIZE
	  change_color(system_color)
	  draw_text(dx+4, dy, dw, line_height, Vocab::param(param_id))
	  change_color(normal_color)
	  dwa = (Graphics.width * 2 / 5 - 2) / 2
	  draw_text(dx, dy, dwa, line_height, @actor.param(param_id).group, 2)
	  reset_font_settings
	  change_color(system_color)
	  draw_text(dx + dwa, dy, 22, line_height, "→", 1)
	  param_id += 1
	  dy += line_height
	  break if dy + line_height > contents.height
unless @element_window.nil?
@element_window.opacity = 0
@element_window.contents_opacity = 0
@element_window.back_opacity = 0
@opacity = 255
end
    end
  end
end # Window_StatusItem
#==============================================================================
# ▼ Window_ElementStatus
#==============================================================================
class Window_ElementStatus < Window_Selectable
  def initialize(x, y, width, height)
    super(x, y, width, height)
    @opacity = 255
  end
  def actor=(actor)
    return if @actor == actor
    @actor = actor
    refresh
  end
  def ignore_list
    Status_Element::Ignore
  end
  def include?(item)
    return true unless item.nil? || item.empty? || ignore_list.include?(item)
  end
  def item_max
    @data ? @data.size : 1
  end
  def make_item_list
    @data = $data_system.elements.select {|item| include?(item) }
    @data.push(nil) if include?(nil)
  end
  def element_info(item)
    Status_Element::Elements[item]
  end
  def attack_icon
    Status_Element::Attack_Icon
  end
  def resist_icon
    Status_Element::Resist_Icon
  end
  def element_resist(element_id)
    if $imported["Elemental_Modifiers"]
	  element_rate = @actor.element_resist_rate(element_id)
    else
	  element_rate = @actor.element_rate(element_id)
    end
    resist = "%d%" %[0 + (element_rate*100 - 100) * -1.to_i]
    return resist
  end
  def element_damage(element_id)
    if $imported["Elemental_Modifiers"]
	  element_rate = @actor.element_attack_rate(element_id)
    else
	  element_rate = @actor.element_rate(element_id)
    end
    resist = "%d%" %[0 + (element_rate*100 - 100).to_i]
    return resist
  end
  def draw_item(index)
    item = @data[index]
    if item
	  info = element_info(item)
	  icon_index = info
	  rect = item_rect(index)
	  rect.width -= 4
	  draw_icon(icon_index, rect.x, rect.y) if icon_index
	  draw_text(rect.x + 32, rect.y, 172, line_height, item)
	  draw_icon(attack_icon, rect.x + 148, rect.y)
	  draw_text(rect.x + 180, rect.y, 172, line_height, element_damage(info))
	  draw_icon(resist_icon, rect.x + 252, rect.y)
	  draw_text(rect.x + 284, rect.y, 172, line_height, element_resist(info))
    end
  end
  def refresh
    make_item_list
    contents.clear
    draw_all_items
  end
  def slide_speed
    10
  end
  def show
#~	 self.opacity = 255
#~	   self.contents_opacity = 255
#~	   self.back_opacity = 255
@opacity = 255
  end
  def hide
#~	   self.opacity = 0
#~	   self.contents_opacity = 0
#~	   self.back_opacity = 0
@opacity = 255
    end
end  # Window_ElementStatus
#==============================================================================
# ■ Scene_Status
#==============================================================================
class Scene_Status < Scene_MenuBase
  #--------------------------------------------------------------------------
  include WALLPAPER_EX
  #--------------------------------------------------------------------------
  # * start
  #--------------------------------------------------------------------------
  def start
    super
    create_help_window
    create_command_window
    create_status_window
    create_item_window
    relocate_windows
  end
  #--------------------------------------------------------------------------
  def on_status_ok
    @element_window.show
    @element_window.activate   
  end
  #--------------------------------------------------------------------------
  def on_element_cancel
    @element_window.hide
    @status_window.activate
  end
  #--------------------------------------------------------------------------
  # create_command_window
  #--------------------------------------------------------------------------
  def create_command_window
    wy = @help_window.height
    @command_window = Window_StatusCommand.new(0, wy)
    @command_window.viewport = @viewport
    @command_window.actor = @actor
    @command_window.help_window = @help_window
    @command_window.set_handler(:cancel,   method(:return_scene))
    @command_window.set_handler(:pagedown, method(:next_actor))
    @command_window.set_handler(:pageup,   method(:prev_actor))
    process_custom_status_commands
  end
  #--------------------------------------------------------------------------
  # process_custom_status_commands
  #--------------------------------------------------------------------------
  def process_custom_status_commands
    for command in YEA::STATUS::COMMANDS
	  next unless YEA::STATUS::CUSTOM_STATUS_COMMANDS.include?(command[0])
	  called_method = YEA::STATUS::CUSTOM_STATUS_COMMANDS[command[0]][2]
	  @command_window.set_handler(command[0], method(called_method))
    end
  end
  #--------------------------------------------------------------------------
  # create_status_window
  #--------------------------------------------------------------------------
  def create_status_window
    wy = @help_window.height
    @status_window = Window_StatusActor.new(@command_window.width, wy)
    @status_window.viewport = @viewport
    @status_window.actor = @actor
  end
  #--------------------------------------------------------------------------
  # create_item_window
  #--------------------------------------------------------------------------
  def create_item_window
    dy = @command_window.y + @command_window.height
    @item_window = Window_StatusItem.new(0, dy, @command_window)
    @item_window.viewport = @viewport
    @item_window.actor = @actor
    @command_window.item_window = @item_window
  end
  #--------------------------------------------------------------------------
  # relocate_windows
  #--------------------------------------------------------------------------
  def relocate_windows
    return unless $imported["YEA-AceMenuEngine"]
    case Menu.help_window_location
    when 0 # Top
	  @help_window.y = 0
	  @command_window.y = @help_window.height
	  @item_window.y = @command_window.y + @command_window.height
    when 1 # Middle
	  @command_window.y = 0
	  @help_window.y = @command_window.height
	  @item_window.y = @help_window.y + @help_window.height
    else # Bottom
	  @command_window.y = 0
	  @item_window.y = @command_window.height
	  @help_window.y = @item_window.y + @item_window.height
    end
    @status_window.y = @command_window.y
  end
  #--------------------------------------------------------------------------
  # on_actor_change
  #--------------------------------------------------------------------------
  def on_actor_change
    @command_window.actor = @actor
    @status_window.actor = @actor
    @item_window.actor = @actor
    @command_window.activate
  end
  #--------------------------------------------------------------------------
  # new method: command_name1
  #--------------------------------------------------------------------------
  def command_name1
    SceneManager.call(Scene_Skill)
  end
  #--------------------------------------------------------------------------
  # new method: command_name2
  #--------------------------------------------------------------------------
  def command_name2
    SceneManager.call(Scene_Equip)
  end
  #--------------------------------------------------------------------------
  # new method: command_name3
  #--------------------------------------------------------------------------
  def command_name3
    unless $imported["YEA-ClassSystem"]
	  @command_window.activate
	  return
    end
    SceneManager.call(Scene_Class)
  end
end # Scene_Status
#==============================================================================
#
# ▼ End of File
#
#==============================================================================

#==============================================================================
# ■ Window_StatusCommand
#==============================================================================
class Window_StatusCommand < Window_Command
  #-----------------------------------------------------------------------------
  MouseTimer = 5
  #-----------------------------------------------------------------------------
  def get_mouse_timer
    return MouseTimer
  end
  #-----------------------------------------------------------------------------
end
#==============================================================================
# ■ Window_StatusItem
#==============================================================================
class Window_StatusItem < Window_Base
  #-----------------------------------------------------------------------------
  attr_accessor :skillbar
  #--------------------------------------------------------------------------
  # * alias method : initialize
  #--------------------------------------------------------------------------
  alias init_skillbar initialize
  def initialize(dx, dy, command_window)
    create_skillbar
    init_skillbar(dx, dy, command_window)
  end
  #--------------------------------------------------------------------------
  # * Create skillbar instance
  #--------------------------------------------------------------------------
  def create_skillbar
    @skillbar = $game_party.skillbar
    @skillbar.create_layout(SceneManager.viewport, 1)
    @skillbar.hide
  end
  #--------------------------------------------------------------------------
  # * alias: refresh
  #--------------------------------------------------------------------------
  alias refresh_skillbar refresh
  def refresh
    ori_opa = self.opacity
    @skillbar.hide
    refresh_skillbar
    self.opacity = ori_opa
  end
  #--------------------------------------------------------------------------
  # * alias method: draw actor general
  #--------------------------------------------------------------------------
  alias draw_actor_general_skillbar draw_actor_general
  def draw_actor_general
    @skillbar.show
    @skillbar.z = self.z + 1
    @skillbar.refresh(@actor)
    draw_actor_general_skillbar
  end
  #--------------------------------------------------------------------------
  # * Draw current setting of tactic logic
  #--------------------------------------------------------------------------
  def draw_tactic_overview
  end # queued: tactics AI
  #--------------------------------------------------------------------------
  # * dispose window
  #--------------------------------------------------------------------------
  def dispose
    @skillbar.dispose_layout
    super
  end
  #-----------------------------------------------------------------------------
end
#==============================================================================
# ■ Scene_Status
#==============================================================================
class Scene_Status < Scene_MenuBase
  #--------------------------------------------------------------------------
  alias start_scstat start
  def start
    start_scstat
    @skillbar = @item_window.skillbar
    create_foreground
  end
  #--------------------------------------------------------------------------
  alias update_scstat_skillbar update
  def update
    update_scstat_skillbar
    return unless @skillbar.edit_enabled
    @skillbar.update
    on_edit_end
  end
  #--------------------------------------------------------------------------
  def create_foreground
    @foreground = Sprite.new(@viewport)
    @foreground.bitmap = Bitmap.new(Graphics.width, Graphics.height)
    wy = @help_window.height
    @foreground.bitmap.fill_rect(0, wy, Graphics.width, Graphics.height - wy, DND::COLOR::Black)
    cx = @skillbar.x + 32 * 4
    cy = @skillbar.y - 2
    crect = Rect.new(cx, cy, 32 * HotKeys::HotKeys.size, 32)
    @foreground.bitmap.clear_rect(crect)
    @foreground.z = PONY::SpriteDepth::Table[:foreground]
    @foreground.opacity = 196
    @foreground.hide
  end
  #--------------------------------------------------------------------------
  # * Activate edit mode of skillbar
  #--------------------------------------------------------------------------
  def edit_skillbar
    return unless @skillbar
    @skillbar.edit_enabled = true
    @help_window.set_text(Vocab::Skillbar::MouseEdit)
    @foreground.show
  end
  #--------------------------------------------------------------------------
  def on_edit_end
    return unless Input.trigger?(:B)
    @skillbar.cancel_edit
    Sound.play_cancel
    @command_window.activate
    @skillbar.unselect
    @foreground.hide
  end
  #--------------------------------------------------------------------------
  def call_tactic_scene
    @command_window.activate
    #raise_overlay_window(:popinfo, "Not available yet!")
    SceneManager.call(Scene_Tactic)
  end
  #--------------------------------------------------------------------------
  alias terminate_scstat terminate
  def terminate
    @foreground.dispose
    terminate_scstat
  end
  
end

#==============================================================================
# +++ MOG - Animated Title A (v2.4) +++
#==============================================================================
# By Moghunter 
# https://atelierrgss.wordpress.com/
#==============================================================================
# Tela de titulo animado, com logo, imagens aleatórias e outros efeitos visuais.
#==============================================================================
#==============================================================================
# IMAGENS NECESSÁRIAS
#==============================================================================
# Serão necessários as seguintes imagens na pasta Graphics/Titles2/
#
# Cursor.png   
# Commmand_Name.png (image filename = name of command)
# Particle.png   (Opcional)
# Logo.jpg       (Opcional)
# Animated.png   (Opcional)
#==============================================================================
#==============================================================================
# NOTA 1 - Para definir a imagem de texto basta selecionar no banco de dados
# a imagem do titulo numero 2 (Segunda camada)
#==============================================================================
#==============================================================================
# NOTA 2 - O nome da imagem de comando é iguál ao nome do comando definido
# no banco de dados do Rpg Maker.
#==============================================================================
#==============================================================================
# ● Histórico (Version History)
#==============================================================================
# v 2.4 - Compatibilidade com resoluções acima do padrão.
# v 2.3 - O nome do comando não é mais baseado no database. 
#==============================================================================
module MOG_SCENE_TITLE_A
  #--------------------------------------------------------------------------
  # ▼ LOGO ▼
  #--------------------------------------------------------------------------
  # Apresenta um Logo ao começar a tela de titulo.
  # Será necessário ter a imagem LOGO.jpg (png) na pasta Graphics/Title2
  #--------------------------------------------------------------------------
  # Ativar Logo
  LOGO = true
  # Duração do logo.
  LOGO_DURATION = 2 #(Sec)
  
  #--------------------------------------------------------------------------
  # ▼ RANDOM BACKGROUND ▼
  #--------------------------------------------------------------------------  
  #Definição das pictures. 
  #--------------------------------------------------------------------------
  RANDOM_PICTURES = [
  "Title0"#, "Title1", "Title2", "Title3"  
  #"Title4","Title5","Title6","Title7"
  ]
  #Tempo de duração para ativar a troca de imagens.
  RANDOM_PICTURES_DURATION = 10#(sec)
  #Seleção aleatória.
  RAMDOM_SELECTION = true
  #Velocidade de Scrolling. (Speed X , Speed Y)
  RANDOM_PICTURES_SCROLL_SPEED = [0,0]
  
  #--------------------------------------------------------------------------
  # ▼ MULTIPLE LAYERS ▼
  #--------------------------------------------------------------------------
  # Definição de multiplas camadas. * (não há limíte na quantidade de camadas
  # usadas)
  #--------------------------------------------------------------------------
  # MULTIPLE_LAYERS = [  ["A",B,C,D], ["A",B,C,D], ["A",B,C D], ["A",B,C,D ], ....]
  #
  # A - Nome da imagem.
  # B - Velocidade de scroll na horizontal.
  # C - Velocidade de scroll na vertical.
  # D - Tipo de Blend. (0 - Normal / 2 - Add / 3 - Substract)
  #
  MULTIPLE_LAYERS = [
  ["Layer1",1,0,1],
  ["Layer2",3,0,1],   
#  ["Layer3",0,0,0]
#  ["Layer4",0,0,0],
#  ["Layer5",0,0,0],
#  ["Layer6",0,0,0]
  ]  
  
  #--------------------------------------------------------------------------
  # ▼ PARTICLES ▼
  #--------------------------------------------------------------------------
  # Adiciona partículas animadas na tela do titulo.
  # Será necessário ter a imagem PARTICLE.png na pasta Graphics/Title2
  #--------------------------------------------------------------------------
  # Ativar Partículas.
  PARTICLE = true
  # Ativar Cores Aleatórias.
  PARTICLE_RANDOM_COLOR = true  
  # Definição do tipo de blend. (0,1,2)
  PARTICLE_BLEND_TYPE = 1
  #Definição do limite de velocidade das partículas.
  PARTICLE_MOVEMENT_RANGE_X = 3
  PARTICLE_MOVEMENT_RANGE_Y = 3
  PARTICLE_ANGLE_RANGE = 3
  
  #--------------------------------------------------------------------------
  # ▼ WAVE TITLE ▼
  #--------------------------------------------------------------------------  
  # Ativa o efeito  WAVE no texto do titulo, o Texto do titulo é definido
  # na camada do titulo 2, que pode ser definido através do banco de dados
  #--------------------------------------------------------------------------    
  #Ativar o efeito do titulo com efeito WAVE.
  TITLE_WAVE = true
  #Configuração do efeito WAVE
  #
  # TITLE_WAVE_CONFIG = [ AMP, LENGTH , SPEED]
  #
  TITLE_WAVE_CONFIG = [1 , 10 , 20]
  
  #--------------------------------------------------------------------------
  # ▼ ANIMATED_SPRITE ▼ (Opcional)
  #--------------------------------------------------------------------------
  # Adiciona um sprite animado no titulo.
  # A quantidade de frames é proporcional a largura dividido pela altura
  # da imagem, ou seja, não há limite de quantidade de frames e nem de 
  # tamanho da imagem.
  # Será necessário ter a imagem ANIMATED.png (Jpg) na pasta Graphics/Title2
  #--------------------------------------------------------------------------
  # Ativar Sprite animado.
  ANIMATED_SPRITE = false
  # Posição do Sprite animado.
  ANIMATED_SPRITE_POSITION = [130,150]
  # Velocidade da animação
  ANIMATED_SPRITE_SPEED = 10
  # Tipo de Blend. (0 - Normal / 2 - Add / 3 - Substract)
  ANIMATED_SPRITE_BLEND_TYPE = 1
  # Definição do zoom,
  ANIMATED_SPRITE_ZOOM = 1.5
  
  
  #--------------------------------------------------------------------------
  # ▼ COMMANDS / SELECTION ▼
  #--------------------------------------------------------------------------
  # Configuração extras da tela de titulo.
  #--------------------------------------------------------------------------
  # Posição do comando.
  COMMANDS_POS = [250 , 150]
  # Ativar o efeito de tremor ao selecionar o comando.
  COMMAND_SHAKE = true
  # Definição da posição do cursor.(Para ajustes)
  CURSOR_POS = [-32,-7]
  # Ativar flash ao mover o comando.
  CURSOR_FLASH_SELECTION = true
  # Definição da posição do flash.
  CURSOR_FLASH_SLECTION_POS = [-250,0]
  # Tipo de Blend. (0 - Normal / 2 - Add / 3 - Substract)
  CURSOR_FLASH_SLECTION_BLEND_TYPE = 1
  
end
#==============================================================================
# ■ Window TitleCommand
#==============================================================================
class Window_TitleCommand < Window_Command
  attr_reader :list
end
#==============================================================================
# ■ Particle Title
#==============================================================================
class Particle_Title < Sprite
  
  include MOG_SCENE_TITLE_A
  
 #--------------------------------------------------------------------------
 # ● Initialize
 #--------------------------------------------------------------------------             
  def initialize(viewport = nil)
      super(viewport)
      self.bitmap = Cache.title2("Particle")
      self.tone.set(rand(255),rand(255), rand(255), 255) if PARTICLE_RANDOM_COLOR
      self.blend_type = PARTICLE_BLEND_TYPE
      self.z = 50
      @sc_x = [self.bitmap.width / 2, self.bitmap.width, Graphics.width ]
      @sc_y = [self.bitmap.height / 2, self.bitmap.height, Graphics.height ] 
      
      @cw0 = self.bitmap.width / 2 ; @ch0 = self.bitmap.height / 2
      @cw = self.bitmap.width + @cw0 ; @cw2 = Graphics.width
      @ch = self.bitmap.height + @ch0 ; @ch2 = Graphics.height
      
      @nx = PARTICLE_MOVEMENT_RANGE_X
      @ny = PARTICLE_MOVEMENT_RANGE_Y
      reset_setting
  end  
  
 #--------------------------------------------------------------------------
 # ● Reset Setting
 #--------------------------------------------------------------------------               
  def reset_setting
      zoom = (50 + rand(100)) / 100.1
      self.zoom_x = zoom
      self.zoom_y = zoom
      self.x = (rand(@cw2 + 32) -32)
      self.y = rand((@ch2 + 32) + @ch) 
      self.opacity = 0
      self.angle = rand(360)
      nx2 = rand(@nx).abs
      nx2 = 1 if (@nx != 0 and nx2 < 1)      
      @speed_x = @nx > 0 ? nx2 : @nx < 0 ? -nx2 : 0        
      ny2 = rand(@ny).abs
      ny2 = 1 if (@ny != 0 and ny2 < 1)      
      @speed_y = @ny > 0 ? ny2 : @ny < 0 ? -ny2 : 0   
      @speed_a = [[rand(PARTICLE_ANGLE_RANGE), PARTICLE_ANGLE_RANGE].min, 0].max 
  end
  
 #--------------------------------------------------------------------------
 # ● Dispose
 #--------------------------------------------------------------------------               
  def dispose
      super
      self.bitmap.dispose
  end  
  
 #--------------------------------------------------------------------------
 # ● Update
 #--------------------------------------------------------------------------               
  def update
    return if disposed?
      super
      self.x += @speed_x
      self.y -= @speed_y
      self.angle += @speed_a      
      self.opacity += 5
      reset_setting if can_reset_setting?
  end  
  
 #--------------------------------------------------------------------------
 # ● Can Reset Setting
 #--------------------------------------------------------------------------                 
  def can_reset_setting?
      return true if (self.x < -(@cw * 2) or self.x > (@cw2 + @cw))    
      return true if (self.y < -(@ch * 2) or self.y > (@ch2 + @ch))
      return false
  end  
end
#==============================================================================
# ■ Multiple Layers Title
#==============================================================================
class Multiple_Layers_Title
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------  
  def initialize(name = "", scroll_x = 0, scroll_y = 0, blend = 0, index = 0)
      @layer = Plane.new
      @layer.bitmap = Cache.title1(name.to_s) rescue nil
      @layer.bitmap = Bitmap.new(32,32) if @layer.bitmap == nil
      @layer.z = 10 + index
      @layer.opacity = 0
      @layer.blend_type = blend
      @scroll_speed = [scroll_x, scroll_y]
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose
  #--------------------------------------------------------------------------  
  def dispose
      @layer.bitmap.dispose
      @layer.bitmap = nil
      @layer.dispose
  end
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------  
  def update
      @layer.opacity += 2
      @layer.ox += @scroll_speed[0]
      @layer.oy += @scroll_speed[1] 
  end
  
end 
#==============================================================================
# ■ Scene Title
#==============================================================================
class Scene_Title < Scene_Base
 include MOG_SCENE_TITLE_A 
 
 #--------------------------------------------------------------------------
 # ● Start
 #--------------------------------------------------------------------------          
 def start
     super
     #tag: title_start
     create_help_window
     create_mode_window
     create_option_window
     create_language_window
     create_progress_window
     RPG::BGM.fade(2000)
     @logo_active = LOGO
     SceneManager.clear
     @phase = 1
     @phase_time = -1
     dispose_title_sprites
     create_logo if @logo_active
     create_command_window
     create_commands
     create_background
     create_light
     create_cursor
     create_animated_object
     create_flash_select
     create_multiple_layers
     play_title_music unless @logo_active
 end
   
 #--------------------------------------------------------------------------
 # ● Create Multiple Layers
 #--------------------------------------------------------------------------
 def create_flash_select
     return if !CURSOR_FLASH_SELECTION
     @flash_select = Sprite.new
     @flash_select.bitmap = Cache.title2("Cursor2")
     @flash_select.z = 99
     @flash_select.opacity = 0
     @flash_select.blend_type = CURSOR_FLASH_SLECTION_BLEND_TYPE
 end  
 
 #--------------------------------------------------------------------------
 # ● Create Multiple Layers
 #--------------------------------------------------------------------------           
 def create_multiple_layers
     @m_layers = []
     index = 0
     for i in MULTIPLE_LAYERS
         @m_layers.push(Multiple_Layers_Title.new(i[0],i[1],i[2],i[3],index))
         index += 1
     end  
 end
 #--------------------------------------------------------------------------
 # ● Create_Logo
 #--------------------------------------------------------------------------            
 def create_animated_object
      return if !ANIMATED_SPRITE
      @object_index = 0
      @object_animation_speed = 0
      @object = Sprite.new
      @object.z = 98
      @object.opacity = 0
      @object.blend_type = ANIMATED_SPRITE_BLEND_TYPE
      @object.zoom_x = ANIMATED_SPRITE_ZOOM
      @object.zoom_y = ANIMATED_SPRITE_ZOOM
      @object_image = Cache.title2("Animated")
      @object_frame_max = @object_image.width / @object_image.height
      @object_width = @object_image.width / @object_frame_max  
      @object.bitmap = Bitmap.new(@object_width,@object_image.height)
      @object.x = ANIMATED_SPRITE_POSITION[0]
      @object.y = ANIMATED_SPRITE_POSITION[1]     
      make_object_bitmap
 end  
 
 #--------------------------------------------------------------------------
 # ● Create_Logo
 #--------------------------------------------------------------------------           
 def create_cursor
    @cursor = Sprite.new
     @cursor.bitmap = Cache.title2("Cursor")
     @cursor.opacity = 0
     @cursor.z = 130
     @cursor_position = [0,0]
     @mx = [0,0,0]
 end 
 
 #--------------------------------------------------------------------------
 # ● Create_Logo
 #--------------------------------------------------------------------------           
 def create_logo
     @phase = 0
     @logo = Sprite.new
     @logo.bitmap = Cache.title2("Logo")
     @logo.opacity = 0
     @logo_duration = 180 + (LOGO_DURATION * 60)
     @logo.z = 200
 end
 
  #--------------------------------------------------------------------------
  # ● Create Commands
  #--------------------------------------------------------------------------           
  def create_commands
    
    @command_window.visible = false
    @commands_index_old = -1
    @commands = []
    @commands_shake_duration = 0
    index = 0
  
    for com in 0...@command_window.item_max
      sprite = Sprite.new
      case index
        when 0; com_name = "Continue"
        when 1; com_name = "New_Game"
        when 2; com_name = "Option"
        when 3; com_name = "Credits"
        when 4; com_name = "Shutdown"
      end
      sprite.bitmap = Cache.title2(com_name.to_s) rescue nil
      if sprite.bitmap == nil
        sprite.bitmap = Bitmap.new(200,26)
        sprite.bitmap.font.size = 24
        sprite.bitmap.font.bold = true
        sprite.bitmap.font.italic = true
        sprite.bitmap.draw_text(0, 0, 200, 26, com_name.to_s,1)
      end
      sprite.x = COMMANDS_POS[0] - 100
      sprite.y = index * sprite.bitmap.height + COMMANDS_POS[1]
      sprite.z = 100 + index
      sprite.opacity = 0
      index += 1
      @commands.push(sprite)
    end # for command 
    
    @command_max = index  
  end
  
  #--------------------------------------------------------------------------
  # ● create_background
  #--------------------------------------------------------------------------
  def create_background
      @rand_title_duration = 120
      @old_back_index = 0
      @sprite1 = Plane.new
      @sprite1.opacity = 0
      @sprite1.z = 1
      if RAMDOM_SELECTION
         execute_random_picture(false)
      else
         execute_random_picture(true)
      end
      @sprite2 = Sprite.new
      @sprite2.bitmap = Cache.title2($data_system.title2_name)
      @sprite2.z = 140
      @sprite2.opacity = 0
      if TITLE_WAVE
          @sprite2.wave_amp = TITLE_WAVE_CONFIG[0]
          @sprite2.wave_length = TITLE_WAVE_CONFIG[1]
          @sprite2.wave_speed = TITLE_WAVE_CONFIG[2]
      end    
  end
  
  #--------------------------------------------------------------------------
  # ● Create Light
  #--------------------------------------------------------------------------  
  def create_light
      return unless PARTICLE
      @light_bitmap =[]
      for i in 0...20
          @light_bitmap.push(Particle_Title.new(nil))
      end  
  end
    
  #--------------------------------------------------------------------------
  # ● dispose Background1
  #--------------------------------------------------------------------------
  def dispose_background1
    @sprite1.bitmap.dispose
    #@sprite1.bitmap = nil
    @sprite1.dispose
    @sprite1 = nil
  end
  
 #--------------------------------------------------------------------------
 # ● Dispose Background2
 #--------------------------------------------------------------------------                
  def dispose_background2
    return if @sprite2.disposed?
      if @sprite2.bitmap != nil
         @sprite2.bitmap.dispose
         @sprite2.bitmap = nil
         @sprite2.dispose
         @sprite2 = nil
      end
  end
    
 #--------------------------------------------------------------------------
 # ● Dispose Light
 #--------------------------------------------------------------------------              
  def dispose_light
      return unless PARTICLE
      if @light_bitmap != nil
         for i in @light_bitmap
             i.dispose
         end
         @light_bitmap = nil
      end
  end    
  
 #--------------------------------------------------------------------------
 # ● Dispose Logo
 #--------------------------------------------------------------------------             
 def dispose_logo
     return unless @logo_active
     @logo.bitmap.dispose
     @logo.dispose
 end  
  
 #--------------------------------------------------------------------------
 # ● Dispose Multiple Layers
 #--------------------------------------------------------------------------                          
 def dispose_multiple_layers
     return if @m_layers == nil
     @m_layers.each {|layer| layer.dispose }
 end 
 
 #--------------------------------------------------------------------------
 # ● Terminate
 #--------------------------------------------------------------------------            
 def terminate
     super
     dispose_title_sprites     
 end  
 
 #--------------------------------------------------------------------------
 # ● Dispose Title Sprites
 #--------------------------------------------------------------------------             
 def dispose_title_sprites
     return if @cursor == nil
     dispose_background1
     dispose_background2
     dispose_light
     dispose_logo
     dispose_multiple_layers
     @cursor.bitmap.dispose
     @cursor.dispose
     @cursor = nil
     if @flash_select != nil
        @flash_select.bitmap.dispose
        @flash_select.dispose
     end   
     for com in @commands
         com.bitmap.dispose
         com.dispose
     end
     if ANIMATED_SPRITE
        @object.bitmap.dispose
        @object.dispose
        @object_image.dispose
     end         
 end
   
 #--------------------------------------------------------------------------
 # ● Update
 #--------------------------------------------------------------------------             
 def update
     super
     update_mouse_selection
     update_logo
     update_initial_animation
     update_command
     update_background
     update_light
     update_object_animation
     update_multiple_layers
 end
 
 #--------------------------------------------------------------------------
 # ● Update Multiple Layers
 #--------------------------------------------------------------------------                          
 def update_multiple_layers
     return if @m_layers == nil
     @m_layers.each {|layer| layer.update }
 end
   
 #--------------------------------------------------------------------------
 # ● Make Object bitmap
 #--------------------------------------------------------------------------                         
  def make_object_bitmap
      @object.bitmap.clear
      src_rect_back = Rect.new(@object_width * @object_index, 0,@object_width,@object_image.height)
      @object.bitmap.blt(0,0, @object_image, src_rect_back)  
  end
    
 #--------------------------------------------------------------------------
 # ● Update Object Animation
 #--------------------------------------------------------------------------                       
  def update_object_animation
      return if !ANIMATED_SPRITE 
      @object.opacity += 2
      @object_animation_speed += 1
      if @object_animation_speed > ANIMATED_SPRITE_SPEED
         @object_animation_speed = 0
         @object_index += 1
         @object_index = 0 if @object_index >= @object_frame_max
         make_object_bitmap    
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Update Cursor Position
  #--------------------------------------------------------------------------            
  def update_cursor_position
    return if @cursor.disposed?
    @cursor.opacity += 5
    execute_animation_s
    execute_cursor_move(0,@cursor.x,@cursor_position[0] + @mx[1])
    execute_cursor_move(1,@cursor.y,@cursor_position[1])
  end
  #--------------------------------------------------------------------------
  # * Update Mouse Selection
  # tag: modified
  #--------------------------------------------------------------------------
  def update_mouse_selection
    return if Mouse.nil?
    return unless Mouse.moved?
    return unless @command_window.active?
    for i in 0...@commands.size
      sprite = @commands[i]
      if Mouse.collide_sprite?(sprite)
        Sound.play_cursor if @command_window.index != i
        @command_window.select(i)
      end
    end
  end
  #--------------------------------------------------------------------------
  # ● Execute Animation S
  #--------------------------------------------------------------------------      
  def execute_animation_s
      @mx[2] += 1
      return if @mx[2] < 4
      @mx[2] = 0
      @mx[0] += 1
      case @mx[0]
         when 1..7;  @mx[1] += 1            
         when 8..14; @mx[1] -= 1
         else
           @mx[0] = 0
           @mx[1] = 0
      end
  end
    
  #--------------------------------------------------------------------------
  # ● Execute Cursor Move
  #--------------------------------------------------------------------------      
  def execute_cursor_move(type,cp,np)
      sp = 5 + ((cp - np).abs / 5)
      if cp > np 
         cp -= sp
         cp = np if cp < np
      elsif cp < np 
         cp += sp
         cp = np if cp > np
      end     
      @cursor.x = cp if type == 0
      @cursor.y = cp if type == 1
  end   
 
 #--------------------------------------------------------------------------
 # ● Update Logo
 #--------------------------------------------------------------------------            
 def update_logo
     return if @phase != 0
     loop do
        break if  @logo_duration == 0
        execute_logo 
        Graphics.update
        Input.update
     end
     play_title_music 
 end 
 
 #--------------------------------------------------------------------------
 # ● Execute Logo
 #--------------------------------------------------------------------------             
 def execute_logo
     if @logo_duration > 120 and (Input.trigger?(:C) or Input.trigger?(:B))
        @logo_duration = 120
     end  
     @logo_duration -= 1
     if @logo_duration > 120
        @logo.opacity += 5
     else
        @logo.opacity -= 5
     end
     if @logo.opacity <= 0 
        @logo_duration = 0
        @phase = 1
     end     
 end
   
 #--------------------------------------------------------------------------
 # ● Update Background
 #--------------------------------------------------------------------------              
 def update_background
   return if @sprite2.disposed?
     @sprite1.ox += RANDOM_PICTURES_SCROLL_SPEED[0]
     @sprite1.oy += RANDOM_PICTURES_SCROLL_SPEED[1]
     @sprite2.opacity += 2
     @sprite2.update
     return if RANDOM_PICTURES.size < 1
     @rand_title_duration -= 1
     if @rand_title_duration <= 0
        @sprite1.opacity -= 5 unless RANDOM_PICTURES.size < 2
     else
        @sprite1.opacity += 5
     end   
     return if @sprite1.opacity != 0
     execute_random_picture
 end
 
 #--------------------------------------------------------------------------
 # ● Execute Random Picture
 #--------------------------------------------------------------------------              
 def execute_random_picture(initial = false)
     @rand_title_duration = [[60 * RANDOM_PICTURES_DURATION, 9999].min, 60].max 
     if @sprite1.bitmap != nil
        @sprite1.bitmap.dispose
        @sprite1.bitmap = nil
     end
     if RAMDOM_SELECTION
         rand_pic = rand(RANDOM_PICTURES.size)
         if rand_pic == @old_back_index
            rand_pic += 1
            rand_pic = 0 if rand_pic >= RANDOM_PICTURES.size
         end
         @old_back_index = rand_pic   
     else
         @old_back_index += 1 unless initial
         @old_back_index = 0 if @old_back_index >= RANDOM_PICTURES.size
     end
     pic = RANDOM_PICTURES[@old_back_index]
     @sprite1.bitmap = Cache.title1(pic) rescue nil
     @sprite1.bitmap = Cache.title1("") if @sprite1.bitmap == nil 
 end
   
 #--------------------------------------------------------------------------
 # ● Update Light
 #--------------------------------------------------------------------------              
 def update_light
     return unless PARTICLE
     if @light_bitmap != nil
        for i in @light_bitmap
            i.update
        end  
     end   
 end
    
 #--------------------------------------------------------------------------
 # ● Update Initial Animation
 #--------------------------------------------------------------------------               
 def update_initial_animation
     return if @phase != 1
     @phase_time -= 1 if @phase_time > 0
     if @phase_time == 0
        @phase = 2
        @phase_time = 30
        @command_window.ready = true
     end   
     for i in @commands
        index = 0
        if i.x < COMMANDS_POS[0]
           i.x += 5 + (2 * index)
           i.opacity += 10
           if i.x >= COMMANDS_POS[0]
              i.x = COMMANDS_POS[0]
              i.opacity = 255
              if @phase_time < 15 / 2 
                 @phase_time = 15
              end   
           end  
         end
         index += 1
     end  
 end  
 
 #--------------------------------------------------------------------------
 # ● Update Command
 #--------------------------------------------------------------------------              
 def update_command
     return if @phase != 2   
     update_command_slide
     update_cursor_position
     update_flash_select
 end
 
 #--------------------------------------------------------------------------
 # ● Update Command Slide
 #--------------------------------------------------------------------------               
 def update_command_slide
    return if @commands.any?{|sprite| sprite.disposed?} || @flash_select.disposed?
    
     if @commands_index_old != @command_window.index
        @commands_index_old = @command_window.index
        @commands_shake_duration = 30
        if @flash_select != nil
           @flash_select.opacity = 255
        end   
     end
     return if @commands_shake_duration == 0
     @commands_shake_duration -= 1 if @commands_shake_duration > 0  
     @commands_shake_duration = 0 if !COMMAND_SHAKE
     for i in @commands
       if (i.z - 100) == @command_window.index
          i.opacity += 10
          @cursor_position = [COMMANDS_POS[0] + CURSOR_POS[0],i.y + CURSOR_POS[1]]
          i.x = COMMANDS_POS[0] + rand(@commands_shake_duration)
       else  
          i.opacity -= 7 if i.opacity > 55
          i.x = COMMANDS_POS[0]
       end
     end  
   end
   
 #--------------------------------------------------------------------------
 # ● Update Flash Select
 #--------------------------------------------------------------------------                  
 def update_flash_select
     return if !CURSOR_FLASH_SELECTION || @flash_select.disposed?
     @flash_select.opacity -= 8
     @flash_select.x = @cursor_position[0] + CURSOR_FLASH_SLECTION_POS[0]
     @flash_select.y = @cursor_position[1] + CURSOR_FLASH_SLECTION_POS[1]     
 end
   
end
$mog_rgss3_animated_title_a = true

#==============================================================================
# +++ MOG - Wallpaper EX (V1.1) +++
#==============================================================================
# By Moghunter
# http://www.atelier-rgss.com
#==============================================================================
# - Adiciona um papel de parede e adiciona alguns efeitos animados.
#==============================================================================
# Para mudar de papel de parede no meio do jogo basta usar o código abaixo.
#
# $game_system.wallpaper = "FILE_NAME"
#
#==============================================================================
# E para mudar de velocidade de scroll use o código abaixo.
#
# $game_system.wallpaper_scroll = [ SPEED_X, SPEED_Y]
#
#==============================================================================
# Serão necessários os seguintes arquivos na pasta GRAPHICS/SYSTEM.
# 
# Menu_Particles.png
# wallpaper
#
#==============================================================================
# ● Histórico (Version History)
#==============================================================================
# v 1.1 - Melhoria no sistema de dispose de imagens.
#==============================================================================
#==============================================================================
# ■ Game_System
#==============================================================================
class Game_System
  
  attr_accessor :wallpaper
  attr_accessor :wallpaper_scroll
  
 #--------------------------------------------------------------------------
 # ● Initialize
 #--------------------------------------------------------------------------  
  alias mog_wallpaper_initialize initialize
  def initialize
    mog_wallpaper_initialize
    @wallpaper = "Wallpaper"    
    @wallpaper_scroll = MOG_WALLPAPER_EX::BACKGROUND_SCROLL_SPEED
  end
  
end  
#==============================================================================
# ■ Menu Particles
#==============================================================================
class Menu_Particles < Sprite
  
 #--------------------------------------------------------------------------
 # ● Initialize
 #--------------------------------------------------------------------------             
  def initialize(viewport = nil)
    super(viewport)
    self.bitmap = Cache.system("Menu_Particles")
    reset_setting(true)
  end  
  
 #--------------------------------------------------------------------------
 # ● Reset Setting
 #--------------------------------------------------------------------------               
  def reset_setting(start)
      zoom = (50 + rand(100)) / 100.1
      self.zoom_x = zoom
      self.zoom_y = zoom
      self.x = rand(544)
      if start
         self.y = rand(416 + self.bitmap.height)
      else
         self.y = 416 + rand(32 + self.bitmap.height)
      end        
      self.opacity = 0
      self.blend_type = 1
      @speed_x = 0
      @speed_y = [[rand(3), 3].min, 1].max
      @speed_a = 0#rand(3)
  end
  
 #--------------------------------------------------------------------------
 # ● Dispose
 #--------------------------------------------------------------------------               
  def dispose
      super
      self.bitmap.dispose
  end  
  
 #--------------------------------------------------------------------------
 # ● Update
 #--------------------------------------------------------------------------               
  def update
    super
    self.x += @speed_x
    self.y -= @speed_y
    self.angle += @speed_a      
    self.opacity += 5
    reset_setting(false) if self.y < 0
  end  
  
end
#==============================================================================
# ● Scene Menu
#==============================================================================
class Scene_Menu < Scene_MenuBase
  include WALLPAPER_EX
  
 #--------------------------------------------------------------------------
 # ● Start
 #--------------------------------------------------------------------------                
  alias mog_layout_ex_start start
  def start
      wallpapers = MOG_WALLPAPER_EX::Wallpapers
      $game_system.wallpaper = wallpapers[rand(wallpapers.size)]
      mog_layout_ex_start
      set_window_opacity
  end  
end
#==============================================================================
# ● Scene Item
#==============================================================================
class Scene_Item < Scene_ItemBase
  include WALLPAPER_EX
  
 #--------------------------------------------------------------------------
 # ● Start
 #--------------------------------------------------------------------------                
  alias mog_layout_ex_start start
  def start
      mog_layout_ex_start
      set_window_opacity
  end  
end
#==============================================================================
# ● Scene Skill
#==============================================================================
class Scene_Skill < Scene_ItemBase
  include WALLPAPER_EX
  
 #--------------------------------------------------------------------------
 # ● Start
 #--------------------------------------------------------------------------                
  alias mog_layout_ex_start start
  def start
      mog_layout_ex_start
      set_window_opacity
  end  
end
#==============================================================================
# ● Scene Equip
#==============================================================================
class Scene_Equip < Scene_MenuBase
  include WALLPAPER_EX
  
 #--------------------------------------------------------------------------
 # ● Start
 #--------------------------------------------------------------------------                
  alias mog_layout_ex_start start
  def start
      mog_layout_ex_start
      set_window_opacity
  end  
end
#==============================================================================
# ● Scene Status
#==============================================================================
class Scene_Status < Scene_MenuBase
  include WALLPAPER_EX
  
 #--------------------------------------------------------------------------
 # ● Start
 #--------------------------------------------------------------------------                
  alias mog_layout_ex_start start
  def start
      mog_layout_ex_start
      set_window_opacity
  end  
end
#==============================================================================
# ● Scene File
#==============================================================================
class Scene_File < Scene_MenuBase
  include WALLPAPER_EX
  
 #--------------------------------------------------------------------------
 # ● Start
 #--------------------------------------------------------------------------                
  alias mog_layout_ex_start start
  def start
      mog_layout_ex_start
      set_window_opacity
  end  
end
#==============================================================================
# ● Scene End
#==============================================================================
class Scene_End < Scene_MenuBase
  include WALLPAPER_EX
  
 #--------------------------------------------------------------------------
 # ● Start
 #--------------------------------------------------------------------------                
  alias mog_layout_ex_start start
  def start
      mog_layout_ex_start
      set_window_opacity
  end  
end
#==============================================================================
# ● Window SaveFile
#==============================================================================
class Window_SaveFile < Window_Base
  
 #--------------------------------------------------------------------------
 # ● Initialize
 #--------------------------------------------------------------------------                  
  alias mog_wallpaper_initialize initialize 
  def initialize(height, index)
      mog_wallpaper_initialize(height, index)
      self.opacity = WALLPAPER_EX::WINDOW_OPACITY if can_opacity_window?
  end
    
 #--------------------------------------------------------------------------
 # ● Can Opacity Window
 #--------------------------------------------------------------------------                    
  def can_opacity_window?
      return true
  end  
end

#==============================================================================
# ** LUNA SAYS U CANNOT SHUTDOWN
#------------------------------------------------------------------------------
#  Exit button ('X') is disabled in game window, but still available in console
#==============================================================================
SetClassLong = Win32API.new('user32', 'SetClassLong', 'lil', 'i')
SetClassLong.call(PONY::API::Hwnd, -26, 0x0200)

#==============================================================================
# ** Theread Assist
#------------------------------------------------------------------------------
#  This defined the method for assist thread
#==============================================================================
#tag: 3( Thread Assist
module Thread_Assist
  #----------------------------------------------------------------------------
  # * Constants
  #----------------------------------------------------------------------------
  Uwait = 0.03 # Time wait until next update
  @work      = 0
  @work_args = []
  # >> Work type definiation
  WorkTable = {
    :BCmine    => 1,
    :BCquery   => 2,
    :SoundPlay => 3,
  }
  #----------------------------------------------------------------------------
  module_function
  #----------------------------------------------------------------------------
  # * Assign work
  #----------------------------------------------------------------------------
  def assign_work(*args)
    return unless @work == 0
    type = args[0]
    puts "[Thread]: Work assigned: #{type}"
    @work = WorkTable[type]
    args.shift rescue []
    @work_args = args
  end
  #----------------------------------------------------------------------------
  # * Main entry access
  #----------------------------------------------------------------------------
  def assist_main
    @work = 0
    begin
      loop do
        update_assist
        sleep(Uwait)
      end
    rescue Exception => e
      PONY::ERRNO.mutex_error e
    end
  end
  #----------------------------------------------------------------------------
  # * Check wether need to pause
  #----------------------------------------------------------------------------
  def pause?
    return true if Graphics.transitioning?
    return true if BattleManager.in_battle?
    return false
  end
  #----------------------------------------------------------------------------
  # * Main update process
  #----------------------------------------------------------------------------
  def update_assist
    return if @work == 0
    case @work
    when WorkTable[:BCmine] && !BlockChain.locked?
      puts "[Thread]: Assist mining"
      $mutex.synchronize{BlockChain.mining(true)}
    when WorkTable[:SoundPlay]
      $mutex.synchronize{PONY.PlayAudio('sound.wav',8,0,0,0,0,0)}
    end
    @work = 0
  end
  #----------------------------------------------------------------------------
  def work?(symbol)
    @work == WorkTable[symbol]
  end
  #----------------------------------------------------------------------------
  def yield
    @work = 0
    File.open("test.txt", 'a'){|file| file.write("Kill Thread: #{$thassist}\n")}
    Thread.kill($thassist)
    puts "[Thread]: #{Time.now} #{$thassist.stop?}"
  end
end

#================================================
# * Script Processions
#================================================
script_disable_flag = false
output_script       = true

Dir.mkdir("Scripts/") unless File.exist?("Scripts/")
permutation_order = 0
$RGSS_SCRIPTS.each_with_index {|data, i|
  script_disable_flag = true  if data.at(1) =~ /<Disabled_Scripts>/i
  script_disable_flag = false if data.at(1) =~ /<\/Disabled_Scripts>/i
  next if data[4]

  if output_script
    string_order = permutation_order.to_fileid(3).to_s
    
    file_name = string_order + "_" + data[1] + ".rb"
    file_name = string_order + "-----------------------------" if $RGSS_SCRIPTS[i][1].size < 1
    file_name = "Scripts/" + file_name.tr(':<>|/','')
    
    script_file = File.new(file_name, 'w')
    
    codes = data[3]
    codes.split(/[\r\n]+/).each { |line|
     script_file.write(line)
     script_file.write("\n")
    }
    script_file.close
    permutation_order += 1
  end
  
  $RGSS_SCRIPTS.at(i)[2] = $RGSS_SCRIPTS.at(i)[3] = '' if script_disable_flag 
}
#==============================================================================
# tag: test
TEST = 1
if TEST == 1
module SceneManager
  #--------------------------------------------------------------------------
  # * Get First Scene Class
  #--------------------------------------------------------------------------
  def self.first_scene_class
    focus_game_window
    Scene_Test
  end
end
end
#==============================================================================
# *) New global class
#==============================================================================
$rgss   = self
$assist = RubyVM::InstructionSequence.compile("$thassist=Thread.new{Thread_Assist.assist_main}.run")
$mutex  = Mutex.new
#==============================================================================
# ** Ex-Main
#==============================================================================
setup_font
Graphics.resize_screen(640 ,480)
puts "[Debug]: Screen resized"
Graphics.frame_rate = 60
GameManager.load_volume
Cache.init
Mouse.init
Mouse.cursor.visible = false
#PONY.InitOpenAL
PONY.InitObjSpace
$assist.eval

rescue SystemExit
  exit
rescue Exception => e
  report_exception(e)
  flag_error(e)
end
